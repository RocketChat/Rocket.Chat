{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/weslley/Documents/projects/Rocket.Chat/packages/mongo/observe_multiplex.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"packages/mongo/observe_multiplex.js","filename":"/home/weslley/Documents/projects/Rocket.Chat/packages/mongo/observe_multiplex.js","targets":{"android":"95.0.0","chrome":"95.0.0","edge":"95.0.0","firefox":"78.0.0","ie":"10.0.0","ios":"15.0.0","opera":"81.0.0","safari":"15.1.0","samsung":"14.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/home/weslley/Documents/projects/Rocket.Chat","root":"/home/weslley/Documents/projects/Rocket.Chat","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.16.5","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/home/weslley/Documents/projects/Rocket.Chat/packages/mongo/observe_multiplex.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/mongo/observe_multiplex.js"}},"code":"const _excluded = [\"_id\"];\n\nlet _objectWithoutProperties;\n\nmodule.link(\"@babel/runtime/helpers/objectWithoutProperties\", {\n  default(v) {\n    _objectWithoutProperties = v;\n  }\n\n}, 0);\n\nvar Future = Npm.require('fibers/future');\n\nObserveMultiplexer = function (options) {\n  var self = this;\n  if (!options || !_.has(options, 'ordered')) throw Error(\"must specified ordered\");\n  Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"mongo-livedata\", \"observe-multiplexers\", 1);\n  self._ordered = options.ordered;\n\n  self._onStop = options.onStop || function () {};\n\n  self._queue = new Meteor._SynchronousQueue();\n  self._handles = {};\n  self._readyFuture = new Future();\n  self._cache = new LocalCollection._CachingChangeObserver({\n    ordered: options.ordered\n  }); // Number of addHandleAndSendInitialAdds tasks scheduled but not yet\n  // running. removeHandle uses this to know if it's time to call the onStop\n  // callback.\n\n  self._addHandleTasksScheduledButNotPerformed = 0;\n\n  _.each(self.callbackNames(), function (callbackName) {\n    self[callbackName] = function\n      /* ... */\n    () {\n      self._applyCallback(callbackName, _.toArray(arguments));\n    };\n  });\n};\n\n_.extend(ObserveMultiplexer.prototype, {\n  addHandleAndSendInitialAdds: function (handle) {\n    var self = this; // Check this before calling runTask (even though runTask does the same\n    // check) so that we don't leak an ObserveMultiplexer on error by\n    // incrementing _addHandleTasksScheduledButNotPerformed and never\n    // decrementing it.\n\n    if (!self._queue.safeToRunTask()) throw new Error(\"Can't call observeChanges from an observe callback on the same query\");\n    ++self._addHandleTasksScheduledButNotPerformed;\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"mongo-livedata\", \"observe-handles\", 1);\n\n    self._queue.runTask(function () {\n      self._handles[handle._id] = handle; // Send out whatever adds we have so far (whether or not we the\n      // multiplexer is ready).\n\n      self._sendAdds(handle);\n\n      --self._addHandleTasksScheduledButNotPerformed;\n    }); // *outside* the task, since otherwise we'd deadlock\n\n\n    self._readyFuture.wait();\n  },\n  // Remove an observe handle. If it was the last observe handle, call the\n  // onStop callback; you cannot add any more observe handles after this.\n  //\n  // This is not synchronized with polls and handle additions: this means that\n  // you can safely call it from within an observe callback, but it also means\n  // that we have to be careful when we iterate over _handles.\n  removeHandle: function (id) {\n    var self = this; // This should not be possible: you can only call removeHandle by having\n    // access to the ObserveHandle, which isn't returned to user code until the\n    // multiplex is ready.\n\n    if (!self._ready()) throw new Error(\"Can't remove handles until the multiplex is ready\");\n    delete self._handles[id];\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"mongo-livedata\", \"observe-handles\", -1);\n\n    if (_.isEmpty(self._handles) && self._addHandleTasksScheduledButNotPerformed === 0) {\n      self._stop();\n    }\n  },\n  _stop: function (options) {\n    var self = this;\n    options = options || {}; // It shouldn't be possible for us to stop when all our handles still\n    // haven't been returned from observeChanges!\n\n    if (!self._ready() && !options.fromQueryError) throw Error(\"surprising _stop: not ready\"); // Call stop callback (which kills the underlying process which sends us\n    // callbacks and removes us from the connection's dictionary).\n\n    self._onStop();\n\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"mongo-livedata\", \"observe-multiplexers\", -1); // Cause future addHandleAndSendInitialAdds calls to throw (but the onStop\n    // callback should make our connection forget about us).\n\n    self._handles = null;\n  },\n  // Allows all addHandleAndSendInitialAdds calls to return, once all preceding\n  // adds have been processed. Does not block.\n  ready: function () {\n    var self = this;\n\n    self._queue.queueTask(function () {\n      if (self._ready()) throw Error(\"can't make ObserveMultiplex ready twice!\");\n\n      self._readyFuture.return();\n    });\n  },\n  // If trying to execute the query results in an error, call this. This is\n  // intended for permanent errors, not transient network errors that could be\n  // fixed. It should only be called before ready(), because if you called ready\n  // that meant that you managed to run the query once. It will stop this\n  // ObserveMultiplex and cause addHandleAndSendInitialAdds calls (and thus\n  // observeChanges calls) to throw the error.\n  queryError: function (err) {\n    var self = this;\n\n    self._queue.runTask(function () {\n      if (self._ready()) throw Error(\"can't claim query has an error after it worked!\");\n\n      self._stop({\n        fromQueryError: true\n      });\n\n      self._readyFuture.throw(err);\n    });\n  },\n  // Calls \"cb\" once the effects of all \"ready\", \"addHandleAndSendInitialAdds\"\n  // and observe callbacks which came before this call have been propagated to\n  // all handles. \"ready\" must have already been called on this multiplexer.\n  onFlush: function (cb) {\n    var self = this;\n\n    self._queue.queueTask(function () {\n      if (!self._ready()) throw Error(\"only call onFlush on a multiplexer that will be ready\");\n      cb();\n    });\n  },\n  callbackNames: function () {\n    var self = this;\n    if (self._ordered) return [\"addedBefore\", \"changed\", \"movedBefore\", \"removed\"];else return [\"added\", \"changed\", \"removed\"];\n  },\n  _ready: function () {\n    return this._readyFuture.isResolved();\n  },\n  _applyCallback: function (callbackName, args) {\n    var self = this;\n\n    self._queue.queueTask(function () {\n      // If we stopped in the meantime, do nothing.\n      if (!self._handles) return; // First, apply the change to the cache.\n\n      self._cache.applyChange[callbackName].apply(null, args); // If we haven't finished the initial adds, then we should only be getting\n      // adds.\n\n\n      if (!self._ready() && callbackName !== 'added' && callbackName !== 'addedBefore') {\n        throw new Error(\"Got \" + callbackName + \" during initial adds\");\n      } // Now multiplex the callbacks out to all observe handles. It's OK if\n      // these calls yield; since we're inside a task, no other use of our queue\n      // can continue until these are done. (But we do have to be careful to not\n      // use a handle that got removed, because removeHandle does not use the\n      // queue; thus, we iterate over an array of keys that we control.)\n\n\n      _.each(_.keys(self._handles), function (handleId) {\n        var handle = self._handles && self._handles[handleId];\n        if (!handle) return;\n        var callback = handle['_' + callbackName]; // clone arguments so that callbacks can mutate their arguments\n\n        callback && callback.apply(null, handle.nonMutatingCallbacks ? args : EJSON.clone(args));\n      });\n    });\n  },\n  // Sends initial adds to a handle. It should only be called from within a task\n  // (the task that is processing the addHandleAndSendInitialAdds call). It\n  // synchronously invokes the handle's added or addedBefore; there's no need to\n  // flush the queue afterwards to ensure that the callbacks get out.\n  _sendAdds: function (handle) {\n    var self = this;\n    if (self._queue.safeToRunTask()) throw Error(\"_sendAdds may only be called from within a task!\");\n    var add = self._ordered ? handle._addedBefore : handle._added;\n    if (!add) return; // note: docs may be an _IdMap or an OrderedDict\n\n    self._cache.docs.forEach(function (doc, id) {\n      if (!_.has(self._handles, handle._id)) throw Error(\"handle got removed before sending initial adds!\");\n\n      const _ref = handle.nonMutatingCallbacks ? doc : EJSON.clone(doc),\n            {\n        _id\n      } = _ref,\n            fields = _objectWithoutProperties(_ref, _excluded);\n\n      if (self._ordered) add(id, fields, null); // we're going in order, so add at end\n      else add(id, fields);\n    });\n  }\n});\n\nvar nextObserveHandleId = 1; // When the callbacks do not mutate the arguments, we can skip a lot of data clones\n\nObserveHandle = function (multiplexer, callbacks) {\n  let nonMutatingCallbacks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var self = this; // The end user is only supposed to call stop().  The other fields are\n  // accessible to the multiplexer, though.\n\n  self._multiplexer = multiplexer;\n\n  _.each(multiplexer.callbackNames(), function (name) {\n    if (callbacks[name]) {\n      self['_' + name] = callbacks[name];\n    } else if (name === \"addedBefore\" && callbacks.added) {\n      // Special case: if you specify \"added\" and \"movedBefore\", you get an\n      // ordered observe where for some reason you don't get ordering data on\n      // the adds.  I dunno, we wrote tests for it, there must have been a\n      // reason.\n      self._addedBefore = function (id, fields, before) {\n        callbacks.added(id, fields);\n      };\n    }\n  });\n\n  self._stopped = false;\n  self._id = nextObserveHandleId++;\n  self.nonMutatingCallbacks = nonMutatingCallbacks;\n};\n\nObserveHandle.prototype.stop = function () {\n  var self = this;\n  if (self._stopped) return;\n  self._stopped = true;\n\n  self._multiplexer.removeHandle(self._id);\n};","map":{"version":3,"sources":["packages/mongo/observe_multiplex.js"],"names":["_objectWithoutProperties","module","link","default","v","Future","Npm","require","ObserveMultiplexer","options","self","_","has","Error","Package","Facts","incrementServerFact","_ordered","ordered","_onStop","onStop","_queue","Meteor","_SynchronousQueue","_handles","_readyFuture","_cache","LocalCollection","_CachingChangeObserver","_addHandleTasksScheduledButNotPerformed","each","callbackNames","callbackName","_applyCallback","toArray","arguments","extend","prototype","addHandleAndSendInitialAdds","handle","safeToRunTask","runTask","_id","_sendAdds","wait","removeHandle","id","_ready","isEmpty","_stop","fromQueryError","ready","queueTask","return","queryError","err","throw","onFlush","cb","isResolved","args","applyChange","apply","keys","handleId","callback","nonMutatingCallbacks","EJSON","clone","add","_addedBefore","_added","docs","forEach","doc","fields","nextObserveHandleId","ObserveHandle","multiplexer","callbacks","_multiplexer","name","added","before","_stopped","stop"],"mappings":"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","sourcesContent":["var Future = Npm.require('fibers/future');\n\nObserveMultiplexer = function (options) {\n  var self = this;\n\n  if (!options || !_.has(options, 'ordered'))\n    throw Error(\"must specified ordered\");\n\n  Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n    \"mongo-livedata\", \"observe-multiplexers\", 1);\n\n  self._ordered = options.ordered;\n  self._onStop = options.onStop || function () {};\n  self._queue = new Meteor._SynchronousQueue();\n  self._handles = {};\n  self._readyFuture = new Future;\n  self._cache = new LocalCollection._CachingChangeObserver({\n    ordered: options.ordered});\n  // Number of addHandleAndSendInitialAdds tasks scheduled but not yet\n  // running. removeHandle uses this to know if it's time to call the onStop\n  // callback.\n  self._addHandleTasksScheduledButNotPerformed = 0;\n\n  _.each(self.callbackNames(), function (callbackName) {\n    self[callbackName] = function (/* ... */) {\n      self._applyCallback(callbackName, _.toArray(arguments));\n    };\n  });\n};\n\n_.extend(ObserveMultiplexer.prototype, {\n  addHandleAndSendInitialAdds: function (handle) {\n    var self = this;\n\n    // Check this before calling runTask (even though runTask does the same\n    // check) so that we don't leak an ObserveMultiplexer on error by\n    // incrementing _addHandleTasksScheduledButNotPerformed and never\n    // decrementing it.\n    if (!self._queue.safeToRunTask())\n      throw new Error(\"Can't call observeChanges from an observe callback on the same query\");\n    ++self._addHandleTasksScheduledButNotPerformed;\n\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n      \"mongo-livedata\", \"observe-handles\", 1);\n\n    self._queue.runTask(function () {\n      self._handles[handle._id] = handle;\n      // Send out whatever adds we have so far (whether or not we the\n      // multiplexer is ready).\n      self._sendAdds(handle);\n      --self._addHandleTasksScheduledButNotPerformed;\n    });\n    // *outside* the task, since otherwise we'd deadlock\n    self._readyFuture.wait();\n  },\n\n  // Remove an observe handle. If it was the last observe handle, call the\n  // onStop callback; you cannot add any more observe handles after this.\n  //\n  // This is not synchronized with polls and handle additions: this means that\n  // you can safely call it from within an observe callback, but it also means\n  // that we have to be careful when we iterate over _handles.\n  removeHandle: function (id) {\n    var self = this;\n\n    // This should not be possible: you can only call removeHandle by having\n    // access to the ObserveHandle, which isn't returned to user code until the\n    // multiplex is ready.\n    if (!self._ready())\n      throw new Error(\"Can't remove handles until the multiplex is ready\");\n\n    delete self._handles[id];\n\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n      \"mongo-livedata\", \"observe-handles\", -1);\n\n    if (_.isEmpty(self._handles) &&\n        self._addHandleTasksScheduledButNotPerformed === 0) {\n      self._stop();\n    }\n  },\n  _stop: function (options) {\n    var self = this;\n    options = options || {};\n\n    // It shouldn't be possible for us to stop when all our handles still\n    // haven't been returned from observeChanges!\n    if (! self._ready() && ! options.fromQueryError)\n      throw Error(\"surprising _stop: not ready\");\n\n    // Call stop callback (which kills the underlying process which sends us\n    // callbacks and removes us from the connection's dictionary).\n    self._onStop();\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n      \"mongo-livedata\", \"observe-multiplexers\", -1);\n\n    // Cause future addHandleAndSendInitialAdds calls to throw (but the onStop\n    // callback should make our connection forget about us).\n    self._handles = null;\n  },\n\n  // Allows all addHandleAndSendInitialAdds calls to return, once all preceding\n  // adds have been processed. Does not block.\n  ready: function () {\n    var self = this;\n    self._queue.queueTask(function () {\n      if (self._ready())\n        throw Error(\"can't make ObserveMultiplex ready twice!\");\n      self._readyFuture.return();\n    });\n  },\n\n  // If trying to execute the query results in an error, call this. This is\n  // intended for permanent errors, not transient network errors that could be\n  // fixed. It should only be called before ready(), because if you called ready\n  // that meant that you managed to run the query once. It will stop this\n  // ObserveMultiplex and cause addHandleAndSendInitialAdds calls (and thus\n  // observeChanges calls) to throw the error.\n  queryError: function (err) {\n    var self = this;\n    self._queue.runTask(function () {\n      if (self._ready())\n        throw Error(\"can't claim query has an error after it worked!\");\n      self._stop({fromQueryError: true});\n      self._readyFuture.throw(err);\n    });\n  },\n\n  // Calls \"cb\" once the effects of all \"ready\", \"addHandleAndSendInitialAdds\"\n  // and observe callbacks which came before this call have been propagated to\n  // all handles. \"ready\" must have already been called on this multiplexer.\n  onFlush: function (cb) {\n    var self = this;\n    self._queue.queueTask(function () {\n      if (!self._ready())\n        throw Error(\"only call onFlush on a multiplexer that will be ready\");\n      cb();\n    });\n  },\n  callbackNames: function () {\n    var self = this;\n    if (self._ordered)\n      return [\"addedBefore\", \"changed\", \"movedBefore\", \"removed\"];\n    else\n      return [\"added\", \"changed\", \"removed\"];\n  },\n  _ready: function () {\n    return this._readyFuture.isResolved();\n  },\n  _applyCallback: function (callbackName, args) {\n    var self = this;\n    self._queue.queueTask(function () {\n      // If we stopped in the meantime, do nothing.\n      if (!self._handles)\n        return;\n\n      // First, apply the change to the cache.\n      self._cache.applyChange[callbackName].apply(null, args);\n\n      // If we haven't finished the initial adds, then we should only be getting\n      // adds.\n      if (!self._ready() &&\n          (callbackName !== 'added' && callbackName !== 'addedBefore')) {\n        throw new Error(\"Got \" + callbackName + \" during initial adds\");\n      }\n\n      // Now multiplex the callbacks out to all observe handles. It's OK if\n      // these calls yield; since we're inside a task, no other use of our queue\n      // can continue until these are done. (But we do have to be careful to not\n      // use a handle that got removed, because removeHandle does not use the\n      // queue; thus, we iterate over an array of keys that we control.)\n      _.each(_.keys(self._handles), function (handleId) {\n        var handle = self._handles && self._handles[handleId];\n        if (!handle)\n          return;\n        var callback = handle['_' + callbackName];\n        // clone arguments so that callbacks can mutate their arguments\n        callback && callback.apply(null,\n          handle.nonMutatingCallbacks ? args : EJSON.clone(args));\n      });\n    });\n  },\n\n  // Sends initial adds to a handle. It should only be called from within a task\n  // (the task that is processing the addHandleAndSendInitialAdds call). It\n  // synchronously invokes the handle's added or addedBefore; there's no need to\n  // flush the queue afterwards to ensure that the callbacks get out.\n  _sendAdds: function (handle) {\n    var self = this;\n    if (self._queue.safeToRunTask())\n      throw Error(\"_sendAdds may only be called from within a task!\");\n    var add = self._ordered ? handle._addedBefore : handle._added;\n    if (!add)\n      return;\n    // note: docs may be an _IdMap or an OrderedDict\n    self._cache.docs.forEach(function (doc, id) {\n      if (!_.has(self._handles, handle._id))\n        throw Error(\"handle got removed before sending initial adds!\");\n      const { _id, ...fields } = handle.nonMutatingCallbacks ? doc\n        : EJSON.clone(doc);\n      if (self._ordered)\n        add(id, fields, null); // we're going in order, so add at end\n      else\n        add(id, fields);\n    });\n  }\n});\n\n\nvar nextObserveHandleId = 1;\n\n// When the callbacks do not mutate the arguments, we can skip a lot of data clones\nObserveHandle = function (multiplexer, callbacks, nonMutatingCallbacks = false) {\n  var self = this;\n  // The end user is only supposed to call stop().  The other fields are\n  // accessible to the multiplexer, though.\n  self._multiplexer = multiplexer;\n  _.each(multiplexer.callbackNames(), function (name) {\n    if (callbacks[name]) {\n      self['_' + name] = callbacks[name];\n    } else if (name === \"addedBefore\" && callbacks.added) {\n      // Special case: if you specify \"added\" and \"movedBefore\", you get an\n      // ordered observe where for some reason you don't get ordering data on\n      // the adds.  I dunno, we wrote tests for it, there must have been a\n      // reason.\n      self._addedBefore = function (id, fields, before) {\n        callbacks.added(id, fields);\n      };\n    }\n  });\n  self._stopped = false;\n  self._id = nextObserveHandleId++;\n  self.nonMutatingCallbacks = nonMutatingCallbacks;\n};\nObserveHandle.prototype.stop = function () {\n  var self = this;\n  if (self._stopped)\n    return;\n  self._stopped = true;\n  self._multiplexer.removeHandle(self._id);\n};\n"]},"sourceType":"module","hash":"0b562bf7df0272c1992806eda411507f283efece"}
