{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/weslley/Documents/projects/Rocket.Chat/packages/shell-server/shell-server.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"packages/shell-server/shell-server.js","filename":"/home/weslley/Documents/projects/Rocket.Chat/packages/shell-server/shell-server.js","targets":{"android":"95.0.0","chrome":"95.0.0","edge":"95.0.0","firefox":"78.0.0","ie":"10.0.0","ios":"15.0.0","opera":"81.0.0","safari":"15.1.0","samsung":"14.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/home/weslley/Documents/projects/Rocket.Chat","root":"/home/weslley/Documents/projects/Rocket.Chat","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.16.5","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/home/weslley/Documents/projects/Rocket.Chat/packages/shell-server/shell-server.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/shell-server/shell-server.js"}},"code":"!function (module1) {\n  module1.export({\n    listen: () => listen,\n    disable: () => disable\n  });\n  let assert;\n  module1.link(\"assert\", {\n    default(v) {\n      assert = v;\n    }\n\n  }, 0);\n  let pathJoin;\n  module1.link(\"path\", {\n    join(v) {\n      pathJoin = v;\n    }\n\n  }, 1);\n  let PassThrough;\n  module1.link(\"stream\", {\n    PassThrough(v) {\n      PassThrough = v;\n    }\n\n  }, 2);\n  let closeSync, openSync, readFileSync, unlink, writeFileSync, writeSync;\n  module1.link(\"fs\", {\n    closeSync(v) {\n      closeSync = v;\n    },\n\n    openSync(v) {\n      openSync = v;\n    },\n\n    readFileSync(v) {\n      readFileSync = v;\n    },\n\n    unlink(v) {\n      unlink = v;\n    },\n\n    writeFileSync(v) {\n      writeFileSync = v;\n    },\n\n    writeSync(v) {\n      writeSync = v;\n    }\n\n  }, 3);\n  let createServer;\n  module1.link(\"net\", {\n    createServer(v) {\n      createServer = v;\n    }\n\n  }, 4);\n  let replStart;\n  module1.link(\"repl\", {\n    start(v) {\n      replStart = v;\n    }\n\n  }, 5);\n  module1.link(\"meteor/inter-process-messaging\");\n  const INFO_FILE_MODE = parseInt(\"600\", 8); // Only the owner can read or write.\n\n  const EXITING_MESSAGE = \"Shell exiting...\"; // Invoked by the server process to listen for incoming connections from\n  // shell clients. Each connection gets its own REPL instance.\n\n  function listen(shellDir) {\n    function callback() {\n      new Server(shellDir).listen();\n    } // If the server is still in the very early stages of starting up,\n    // Meteor.startup may not available yet.\n\n\n    if (typeof Meteor === \"object\") {\n      Meteor.startup(callback);\n    } else if (typeof __meteor_bootstrap__ === \"object\") {\n      const hooks = __meteor_bootstrap__.startupHooks;\n\n      if (hooks) {\n        hooks.push(callback);\n      } else {\n        // As a fallback, just call the callback asynchronously.\n        setImmediate(callback);\n      }\n    }\n  }\n\n  function disable(shellDir) {\n    try {\n      // Replace info.json with a file that says the shell server is\n      // disabled, so that any connected shell clients will fail to\n      // reconnect after the server process closes their sockets.\n      writeFileSync(getInfoFile(shellDir), JSON.stringify({\n        status: \"disabled\",\n        reason: \"Shell server has shut down.\"\n      }) + \"\\n\", {\n        mode: INFO_FILE_MODE\n      });\n    } catch (ignored) {}\n  }\n\n  // Shell commands need to be executed in a Fiber in case they call into\n  // code that yields. Using a Promise is an even better idea, since it runs\n  // its callbacks in Fibers drawn from a pool, so the Fibers are recycled.\n  const evalCommandPromise = Promise.resolve();\n\n  class Server {\n    constructor(shellDir) {\n      assert.ok(this instanceof Server);\n      this.shellDir = shellDir;\n      this.key = Math.random().toString(36).slice(2);\n      this.server = createServer(socket => {\n        this.onConnection(socket);\n      }).on(\"error\", err => {\n        console.error(err.stack);\n      });\n    }\n\n    listen() {\n      const infoFile = getInfoFile(this.shellDir);\n      unlink(infoFile, () => {\n        this.server.listen(0, \"127.0.0.1\", () => {\n          writeFileSync(infoFile, JSON.stringify({\n            status: \"enabled\",\n            port: this.server.address().port,\n            key: this.key\n          }) + \"\\n\", {\n            mode: INFO_FILE_MODE\n          });\n        });\n      });\n    }\n\n    onConnection(socket) {\n      // Make sure this function doesn't try to write anything to the socket\n      // after it has been closed.\n      socket.on(\"close\", function () {\n        socket = null;\n      }); // If communication is not established within 1000ms of the first\n      // connection, forcibly close the socket.\n\n      const timeout = setTimeout(function () {\n        if (socket) {\n          socket.removeAllListeners(\"data\");\n          socket.end(EXITING_MESSAGE + \"\\n\");\n        }\n      }, 1000); // Let connecting clients configure certain REPL options by sending a\n      // JSON object over the socket. For example, only the client knows\n      // whether it's running a TTY or an Emacs subshell or some other kind of\n      // terminal, so the client must decide the value of options.terminal.\n\n      readJSONFromStream(socket, (error, options, replInputSocket) => {\n        clearTimeout(timeout);\n\n        if (error) {\n          socket = null;\n          console.error(error.stack);\n          return;\n        }\n\n        if (options.key !== this.key) {\n          if (socket) {\n            socket.end(EXITING_MESSAGE + \"\\n\");\n          }\n\n          return;\n        }\n\n        delete options.key; // Set the columns to what is being requested by the client.\n\n        if (options.columns && socket) {\n          socket.columns = options.columns;\n        }\n\n        delete options.columns;\n        options = Object.assign(Object.create(null), // Defaults for configurable options.\n        {\n          prompt: \"> \",\n          terminal: true,\n          useColors: true,\n          ignoreUndefined: true\n        }, // Configurable options\n        options, // Immutable options.\n        {\n          input: replInputSocket,\n          useGlobal: false,\n          output: socket\n        }); // The prompt during an evaluateAndExit must be blank to ensure\n        // that the prompt doesn't inadvertently get parsed as part of\n        // the JSON communication channel.\n\n        if (options.evaluateAndExit) {\n          options.prompt = \"\";\n        } // Start the REPL.\n\n\n        this.startREPL(options);\n\n        if (options.evaluateAndExit) {\n          this._wrappedDefaultEval.call(Object.create(null), options.evaluateAndExit.command, global, options.evaluateAndExit.filename || \"<meteor shell>\", function (error, result) {\n            if (socket) {\n              function sendResultToSocket(message) {\n                // Sending back a JSON payload allows the client to\n                // distinguish between errors and successful results.\n                socket.end(JSON.stringify(message) + \"\\n\");\n              }\n\n              if (error) {\n                sendResultToSocket({\n                  error: error.toString(),\n                  code: 1\n                });\n              } else {\n                sendResultToSocket({\n                  result\n                });\n              }\n            }\n          });\n\n          return;\n        }\n\n        delete options.evaluateAndExit;\n        this.enableInteractiveMode(options);\n      });\n    }\n\n    startREPL(options) {\n      // Make sure this function doesn't try to write anything to the output\n      // stream after it has been closed.\n      options.output.on(\"close\", function () {\n        options.output = null;\n      });\n      const repl = this.repl = replStart(options);\n      const {\n        shellDir\n      } = this; // This is technique of setting `repl.context` is similar to how the\n      // `useGlobal` option would work during a normal `repl.start()` and\n      // allows shell access (and tab completion!) to Meteor globals (i.e.\n      // Underscore _, Meteor, etc.). By using this technique, which changes\n      // the context after startup, we avoid stomping on the special `_`\n      // variable (in `repl` this equals the value of the last command) from\n      // being overridden in the client/server socket-handshaking.  Furthermore,\n      // by setting `useGlobal` back to true, we allow the default eval function\n      // to use the desired `runInThisContext` method (https://git.io/vbvAB).\n\n      repl.context = global;\n      repl.useGlobal = true;\n      setRequireAndModule(repl.context); // In order to avoid duplicating code here, specifically the complexities\n      // of catching so-called \"Recoverable Errors\" (https://git.io/vbvbl),\n      // we will wrap the default eval, run it in a Fiber (via a Promise), and\n      // give it the opportunity to decide if the user is mid-code-block.\n\n      const defaultEval = repl.eval;\n\n      function wrappedDefaultEval(code, context, file, callback) {\n        if (Package.ecmascript) {\n          try {\n            code = Package.ecmascript.ECMAScript.compileForShell(code, {\n              cacheDirectory: getCacheDirectory(shellDir)\n            });\n          } catch (err) {// Any Babel error here might be just fine since it's\n            // possible the code was incomplete (multi-line code on the REPL).\n            // The defaultEval below will use its own functionality to determine\n            // if this error is \"recoverable\".\n          }\n        }\n\n        evalCommandPromise.then(() => defaultEval(code, context, file, callback)).catch(callback);\n      } // Have the REPL use the newly wrapped function instead and store the\n      // _wrappedDefaultEval so that evalulateAndExit calls can use it directly.\n\n\n      repl.eval = this._wrappedDefaultEval = wrappedDefaultEval;\n    }\n\n    enableInteractiveMode(options) {\n      // History persists across shell sessions!\n      this.initializeHistory();\n      const repl = this.repl; // Implement an alternate means of fetching the return value,\n      // via `__` (double underscore) as originally implemented in:\n      // https://github.com/meteor/meteor/commit/2443d832265c7d1c\n\n      Object.defineProperty(repl.context, \"__\", {\n        get: () => repl.last,\n        set: val => {\n          repl.last = val;\n        },\n        // Allow this property to be (re)defined more than once (e.g. each\n        // time the server restarts).\n        configurable: true\n      }); // Some improvements to the existing help messages.\n\n      function addHelp(cmd, helpText) {\n        const info = repl.commands[cmd] || repl.commands[\".\" + cmd];\n\n        if (info) {\n          info.help = helpText;\n        }\n      }\n\n      addHelp(\"break\", \"Terminate current command input and display new prompt\");\n      addHelp(\"exit\", \"Disconnect from server and leave shell\");\n      addHelp(\"help\", \"Show this help information\"); // When the REPL exits, signal the attached client to exit by sending it\n      // the special EXITING_MESSAGE.\n\n      repl.on(\"exit\", function () {\n        if (options.output) {\n          options.output.write(EXITING_MESSAGE + \"\\n\");\n          options.output.end();\n        }\n      }); // When the server process exits, end the output stream but do not\n      // signal the attached client to exit.\n\n      process.on(\"exit\", function () {\n        if (options.output) {\n          options.output.end();\n        }\n      }); // This Meteor-specific shell command rebuilds the application as if a\n      // change was made to server code.\n\n      repl.defineCommand(\"reload\", {\n        help: \"Restart the server and the shell\",\n        action: function () {\n          if (process.sendMessage) {\n            process.sendMessage(\"shell-server\", {\n              command: \"reload\"\n            });\n          } else {\n            process.exit(0);\n          }\n        }\n      });\n    } // This function allows a persistent history of shell commands to be saved\n    // to and loaded from .meteor/local/shell/history.\n\n\n    initializeHistory() {\n      const repl = this.repl;\n      const historyFile = getHistoryFile(this.shellDir);\n      let historyFd = openSync(historyFile, \"a+\");\n      const historyLines = readFileSync(historyFile, \"utf8\").split(\"\\n\");\n      const seenLines = Object.create(null);\n\n      if (!repl.history) {\n        repl.history = [];\n        repl.historyIndex = -1;\n      }\n\n      while (repl.history && historyLines.length > 0) {\n        const line = historyLines.pop();\n\n        if (line && /\\S/.test(line) && !seenLines[line]) {\n          repl.history.push(line);\n          seenLines[line] = true;\n        }\n      }\n\n      repl.addListener(\"line\", function (line) {\n        if (historyFd >= 0 && /\\S/.test(line)) {\n          writeSync(historyFd, line + \"\\n\");\n        }\n      });\n      this.repl.on(\"exit\", function () {\n        closeSync(historyFd);\n        historyFd = -1;\n      });\n    }\n\n  }\n\n  function readJSONFromStream(inputStream, callback) {\n    const outputStream = new PassThrough();\n    let dataSoFar = \"\";\n\n    function onData(buffer) {\n      const lines = buffer.toString(\"utf8\").split(\"\\n\");\n\n      while (lines.length > 0) {\n        dataSoFar += lines.shift();\n        let json;\n\n        try {\n          json = JSON.parse(dataSoFar);\n        } catch (error) {\n          if (error instanceof SyntaxError) {\n            continue;\n          }\n\n          return finish(error);\n        }\n\n        if (lines.length > 0) {\n          outputStream.write(lines.join(\"\\n\"));\n        }\n\n        inputStream.pipe(outputStream);\n        return finish(null, json);\n      }\n    }\n\n    function onClose() {\n      finish(new Error(\"stream unexpectedly closed\"));\n    }\n\n    let finished = false;\n\n    function finish(error, json) {\n      if (!finished) {\n        finished = true;\n        inputStream.removeListener(\"data\", onData);\n        inputStream.removeListener(\"error\", finish);\n        inputStream.removeListener(\"close\", onClose);\n        callback(error, json, outputStream);\n      }\n    }\n\n    inputStream.on(\"data\", onData);\n    inputStream.on(\"error\", finish);\n    inputStream.on(\"close\", onClose);\n  }\n\n  function getInfoFile(shellDir) {\n    return pathJoin(shellDir, \"info.json\");\n  }\n\n  function getHistoryFile(shellDir) {\n    return pathJoin(shellDir, \"history\");\n  }\n\n  function getCacheDirectory(shellDir) {\n    return pathJoin(shellDir, \"cache\");\n  }\n\n  function setRequireAndModule(context) {\n    if (Package.modules) {\n      // Use the same `require` function and `module` object visible to the\n      // application.\n      const toBeInstalled = {};\n      const shellModuleName = \"meteor-shell-\" + Math.random().toString(36).slice(2) + \".js\";\n\n      toBeInstalled[shellModuleName] = function (require, exports, module) {\n        context.module = module;\n        context.require = require; // Tab completion sometimes uses require.extensions, but only for\n        // the keys.\n\n        require.extensions = {\n          \".js\": true,\n          \".json\": true,\n          \".node\": true\n        };\n      }; // This populates repl.context.{module,require} by evaluating the\n      // module defined above.\n\n\n      Package.modules.meteorInstall(toBeInstalled)(\"./\" + shellModuleName);\n    }\n  }\n}.call(this, module);","map":{"version":3,"sources":["packages/shell-server/shell-server.js"],"names":["module1","export","listen","disable","assert","link","default","v","pathJoin","join","PassThrough","closeSync","openSync","readFileSync","unlink","writeFileSync","writeSync","createServer","replStart","start","INFO_FILE_MODE","parseInt","EXITING_MESSAGE","shellDir","callback","Server","Meteor","startup","__meteor_bootstrap__","hooks","startupHooks","push","setImmediate","getInfoFile","JSON","stringify","status","reason","mode","ignored","evalCommandPromise","Promise","resolve","constructor","ok","key","Math","random","toString","slice","server","socket","onConnection","on","err","console","error","stack","infoFile","port","address","timeout","setTimeout","removeAllListeners","end","readJSONFromStream","options","replInputSocket","clearTimeout","columns","Object","assign","create","prompt","terminal","useColors","ignoreUndefined","input","useGlobal","output","evaluateAndExit","startREPL","_wrappedDefaultEval","call","command","global","filename","result","sendResultToSocket","message","code","enableInteractiveMode","repl","context","setRequireAndModule","defaultEval","eval","wrappedDefaultEval","file","Package","ecmascript","ECMAScript","compileForShell","cacheDirectory","getCacheDirectory","then","catch","initializeHistory","defineProperty","get","last","set","val","configurable","addHelp","cmd","helpText","info","commands","help","write","process","defineCommand","action","sendMessage","exit","historyFile","getHistoryFile","historyFd","historyLines","split","seenLines","history","historyIndex","length","line","pop","test","addListener","inputStream","outputStream","dataSoFar","onData","buffer","lines","shift","json","parse","SyntaxError","finish","pipe","onClose","Error","finished","removeListener","modules","toBeInstalled","shellModuleName","require","exports","module","extensions","meteorInstall"],"mappings":";AAAAA,EAAAA,OAAO,CAACC,MAAR,CAAe;AAACC,IAAAA,MAAM,EAAC,MAAIA,MAAZ;AAAmBC,IAAAA,OAAO,EAAC,MAAIA;AAA/B,GAAf;AAAwD,MAAIC,MAAJ;AAAWJ,EAAAA,OAAO,CAACK,IAAR,CAAa,QAAb,EAAsB;AAACC,IAAAA,OAAO,CAACC,CAAD,EAAG;AAACH,MAAAA,MAAM,GAACG,CAAP;AAAS;;AAArB,GAAtB,EAA6C,CAA7C;AAAgD,MAAIC,QAAJ;AAAaR,EAAAA,OAAO,CAACK,IAAR,CAAa,MAAb,EAAoB;AAACI,IAAAA,IAAI,CAACF,CAAD,EAAG;AAACC,MAAAA,QAAQ,GAACD,CAAT;AAAW;;AAApB,GAApB,EAA0C,CAA1C;AAA6C,MAAIG,WAAJ;AAAgBV,EAAAA,OAAO,CAACK,IAAR,CAAa,QAAb,EAAsB;AAACK,IAAAA,WAAW,CAACH,CAAD,EAAG;AAACG,MAAAA,WAAW,GAACH,CAAZ;AAAc;;AAA9B,GAAtB,EAAsD,CAAtD;AAAyD,MAAII,SAAJ,EAAcC,QAAd,EAAuBC,YAAvB,EAAoCC,MAApC,EAA2CC,aAA3C,EAAyDC,SAAzD;AAAmEhB,EAAAA,OAAO,CAACK,IAAR,CAAa,IAAb,EAAkB;AAACM,IAAAA,SAAS,CAACJ,CAAD,EAAG;AAACI,MAAAA,SAAS,GAACJ,CAAV;AAAY,KAA1B;;AAA2BK,IAAAA,QAAQ,CAACL,CAAD,EAAG;AAACK,MAAAA,QAAQ,GAACL,CAAT;AAAW,KAAlD;;AAAmDM,IAAAA,YAAY,CAACN,CAAD,EAAG;AAACM,MAAAA,YAAY,GAACN,CAAb;AAAe,KAAlF;;AAAmFO,IAAAA,MAAM,CAACP,CAAD,EAAG;AAACO,MAAAA,MAAM,GAACP,CAAP;AAAS,KAAtG;;AAAuGQ,IAAAA,aAAa,CAACR,CAAD,EAAG;AAACQ,MAAAA,aAAa,GAACR,CAAd;AAAgB,KAAxI;;AAAyIS,IAAAA,SAAS,CAACT,CAAD,EAAG;AAACS,MAAAA,SAAS,GAACT,CAAV;AAAY;;AAAlK,GAAlB,EAAsL,CAAtL;AAAyL,MAAIU,YAAJ;AAAiBjB,EAAAA,OAAO,CAACK,IAAR,CAAa,KAAb,EAAmB;AAACY,IAAAA,YAAY,CAACV,CAAD,EAAG;AAACU,MAAAA,YAAY,GAACV,CAAb;AAAe;;AAAhC,GAAnB,EAAqD,CAArD;AAAwD,MAAIW,SAAJ;AAAclB,EAAAA,OAAO,CAACK,IAAR,CAAa,MAAb,EAAoB;AAACc,IAAAA,KAAK,CAACZ,CAAD,EAAG;AAACW,MAAAA,SAAS,GAACX,CAAV;AAAY;;AAAtB,GAApB,EAA4C,CAA5C;AAA+CP,EAAAA,OAAO,CAACK,IAAR,CAAa,gCAAb;AAiBxnB,QAAMe,cAAc,GAAGC,QAAQ,CAAC,KAAD,EAAQ,CAAR,CAA/B,C,CAA2C;;AAC3C,QAAMC,eAAe,GAAG,kBAAxB,C,CAEA;AACA;;AACO,WAASpB,MAAT,CAAgBqB,QAAhB,EAA0B;AAC/B,aAASC,QAAT,GAAoB;AAClB,UAAIC,MAAJ,CAAWF,QAAX,EAAqBrB,MAArB;AACD,KAH8B,CAK/B;AACA;;;AACA,QAAI,OAAOwB,MAAP,KAAkB,QAAtB,EAAgC;AAC9BA,MAAAA,MAAM,CAACC,OAAP,CAAeH,QAAf;AACD,KAFD,MAEO,IAAI,OAAOI,oBAAP,KAAgC,QAApC,EAA8C;AACnD,YAAMC,KAAK,GAAGD,oBAAoB,CAACE,YAAnC;;AACA,UAAID,KAAJ,EAAW;AACTA,QAAAA,KAAK,CAACE,IAAN,CAAWP,QAAX;AACD,OAFD,MAEO;AACL;AACAQ,QAAAA,YAAY,CAACR,QAAD,CAAZ;AACD;AACF;AACF;;AAGM,WAASrB,OAAT,CAAiBoB,QAAjB,EAA2B;AAChC,QAAI;AACF;AACA;AACA;AACAR,MAAAA,aAAa,CACXkB,WAAW,CAACV,QAAD,CADA,EAEXW,IAAI,CAACC,SAAL,CAAe;AACbC,QAAAA,MAAM,EAAE,UADK;AAEbC,QAAAA,MAAM,EAAE;AAFK,OAAf,IAGK,IALM,EAMX;AAAEC,QAAAA,IAAI,EAAElB;AAAR,OANW,CAAb;AAQD,KAZD,CAYE,OAAOmB,OAAP,EAAgB,CAAE;AACrB;;AAED;AACA;AACA;AACA,QAAMC,kBAAkB,GAAGC,OAAO,CAACC,OAAR,EAA3B;;AAEA,QAAMjB,MAAN,CAAa;AACXkB,IAAAA,WAAW,CAACpB,QAAD,EAAW;AACpBnB,MAAAA,MAAM,CAACwC,EAAP,CAAU,gBAAgBnB,MAA1B;AAEA,WAAKF,QAAL,GAAgBA,QAAhB;AACA,WAAKsB,GAAL,GAAWC,IAAI,CAACC,MAAL,GAAcC,QAAd,CAAuB,EAAvB,EAA2BC,KAA3B,CAAiC,CAAjC,CAAX;AAEA,WAAKC,MAAL,GACEjC,YAAY,CAAEkC,MAAD,IAAY;AACvB,aAAKC,YAAL,CAAkBD,MAAlB;AACD,OAFW,CAAZ,CAGCE,EAHD,CAGI,OAHJ,EAGcC,GAAD,IAAS;AACpBC,QAAAA,OAAO,CAACC,KAAR,CAAcF,GAAG,CAACG,KAAlB;AACD,OALD,CADF;AAOD;;AAEDvD,IAAAA,MAAM,GAAG;AACP,YAAMwD,QAAQ,GAAGzB,WAAW,CAAC,KAAKV,QAAN,CAA5B;AAEAT,MAAAA,MAAM,CAAC4C,QAAD,EAAW,MAAM;AACrB,aAAKR,MAAL,CAAYhD,MAAZ,CAAmB,CAAnB,EAAsB,WAAtB,EAAmC,MAAM;AACvCa,UAAAA,aAAa,CAAC2C,QAAD,EAAWxB,IAAI,CAACC,SAAL,CAAe;AACrCC,YAAAA,MAAM,EAAE,SAD6B;AAErCuB,YAAAA,IAAI,EAAE,KAAKT,MAAL,CAAYU,OAAZ,GAAsBD,IAFS;AAGrCd,YAAAA,GAAG,EAAE,KAAKA;AAH2B,WAAf,IAInB,IAJQ,EAIF;AACTP,YAAAA,IAAI,EAAElB;AADG,WAJE,CAAb;AAOD,SARD;AASD,OAVK,CAAN;AAWD;;AAEDgC,IAAAA,YAAY,CAACD,MAAD,EAAS;AACnB;AACA;AACAA,MAAAA,MAAM,CAACE,EAAP,CAAU,OAAV,EAAmB,YAAW;AAC5BF,QAAAA,MAAM,GAAG,IAAT;AACD,OAFD,EAHmB,CAOnB;AACA;;AACA,YAAMU,OAAO,GAAGC,UAAU,CAAC,YAAW;AACpC,YAAIX,MAAJ,EAAY;AACVA,UAAAA,MAAM,CAACY,kBAAP,CAA0B,MAA1B;AACAZ,UAAAA,MAAM,CAACa,GAAP,CAAW1C,eAAe,GAAG,IAA7B;AACD;AACF,OALyB,EAKvB,IALuB,CAA1B,CATmB,CAgBnB;AACA;AACA;AACA;;AACA2C,MAAAA,kBAAkB,CAACd,MAAD,EAAS,CAACK,KAAD,EAAQU,OAAR,EAAiBC,eAAjB,KAAqC;AAC9DC,QAAAA,YAAY,CAACP,OAAD,CAAZ;;AAEA,YAAIL,KAAJ,EAAW;AACTL,UAAAA,MAAM,GAAG,IAAT;AACAI,UAAAA,OAAO,CAACC,KAAR,CAAcA,KAAK,CAACC,KAApB;AACA;AACD;;AAED,YAAIS,OAAO,CAACrB,GAAR,KAAgB,KAAKA,GAAzB,EAA8B;AAC5B,cAAIM,MAAJ,EAAY;AACVA,YAAAA,MAAM,CAACa,GAAP,CAAW1C,eAAe,GAAG,IAA7B;AACD;;AACD;AACD;;AACD,eAAO4C,OAAO,CAACrB,GAAf,CAf8D,CAiB9D;;AACA,YAAIqB,OAAO,CAACG,OAAR,IAAmBlB,MAAvB,EAA+B;AAC7BA,UAAAA,MAAM,CAACkB,OAAP,GAAiBH,OAAO,CAACG,OAAzB;AACD;;AACD,eAAOH,OAAO,CAACG,OAAf;AAEAH,QAAAA,OAAO,GAAGI,MAAM,CAACC,MAAP,CACRD,MAAM,CAACE,MAAP,CAAc,IAAd,CADQ,EAGR;AACA;AACEC,UAAAA,MAAM,EAAE,IADV;AAEEC,UAAAA,QAAQ,EAAE,IAFZ;AAGEC,UAAAA,SAAS,EAAE,IAHb;AAIEC,UAAAA,eAAe,EAAE;AAJnB,SAJQ,EAWR;AACAV,QAAAA,OAZQ,EAcR;AACA;AACEW,UAAAA,KAAK,EAAEV,eADT;AAEEW,UAAAA,SAAS,EAAE,KAFb;AAGEC,UAAAA,MAAM,EAAE5B;AAHV,SAfQ,CAAV,CAvB8D,CA6C9D;AACA;AACA;;AACA,YAAIe,OAAO,CAACc,eAAZ,EAA6B;AAC3Bd,UAAAA,OAAO,CAACO,MAAR,GAAiB,EAAjB;AACD,SAlD6D,CAoD9D;;;AACA,aAAKQ,SAAL,CAAef,OAAf;;AAEA,YAAIA,OAAO,CAACc,eAAZ,EAA6B;AAC3B,eAAKE,mBAAL,CAAyBC,IAAzB,CACEb,MAAM,CAACE,MAAP,CAAc,IAAd,CADF,EAEEN,OAAO,CAACc,eAAR,CAAwBI,OAF1B,EAGEC,MAHF,EAIEnB,OAAO,CAACc,eAAR,CAAwBM,QAAxB,IAAoC,gBAJtC,EAKE,UAAU9B,KAAV,EAAiB+B,MAAjB,EAAyB;AACvB,gBAAIpC,MAAJ,EAAY;AACV,uBAASqC,kBAAT,CAA4BC,OAA5B,EAAqC;AACnC;AACA;AACAtC,gBAAAA,MAAM,CAACa,GAAP,CAAW9B,IAAI,CAACC,SAAL,CAAesD,OAAf,IAA0B,IAArC;AACD;;AAED,kBAAIjC,KAAJ,EAAW;AACTgC,gBAAAA,kBAAkB,CAAC;AACjBhC,kBAAAA,KAAK,EAAEA,KAAK,CAACR,QAAN,EADU;AAEjB0C,kBAAAA,IAAI,EAAE;AAFW,iBAAD,CAAlB;AAID,eALD,MAKO;AACLF,gBAAAA,kBAAkB,CAAC;AACjBD,kBAAAA;AADiB,iBAAD,CAAlB;AAGD;AACF;AACF,WAxBH;;AA0BA;AACD;;AACD,eAAOrB,OAAO,CAACc,eAAf;AAEA,aAAKW,qBAAL,CAA2BzB,OAA3B;AACD,OAvFiB,CAAlB;AAwFD;;AAEDe,IAAAA,SAAS,CAACf,OAAD,EAAU;AACjB;AACA;AACAA,MAAAA,OAAO,CAACa,MAAR,CAAe1B,EAAf,CAAkB,OAAlB,EAA2B,YAAW;AACpCa,QAAAA,OAAO,CAACa,MAAR,GAAiB,IAAjB;AACD,OAFD;AAIA,YAAMa,IAAI,GAAG,KAAKA,IAAL,GAAY1E,SAAS,CAACgD,OAAD,CAAlC;AACA,YAAM;AAAE3C,QAAAA;AAAF,UAAe,IAArB,CARiB,CAUjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAqE,MAAAA,IAAI,CAACC,OAAL,GAAeR,MAAf;AACAO,MAAAA,IAAI,CAACd,SAAL,GAAiB,IAAjB;AAEAgB,MAAAA,mBAAmB,CAACF,IAAI,CAACC,OAAN,CAAnB,CAtBiB,CAwBjB;AACA;AACA;AACA;;AACA,YAAME,WAAW,GAAGH,IAAI,CAACI,IAAzB;;AAEA,eAASC,kBAAT,CAA4BP,IAA5B,EAAkCG,OAAlC,EAA2CK,IAA3C,EAAiD1E,QAAjD,EAA2D;AACzD,YAAI2E,OAAO,CAACC,UAAZ,EAAwB;AACtB,cAAI;AACFV,YAAAA,IAAI,GAAGS,OAAO,CAACC,UAAR,CAAmBC,UAAnB,CAA8BC,eAA9B,CAA8CZ,IAA9C,EAAoD;AACzDa,cAAAA,cAAc,EAAEC,iBAAiB,CAACjF,QAAD;AADwB,aAApD,CAAP;AAGD,WAJD,CAIE,OAAO+B,GAAP,EAAY,CACZ;AACA;AACA;AACA;AACD;AACF;;AAEDd,QAAAA,kBAAkB,CACfiE,IADH,CACQ,MAAMV,WAAW,CAACL,IAAD,EAAOG,OAAP,EAAgBK,IAAhB,EAAsB1E,QAAtB,CADzB,EAEGkF,KAFH,CAESlF,QAFT;AAGD,OA/CgB,CAiDjB;AACA;;;AACAoE,MAAAA,IAAI,CAACI,IAAL,GAAY,KAAKd,mBAAL,GAA2Be,kBAAvC;AACD;;AAEDN,IAAAA,qBAAqB,CAACzB,OAAD,EAAU;AAC7B;AACA,WAAKyC,iBAAL;AAEA,YAAMf,IAAI,GAAG,KAAKA,IAAlB,CAJ6B,CAM7B;AACA;AACA;;AACAtB,MAAAA,MAAM,CAACsC,cAAP,CAAsBhB,IAAI,CAACC,OAA3B,EAAoC,IAApC,EAA0C;AACxCgB,QAAAA,GAAG,EAAE,MAAMjB,IAAI,CAACkB,IADwB;AAExCC,QAAAA,GAAG,EAAGC,GAAD,IAAS;AACZpB,UAAAA,IAAI,CAACkB,IAAL,GAAYE,GAAZ;AACD,SAJuC;AAMxC;AACA;AACAC,QAAAA,YAAY,EAAE;AAR0B,OAA1C,EAT6B,CAoB7B;;AACA,eAASC,OAAT,CAAiBC,GAAjB,EAAsBC,QAAtB,EAAgC;AAC9B,cAAMC,IAAI,GAAGzB,IAAI,CAAC0B,QAAL,CAAcH,GAAd,KAAsBvB,IAAI,CAAC0B,QAAL,CAAc,MAAMH,GAApB,CAAnC;;AACA,YAAIE,IAAJ,EAAU;AACRA,UAAAA,IAAI,CAACE,IAAL,GAAYH,QAAZ;AACD;AACF;;AACDF,MAAAA,OAAO,CAAC,OAAD,EAAU,wDAAV,CAAP;AACAA,MAAAA,OAAO,CAAC,MAAD,EAAS,wCAAT,CAAP;AACAA,MAAAA,OAAO,CAAC,MAAD,EAAS,4BAAT,CAAP,CA7B6B,CA+B7B;AACA;;AACAtB,MAAAA,IAAI,CAACvC,EAAL,CAAQ,MAAR,EAAgB,YAAW;AACzB,YAAIa,OAAO,CAACa,MAAZ,EAAoB;AAClBb,UAAAA,OAAO,CAACa,MAAR,CAAeyC,KAAf,CAAqBlG,eAAe,GAAG,IAAvC;AACA4C,UAAAA,OAAO,CAACa,MAAR,CAAef,GAAf;AACD;AACF,OALD,EAjC6B,CAwC7B;AACA;;AACAyD,MAAAA,OAAO,CAACpE,EAAR,CAAW,MAAX,EAAmB,YAAW;AAC5B,YAAIa,OAAO,CAACa,MAAZ,EAAoB;AAClBb,UAAAA,OAAO,CAACa,MAAR,CAAef,GAAf;AACD;AACF,OAJD,EA1C6B,CAgD7B;AACA;;AACA4B,MAAAA,IAAI,CAAC8B,aAAL,CAAmB,QAAnB,EAA6B;AAC3BH,QAAAA,IAAI,EAAE,kCADqB;AAE3BI,QAAAA,MAAM,EAAE,YAAW;AACjB,cAAIF,OAAO,CAACG,WAAZ,EAAyB;AACvBH,YAAAA,OAAO,CAACG,WAAR,CAAoB,cAApB,EAAoC;AAAExC,cAAAA,OAAO,EAAE;AAAX,aAApC;AACD,WAFD,MAEO;AACLqC,YAAAA,OAAO,CAACI,IAAR,CAAa,CAAb;AACD;AACF;AAR0B,OAA7B;AAUD,KAhQU,CAkQX;AACA;;;AACAlB,IAAAA,iBAAiB,GAAG;AAClB,YAAMf,IAAI,GAAG,KAAKA,IAAlB;AACA,YAAMkC,WAAW,GAAGC,cAAc,CAAC,KAAKxG,QAAN,CAAlC;AACA,UAAIyG,SAAS,GAAGpH,QAAQ,CAACkH,WAAD,EAAc,IAAd,CAAxB;AACA,YAAMG,YAAY,GAAGpH,YAAY,CAACiH,WAAD,EAAc,MAAd,CAAZ,CAAkCI,KAAlC,CAAwC,IAAxC,CAArB;AACA,YAAMC,SAAS,GAAG7D,MAAM,CAACE,MAAP,CAAc,IAAd,CAAlB;;AAEA,UAAI,CAAEoB,IAAI,CAACwC,OAAX,EAAoB;AAClBxC,QAAAA,IAAI,CAACwC,OAAL,GAAe,EAAf;AACAxC,QAAAA,IAAI,CAACyC,YAAL,GAAoB,CAAC,CAArB;AACD;;AAED,aAAOzC,IAAI,CAACwC,OAAL,IAAgBH,YAAY,CAACK,MAAb,GAAsB,CAA7C,EAAgD;AAC9C,cAAMC,IAAI,GAAGN,YAAY,CAACO,GAAb,EAAb;;AACA,YAAID,IAAI,IAAI,KAAKE,IAAL,CAAUF,IAAV,CAAR,IAA2B,CAAEJ,SAAS,CAACI,IAAD,CAA1C,EAAkD;AAChD3C,UAAAA,IAAI,CAACwC,OAAL,CAAarG,IAAb,CAAkBwG,IAAlB;AACAJ,UAAAA,SAAS,CAACI,IAAD,CAAT,GAAkB,IAAlB;AACD;AACF;;AAED3C,MAAAA,IAAI,CAAC8C,WAAL,CAAiB,MAAjB,EAAyB,UAASH,IAAT,EAAe;AACtC,YAAIP,SAAS,IAAI,CAAb,IAAkB,KAAKS,IAAL,CAAUF,IAAV,CAAtB,EAAuC;AACrCvH,UAAAA,SAAS,CAACgH,SAAD,EAAYO,IAAI,GAAG,IAAnB,CAAT;AACD;AACF,OAJD;AAMA,WAAK3C,IAAL,CAAUvC,EAAV,CAAa,MAAb,EAAqB,YAAW;AAC9B1C,QAAAA,SAAS,CAACqH,SAAD,CAAT;AACAA,QAAAA,SAAS,GAAG,CAAC,CAAb;AACD,OAHD;AAID;;AAlSU;;AAqSb,WAAS/D,kBAAT,CAA4B0E,WAA5B,EAAyCnH,QAAzC,EAAmD;AACjD,UAAMoH,YAAY,GAAG,IAAIlI,WAAJ,EAArB;AACA,QAAImI,SAAS,GAAG,EAAhB;;AAEA,aAASC,MAAT,CAAgBC,MAAhB,EAAwB;AACtB,YAAMC,KAAK,GAAGD,MAAM,CAAC/F,QAAP,CAAgB,MAAhB,EAAwBkF,KAAxB,CAA8B,IAA9B,CAAd;;AAEA,aAAOc,KAAK,CAACV,MAAN,GAAe,CAAtB,EAAyB;AACvBO,QAAAA,SAAS,IAAIG,KAAK,CAACC,KAAN,EAAb;AAEA,YAAIC,IAAJ;;AACA,YAAI;AACFA,UAAAA,IAAI,GAAGhH,IAAI,CAACiH,KAAL,CAAWN,SAAX,CAAP;AACD,SAFD,CAEE,OAAOrF,KAAP,EAAc;AACd,cAAIA,KAAK,YAAY4F,WAArB,EAAkC;AAChC;AACD;;AAED,iBAAOC,MAAM,CAAC7F,KAAD,CAAb;AACD;;AAED,YAAIwF,KAAK,CAACV,MAAN,GAAe,CAAnB,EAAsB;AACpBM,UAAAA,YAAY,CAACpB,KAAb,CAAmBwB,KAAK,CAACvI,IAAN,CAAW,IAAX,CAAnB;AACD;;AAEDkI,QAAAA,WAAW,CAACW,IAAZ,CAAiBV,YAAjB;AAEA,eAAOS,MAAM,CAAC,IAAD,EAAOH,IAAP,CAAb;AACD;AACF;;AAED,aAASK,OAAT,GAAmB;AACjBF,MAAAA,MAAM,CAAC,IAAIG,KAAJ,CAAU,4BAAV,CAAD,CAAN;AACD;;AAED,QAAIC,QAAQ,GAAG,KAAf;;AACA,aAASJ,MAAT,CAAgB7F,KAAhB,EAAuB0F,IAAvB,EAA6B;AAC3B,UAAI,CAAEO,QAAN,EAAgB;AACdA,QAAAA,QAAQ,GAAG,IAAX;AACAd,QAAAA,WAAW,CAACe,cAAZ,CAA2B,MAA3B,EAAmCZ,MAAnC;AACAH,QAAAA,WAAW,CAACe,cAAZ,CAA2B,OAA3B,EAAoCL,MAApC;AACAV,QAAAA,WAAW,CAACe,cAAZ,CAA2B,OAA3B,EAAoCH,OAApC;AACA/H,QAAAA,QAAQ,CAACgC,KAAD,EAAQ0F,IAAR,EAAcN,YAAd,CAAR;AACD;AACF;;AAEDD,IAAAA,WAAW,CAACtF,EAAZ,CAAe,MAAf,EAAuByF,MAAvB;AACAH,IAAAA,WAAW,CAACtF,EAAZ,CAAe,OAAf,EAAwBgG,MAAxB;AACAV,IAAAA,WAAW,CAACtF,EAAZ,CAAe,OAAf,EAAwBkG,OAAxB;AACD;;AAED,WAAStH,WAAT,CAAqBV,QAArB,EAA+B;AAC7B,WAAOf,QAAQ,CAACe,QAAD,EAAW,WAAX,CAAf;AACD;;AAED,WAASwG,cAAT,CAAwBxG,QAAxB,EAAkC;AAChC,WAAOf,QAAQ,CAACe,QAAD,EAAW,SAAX,CAAf;AACD;;AAED,WAASiF,iBAAT,CAA2BjF,QAA3B,EAAqC;AACnC,WAAOf,QAAQ,CAACe,QAAD,EAAW,OAAX,CAAf;AACD;;AAED,WAASuE,mBAAT,CAA6BD,OAA7B,EAAsC;AACpC,QAAIM,OAAO,CAACwD,OAAZ,EAAqB;AACnB;AACA;AACA,YAAMC,aAAa,GAAG,EAAtB;AACA,YAAMC,eAAe,GAAG,kBACtB/G,IAAI,CAACC,MAAL,GAAcC,QAAd,CAAuB,EAAvB,EAA2BC,KAA3B,CAAiC,CAAjC,CADsB,GACgB,KADxC;;AAGA2G,MAAAA,aAAa,CAACC,eAAD,CAAb,GAAiC,UAAUC,OAAV,EAAmBC,OAAnB,EAA4BC,MAA5B,EAAoC;AACnEnE,QAAAA,OAAO,CAACmE,MAAR,GAAiBA,MAAjB;AACAnE,QAAAA,OAAO,CAACiE,OAAR,GAAkBA,OAAlB,CAFmE,CAInE;AACA;;AACAA,QAAAA,OAAO,CAACG,UAAR,GAAqB;AACnB,iBAAO,IADY;AAEnB,mBAAS,IAFU;AAGnB,mBAAS;AAHU,SAArB;AAKD,OAXD,CAPmB,CAoBnB;AACA;;;AACA9D,MAAAA,OAAO,CAACwD,OAAR,CAAgBO,aAAhB,CAA8BN,aAA9B,EAA6C,OAAOC,eAApD;AACD;AACF","sourcesContent":["import assert from \"assert\";\nimport { join as pathJoin } from \"path\";\nimport { PassThrough } from \"stream\";\nimport {\n  closeSync,\n  openSync,\n  readFileSync,\n  unlink,\n  writeFileSync,\n  writeSync,\n} from \"fs\";\nimport { createServer } from \"net\";\nimport { start as replStart } from \"repl\";\n\n// Enable process.sendMessage for communication with build process.\nimport \"meteor/inter-process-messaging\";\n\nconst INFO_FILE_MODE = parseInt(\"600\", 8); // Only the owner can read or write.\nconst EXITING_MESSAGE = \"Shell exiting...\";\n\n// Invoked by the server process to listen for incoming connections from\n// shell clients. Each connection gets its own REPL instance.\nexport function listen(shellDir) {\n  function callback() {\n    new Server(shellDir).listen();\n  }\n\n  // If the server is still in the very early stages of starting up,\n  // Meteor.startup may not available yet.\n  if (typeof Meteor === \"object\") {\n    Meteor.startup(callback);\n  } else if (typeof __meteor_bootstrap__ === \"object\") {\n    const hooks = __meteor_bootstrap__.startupHooks;\n    if (hooks) {\n      hooks.push(callback);\n    } else {\n      // As a fallback, just call the callback asynchronously.\n      setImmediate(callback);\n    }\n  }\n}\n\n// Disabling the shell causes all attached clients to disconnect and exit.\nexport function disable(shellDir) {\n  try {\n    // Replace info.json with a file that says the shell server is\n    // disabled, so that any connected shell clients will fail to\n    // reconnect after the server process closes their sockets.\n    writeFileSync(\n      getInfoFile(shellDir),\n      JSON.stringify({\n        status: \"disabled\",\n        reason: \"Shell server has shut down.\"\n      }) + \"\\n\",\n      { mode: INFO_FILE_MODE }\n    );\n  } catch (ignored) {}\n}\n\n// Shell commands need to be executed in a Fiber in case they call into\n// code that yields. Using a Promise is an even better idea, since it runs\n// its callbacks in Fibers drawn from a pool, so the Fibers are recycled.\nconst evalCommandPromise = Promise.resolve();\n\nclass Server {\n  constructor(shellDir) {\n    assert.ok(this instanceof Server);\n\n    this.shellDir = shellDir;\n    this.key = Math.random().toString(36).slice(2);\n\n    this.server =\n      createServer((socket) => {\n        this.onConnection(socket);\n      })\n      .on(\"error\", (err) => {\n        console.error(err.stack);\n      });\n  }\n\n  listen() {\n    const infoFile = getInfoFile(this.shellDir);\n\n    unlink(infoFile, () => {\n      this.server.listen(0, \"127.0.0.1\", () => {\n        writeFileSync(infoFile, JSON.stringify({\n          status: \"enabled\",\n          port: this.server.address().port,\n          key: this.key\n        }) + \"\\n\", {\n          mode: INFO_FILE_MODE\n        });\n      });\n    });\n  }\n\n  onConnection(socket) {\n    // Make sure this function doesn't try to write anything to the socket\n    // after it has been closed.\n    socket.on(\"close\", function() {\n      socket = null;\n    });\n\n    // If communication is not established within 1000ms of the first\n    // connection, forcibly close the socket.\n    const timeout = setTimeout(function() {\n      if (socket) {\n        socket.removeAllListeners(\"data\");\n        socket.end(EXITING_MESSAGE + \"\\n\");\n      }\n    }, 1000);\n\n    // Let connecting clients configure certain REPL options by sending a\n    // JSON object over the socket. For example, only the client knows\n    // whether it's running a TTY or an Emacs subshell or some other kind of\n    // terminal, so the client must decide the value of options.terminal.\n    readJSONFromStream(socket, (error, options, replInputSocket) => {\n      clearTimeout(timeout);\n\n      if (error) {\n        socket = null;\n        console.error(error.stack);\n        return;\n      }\n\n      if (options.key !== this.key) {\n        if (socket) {\n          socket.end(EXITING_MESSAGE + \"\\n\");\n        }\n        return;\n      }\n      delete options.key;\n\n      // Set the columns to what is being requested by the client.\n      if (options.columns && socket) {\n        socket.columns = options.columns;\n      }\n      delete options.columns;\n\n      options = Object.assign(\n        Object.create(null),\n\n        // Defaults for configurable options.\n        {\n          prompt: \"> \",\n          terminal: true,\n          useColors: true,\n          ignoreUndefined: true,\n        },\n\n        // Configurable options\n        options,\n\n        // Immutable options.\n        {\n          input: replInputSocket,\n          useGlobal: false,\n          output: socket\n        }\n      );\n\n      // The prompt during an evaluateAndExit must be blank to ensure\n      // that the prompt doesn't inadvertently get parsed as part of\n      // the JSON communication channel.\n      if (options.evaluateAndExit) {\n        options.prompt = \"\";\n      }\n\n      // Start the REPL.\n      this.startREPL(options);\n\n      if (options.evaluateAndExit) {\n        this._wrappedDefaultEval.call(\n          Object.create(null),\n          options.evaluateAndExit.command,\n          global,\n          options.evaluateAndExit.filename || \"<meteor shell>\",\n          function (error, result) {\n            if (socket) {\n              function sendResultToSocket(message) {\n                // Sending back a JSON payload allows the client to\n                // distinguish between errors and successful results.\n                socket.end(JSON.stringify(message) + \"\\n\");\n              }\n\n              if (error) {\n                sendResultToSocket({\n                  error: error.toString(),\n                  code: 1\n                });\n              } else {\n                sendResultToSocket({\n                  result,\n                });\n              }\n            }\n          }\n        );\n        return;\n      }\n      delete options.evaluateAndExit;\n\n      this.enableInteractiveMode(options);\n    });\n  }\n\n  startREPL(options) {\n    // Make sure this function doesn't try to write anything to the output\n    // stream after it has been closed.\n    options.output.on(\"close\", function() {\n      options.output = null;\n    });\n\n    const repl = this.repl = replStart(options);\n    const { shellDir } = this;\n\n    // This is technique of setting `repl.context` is similar to how the\n    // `useGlobal` option would work during a normal `repl.start()` and\n    // allows shell access (and tab completion!) to Meteor globals (i.e.\n    // Underscore _, Meteor, etc.). By using this technique, which changes\n    // the context after startup, we avoid stomping on the special `_`\n    // variable (in `repl` this equals the value of the last command) from\n    // being overridden in the client/server socket-handshaking.  Furthermore,\n    // by setting `useGlobal` back to true, we allow the default eval function\n    // to use the desired `runInThisContext` method (https://git.io/vbvAB).\n    repl.context = global;\n    repl.useGlobal = true;\n\n    setRequireAndModule(repl.context);\n\n    // In order to avoid duplicating code here, specifically the complexities\n    // of catching so-called \"Recoverable Errors\" (https://git.io/vbvbl),\n    // we will wrap the default eval, run it in a Fiber (via a Promise), and\n    // give it the opportunity to decide if the user is mid-code-block.\n    const defaultEval = repl.eval;\n\n    function wrappedDefaultEval(code, context, file, callback) {\n      if (Package.ecmascript) {\n        try {\n          code = Package.ecmascript.ECMAScript.compileForShell(code, {\n            cacheDirectory: getCacheDirectory(shellDir)\n          });\n        } catch (err) {\n          // Any Babel error here might be just fine since it's\n          // possible the code was incomplete (multi-line code on the REPL).\n          // The defaultEval below will use its own functionality to determine\n          // if this error is \"recoverable\".\n        }\n      }\n\n      evalCommandPromise\n        .then(() => defaultEval(code, context, file, callback))\n        .catch(callback);\n    }\n\n    // Have the REPL use the newly wrapped function instead and store the\n    // _wrappedDefaultEval so that evalulateAndExit calls can use it directly.\n    repl.eval = this._wrappedDefaultEval = wrappedDefaultEval;\n  }\n\n  enableInteractiveMode(options) {\n    // History persists across shell sessions!\n    this.initializeHistory();\n\n    const repl = this.repl;\n\n    // Implement an alternate means of fetching the return value,\n    // via `__` (double underscore) as originally implemented in:\n    // https://github.com/meteor/meteor/commit/2443d832265c7d1c\n    Object.defineProperty(repl.context, \"__\", {\n      get: () => repl.last,\n      set: (val) => {\n        repl.last = val;\n      },\n\n      // Allow this property to be (re)defined more than once (e.g. each\n      // time the server restarts).\n      configurable: true\n    });\n\n    // Some improvements to the existing help messages.\n    function addHelp(cmd, helpText) {\n      const info = repl.commands[cmd] || repl.commands[\".\" + cmd];\n      if (info) {\n        info.help = helpText;\n      }\n    }\n    addHelp(\"break\", \"Terminate current command input and display new prompt\");\n    addHelp(\"exit\", \"Disconnect from server and leave shell\");\n    addHelp(\"help\", \"Show this help information\");\n\n    // When the REPL exits, signal the attached client to exit by sending it\n    // the special EXITING_MESSAGE.\n    repl.on(\"exit\", function() {\n      if (options.output) {\n        options.output.write(EXITING_MESSAGE + \"\\n\");\n        options.output.end();\n      }\n    });\n\n    // When the server process exits, end the output stream but do not\n    // signal the attached client to exit.\n    process.on(\"exit\", function() {\n      if (options.output) {\n        options.output.end();\n      }\n    });\n\n    // This Meteor-specific shell command rebuilds the application as if a\n    // change was made to server code.\n    repl.defineCommand(\"reload\", {\n      help: \"Restart the server and the shell\",\n      action: function() {\n        if (process.sendMessage) {\n          process.sendMessage(\"shell-server\", { command: \"reload\" });\n        } else {\n          process.exit(0);\n        }\n      }\n    });\n  }\n\n  // This function allows a persistent history of shell commands to be saved\n  // to and loaded from .meteor/local/shell/history.\n  initializeHistory() {\n    const repl = this.repl;\n    const historyFile = getHistoryFile(this.shellDir);\n    let historyFd = openSync(historyFile, \"a+\");\n    const historyLines = readFileSync(historyFile, \"utf8\").split(\"\\n\");\n    const seenLines = Object.create(null);\n\n    if (! repl.history) {\n      repl.history = [];\n      repl.historyIndex = -1;\n    }\n\n    while (repl.history && historyLines.length > 0) {\n      const line = historyLines.pop();\n      if (line && /\\S/.test(line) && ! seenLines[line]) {\n        repl.history.push(line);\n        seenLines[line] = true;\n      }\n    }\n\n    repl.addListener(\"line\", function(line) {\n      if (historyFd >= 0 && /\\S/.test(line)) {\n        writeSync(historyFd, line + \"\\n\");\n      }\n    });\n\n    this.repl.on(\"exit\", function() {\n      closeSync(historyFd);\n      historyFd = -1;\n    });\n  }\n}\n\nfunction readJSONFromStream(inputStream, callback) {\n  const outputStream = new PassThrough();\n  let dataSoFar = \"\";\n\n  function onData(buffer) {\n    const lines = buffer.toString(\"utf8\").split(\"\\n\");\n\n    while (lines.length > 0) {\n      dataSoFar += lines.shift();\n\n      let json;\n      try {\n        json = JSON.parse(dataSoFar);\n      } catch (error) {\n        if (error instanceof SyntaxError) {\n          continue;\n        }\n\n        return finish(error);\n      }\n\n      if (lines.length > 0) {\n        outputStream.write(lines.join(\"\\n\"));\n      }\n\n      inputStream.pipe(outputStream);\n\n      return finish(null, json);\n    }\n  }\n\n  function onClose() {\n    finish(new Error(\"stream unexpectedly closed\"));\n  }\n\n  let finished = false;\n  function finish(error, json) {\n    if (! finished) {\n      finished = true;\n      inputStream.removeListener(\"data\", onData);\n      inputStream.removeListener(\"error\", finish);\n      inputStream.removeListener(\"close\", onClose);\n      callback(error, json, outputStream);\n    }\n  }\n\n  inputStream.on(\"data\", onData);\n  inputStream.on(\"error\", finish);\n  inputStream.on(\"close\", onClose);\n}\n\nfunction getInfoFile(shellDir) {\n  return pathJoin(shellDir, \"info.json\");\n}\n\nfunction getHistoryFile(shellDir) {\n  return pathJoin(shellDir, \"history\");\n}\n\nfunction getCacheDirectory(shellDir) {\n  return pathJoin(shellDir, \"cache\");\n}\n\nfunction setRequireAndModule(context) {\n  if (Package.modules) {\n    // Use the same `require` function and `module` object visible to the\n    // application.\n    const toBeInstalled = {};\n    const shellModuleName = \"meteor-shell-\" +\n      Math.random().toString(36).slice(2) + \".js\";\n\n    toBeInstalled[shellModuleName] = function (require, exports, module) {\n      context.module = module;\n      context.require = require;\n\n      // Tab completion sometimes uses require.extensions, but only for\n      // the keys.\n      require.extensions = {\n        \".js\": true,\n        \".json\": true,\n        \".node\": true,\n      };\n    };\n\n    // This populates repl.context.{module,require} by evaluating the\n    // module defined above.\n    Package.modules.meteorInstall(toBeInstalled)(\"./\" + shellModuleName);\n  }\n}\n"]},"sourceType":"module","hash":"0d86224f9fb09c3c364883fefcda624c00439757"}
