{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/packages/minimongo/common.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"packages/minimongo/common.js","filename":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/packages/minimongo/common.js","targets":{"android":"95.0.0","chrome":"95.0.0","edge":"95.0.0","firefox":"78.0.0","ie":"10.0.0","ios":"15.0.0","opera":"81.0.0","safari":"15.1.0","samsung":"14.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat","root":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.16.5","helpers":true,"useESModules":false,"corejs":false}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/packages/minimongo/common.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/minimongo/common.js"}},"code":"module.export({\n  hasOwn: () => hasOwn,\n  ELEMENT_OPERATORS: () => ELEMENT_OPERATORS,\n  compileDocumentSelector: () => compileDocumentSelector,\n  equalityElementMatcher: () => equalityElementMatcher,\n  expandArraysInBranches: () => expandArraysInBranches,\n  isIndexable: () => isIndexable,\n  isNumericKey: () => isNumericKey,\n  isOperatorObject: () => isOperatorObject,\n  makeLookupFunction: () => makeLookupFunction,\n  nothingMatcher: () => nothingMatcher,\n  pathsToTree: () => pathsToTree,\n  populateDocumentWithQueryFields: () => populateDocumentWithQueryFields,\n  projectionDetails: () => projectionDetails,\n  regexpElementMatcher: () => regexpElementMatcher\n});\nlet LocalCollection;\nmodule.link(\"./local_collection.js\", {\n  default(v) {\n    LocalCollection = v;\n  }\n\n}, 0);\nconst hasOwn = Object.prototype.hasOwnProperty;\nconst ELEMENT_OPERATORS = {\n  $lt: makeInequality(cmpValue => cmpValue < 0),\n  $gt: makeInequality(cmpValue => cmpValue > 0),\n  $lte: makeInequality(cmpValue => cmpValue <= 0),\n  $gte: makeInequality(cmpValue => cmpValue >= 0),\n  $mod: {\n    compileElementSelector(operand) {\n      if (!(Array.isArray(operand) && operand.length === 2 && typeof operand[0] === 'number' && typeof operand[1] === 'number')) {\n        throw Error('argument to $mod must be an array of two numbers');\n      } // XXX could require to be ints or round or something\n\n\n      const divisor = operand[0];\n      const remainder = operand[1];\n      return value => typeof value === 'number' && value % divisor === remainder;\n    }\n\n  },\n  $in: {\n    compileElementSelector(operand) {\n      if (!Array.isArray(operand)) {\n        throw Error('$in needs an array');\n      }\n\n      const elementMatchers = operand.map(option => {\n        if (option instanceof RegExp) {\n          return regexpElementMatcher(option);\n        }\n\n        if (isOperatorObject(option)) {\n          throw Error('cannot nest $ under $in');\n        }\n\n        return equalityElementMatcher(option);\n      });\n      return value => {\n        // Allow {a: {$in: [null]}} to match when 'a' does not exist.\n        if (value === undefined) {\n          value = null;\n        }\n\n        return elementMatchers.some(matcher => matcher(value));\n      };\n    }\n\n  },\n  $size: {\n    // {a: [[5, 5]]} must match {a: {$size: 1}} but not {a: {$size: 2}}, so we\n    // don't want to consider the element [5,5] in the leaf array [[5,5]] as a\n    // possible value.\n    dontExpandLeafArrays: true,\n\n    compileElementSelector(operand) {\n      if (typeof operand === 'string') {\n        // Don't ask me why, but by experimentation, this seems to be what Mongo\n        // does.\n        operand = 0;\n      } else if (typeof operand !== 'number') {\n        throw Error('$size needs a number');\n      }\n\n      return value => Array.isArray(value) && value.length === operand;\n    }\n\n  },\n  $type: {\n    // {a: [5]} must not match {a: {$type: 4}} (4 means array), but it should\n    // match {a: {$type: 1}} (1 means number), and {a: [[5]]} must match {$a:\n    // {$type: 4}}. Thus, when we see a leaf array, we *should* expand it but\n    // should *not* include it itself.\n    dontIncludeLeafArrays: true,\n\n    compileElementSelector(operand) {\n      if (typeof operand === 'string') {\n        const operandAliasMap = {\n          'double': 1,\n          'string': 2,\n          'object': 3,\n          'array': 4,\n          'binData': 5,\n          'undefined': 6,\n          'objectId': 7,\n          'bool': 8,\n          'date': 9,\n          'null': 10,\n          'regex': 11,\n          'dbPointer': 12,\n          'javascript': 13,\n          'symbol': 14,\n          'javascriptWithScope': 15,\n          'int': 16,\n          'timestamp': 17,\n          'long': 18,\n          'decimal': 19,\n          'minKey': -1,\n          'maxKey': 127\n        };\n\n        if (!hasOwn.call(operandAliasMap, operand)) {\n          throw Error(\"unknown string alias for $type: \".concat(operand));\n        }\n\n        operand = operandAliasMap[operand];\n      } else if (typeof operand === 'number') {\n        if (operand === 0 || operand < -1 || operand > 19 && operand !== 127) {\n          throw Error(\"Invalid numerical $type code: \".concat(operand));\n        }\n      } else {\n        throw Error('argument to $type is not a number or a string');\n      }\n\n      return value => value !== undefined && LocalCollection._f._type(value) === operand;\n    }\n\n  },\n  $bitsAllSet: {\n    compileElementSelector(operand) {\n      const mask = getOperandBitmask(operand, '$bitsAllSet');\n      return value => {\n        const bitmask = getValueBitmask(value, mask.length);\n        return bitmask && mask.every((byte, i) => (bitmask[i] & byte) === byte);\n      };\n    }\n\n  },\n  $bitsAnySet: {\n    compileElementSelector(operand) {\n      const mask = getOperandBitmask(operand, '$bitsAnySet');\n      return value => {\n        const bitmask = getValueBitmask(value, mask.length);\n        return bitmask && mask.some((byte, i) => (~bitmask[i] & byte) !== byte);\n      };\n    }\n\n  },\n  $bitsAllClear: {\n    compileElementSelector(operand) {\n      const mask = getOperandBitmask(operand, '$bitsAllClear');\n      return value => {\n        const bitmask = getValueBitmask(value, mask.length);\n        return bitmask && mask.every((byte, i) => !(bitmask[i] & byte));\n      };\n    }\n\n  },\n  $bitsAnyClear: {\n    compileElementSelector(operand) {\n      const mask = getOperandBitmask(operand, '$bitsAnyClear');\n      return value => {\n        const bitmask = getValueBitmask(value, mask.length);\n        return bitmask && mask.some((byte, i) => (bitmask[i] & byte) !== byte);\n      };\n    }\n\n  },\n  $regex: {\n    compileElementSelector(operand, valueSelector) {\n      if (!(typeof operand === 'string' || operand instanceof RegExp)) {\n        throw Error('$regex has to be a string or RegExp');\n      }\n\n      let regexp;\n\n      if (valueSelector.$options !== undefined) {\n        // Options passed in $options (even the empty string) always overrides\n        // options in the RegExp object itself.\n        // Be clear that we only support the JS-supported options, not extended\n        // ones (eg, Mongo supports x and s). Ideally we would implement x and s\n        // by transforming the regexp, but not today...\n        if (/[^gim]/.test(valueSelector.$options)) {\n          throw new Error('Only the i, m, and g regexp options are supported');\n        }\n\n        const source = operand instanceof RegExp ? operand.source : operand;\n        regexp = new RegExp(source, valueSelector.$options);\n      } else if (operand instanceof RegExp) {\n        regexp = operand;\n      } else {\n        regexp = new RegExp(operand);\n      }\n\n      return regexpElementMatcher(regexp);\n    }\n\n  },\n  $elemMatch: {\n    dontExpandLeafArrays: true,\n\n    compileElementSelector(operand, valueSelector, matcher) {\n      if (!LocalCollection._isPlainObject(operand)) {\n        throw Error('$elemMatch need an object');\n      }\n\n      const isDocMatcher = !isOperatorObject(Object.keys(operand).filter(key => !hasOwn.call(LOGICAL_OPERATORS, key)).reduce((a, b) => Object.assign(a, {\n        [b]: operand[b]\n      }), {}), true);\n      let subMatcher;\n\n      if (isDocMatcher) {\n        // This is NOT the same as compileValueSelector(operand), and not just\n        // because of the slightly different calling convention.\n        // {$elemMatch: {x: 3}} means \"an element has a field x:3\", not\n        // \"consists only of a field x:3\". Also, regexps and sub-$ are allowed.\n        subMatcher = compileDocumentSelector(operand, matcher, {\n          inElemMatch: true\n        });\n      } else {\n        subMatcher = compileValueSelector(operand, matcher);\n      }\n\n      return value => {\n        if (!Array.isArray(value)) {\n          return false;\n        }\n\n        for (let i = 0; i < value.length; ++i) {\n          const arrayElement = value[i];\n          let arg;\n\n          if (isDocMatcher) {\n            // We can only match {$elemMatch: {b: 3}} against objects.\n            // (We can also match against arrays, if there's numeric indices,\n            // eg {$elemMatch: {'0.b': 3}} or {$elemMatch: {0: 3}}.)\n            if (!isIndexable(arrayElement)) {\n              return false;\n            }\n\n            arg = arrayElement;\n          } else {\n            // dontIterate ensures that {a: {$elemMatch: {$gt: 5}}} matches\n            // {a: [8]} but not {a: [[8]]}\n            arg = [{\n              value: arrayElement,\n              dontIterate: true\n            }];\n          } // XXX support $near in $elemMatch by propagating $distance?\n\n\n          if (subMatcher(arg).result) {\n            return i; // specially understood to mean \"use as arrayIndices\"\n          }\n        }\n\n        return false;\n      };\n    }\n\n  }\n};\n// Operators that appear at the top level of a document selector.\nconst LOGICAL_OPERATORS = {\n  $and(subSelector, matcher, inElemMatch) {\n    return andDocumentMatchers(compileArrayOfDocumentSelectors(subSelector, matcher, inElemMatch));\n  },\n\n  $or(subSelector, matcher, inElemMatch) {\n    const matchers = compileArrayOfDocumentSelectors(subSelector, matcher, inElemMatch); // Special case: if there is only one matcher, use it directly, *preserving*\n    // any arrayIndices it returns.\n\n    if (matchers.length === 1) {\n      return matchers[0];\n    }\n\n    return doc => {\n      const result = matchers.some(fn => fn(doc).result); // $or does NOT set arrayIndices when it has multiple\n      // sub-expressions. (Tested against MongoDB.)\n\n      return {\n        result\n      };\n    };\n  },\n\n  $nor(subSelector, matcher, inElemMatch) {\n    const matchers = compileArrayOfDocumentSelectors(subSelector, matcher, inElemMatch);\n    return doc => {\n      const result = matchers.every(fn => !fn(doc).result); // Never set arrayIndices, because we only match if nothing in particular\n      // 'matched' (and because this is consistent with MongoDB).\n\n      return {\n        result\n      };\n    };\n  },\n\n  $where(selectorValue, matcher) {\n    // Record that *any* path may be used.\n    matcher._recordPathUsed('');\n\n    matcher._hasWhere = true;\n\n    if (!(selectorValue instanceof Function)) {\n      // XXX MongoDB seems to have more complex logic to decide where or or not\n      // to add 'return'; not sure exactly what it is.\n      selectorValue = Function('obj', \"return \".concat(selectorValue));\n    } // We make the document available as both `this` and `obj`.\n    // // XXX not sure what we should do if this throws\n\n\n    return doc => ({\n      result: selectorValue.call(doc, doc)\n    });\n  },\n\n  // This is just used as a comment in the query (in MongoDB, it also ends up in\n  // query logs); it has no effect on the actual selection.\n  $comment() {\n    return () => ({\n      result: true\n    });\n  }\n\n}; // Operators that (unlike LOGICAL_OPERATORS) pertain to individual paths in a\n// document, but (unlike ELEMENT_OPERATORS) do not have a simple definition as\n// \"match each branched value independently and combine with\n// convertElementMatcherToBranchedMatcher\".\n\nconst VALUE_OPERATORS = {\n  $eq(operand) {\n    return convertElementMatcherToBranchedMatcher(equalityElementMatcher(operand));\n  },\n\n  $not(operand, valueSelector, matcher) {\n    return invertBranchedMatcher(compileValueSelector(operand, matcher));\n  },\n\n  $ne(operand) {\n    return invertBranchedMatcher(convertElementMatcherToBranchedMatcher(equalityElementMatcher(operand)));\n  },\n\n  $nin(operand) {\n    return invertBranchedMatcher(convertElementMatcherToBranchedMatcher(ELEMENT_OPERATORS.$in.compileElementSelector(operand)));\n  },\n\n  $exists(operand) {\n    const exists = convertElementMatcherToBranchedMatcher(value => value !== undefined);\n    return operand ? exists : invertBranchedMatcher(exists);\n  },\n\n  // $options just provides options for $regex; its logic is inside $regex\n  $options(operand, valueSelector) {\n    if (!hasOwn.call(valueSelector, '$regex')) {\n      throw Error('$options needs a $regex');\n    }\n\n    return everythingMatcher;\n  },\n\n  // $maxDistance is basically an argument to $near\n  $maxDistance(operand, valueSelector) {\n    if (!valueSelector.$near) {\n      throw Error('$maxDistance needs a $near');\n    }\n\n    return everythingMatcher;\n  },\n\n  $all(operand, valueSelector, matcher) {\n    if (!Array.isArray(operand)) {\n      throw Error('$all requires array');\n    } // Not sure why, but this seems to be what MongoDB does.\n\n\n    if (operand.length === 0) {\n      return nothingMatcher;\n    }\n\n    const branchedMatchers = operand.map(criterion => {\n      // XXX handle $all/$elemMatch combination\n      if (isOperatorObject(criterion)) {\n        throw Error('no $ expressions in $all');\n      } // This is always a regexp or equality selector.\n\n\n      return compileValueSelector(criterion, matcher);\n    }); // andBranchedMatchers does NOT require all selectors to return true on the\n    // SAME branch.\n\n    return andBranchedMatchers(branchedMatchers);\n  },\n\n  $near(operand, valueSelector, matcher, isRoot) {\n    if (!isRoot) {\n      throw Error('$near can\\'t be inside another $ operator');\n    }\n\n    matcher._hasGeoQuery = true; // There are two kinds of geodata in MongoDB: legacy coordinate pairs and\n    // GeoJSON. They use different distance metrics, too. GeoJSON queries are\n    // marked with a $geometry property, though legacy coordinates can be\n    // matched using $geometry.\n\n    let maxDistance, point, distance;\n\n    if (LocalCollection._isPlainObject(operand) && hasOwn.call(operand, '$geometry')) {\n      // GeoJSON \"2dsphere\" mode.\n      maxDistance = operand.$maxDistance;\n      point = operand.$geometry;\n\n      distance = value => {\n        // XXX: for now, we don't calculate the actual distance between, say,\n        // polygon and circle. If people care about this use-case it will get\n        // a priority.\n        if (!value) {\n          return null;\n        }\n\n        if (!value.type) {\n          return GeoJSON.pointDistance(point, {\n            type: 'Point',\n            coordinates: pointToArray(value)\n          });\n        }\n\n        if (value.type === 'Point') {\n          return GeoJSON.pointDistance(point, value);\n        }\n\n        return GeoJSON.geometryWithinRadius(value, point, maxDistance) ? 0 : maxDistance + 1;\n      };\n    } else {\n      maxDistance = valueSelector.$maxDistance;\n\n      if (!isIndexable(operand)) {\n        throw Error('$near argument must be coordinate pair or GeoJSON');\n      }\n\n      point = pointToArray(operand);\n\n      distance = value => {\n        if (!isIndexable(value)) {\n          return null;\n        }\n\n        return distanceCoordinatePairs(point, value);\n      };\n    }\n\n    return branchedValues => {\n      // There might be multiple points in the document that match the given\n      // field. Only one of them needs to be within $maxDistance, but we need to\n      // evaluate all of them and use the nearest one for the implicit sort\n      // specifier. (That's why we can't just use ELEMENT_OPERATORS here.)\n      //\n      // Note: This differs from MongoDB's implementation, where a document will\n      // actually show up *multiple times* in the result set, with one entry for\n      // each within-$maxDistance branching point.\n      const result = {\n        result: false\n      };\n      expandArraysInBranches(branchedValues).every(branch => {\n        // if operation is an update, don't skip branches, just return the first\n        // one (#3599)\n        let curDistance;\n\n        if (!matcher._isUpdate) {\n          if (!(typeof branch.value === 'object')) {\n            return true;\n          }\n\n          curDistance = distance(branch.value); // Skip branches that aren't real points or are too far away.\n\n          if (curDistance === null || curDistance > maxDistance) {\n            return true;\n          } // Skip anything that's a tie.\n\n\n          if (result.distance !== undefined && result.distance <= curDistance) {\n            return true;\n          }\n        }\n\n        result.result = true;\n        result.distance = curDistance;\n\n        if (branch.arrayIndices) {\n          result.arrayIndices = branch.arrayIndices;\n        } else {\n          delete result.arrayIndices;\n        }\n\n        return !matcher._isUpdate;\n      });\n      return result;\n    };\n  }\n\n}; // NB: We are cheating and using this function to implement 'AND' for both\n// 'document matchers' and 'branched matchers'. They both return result objects\n// but the argument is different: for the former it's a whole doc, whereas for\n// the latter it's an array of 'branched values'.\n\nfunction andSomeMatchers(subMatchers) {\n  if (subMatchers.length === 0) {\n    return everythingMatcher;\n  }\n\n  if (subMatchers.length === 1) {\n    return subMatchers[0];\n  }\n\n  return docOrBranches => {\n    const match = {};\n    match.result = subMatchers.every(fn => {\n      const subResult = fn(docOrBranches); // Copy a 'distance' number out of the first sub-matcher that has\n      // one. Yes, this means that if there are multiple $near fields in a\n      // query, something arbitrary happens; this appears to be consistent with\n      // Mongo.\n\n      if (subResult.result && subResult.distance !== undefined && match.distance === undefined) {\n        match.distance = subResult.distance;\n      } // Similarly, propagate arrayIndices from sub-matchers... but to match\n      // MongoDB behavior, this time the *last* sub-matcher with arrayIndices\n      // wins.\n\n\n      if (subResult.result && subResult.arrayIndices) {\n        match.arrayIndices = subResult.arrayIndices;\n      }\n\n      return subResult.result;\n    }); // If we didn't actually match, forget any extra metadata we came up with.\n\n    if (!match.result) {\n      delete match.distance;\n      delete match.arrayIndices;\n    }\n\n    return match;\n  };\n}\n\nconst andDocumentMatchers = andSomeMatchers;\nconst andBranchedMatchers = andSomeMatchers;\n\nfunction compileArrayOfDocumentSelectors(selectors, matcher, inElemMatch) {\n  if (!Array.isArray(selectors) || selectors.length === 0) {\n    throw Error('$and/$or/$nor must be nonempty array');\n  }\n\n  return selectors.map(subSelector => {\n    if (!LocalCollection._isPlainObject(subSelector)) {\n      throw Error('$or/$and/$nor entries need to be full objects');\n    }\n\n    return compileDocumentSelector(subSelector, matcher, {\n      inElemMatch\n    });\n  });\n} // Takes in a selector that could match a full document (eg, the original\n// selector). Returns a function mapping document->result object.\n//\n// matcher is the Matcher object we are compiling.\n//\n// If this is the root document selector (ie, not wrapped in $and or the like),\n// then isRoot is true. (This is used by $near.)\n\n\nfunction compileDocumentSelector(docSelector, matcher) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const docMatchers = Object.keys(docSelector).map(key => {\n    const subSelector = docSelector[key];\n\n    if (key.substr(0, 1) === '$') {\n      // Outer operators are either logical operators (they recurse back into\n      // this function), or $where.\n      if (!hasOwn.call(LOGICAL_OPERATORS, key)) {\n        throw new Error(\"Unrecognized logical operator: \".concat(key));\n      }\n\n      matcher._isSimple = false;\n      return LOGICAL_OPERATORS[key](subSelector, matcher, options.inElemMatch);\n    } // Record this path, but only if we aren't in an elemMatcher, since in an\n    // elemMatch this is a path inside an object in an array, not in the doc\n    // root.\n\n\n    if (!options.inElemMatch) {\n      matcher._recordPathUsed(key);\n    } // Don't add a matcher if subSelector is a function -- this is to match\n    // the behavior of Meteor on the server (inherited from the node mongodb\n    // driver), which is to ignore any part of a selector which is a function.\n\n\n    if (typeof subSelector === 'function') {\n      return undefined;\n    }\n\n    const lookUpByIndex = makeLookupFunction(key);\n    const valueMatcher = compileValueSelector(subSelector, matcher, options.isRoot);\n    return doc => valueMatcher(lookUpByIndex(doc));\n  }).filter(Boolean);\n  return andDocumentMatchers(docMatchers);\n}\n\n// Takes in a selector that could match a key-indexed value in a document; eg,\n// {$gt: 5, $lt: 9}, or a regular expression, or any non-expression object (to\n// indicate equality).  Returns a branched matcher: a function mapping\n// [branched value]->result object.\nfunction compileValueSelector(valueSelector, matcher, isRoot) {\n  if (valueSelector instanceof RegExp) {\n    matcher._isSimple = false;\n    return convertElementMatcherToBranchedMatcher(regexpElementMatcher(valueSelector));\n  }\n\n  if (isOperatorObject(valueSelector)) {\n    return operatorBranchedMatcher(valueSelector, matcher, isRoot);\n  }\n\n  return convertElementMatcherToBranchedMatcher(equalityElementMatcher(valueSelector));\n} // Given an element matcher (which evaluates a single value), returns a branched\n// value (which evaluates the element matcher on all the branches and returns a\n// more structured return value possibly including arrayIndices).\n\n\nfunction convertElementMatcherToBranchedMatcher(elementMatcher) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return branches => {\n    const expanded = options.dontExpandLeafArrays ? branches : expandArraysInBranches(branches, options.dontIncludeLeafArrays);\n    const match = {};\n    match.result = expanded.some(element => {\n      let matched = elementMatcher(element.value); // Special case for $elemMatch: it means \"true, and use this as an array\n      // index if I didn't already have one\".\n\n      if (typeof matched === 'number') {\n        // XXX This code dates from when we only stored a single array index\n        // (for the outermost array). Should we be also including deeper array\n        // indices from the $elemMatch match?\n        if (!element.arrayIndices) {\n          element.arrayIndices = [matched];\n        }\n\n        matched = true;\n      } // If some element matched, and it's tagged with array indices, include\n      // those indices in our result object.\n\n\n      if (matched && element.arrayIndices) {\n        match.arrayIndices = element.arrayIndices;\n      }\n\n      return matched;\n    });\n    return match;\n  };\n} // Helpers for $near.\n\n\nfunction distanceCoordinatePairs(a, b) {\n  const pointA = pointToArray(a);\n  const pointB = pointToArray(b);\n  return Math.hypot(pointA[0] - pointB[0], pointA[1] - pointB[1]);\n} // Takes something that is not an operator object and returns an element matcher\n// for equality with that thing.\n\n\nfunction equalityElementMatcher(elementSelector) {\n  if (isOperatorObject(elementSelector)) {\n    throw Error('Can\\'t create equalityValueSelector for operator object');\n  } // Special-case: null and undefined are equal (if you got undefined in there\n  // somewhere, or if you got it due to some branch being non-existent in the\n  // weird special case), even though they aren't with EJSON.equals.\n  // undefined or null\n\n\n  if (elementSelector == null) {\n    return value => value == null;\n  }\n\n  return value => LocalCollection._f._equal(elementSelector, value);\n}\n\nfunction everythingMatcher(docOrBranchedValues) {\n  return {\n    result: true\n  };\n}\n\nfunction expandArraysInBranches(branches, skipTheArrays) {\n  const branchesOut = [];\n  branches.forEach(branch => {\n    const thisIsArray = Array.isArray(branch.value); // We include the branch itself, *UNLESS* we it's an array that we're going\n    // to iterate and we're told to skip arrays.  (That's right, we include some\n    // arrays even skipTheArrays is true: these are arrays that were found via\n    // explicit numerical indices.)\n\n    if (!(skipTheArrays && thisIsArray && !branch.dontIterate)) {\n      branchesOut.push({\n        arrayIndices: branch.arrayIndices,\n        value: branch.value\n      });\n    }\n\n    if (thisIsArray && !branch.dontIterate) {\n      branch.value.forEach((value, i) => {\n        branchesOut.push({\n          arrayIndices: (branch.arrayIndices || []).concat(i),\n          value\n        });\n      });\n    }\n  });\n  return branchesOut;\n}\n\n// Helpers for $bitsAllSet/$bitsAnySet/$bitsAllClear/$bitsAnyClear.\nfunction getOperandBitmask(operand, selector) {\n  // numeric bitmask\n  // You can provide a numeric bitmask to be matched against the operand field.\n  // It must be representable as a non-negative 32-bit signed integer.\n  // Otherwise, $bitsAllSet will return an error.\n  if (Number.isInteger(operand) && operand >= 0) {\n    return new Uint8Array(new Int32Array([operand]).buffer);\n  } // bindata bitmask\n  // You can also use an arbitrarily large BinData instance as a bitmask.\n\n\n  if (EJSON.isBinary(operand)) {\n    return new Uint8Array(operand.buffer);\n  } // position list\n  // If querying a list of bit positions, each <position> must be a non-negative\n  // integer. Bit positions start at 0 from the least significant bit.\n\n\n  if (Array.isArray(operand) && operand.every(x => Number.isInteger(x) && x >= 0)) {\n    const buffer = new ArrayBuffer((Math.max(...operand) >> 3) + 1);\n    const view = new Uint8Array(buffer);\n    operand.forEach(x => {\n      view[x >> 3] |= 1 << (x & 0x7);\n    });\n    return view;\n  } // bad operand\n\n\n  throw Error(\"operand to \".concat(selector, \" must be a numeric bitmask (representable as a \") + 'non-negative 32-bit signed integer), a bindata bitmask or an array with ' + 'bit positions (non-negative integers)');\n}\n\nfunction getValueBitmask(value, length) {\n  // The field value must be either numerical or a BinData instance. Otherwise,\n  // $bits... will not match the current document.\n  // numerical\n  if (Number.isSafeInteger(value)) {\n    // $bits... will not match numerical values that cannot be represented as a\n    // signed 64-bit integer. This can be the case if a value is either too\n    // large or small to fit in a signed 64-bit integer, or if it has a\n    // fractional component.\n    const buffer = new ArrayBuffer(Math.max(length, 2 * Uint32Array.BYTES_PER_ELEMENT));\n    let view = new Uint32Array(buffer, 0, 2);\n    view[0] = value % ((1 << 16) * (1 << 16)) | 0;\n    view[1] = value / ((1 << 16) * (1 << 16)) | 0; // sign extension\n\n    if (value < 0) {\n      view = new Uint8Array(buffer, 2);\n      view.forEach((byte, i) => {\n        view[i] = 0xff;\n      });\n    }\n\n    return new Uint8Array(buffer);\n  } // bindata\n\n\n  if (EJSON.isBinary(value)) {\n    return new Uint8Array(value.buffer);\n  } // no match\n\n\n  return false;\n} // Actually inserts a key value into the selector document\n// However, this checks there is no ambiguity in setting\n// the value for the given key, throws otherwise\n\n\nfunction insertIntoDocument(document, key, value) {\n  Object.keys(document).forEach(existingKey => {\n    if (existingKey.length > key.length && existingKey.indexOf(\"\".concat(key, \".\")) === 0 || key.length > existingKey.length && key.indexOf(\"\".concat(existingKey, \".\")) === 0) {\n      throw new Error(\"cannot infer query fields to set, both paths '\".concat(existingKey, \"' and \") + \"'\".concat(key, \"' are matched\"));\n    } else if (existingKey === key) {\n      throw new Error(\"cannot infer query fields to set, path '\".concat(key, \"' is matched twice\"));\n    }\n  });\n  document[key] = value;\n} // Returns a branched matcher that matches iff the given matcher does not.\n// Note that this implicitly \"deMorganizes\" the wrapped function.  ie, it\n// means that ALL branch values need to fail to match innerBranchedMatcher.\n\n\nfunction invertBranchedMatcher(branchedMatcher) {\n  return branchValues => {\n    // We explicitly choose to strip arrayIndices here: it doesn't make sense to\n    // say \"update the array element that does not match something\", at least\n    // in mongo-land.\n    return {\n      result: !branchedMatcher(branchValues).result\n    };\n  };\n}\n\nfunction isIndexable(obj) {\n  return Array.isArray(obj) || LocalCollection._isPlainObject(obj);\n}\n\nfunction isNumericKey(s) {\n  return /^[0-9]+$/.test(s);\n}\n\nfunction isOperatorObject(valueSelector, inconsistentOK) {\n  if (!LocalCollection._isPlainObject(valueSelector)) {\n    return false;\n  }\n\n  let theseAreOperators = undefined;\n  Object.keys(valueSelector).forEach(selKey => {\n    const thisIsOperator = selKey.substr(0, 1) === '$';\n\n    if (theseAreOperators === undefined) {\n      theseAreOperators = thisIsOperator;\n    } else if (theseAreOperators !== thisIsOperator) {\n      if (!inconsistentOK) {\n        throw new Error(\"Inconsistent operator: \".concat(JSON.stringify(valueSelector)));\n      }\n\n      theseAreOperators = false;\n    }\n  });\n  return !!theseAreOperators; // {} has no operators\n}\n\n// Helper for $lt/$gt/$lte/$gte.\nfunction makeInequality(cmpValueComparator) {\n  return {\n    compileElementSelector(operand) {\n      // Arrays never compare false with non-arrays for any inequality.\n      // XXX This was behavior we observed in pre-release MongoDB 2.5, but\n      //     it seems to have been reverted.\n      //     See https://jira.mongodb.org/browse/SERVER-11444\n      if (Array.isArray(operand)) {\n        return () => false;\n      } // Special case: consider undefined and null the same (so true with\n      // $gte/$lte).\n\n\n      if (operand === undefined) {\n        operand = null;\n      }\n\n      const operandType = LocalCollection._f._type(operand);\n\n      return value => {\n        if (value === undefined) {\n          value = null;\n        } // Comparisons are never true among things of different type (except\n        // null vs undefined).\n\n\n        if (LocalCollection._f._type(value) !== operandType) {\n          return false;\n        }\n\n        return cmpValueComparator(LocalCollection._f._cmp(value, operand));\n      };\n    }\n\n  };\n} // makeLookupFunction(key) returns a lookup function.\n//\n// A lookup function takes in a document and returns an array of matching\n// branches.  If no arrays are found while looking up the key, this array will\n// have exactly one branches (possibly 'undefined', if some segment of the key\n// was not found).\n//\n// If arrays are found in the middle, this can have more than one element, since\n// we 'branch'. When we 'branch', if there are more key segments to look up,\n// then we only pursue branches that are plain objects (not arrays or scalars).\n// This means we can actually end up with no branches!\n//\n// We do *NOT* branch on arrays that are found at the end (ie, at the last\n// dotted member of the key). We just return that array; if you want to\n// effectively 'branch' over the array's values, post-process the lookup\n// function with expandArraysInBranches.\n//\n// Each branch is an object with keys:\n//  - value: the value at the branch\n//  - dontIterate: an optional bool; if true, it means that 'value' is an array\n//    that expandArraysInBranches should NOT expand. This specifically happens\n//    when there is a numeric index in the key, and ensures the\n//    perhaps-surprising MongoDB behavior where {'a.0': 5} does NOT\n//    match {a: [[5]]}.\n//  - arrayIndices: if any array indexing was done during lookup (either due to\n//    explicit numeric indices or implicit branching), this will be an array of\n//    the array indices used, from outermost to innermost; it is falsey or\n//    absent if no array index is used. If an explicit numeric index is used,\n//    the index will be followed in arrayIndices by the string 'x'.\n//\n//    Note: arrayIndices is used for two purposes. First, it is used to\n//    implement the '$' modifier feature, which only ever looks at its first\n//    element.\n//\n//    Second, it is used for sort key generation, which needs to be able to tell\n//    the difference between different paths. Moreover, it needs to\n//    differentiate between explicit and implicit branching, which is why\n//    there's the somewhat hacky 'x' entry: this means that explicit and\n//    implicit array lookups will have different full arrayIndices paths. (That\n//    code only requires that different paths have different arrayIndices; it\n//    doesn't actually 'parse' arrayIndices. As an alternative, arrayIndices\n//    could contain objects with flags like 'implicit', but I think that only\n//    makes the code surrounding them more complex.)\n//\n//    (By the way, this field ends up getting passed around a lot without\n//    cloning, so never mutate any arrayIndices field/var in this package!)\n//\n//\n// At the top level, you may only pass in a plain object or array.\n//\n// See the test 'minimongo - lookup' for some examples of what lookup functions\n// return.\n\n\nfunction makeLookupFunction(key) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const parts = key.split('.');\n  const firstPart = parts.length ? parts[0] : '';\n  const lookupRest = parts.length > 1 && makeLookupFunction(parts.slice(1).join('.'), options);\n\n  const omitUnnecessaryFields = result => {\n    if (!result.dontIterate) {\n      delete result.dontIterate;\n    }\n\n    if (result.arrayIndices && !result.arrayIndices.length) {\n      delete result.arrayIndices;\n    }\n\n    return result;\n  }; // Doc will always be a plain object or an array.\n  // apply an explicit numeric index, an array.\n\n\n  return function (doc) {\n    let arrayIndices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    if (Array.isArray(doc)) {\n      // If we're being asked to do an invalid lookup into an array (non-integer\n      // or out-of-bounds), return no results (which is different from returning\n      // a single undefined result, in that `null` equality checks won't match).\n      if (!(isNumericKey(firstPart) && firstPart < doc.length)) {\n        return [];\n      } // Remember that we used this array index. Include an 'x' to indicate that\n      // the previous index came from being considered as an explicit array\n      // index (not branching).\n\n\n      arrayIndices = arrayIndices.concat(+firstPart, 'x');\n    } // Do our first lookup.\n\n\n    const firstLevel = doc[firstPart]; // If there is no deeper to dig, return what we found.\n    //\n    // If what we found is an array, most value selectors will choose to treat\n    // the elements of the array as matchable values in their own right, but\n    // that's done outside of the lookup function. (Exceptions to this are $size\n    // and stuff relating to $elemMatch.  eg, {a: {$size: 2}} does not match {a:\n    // [[1, 2]]}.)\n    //\n    // That said, if we just did an *explicit* array lookup (on doc) to find\n    // firstLevel, and firstLevel is an array too, we do NOT want value\n    // selectors to iterate over it.  eg, {'a.0': 5} does not match {a: [[5]]}.\n    // So in that case, we mark the return value as 'don't iterate'.\n\n    if (!lookupRest) {\n      return [omitUnnecessaryFields({\n        arrayIndices,\n        dontIterate: Array.isArray(doc) && Array.isArray(firstLevel),\n        value: firstLevel\n      })];\n    } // We need to dig deeper.  But if we can't, because what we've found is not\n    // an array or plain object, we're done. If we just did a numeric index into\n    // an array, we return nothing here (this is a change in Mongo 2.5 from\n    // Mongo 2.4, where {'a.0.b': null} stopped matching {a: [5]}). Otherwise,\n    // return a single `undefined` (which can, for example, match via equality\n    // with `null`).\n\n\n    if (!isIndexable(firstLevel)) {\n      if (Array.isArray(doc)) {\n        return [];\n      }\n\n      return [omitUnnecessaryFields({\n        arrayIndices,\n        value: undefined\n      })];\n    }\n\n    const result = [];\n\n    const appendToResult = more => {\n      result.push(...more);\n    }; // Dig deeper: look up the rest of the parts on whatever we've found.\n    // (lookupRest is smart enough to not try to do invalid lookups into\n    // firstLevel if it's an array.)\n\n\n    appendToResult(lookupRest(firstLevel, arrayIndices)); // If we found an array, then in *addition* to potentially treating the next\n    // part as a literal integer lookup, we should also 'branch': try to look up\n    // the rest of the parts on each array element in parallel.\n    //\n    // In this case, we *only* dig deeper into array elements that are plain\n    // objects. (Recall that we only got this far if we have further to dig.)\n    // This makes sense: we certainly don't dig deeper into non-indexable\n    // objects. And it would be weird to dig into an array: it's simpler to have\n    // a rule that explicit integer indexes only apply to an outer array, not to\n    // an array you find after a branching search.\n    //\n    // In the special case of a numeric part in a *sort selector* (not a query\n    // selector), we skip the branching: we ONLY allow the numeric part to mean\n    // 'look up this index' in that case, not 'also look up this index in all\n    // the elements of the array'.\n\n    if (Array.isArray(firstLevel) && !(isNumericKey(parts[1]) && options.forSort)) {\n      firstLevel.forEach((branch, arrayIndex) => {\n        if (LocalCollection._isPlainObject(branch)) {\n          appendToResult(lookupRest(branch, arrayIndices.concat(arrayIndex)));\n        }\n      });\n    }\n\n    return result;\n  };\n}\n\n// Object exported only for unit testing.\n// Use it to export private functions to test in Tinytest.\nMinimongoTest = {\n  makeLookupFunction\n};\n\nMinimongoError = function (message) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof message === 'string' && options.field) {\n    message += \" for field '\".concat(options.field, \"'\");\n  }\n\n  const error = new Error(message);\n  error.name = 'MinimongoError';\n  return error;\n};\n\nfunction nothingMatcher(docOrBranchedValues) {\n  return {\n    result: false\n  };\n}\n\n// Takes an operator object (an object with $ keys) and returns a branched\n// matcher for it.\nfunction operatorBranchedMatcher(valueSelector, matcher, isRoot) {\n  // Each valueSelector works separately on the various branches.  So one\n  // operator can match one branch and another can match another branch.  This\n  // is OK.\n  const operatorMatchers = Object.keys(valueSelector).map(operator => {\n    const operand = valueSelector[operator];\n    const simpleRange = ['$lt', '$lte', '$gt', '$gte'].includes(operator) && typeof operand === 'number';\n    const simpleEquality = ['$ne', '$eq'].includes(operator) && operand !== Object(operand);\n    const simpleInclusion = ['$in', '$nin'].includes(operator) && Array.isArray(operand) && !operand.some(x => x === Object(x));\n\n    if (!(simpleRange || simpleInclusion || simpleEquality)) {\n      matcher._isSimple = false;\n    }\n\n    if (hasOwn.call(VALUE_OPERATORS, operator)) {\n      return VALUE_OPERATORS[operator](operand, valueSelector, matcher, isRoot);\n    }\n\n    if (hasOwn.call(ELEMENT_OPERATORS, operator)) {\n      const options = ELEMENT_OPERATORS[operator];\n      return convertElementMatcherToBranchedMatcher(options.compileElementSelector(operand, valueSelector, matcher), options);\n    }\n\n    throw new Error(\"Unrecognized operator: \".concat(operator));\n  });\n  return andBranchedMatchers(operatorMatchers);\n} // paths - Array: list of mongo style paths\n// newLeafFn - Function: of form function(path) should return a scalar value to\n//                       put into list created for that path\n// conflictFn - Function: of form function(node, path, fullPath) is called\n//                        when building a tree path for 'fullPath' node on\n//                        'path' was already a leaf with a value. Must return a\n//                        conflict resolution.\n// initial tree - Optional Object: starting tree.\n// @returns - Object: tree represented as a set of nested objects\n\n\nfunction pathsToTree(paths, newLeafFn, conflictFn) {\n  let root = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  paths.forEach(path => {\n    const pathArray = path.split('.');\n    let tree = root; // use .every just for iteration with break\n\n    const success = pathArray.slice(0, -1).every((key, i) => {\n      if (!hasOwn.call(tree, key)) {\n        tree[key] = {};\n      } else if (tree[key] !== Object(tree[key])) {\n        tree[key] = conflictFn(tree[key], pathArray.slice(0, i + 1).join('.'), path); // break out of loop if we are failing for this path\n\n        if (tree[key] !== Object(tree[key])) {\n          return false;\n        }\n      }\n\n      tree = tree[key];\n      return true;\n    });\n\n    if (success) {\n      const lastKey = pathArray[pathArray.length - 1];\n\n      if (hasOwn.call(tree, lastKey)) {\n        tree[lastKey] = conflictFn(tree[lastKey], path, path);\n      } else {\n        tree[lastKey] = newLeafFn(path);\n      }\n    }\n  });\n  return root;\n}\n\n// Makes sure we get 2 elements array and assume the first one to be x and\n// the second one to y no matter what user passes.\n// In case user passes { lon: x, lat: y } returns [x, y]\nfunction pointToArray(point) {\n  return Array.isArray(point) ? point.slice() : [point.x, point.y];\n} // Creating a document from an upsert is quite tricky.\n// E.g. this selector: {\"$or\": [{\"b.foo\": {\"$all\": [\"bar\"]}}]}, should result\n// in: {\"b.foo\": \"bar\"}\n// But this selector: {\"$or\": [{\"b\": {\"foo\": {\"$all\": [\"bar\"]}}}]} should throw\n// an error\n// Some rules (found mainly with trial & error, so there might be more):\n// - handle all childs of $and (or implicit $and)\n// - handle $or nodes with exactly 1 child\n// - ignore $or nodes with more than 1 child\n// - ignore $nor and $not nodes\n// - throw when a value can not be set unambiguously\n// - every value for $all should be dealt with as separate $eq-s\n// - threat all children of $all as $eq setters (=> set if $all.length === 1,\n//   otherwise throw error)\n// - you can not mix '$'-prefixed keys and non-'$'-prefixed keys\n// - you can only have dotted keys on a root-level\n// - you can not have '$'-prefixed keys more than one-level deep in an object\n// Handles one key/value pair to put in the selector document\n\n\nfunction populateDocumentWithKeyValue(document, key, value) {\n  if (value && Object.getPrototypeOf(value) === Object.prototype) {\n    populateDocumentWithObject(document, key, value);\n  } else if (!(value instanceof RegExp)) {\n    insertIntoDocument(document, key, value);\n  }\n} // Handles a key, value pair to put in the selector document\n// if the value is an object\n\n\nfunction populateDocumentWithObject(document, key, value) {\n  const keys = Object.keys(value);\n  const unprefixedKeys = keys.filter(op => op[0] !== '$');\n\n  if (unprefixedKeys.length > 0 || !keys.length) {\n    // Literal (possibly empty) object ( or empty object )\n    // Don't allow mixing '$'-prefixed with non-'$'-prefixed fields\n    if (keys.length !== unprefixedKeys.length) {\n      throw new Error(\"unknown operator: \".concat(unprefixedKeys[0]));\n    }\n\n    validateObject(value, key);\n    insertIntoDocument(document, key, value);\n  } else {\n    Object.keys(value).forEach(op => {\n      const object = value[op];\n\n      if (op === '$eq') {\n        populateDocumentWithKeyValue(document, key, object);\n      } else if (op === '$all') {\n        // every value for $all should be dealt with as separate $eq-s\n        object.forEach(element => populateDocumentWithKeyValue(document, key, element));\n      }\n    });\n  }\n} // Fills a document with certain fields from an upsert selector\n\n\nfunction populateDocumentWithQueryFields(query) {\n  let document = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (Object.getPrototypeOf(query) === Object.prototype) {\n    // handle implicit $and\n    Object.keys(query).forEach(key => {\n      const value = query[key];\n\n      if (key === '$and') {\n        // handle explicit $and\n        value.forEach(element => populateDocumentWithQueryFields(element, document));\n      } else if (key === '$or') {\n        // handle $or nodes with exactly 1 child\n        if (value.length === 1) {\n          populateDocumentWithQueryFields(value[0], document);\n        }\n      } else if (key[0] !== '$') {\n        // Ignore other '$'-prefixed logical selectors\n        populateDocumentWithKeyValue(document, key, value);\n      }\n    });\n  } else {\n    // Handle meteor-specific shortcut for selecting _id\n    if (LocalCollection._selectorIsId(query)) {\n      insertIntoDocument(document, '_id', query);\n    }\n  }\n\n  return document;\n}\n\nfunction projectionDetails(fields) {\n  // Find the non-_id keys (_id is handled specially because it is included\n  // unless explicitly excluded). Sort the keys, so that our code to detect\n  // overlaps like 'foo' and 'foo.bar' can assume that 'foo' comes first.\n  let fieldsKeys = Object.keys(fields).sort(); // If _id is the only field in the projection, do not remove it, since it is\n  // required to determine if this is an exclusion or exclusion. Also keep an\n  // inclusive _id, since inclusive _id follows the normal rules about mixing\n  // inclusive and exclusive fields. If _id is not the only field in the\n  // projection and is exclusive, remove it so it can be handled later by a\n  // special case, since exclusive _id is always allowed.\n\n  if (!(fieldsKeys.length === 1 && fieldsKeys[0] === '_id') && !(fieldsKeys.includes('_id') && fields._id)) {\n    fieldsKeys = fieldsKeys.filter(key => key !== '_id');\n  }\n\n  let including = null; // Unknown\n\n  fieldsKeys.forEach(keyPath => {\n    const rule = !!fields[keyPath];\n\n    if (including === null) {\n      including = rule;\n    } // This error message is copied from MongoDB shell\n\n\n    if (including !== rule) {\n      throw MinimongoError('You cannot currently mix including and excluding fields.');\n    }\n  });\n  const projectionRulesTree = pathsToTree(fieldsKeys, path => including, (node, path, fullPath) => {\n    // Check passed projection fields' keys: If you have two rules such as\n    // 'foo.bar' and 'foo.bar.baz', then the result becomes ambiguous. If\n    // that happens, there is a probability you are doing something wrong,\n    // framework should notify you about such mistake earlier on cursor\n    // compilation step than later during runtime.  Note, that real mongo\n    // doesn't do anything about it and the later rule appears in projection\n    // project, more priority it takes.\n    //\n    // Example, assume following in mongo shell:\n    // > db.coll.insert({ a: { b: 23, c: 44 } })\n    // > db.coll.find({}, { 'a': 1, 'a.b': 1 })\n    // {\"_id\": ObjectId(\"520bfe456024608e8ef24af3\"), \"a\": {\"b\": 23}}\n    // > db.coll.find({}, { 'a.b': 1, 'a': 1 })\n    // {\"_id\": ObjectId(\"520bfe456024608e8ef24af3\"), \"a\": {\"b\": 23, \"c\": 44}}\n    //\n    // Note, how second time the return set of keys is different.\n    const currentPath = fullPath;\n    const anotherPath = path;\n    throw MinimongoError(\"both \".concat(currentPath, \" and \").concat(anotherPath, \" found in fields option, \") + 'using both of them may trigger unexpected behavior. Did you mean to ' + 'use only one of them?');\n  });\n  return {\n    including,\n    tree: projectionRulesTree\n  };\n}\n\nfunction regexpElementMatcher(regexp) {\n  return value => {\n    if (value instanceof RegExp) {\n      return value.toString() === regexp.toString();\n    } // Regexps only work against strings.\n\n\n    if (typeof value !== 'string') {\n      return false;\n    } // Reset regexp's state to avoid inconsistent matching for objects with the\n    // same value on consecutive calls of regexp.test. This happens only if the\n    // regexp has the 'g' flag. Also note that ES6 introduces a new flag 'y' for\n    // which we should *not* change the lastIndex but MongoDB doesn't support\n    // either of these flags.\n\n\n    regexp.lastIndex = 0;\n    return regexp.test(value);\n  };\n}\n\n// Validates the key in a path.\n// Objects that are nested more then 1 level cannot have dotted fields\n// or fields starting with '$'\nfunction validateKeyInPath(key, path) {\n  if (key.includes('.')) {\n    throw new Error(\"The dotted field '\".concat(key, \"' in '\").concat(path, \".\").concat(key, \" is not valid for storage.\"));\n  }\n\n  if (key[0] === '$') {\n    throw new Error(\"The dollar ($) prefixed field  '\".concat(path, \".\").concat(key, \" is not valid for storage.\"));\n  }\n} // Recursively validates an object that is nested more than one level deep\n\n\nfunction validateObject(object, path) {\n  if (object && Object.getPrototypeOf(object) === Object.prototype) {\n    Object.keys(object).forEach(key => {\n      validateKeyInPath(key, path);\n      validateObject(object[key], path + '.' + key);\n    });\n  }\n}","map":{"version":3,"sources":["packages/minimongo/common.js"],"names":["module","export","hasOwn","ELEMENT_OPERATORS","compileDocumentSelector","equalityElementMatcher","expandArraysInBranches","isIndexable","isNumericKey","isOperatorObject","makeLookupFunction","nothingMatcher","pathsToTree","populateDocumentWithQueryFields","projectionDetails","regexpElementMatcher","LocalCollection","link","default","v","Object","prototype","hasOwnProperty","$lt","makeInequality","cmpValue","$gt","$lte","$gte","$mod","compileElementSelector","operand","Array","isArray","length","Error","divisor","remainder","value","$in","elementMatchers","map","option","RegExp","undefined","some","matcher","$size","dontExpandLeafArrays","$type","dontIncludeLeafArrays","operandAliasMap","call","_f","_type","$bitsAllSet","mask","getOperandBitmask","bitmask","getValueBitmask","every","byte","i","$bitsAnySet","$bitsAllClear","$bitsAnyClear","$regex","valueSelector","regexp","$options","test","source","$elemMatch","_isPlainObject","isDocMatcher","keys","filter","key","LOGICAL_OPERATORS","reduce","a","b","assign","subMatcher","inElemMatch","compileValueSelector","arrayElement","arg","dontIterate","result","$and","subSelector","andDocumentMatchers","compileArrayOfDocumentSelectors","$or","matchers","doc","fn","$nor","$where","selectorValue","_recordPathUsed","_hasWhere","Function","$comment","VALUE_OPERATORS","$eq","convertElementMatcherToBranchedMatcher","$not","invertBranchedMatcher","$ne","$nin","$exists","exists","everythingMatcher","$maxDistance","$near","$all","branchedMatchers","criterion","andBranchedMatchers","isRoot","_hasGeoQuery","maxDistance","point","distance","$geometry","type","GeoJSON","pointDistance","coordinates","pointToArray","geometryWithinRadius","distanceCoordinatePairs","branchedValues","branch","curDistance","_isUpdate","arrayIndices","andSomeMatchers","subMatchers","docOrBranches","match","subResult","selectors","docSelector","options","docMatchers","substr","_isSimple","lookUpByIndex","valueMatcher","Boolean","operatorBranchedMatcher","elementMatcher","branches","expanded","element","matched","pointA","pointB","Math","hypot","elementSelector","_equal","docOrBranchedValues","skipTheArrays","branchesOut","forEach","thisIsArray","push","concat","selector","Number","isInteger","Uint8Array","Int32Array","buffer","EJSON","isBinary","x","ArrayBuffer","max","view","isSafeInteger","Uint32Array","BYTES_PER_ELEMENT","insertIntoDocument","document","existingKey","indexOf","branchedMatcher","branchValues","obj","s","inconsistentOK","theseAreOperators","selKey","thisIsOperator","JSON","stringify","cmpValueComparator","operandType","_cmp","parts","split","firstPart","lookupRest","slice","join","omitUnnecessaryFields","firstLevel","appendToResult","more","forSort","arrayIndex","MinimongoTest","MinimongoError","message","field","error","name","operatorMatchers","operator","simpleRange","includes","simpleEquality","simpleInclusion","paths","newLeafFn","conflictFn","root","path","pathArray","tree","success","lastKey","y","populateDocumentWithKeyValue","getPrototypeOf","populateDocumentWithObject","unprefixedKeys","op","validateObject","object","query","_selectorIsId","fields","fieldsKeys","sort","_id","including","keyPath","rule","projectionRulesTree","node","fullPath","currentPath","anotherPath","toString","lastIndex","validateKeyInPath"],"mappings":"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","sourcesContent":["import LocalCollection from './local_collection.js';\n\nexport const hasOwn = Object.prototype.hasOwnProperty;\n\n// Each element selector contains:\n//  - compileElementSelector, a function with args:\n//    - operand - the \"right hand side\" of the operator\n//    - valueSelector - the \"context\" for the operator (so that $regex can find\n//      $options)\n//    - matcher - the Matcher this is going into (so that $elemMatch can compile\n//      more things)\n//    returning a function mapping a single value to bool.\n//  - dontExpandLeafArrays, a bool which prevents expandArraysInBranches from\n//    being called\n//  - dontIncludeLeafArrays, a bool which causes an argument to be passed to\n//    expandArraysInBranches if it is called\nexport const ELEMENT_OPERATORS = {\n  $lt: makeInequality(cmpValue => cmpValue < 0),\n  $gt: makeInequality(cmpValue => cmpValue > 0),\n  $lte: makeInequality(cmpValue => cmpValue <= 0),\n  $gte: makeInequality(cmpValue => cmpValue >= 0),\n  $mod: {\n    compileElementSelector(operand) {\n      if (!(Array.isArray(operand) && operand.length === 2\n            && typeof operand[0] === 'number'\n            && typeof operand[1] === 'number')) {\n        throw Error('argument to $mod must be an array of two numbers');\n      }\n\n      // XXX could require to be ints or round or something\n      const divisor = operand[0];\n      const remainder = operand[1];\n      return value => (\n        typeof value === 'number' && value % divisor === remainder\n      );\n    },\n  },\n  $in: {\n    compileElementSelector(operand) {\n      if (!Array.isArray(operand)) {\n        throw Error('$in needs an array');\n      }\n\n      const elementMatchers = operand.map(option => {\n        if (option instanceof RegExp) {\n          return regexpElementMatcher(option);\n        }\n\n        if (isOperatorObject(option)) {\n          throw Error('cannot nest $ under $in');\n        }\n\n        return equalityElementMatcher(option);\n      });\n\n      return value => {\n        // Allow {a: {$in: [null]}} to match when 'a' does not exist.\n        if (value === undefined) {\n          value = null;\n        }\n\n        return elementMatchers.some(matcher => matcher(value));\n      };\n    },\n  },\n  $size: {\n    // {a: [[5, 5]]} must match {a: {$size: 1}} but not {a: {$size: 2}}, so we\n    // don't want to consider the element [5,5] in the leaf array [[5,5]] as a\n    // possible value.\n    dontExpandLeafArrays: true,\n    compileElementSelector(operand) {\n      if (typeof operand === 'string') {\n        // Don't ask me why, but by experimentation, this seems to be what Mongo\n        // does.\n        operand = 0;\n      } else if (typeof operand !== 'number') {\n        throw Error('$size needs a number');\n      }\n\n      return value => Array.isArray(value) && value.length === operand;\n    },\n  },\n  $type: {\n    // {a: [5]} must not match {a: {$type: 4}} (4 means array), but it should\n    // match {a: {$type: 1}} (1 means number), and {a: [[5]]} must match {$a:\n    // {$type: 4}}. Thus, when we see a leaf array, we *should* expand it but\n    // should *not* include it itself.\n    dontIncludeLeafArrays: true,\n    compileElementSelector(operand) {\n      if (typeof operand === 'string') {\n        const operandAliasMap = {\n          'double': 1,\n          'string': 2,\n          'object': 3,\n          'array': 4,\n          'binData': 5,\n          'undefined': 6,\n          'objectId': 7,\n          'bool': 8,\n          'date': 9,\n          'null': 10,\n          'regex': 11,\n          'dbPointer': 12,\n          'javascript': 13,\n          'symbol': 14,\n          'javascriptWithScope': 15,\n          'int': 16,\n          'timestamp': 17,\n          'long': 18,\n          'decimal': 19,\n          'minKey': -1,\n          'maxKey': 127,\n        };\n        if (!hasOwn.call(operandAliasMap, operand)) {\n          throw Error(`unknown string alias for $type: ${operand}`);\n        }\n        operand = operandAliasMap[operand];\n      } else if (typeof operand === 'number') {\n        if (operand === 0 || operand < -1\n          || (operand > 19 && operand !== 127)) {\n          throw Error(`Invalid numerical $type code: ${operand}`);\n        }\n      } else {\n        throw Error('argument to $type is not a number or a string');\n      }\n\n      return value => (\n        value !== undefined && LocalCollection._f._type(value) === operand\n      );\n    },\n  },\n  $bitsAllSet: {\n    compileElementSelector(operand) {\n      const mask = getOperandBitmask(operand, '$bitsAllSet');\n      return value => {\n        const bitmask = getValueBitmask(value, mask.length);\n        return bitmask && mask.every((byte, i) => (bitmask[i] & byte) === byte);\n      };\n    },\n  },\n  $bitsAnySet: {\n    compileElementSelector(operand) {\n      const mask = getOperandBitmask(operand, '$bitsAnySet');\n      return value => {\n        const bitmask = getValueBitmask(value, mask.length);\n        return bitmask && mask.some((byte, i) => (~bitmask[i] & byte) !== byte);\n      };\n    },\n  },\n  $bitsAllClear: {\n    compileElementSelector(operand) {\n      const mask = getOperandBitmask(operand, '$bitsAllClear');\n      return value => {\n        const bitmask = getValueBitmask(value, mask.length);\n        return bitmask && mask.every((byte, i) => !(bitmask[i] & byte));\n      };\n    },\n  },\n  $bitsAnyClear: {\n    compileElementSelector(operand) {\n      const mask = getOperandBitmask(operand, '$bitsAnyClear');\n      return value => {\n        const bitmask = getValueBitmask(value, mask.length);\n        return bitmask && mask.some((byte, i) => (bitmask[i] & byte) !== byte);\n      };\n    },\n  },\n  $regex: {\n    compileElementSelector(operand, valueSelector) {\n      if (!(typeof operand === 'string' || operand instanceof RegExp)) {\n        throw Error('$regex has to be a string or RegExp');\n      }\n\n      let regexp;\n      if (valueSelector.$options !== undefined) {\n        // Options passed in $options (even the empty string) always overrides\n        // options in the RegExp object itself.\n\n        // Be clear that we only support the JS-supported options, not extended\n        // ones (eg, Mongo supports x and s). Ideally we would implement x and s\n        // by transforming the regexp, but not today...\n        if (/[^gim]/.test(valueSelector.$options)) {\n          throw new Error('Only the i, m, and g regexp options are supported');\n        }\n\n        const source = operand instanceof RegExp ? operand.source : operand;\n        regexp = new RegExp(source, valueSelector.$options);\n      } else if (operand instanceof RegExp) {\n        regexp = operand;\n      } else {\n        regexp = new RegExp(operand);\n      }\n\n      return regexpElementMatcher(regexp);\n    },\n  },\n  $elemMatch: {\n    dontExpandLeafArrays: true,\n    compileElementSelector(operand, valueSelector, matcher) {\n      if (!LocalCollection._isPlainObject(operand)) {\n        throw Error('$elemMatch need an object');\n      }\n\n      const isDocMatcher = !isOperatorObject(\n        Object.keys(operand)\n          .filter(key => !hasOwn.call(LOGICAL_OPERATORS, key))\n          .reduce((a, b) => Object.assign(a, {[b]: operand[b]}), {}),\n        true);\n\n      let subMatcher;\n      if (isDocMatcher) {\n        // This is NOT the same as compileValueSelector(operand), and not just\n        // because of the slightly different calling convention.\n        // {$elemMatch: {x: 3}} means \"an element has a field x:3\", not\n        // \"consists only of a field x:3\". Also, regexps and sub-$ are allowed.\n        subMatcher =\n          compileDocumentSelector(operand, matcher, {inElemMatch: true});\n      } else {\n        subMatcher = compileValueSelector(operand, matcher);\n      }\n\n      return value => {\n        if (!Array.isArray(value)) {\n          return false;\n        }\n\n        for (let i = 0; i < value.length; ++i) {\n          const arrayElement = value[i];\n          let arg;\n          if (isDocMatcher) {\n            // We can only match {$elemMatch: {b: 3}} against objects.\n            // (We can also match against arrays, if there's numeric indices,\n            // eg {$elemMatch: {'0.b': 3}} or {$elemMatch: {0: 3}}.)\n            if (!isIndexable(arrayElement)) {\n              return false;\n            }\n\n            arg = arrayElement;\n          } else {\n            // dontIterate ensures that {a: {$elemMatch: {$gt: 5}}} matches\n            // {a: [8]} but not {a: [[8]]}\n            arg = [{value: arrayElement, dontIterate: true}];\n          }\n          // XXX support $near in $elemMatch by propagating $distance?\n          if (subMatcher(arg).result) {\n            return i; // specially understood to mean \"use as arrayIndices\"\n          }\n        }\n\n        return false;\n      };\n    },\n  },\n};\n\n// Operators that appear at the top level of a document selector.\nconst LOGICAL_OPERATORS = {\n  $and(subSelector, matcher, inElemMatch) {\n    return andDocumentMatchers(\n      compileArrayOfDocumentSelectors(subSelector, matcher, inElemMatch)\n    );\n  },\n\n  $or(subSelector, matcher, inElemMatch) {\n    const matchers = compileArrayOfDocumentSelectors(\n      subSelector,\n      matcher,\n      inElemMatch\n    );\n\n    // Special case: if there is only one matcher, use it directly, *preserving*\n    // any arrayIndices it returns.\n    if (matchers.length === 1) {\n      return matchers[0];\n    }\n\n    return doc => {\n      const result = matchers.some(fn => fn(doc).result);\n      // $or does NOT set arrayIndices when it has multiple\n      // sub-expressions. (Tested against MongoDB.)\n      return {result};\n    };\n  },\n\n  $nor(subSelector, matcher, inElemMatch) {\n    const matchers = compileArrayOfDocumentSelectors(\n      subSelector,\n      matcher,\n      inElemMatch\n    );\n    return doc => {\n      const result = matchers.every(fn => !fn(doc).result);\n      // Never set arrayIndices, because we only match if nothing in particular\n      // 'matched' (and because this is consistent with MongoDB).\n      return {result};\n    };\n  },\n\n  $where(selectorValue, matcher) {\n    // Record that *any* path may be used.\n    matcher._recordPathUsed('');\n    matcher._hasWhere = true;\n\n    if (!(selectorValue instanceof Function)) {\n      // XXX MongoDB seems to have more complex logic to decide where or or not\n      // to add 'return'; not sure exactly what it is.\n      selectorValue = Function('obj', `return ${selectorValue}`);\n    }\n\n    // We make the document available as both `this` and `obj`.\n    // // XXX not sure what we should do if this throws\n    return doc => ({result: selectorValue.call(doc, doc)});\n  },\n\n  // This is just used as a comment in the query (in MongoDB, it also ends up in\n  // query logs); it has no effect on the actual selection.\n  $comment() {\n    return () => ({result: true});\n  },\n};\n\n// Operators that (unlike LOGICAL_OPERATORS) pertain to individual paths in a\n// document, but (unlike ELEMENT_OPERATORS) do not have a simple definition as\n// \"match each branched value independently and combine with\n// convertElementMatcherToBranchedMatcher\".\nconst VALUE_OPERATORS = {\n  $eq(operand) {\n    return convertElementMatcherToBranchedMatcher(\n      equalityElementMatcher(operand)\n    );\n  },\n  $not(operand, valueSelector, matcher) {\n    return invertBranchedMatcher(compileValueSelector(operand, matcher));\n  },\n  $ne(operand) {\n    return invertBranchedMatcher(\n      convertElementMatcherToBranchedMatcher(equalityElementMatcher(operand))\n    );\n  },\n  $nin(operand) {\n    return invertBranchedMatcher(\n      convertElementMatcherToBranchedMatcher(\n        ELEMENT_OPERATORS.$in.compileElementSelector(operand)\n      )\n    );\n  },\n  $exists(operand) {\n    const exists = convertElementMatcherToBranchedMatcher(\n      value => value !== undefined\n    );\n    return operand ? exists : invertBranchedMatcher(exists);\n  },\n  // $options just provides options for $regex; its logic is inside $regex\n  $options(operand, valueSelector) {\n    if (!hasOwn.call(valueSelector, '$regex')) {\n      throw Error('$options needs a $regex');\n    }\n\n    return everythingMatcher;\n  },\n  // $maxDistance is basically an argument to $near\n  $maxDistance(operand, valueSelector) {\n    if (!valueSelector.$near) {\n      throw Error('$maxDistance needs a $near');\n    }\n\n    return everythingMatcher;\n  },\n  $all(operand, valueSelector, matcher) {\n    if (!Array.isArray(operand)) {\n      throw Error('$all requires array');\n    }\n\n    // Not sure why, but this seems to be what MongoDB does.\n    if (operand.length === 0) {\n      return nothingMatcher;\n    }\n\n    const branchedMatchers = operand.map(criterion => {\n      // XXX handle $all/$elemMatch combination\n      if (isOperatorObject(criterion)) {\n        throw Error('no $ expressions in $all');\n      }\n\n      // This is always a regexp or equality selector.\n      return compileValueSelector(criterion, matcher);\n    });\n\n    // andBranchedMatchers does NOT require all selectors to return true on the\n    // SAME branch.\n    return andBranchedMatchers(branchedMatchers);\n  },\n  $near(operand, valueSelector, matcher, isRoot) {\n    if (!isRoot) {\n      throw Error('$near can\\'t be inside another $ operator');\n    }\n\n    matcher._hasGeoQuery = true;\n\n    // There are two kinds of geodata in MongoDB: legacy coordinate pairs and\n    // GeoJSON. They use different distance metrics, too. GeoJSON queries are\n    // marked with a $geometry property, though legacy coordinates can be\n    // matched using $geometry.\n    let maxDistance, point, distance;\n    if (LocalCollection._isPlainObject(operand) && hasOwn.call(operand, '$geometry')) {\n      // GeoJSON \"2dsphere\" mode.\n      maxDistance = operand.$maxDistance;\n      point = operand.$geometry;\n      distance = value => {\n        // XXX: for now, we don't calculate the actual distance between, say,\n        // polygon and circle. If people care about this use-case it will get\n        // a priority.\n        if (!value) {\n          return null;\n        }\n\n        if (!value.type) {\n          return GeoJSON.pointDistance(\n            point,\n            {type: 'Point', coordinates: pointToArray(value)}\n          );\n        }\n\n        if (value.type === 'Point') {\n          return GeoJSON.pointDistance(point, value);\n        }\n\n        return GeoJSON.geometryWithinRadius(value, point, maxDistance)\n          ? 0\n          : maxDistance + 1;\n      };\n    } else {\n      maxDistance = valueSelector.$maxDistance;\n\n      if (!isIndexable(operand)) {\n        throw Error('$near argument must be coordinate pair or GeoJSON');\n      }\n\n      point = pointToArray(operand);\n\n      distance = value => {\n        if (!isIndexable(value)) {\n          return null;\n        }\n\n        return distanceCoordinatePairs(point, value);\n      };\n    }\n\n    return branchedValues => {\n      // There might be multiple points in the document that match the given\n      // field. Only one of them needs to be within $maxDistance, but we need to\n      // evaluate all of them and use the nearest one for the implicit sort\n      // specifier. (That's why we can't just use ELEMENT_OPERATORS here.)\n      //\n      // Note: This differs from MongoDB's implementation, where a document will\n      // actually show up *multiple times* in the result set, with one entry for\n      // each within-$maxDistance branching point.\n      const result = {result: false};\n      expandArraysInBranches(branchedValues).every(branch => {\n        // if operation is an update, don't skip branches, just return the first\n        // one (#3599)\n        let curDistance;\n        if (!matcher._isUpdate) {\n          if (!(typeof branch.value === 'object')) {\n            return true;\n          }\n\n          curDistance = distance(branch.value);\n\n          // Skip branches that aren't real points or are too far away.\n          if (curDistance === null || curDistance > maxDistance) {\n            return true;\n          }\n\n          // Skip anything that's a tie.\n          if (result.distance !== undefined && result.distance <= curDistance) {\n            return true;\n          }\n        }\n\n        result.result = true;\n        result.distance = curDistance;\n\n        if (branch.arrayIndices) {\n          result.arrayIndices = branch.arrayIndices;\n        } else {\n          delete result.arrayIndices;\n        }\n\n        return !matcher._isUpdate;\n      });\n\n      return result;\n    };\n  },\n};\n\n// NB: We are cheating and using this function to implement 'AND' for both\n// 'document matchers' and 'branched matchers'. They both return result objects\n// but the argument is different: for the former it's a whole doc, whereas for\n// the latter it's an array of 'branched values'.\nfunction andSomeMatchers(subMatchers) {\n  if (subMatchers.length === 0) {\n    return everythingMatcher;\n  }\n\n  if (subMatchers.length === 1) {\n    return subMatchers[0];\n  }\n\n  return docOrBranches => {\n    const match = {};\n    match.result = subMatchers.every(fn => {\n      const subResult = fn(docOrBranches);\n\n      // Copy a 'distance' number out of the first sub-matcher that has\n      // one. Yes, this means that if there are multiple $near fields in a\n      // query, something arbitrary happens; this appears to be consistent with\n      // Mongo.\n      if (subResult.result &&\n          subResult.distance !== undefined &&\n          match.distance === undefined) {\n        match.distance = subResult.distance;\n      }\n\n      // Similarly, propagate arrayIndices from sub-matchers... but to match\n      // MongoDB behavior, this time the *last* sub-matcher with arrayIndices\n      // wins.\n      if (subResult.result && subResult.arrayIndices) {\n        match.arrayIndices = subResult.arrayIndices;\n      }\n\n      return subResult.result;\n    });\n\n    // If we didn't actually match, forget any extra metadata we came up with.\n    if (!match.result) {\n      delete match.distance;\n      delete match.arrayIndices;\n    }\n\n    return match;\n  };\n}\n\nconst andDocumentMatchers = andSomeMatchers;\nconst andBranchedMatchers = andSomeMatchers;\n\nfunction compileArrayOfDocumentSelectors(selectors, matcher, inElemMatch) {\n  if (!Array.isArray(selectors) || selectors.length === 0) {\n    throw Error('$and/$or/$nor must be nonempty array');\n  }\n\n  return selectors.map(subSelector => {\n    if (!LocalCollection._isPlainObject(subSelector)) {\n      throw Error('$or/$and/$nor entries need to be full objects');\n    }\n\n    return compileDocumentSelector(subSelector, matcher, {inElemMatch});\n  });\n}\n\n// Takes in a selector that could match a full document (eg, the original\n// selector). Returns a function mapping document->result object.\n//\n// matcher is the Matcher object we are compiling.\n//\n// If this is the root document selector (ie, not wrapped in $and or the like),\n// then isRoot is true. (This is used by $near.)\nexport function compileDocumentSelector(docSelector, matcher, options = {}) {\n  const docMatchers = Object.keys(docSelector).map(key => {\n    const subSelector = docSelector[key];\n\n    if (key.substr(0, 1) === '$') {\n      // Outer operators are either logical operators (they recurse back into\n      // this function), or $where.\n      if (!hasOwn.call(LOGICAL_OPERATORS, key)) {\n        throw new Error(`Unrecognized logical operator: ${key}`);\n      }\n\n      matcher._isSimple = false;\n      return LOGICAL_OPERATORS[key](subSelector, matcher, options.inElemMatch);\n    }\n\n    // Record this path, but only if we aren't in an elemMatcher, since in an\n    // elemMatch this is a path inside an object in an array, not in the doc\n    // root.\n    if (!options.inElemMatch) {\n      matcher._recordPathUsed(key);\n    }\n\n    // Don't add a matcher if subSelector is a function -- this is to match\n    // the behavior of Meteor on the server (inherited from the node mongodb\n    // driver), which is to ignore any part of a selector which is a function.\n    if (typeof subSelector === 'function') {\n      return undefined;\n    }\n\n    const lookUpByIndex = makeLookupFunction(key);\n    const valueMatcher = compileValueSelector(\n      subSelector,\n      matcher,\n      options.isRoot\n    );\n\n    return doc => valueMatcher(lookUpByIndex(doc));\n  }).filter(Boolean);\n\n  return andDocumentMatchers(docMatchers);\n}\n\n// Takes in a selector that could match a key-indexed value in a document; eg,\n// {$gt: 5, $lt: 9}, or a regular expression, or any non-expression object (to\n// indicate equality).  Returns a branched matcher: a function mapping\n// [branched value]->result object.\nfunction compileValueSelector(valueSelector, matcher, isRoot) {\n  if (valueSelector instanceof RegExp) {\n    matcher._isSimple = false;\n    return convertElementMatcherToBranchedMatcher(\n      regexpElementMatcher(valueSelector)\n    );\n  }\n\n  if (isOperatorObject(valueSelector)) {\n    return operatorBranchedMatcher(valueSelector, matcher, isRoot);\n  }\n\n  return convertElementMatcherToBranchedMatcher(\n    equalityElementMatcher(valueSelector)\n  );\n}\n\n// Given an element matcher (which evaluates a single value), returns a branched\n// value (which evaluates the element matcher on all the branches and returns a\n// more structured return value possibly including arrayIndices).\nfunction convertElementMatcherToBranchedMatcher(elementMatcher, options = {}) {\n  return branches => {\n    const expanded = options.dontExpandLeafArrays\n      ? branches\n      : expandArraysInBranches(branches, options.dontIncludeLeafArrays);\n\n    const match = {};\n    match.result = expanded.some(element => {\n      let matched = elementMatcher(element.value);\n\n      // Special case for $elemMatch: it means \"true, and use this as an array\n      // index if I didn't already have one\".\n      if (typeof matched === 'number') {\n        // XXX This code dates from when we only stored a single array index\n        // (for the outermost array). Should we be also including deeper array\n        // indices from the $elemMatch match?\n        if (!element.arrayIndices) {\n          element.arrayIndices = [matched];\n        }\n\n        matched = true;\n      }\n\n      // If some element matched, and it's tagged with array indices, include\n      // those indices in our result object.\n      if (matched && element.arrayIndices) {\n        match.arrayIndices = element.arrayIndices;\n      }\n\n      return matched;\n    });\n\n    return match;\n  };\n}\n\n// Helpers for $near.\nfunction distanceCoordinatePairs(a, b) {\n  const pointA = pointToArray(a);\n  const pointB = pointToArray(b);\n\n  return Math.hypot(pointA[0] - pointB[0], pointA[1] - pointB[1]);\n}\n\n// Takes something that is not an operator object and returns an element matcher\n// for equality with that thing.\nexport function equalityElementMatcher(elementSelector) {\n  if (isOperatorObject(elementSelector)) {\n    throw Error('Can\\'t create equalityValueSelector for operator object');\n  }\n\n  // Special-case: null and undefined are equal (if you got undefined in there\n  // somewhere, or if you got it due to some branch being non-existent in the\n  // weird special case), even though they aren't with EJSON.equals.\n  // undefined or null\n  if (elementSelector == null) {\n    return value => value == null;\n  }\n\n  return value => LocalCollection._f._equal(elementSelector, value);\n}\n\nfunction everythingMatcher(docOrBranchedValues) {\n  return {result: true};\n}\n\nexport function expandArraysInBranches(branches, skipTheArrays) {\n  const branchesOut = [];\n\n  branches.forEach(branch => {\n    const thisIsArray = Array.isArray(branch.value);\n\n    // We include the branch itself, *UNLESS* we it's an array that we're going\n    // to iterate and we're told to skip arrays.  (That's right, we include some\n    // arrays even skipTheArrays is true: these are arrays that were found via\n    // explicit numerical indices.)\n    if (!(skipTheArrays && thisIsArray && !branch.dontIterate)) {\n      branchesOut.push({arrayIndices: branch.arrayIndices, value: branch.value});\n    }\n\n    if (thisIsArray && !branch.dontIterate) {\n      branch.value.forEach((value, i) => {\n        branchesOut.push({\n          arrayIndices: (branch.arrayIndices || []).concat(i),\n          value\n        });\n      });\n    }\n  });\n\n  return branchesOut;\n}\n\n// Helpers for $bitsAllSet/$bitsAnySet/$bitsAllClear/$bitsAnyClear.\nfunction getOperandBitmask(operand, selector) {\n  // numeric bitmask\n  // You can provide a numeric bitmask to be matched against the operand field.\n  // It must be representable as a non-negative 32-bit signed integer.\n  // Otherwise, $bitsAllSet will return an error.\n  if (Number.isInteger(operand) && operand >= 0) {\n    return new Uint8Array(new Int32Array([operand]).buffer);\n  }\n\n  // bindata bitmask\n  // You can also use an arbitrarily large BinData instance as a bitmask.\n  if (EJSON.isBinary(operand)) {\n    return new Uint8Array(operand.buffer);\n  }\n\n  // position list\n  // If querying a list of bit positions, each <position> must be a non-negative\n  // integer. Bit positions start at 0 from the least significant bit.\n  if (Array.isArray(operand) &&\n      operand.every(x => Number.isInteger(x) && x >= 0)) {\n    const buffer = new ArrayBuffer((Math.max(...operand) >> 3) + 1);\n    const view = new Uint8Array(buffer);\n\n    operand.forEach(x => {\n      view[x >> 3] |= 1 << (x & 0x7);\n    });\n\n    return view;\n  }\n\n  // bad operand\n  throw Error(\n    `operand to ${selector} must be a numeric bitmask (representable as a ` +\n    'non-negative 32-bit signed integer), a bindata bitmask or an array with ' +\n    'bit positions (non-negative integers)'\n  );\n}\n\nfunction getValueBitmask(value, length) {\n  // The field value must be either numerical or a BinData instance. Otherwise,\n  // $bits... will not match the current document.\n\n  // numerical\n  if (Number.isSafeInteger(value)) {\n    // $bits... will not match numerical values that cannot be represented as a\n    // signed 64-bit integer. This can be the case if a value is either too\n    // large or small to fit in a signed 64-bit integer, or if it has a\n    // fractional component.\n    const buffer = new ArrayBuffer(\n      Math.max(length, 2 * Uint32Array.BYTES_PER_ELEMENT)\n    );\n\n    let view = new Uint32Array(buffer, 0, 2);\n    view[0] = value % ((1 << 16) * (1 << 16)) | 0;\n    view[1] = value / ((1 << 16) * (1 << 16)) | 0;\n\n    // sign extension\n    if (value < 0) {\n      view = new Uint8Array(buffer, 2);\n      view.forEach((byte, i) => {\n        view[i] = 0xff;\n      });\n    }\n\n    return new Uint8Array(buffer);\n  }\n\n  // bindata\n  if (EJSON.isBinary(value)) {\n    return new Uint8Array(value.buffer);\n  }\n\n  // no match\n  return false;\n}\n\n// Actually inserts a key value into the selector document\n// However, this checks there is no ambiguity in setting\n// the value for the given key, throws otherwise\nfunction insertIntoDocument(document, key, value) {\n  Object.keys(document).forEach(existingKey => {\n    if (\n      (existingKey.length > key.length && existingKey.indexOf(`${key}.`) === 0) ||\n      (key.length > existingKey.length && key.indexOf(`${existingKey}.`) === 0)\n    ) {\n      throw new Error(\n        `cannot infer query fields to set, both paths '${existingKey}' and ` +\n        `'${key}' are matched`\n      );\n    } else if (existingKey === key) {\n      throw new Error(\n        `cannot infer query fields to set, path '${key}' is matched twice`\n      );\n    }\n  });\n\n  document[key] = value;\n}\n\n// Returns a branched matcher that matches iff the given matcher does not.\n// Note that this implicitly \"deMorganizes\" the wrapped function.  ie, it\n// means that ALL branch values need to fail to match innerBranchedMatcher.\nfunction invertBranchedMatcher(branchedMatcher) {\n  return branchValues => {\n    // We explicitly choose to strip arrayIndices here: it doesn't make sense to\n    // say \"update the array element that does not match something\", at least\n    // in mongo-land.\n    return {result: !branchedMatcher(branchValues).result};\n  };\n}\n\nexport function isIndexable(obj) {\n  return Array.isArray(obj) || LocalCollection._isPlainObject(obj);\n}\n\nexport function isNumericKey(s) {\n  return /^[0-9]+$/.test(s);\n}\n\n// Returns true if this is an object with at least one key and all keys begin\n// with $.  Unless inconsistentOK is set, throws if some keys begin with $ and\n// others don't.\nexport function isOperatorObject(valueSelector, inconsistentOK) {\n  if (!LocalCollection._isPlainObject(valueSelector)) {\n    return false;\n  }\n\n  let theseAreOperators = undefined;\n  Object.keys(valueSelector).forEach(selKey => {\n    const thisIsOperator = selKey.substr(0, 1) === '$';\n\n    if (theseAreOperators === undefined) {\n      theseAreOperators = thisIsOperator;\n    } else if (theseAreOperators !== thisIsOperator) {\n      if (!inconsistentOK) {\n        throw new Error(\n          `Inconsistent operator: ${JSON.stringify(valueSelector)}`\n        );\n      }\n\n      theseAreOperators = false;\n    }\n  });\n\n  return !!theseAreOperators; // {} has no operators\n}\n\n// Helper for $lt/$gt/$lte/$gte.\nfunction makeInequality(cmpValueComparator) {\n  return {\n    compileElementSelector(operand) {\n      // Arrays never compare false with non-arrays for any inequality.\n      // XXX This was behavior we observed in pre-release MongoDB 2.5, but\n      //     it seems to have been reverted.\n      //     See https://jira.mongodb.org/browse/SERVER-11444\n      if (Array.isArray(operand)) {\n        return () => false;\n      }\n\n      // Special case: consider undefined and null the same (so true with\n      // $gte/$lte).\n      if (operand === undefined) {\n        operand = null;\n      }\n\n      const operandType = LocalCollection._f._type(operand);\n\n      return value => {\n        if (value === undefined) {\n          value = null;\n        }\n\n        // Comparisons are never true among things of different type (except\n        // null vs undefined).\n        if (LocalCollection._f._type(value) !== operandType) {\n          return false;\n        }\n\n        return cmpValueComparator(LocalCollection._f._cmp(value, operand));\n      };\n    },\n  };\n}\n\n// makeLookupFunction(key) returns a lookup function.\n//\n// A lookup function takes in a document and returns an array of matching\n// branches.  If no arrays are found while looking up the key, this array will\n// have exactly one branches (possibly 'undefined', if some segment of the key\n// was not found).\n//\n// If arrays are found in the middle, this can have more than one element, since\n// we 'branch'. When we 'branch', if there are more key segments to look up,\n// then we only pursue branches that are plain objects (not arrays or scalars).\n// This means we can actually end up with no branches!\n//\n// We do *NOT* branch on arrays that are found at the end (ie, at the last\n// dotted member of the key). We just return that array; if you want to\n// effectively 'branch' over the array's values, post-process the lookup\n// function with expandArraysInBranches.\n//\n// Each branch is an object with keys:\n//  - value: the value at the branch\n//  - dontIterate: an optional bool; if true, it means that 'value' is an array\n//    that expandArraysInBranches should NOT expand. This specifically happens\n//    when there is a numeric index in the key, and ensures the\n//    perhaps-surprising MongoDB behavior where {'a.0': 5} does NOT\n//    match {a: [[5]]}.\n//  - arrayIndices: if any array indexing was done during lookup (either due to\n//    explicit numeric indices or implicit branching), this will be an array of\n//    the array indices used, from outermost to innermost; it is falsey or\n//    absent if no array index is used. If an explicit numeric index is used,\n//    the index will be followed in arrayIndices by the string 'x'.\n//\n//    Note: arrayIndices is used for two purposes. First, it is used to\n//    implement the '$' modifier feature, which only ever looks at its first\n//    element.\n//\n//    Second, it is used for sort key generation, which needs to be able to tell\n//    the difference between different paths. Moreover, it needs to\n//    differentiate between explicit and implicit branching, which is why\n//    there's the somewhat hacky 'x' entry: this means that explicit and\n//    implicit array lookups will have different full arrayIndices paths. (That\n//    code only requires that different paths have different arrayIndices; it\n//    doesn't actually 'parse' arrayIndices. As an alternative, arrayIndices\n//    could contain objects with flags like 'implicit', but I think that only\n//    makes the code surrounding them more complex.)\n//\n//    (By the way, this field ends up getting passed around a lot without\n//    cloning, so never mutate any arrayIndices field/var in this package!)\n//\n//\n// At the top level, you may only pass in a plain object or array.\n//\n// See the test 'minimongo - lookup' for some examples of what lookup functions\n// return.\nexport function makeLookupFunction(key, options = {}) {\n  const parts = key.split('.');\n  const firstPart = parts.length ? parts[0] : '';\n  const lookupRest = (\n    parts.length > 1 &&\n    makeLookupFunction(parts.slice(1).join('.'), options)\n  );\n\n  const omitUnnecessaryFields = result => {\n    if (!result.dontIterate) {\n      delete result.dontIterate;\n    }\n\n    if (result.arrayIndices && !result.arrayIndices.length) {\n      delete result.arrayIndices;\n    }\n\n    return result;\n  };\n\n  // Doc will always be a plain object or an array.\n  // apply an explicit numeric index, an array.\n  return (doc, arrayIndices = []) => {\n    if (Array.isArray(doc)) {\n      // If we're being asked to do an invalid lookup into an array (non-integer\n      // or out-of-bounds), return no results (which is different from returning\n      // a single undefined result, in that `null` equality checks won't match).\n      if (!(isNumericKey(firstPart) && firstPart < doc.length)) {\n        return [];\n      }\n\n      // Remember that we used this array index. Include an 'x' to indicate that\n      // the previous index came from being considered as an explicit array\n      // index (not branching).\n      arrayIndices = arrayIndices.concat(+firstPart, 'x');\n    }\n\n    // Do our first lookup.\n    const firstLevel = doc[firstPart];\n\n    // If there is no deeper to dig, return what we found.\n    //\n    // If what we found is an array, most value selectors will choose to treat\n    // the elements of the array as matchable values in their own right, but\n    // that's done outside of the lookup function. (Exceptions to this are $size\n    // and stuff relating to $elemMatch.  eg, {a: {$size: 2}} does not match {a:\n    // [[1, 2]]}.)\n    //\n    // That said, if we just did an *explicit* array lookup (on doc) to find\n    // firstLevel, and firstLevel is an array too, we do NOT want value\n    // selectors to iterate over it.  eg, {'a.0': 5} does not match {a: [[5]]}.\n    // So in that case, we mark the return value as 'don't iterate'.\n    if (!lookupRest) {\n      return [omitUnnecessaryFields({\n        arrayIndices,\n        dontIterate: Array.isArray(doc) && Array.isArray(firstLevel),\n        value: firstLevel\n      })];\n    }\n\n    // We need to dig deeper.  But if we can't, because what we've found is not\n    // an array or plain object, we're done. If we just did a numeric index into\n    // an array, we return nothing here (this is a change in Mongo 2.5 from\n    // Mongo 2.4, where {'a.0.b': null} stopped matching {a: [5]}). Otherwise,\n    // return a single `undefined` (which can, for example, match via equality\n    // with `null`).\n    if (!isIndexable(firstLevel)) {\n      if (Array.isArray(doc)) {\n        return [];\n      }\n\n      return [omitUnnecessaryFields({arrayIndices, value: undefined})];\n    }\n\n    const result = [];\n    const appendToResult = more => {\n      result.push(...more);\n    };\n\n    // Dig deeper: look up the rest of the parts on whatever we've found.\n    // (lookupRest is smart enough to not try to do invalid lookups into\n    // firstLevel if it's an array.)\n    appendToResult(lookupRest(firstLevel, arrayIndices));\n\n    // If we found an array, then in *addition* to potentially treating the next\n    // part as a literal integer lookup, we should also 'branch': try to look up\n    // the rest of the parts on each array element in parallel.\n    //\n    // In this case, we *only* dig deeper into array elements that are plain\n    // objects. (Recall that we only got this far if we have further to dig.)\n    // This makes sense: we certainly don't dig deeper into non-indexable\n    // objects. And it would be weird to dig into an array: it's simpler to have\n    // a rule that explicit integer indexes only apply to an outer array, not to\n    // an array you find after a branching search.\n    //\n    // In the special case of a numeric part in a *sort selector* (not a query\n    // selector), we skip the branching: we ONLY allow the numeric part to mean\n    // 'look up this index' in that case, not 'also look up this index in all\n    // the elements of the array'.\n    if (Array.isArray(firstLevel) &&\n        !(isNumericKey(parts[1]) && options.forSort)) {\n      firstLevel.forEach((branch, arrayIndex) => {\n        if (LocalCollection._isPlainObject(branch)) {\n          appendToResult(lookupRest(branch, arrayIndices.concat(arrayIndex)));\n        }\n      });\n    }\n\n    return result;\n  };\n}\n\n// Object exported only for unit testing.\n// Use it to export private functions to test in Tinytest.\nMinimongoTest = {makeLookupFunction};\nMinimongoError = (message, options = {}) => {\n  if (typeof message === 'string' && options.field) {\n    message += ` for field '${options.field}'`;\n  }\n\n  const error = new Error(message);\n  error.name = 'MinimongoError';\n  return error;\n};\n\nexport function nothingMatcher(docOrBranchedValues) {\n  return {result: false};\n}\n\n// Takes an operator object (an object with $ keys) and returns a branched\n// matcher for it.\nfunction operatorBranchedMatcher(valueSelector, matcher, isRoot) {\n  // Each valueSelector works separately on the various branches.  So one\n  // operator can match one branch and another can match another branch.  This\n  // is OK.\n  const operatorMatchers = Object.keys(valueSelector).map(operator => {\n    const operand = valueSelector[operator];\n\n    const simpleRange = (\n      ['$lt', '$lte', '$gt', '$gte'].includes(operator) &&\n      typeof operand === 'number'\n    );\n\n    const simpleEquality = (\n      ['$ne', '$eq'].includes(operator) &&\n      operand !== Object(operand)\n    );\n\n    const simpleInclusion = (\n      ['$in', '$nin'].includes(operator)\n      && Array.isArray(operand)\n      && !operand.some(x => x === Object(x))\n    );\n\n    if (!(simpleRange || simpleInclusion || simpleEquality)) {\n      matcher._isSimple = false;\n    }\n\n    if (hasOwn.call(VALUE_OPERATORS, operator)) {\n      return VALUE_OPERATORS[operator](operand, valueSelector, matcher, isRoot);\n    }\n\n    if (hasOwn.call(ELEMENT_OPERATORS, operator)) {\n      const options = ELEMENT_OPERATORS[operator];\n      return convertElementMatcherToBranchedMatcher(\n        options.compileElementSelector(operand, valueSelector, matcher),\n        options\n      );\n    }\n\n    throw new Error(`Unrecognized operator: ${operator}`);\n  });\n\n  return andBranchedMatchers(operatorMatchers);\n}\n\n// paths - Array: list of mongo style paths\n// newLeafFn - Function: of form function(path) should return a scalar value to\n//                       put into list created for that path\n// conflictFn - Function: of form function(node, path, fullPath) is called\n//                        when building a tree path for 'fullPath' node on\n//                        'path' was already a leaf with a value. Must return a\n//                        conflict resolution.\n// initial tree - Optional Object: starting tree.\n// @returns - Object: tree represented as a set of nested objects\nexport function pathsToTree(paths, newLeafFn, conflictFn, root = {}) {\n  paths.forEach(path => {\n    const pathArray = path.split('.');\n    let tree = root;\n\n    // use .every just for iteration with break\n    const success = pathArray.slice(0, -1).every((key, i) => {\n      if (!hasOwn.call(tree, key)) {\n        tree[key] = {};\n      } else if (tree[key] !== Object(tree[key])) {\n        tree[key] = conflictFn(\n          tree[key],\n          pathArray.slice(0, i + 1).join('.'),\n          path\n        );\n\n        // break out of loop if we are failing for this path\n        if (tree[key] !== Object(tree[key])) {\n          return false;\n        }\n      }\n\n      tree = tree[key];\n\n      return true;\n    });\n\n    if (success) {\n      const lastKey = pathArray[pathArray.length - 1];\n      if (hasOwn.call(tree, lastKey)) {\n        tree[lastKey] = conflictFn(tree[lastKey], path, path);\n      } else {\n        tree[lastKey] = newLeafFn(path);\n      }\n    }\n  });\n\n  return root;\n}\n\n// Makes sure we get 2 elements array and assume the first one to be x and\n// the second one to y no matter what user passes.\n// In case user passes { lon: x, lat: y } returns [x, y]\nfunction pointToArray(point) {\n  return Array.isArray(point) ? point.slice() : [point.x, point.y];\n}\n\n// Creating a document from an upsert is quite tricky.\n// E.g. this selector: {\"$or\": [{\"b.foo\": {\"$all\": [\"bar\"]}}]}, should result\n// in: {\"b.foo\": \"bar\"}\n// But this selector: {\"$or\": [{\"b\": {\"foo\": {\"$all\": [\"bar\"]}}}]} should throw\n// an error\n\n// Some rules (found mainly with trial & error, so there might be more):\n// - handle all childs of $and (or implicit $and)\n// - handle $or nodes with exactly 1 child\n// - ignore $or nodes with more than 1 child\n// - ignore $nor and $not nodes\n// - throw when a value can not be set unambiguously\n// - every value for $all should be dealt with as separate $eq-s\n// - threat all children of $all as $eq setters (=> set if $all.length === 1,\n//   otherwise throw error)\n// - you can not mix '$'-prefixed keys and non-'$'-prefixed keys\n// - you can only have dotted keys on a root-level\n// - you can not have '$'-prefixed keys more than one-level deep in an object\n\n// Handles one key/value pair to put in the selector document\nfunction populateDocumentWithKeyValue(document, key, value) {\n  if (value && Object.getPrototypeOf(value) === Object.prototype) {\n    populateDocumentWithObject(document, key, value);\n  } else if (!(value instanceof RegExp)) {\n    insertIntoDocument(document, key, value);\n  }\n}\n\n// Handles a key, value pair to put in the selector document\n// if the value is an object\nfunction populateDocumentWithObject(document, key, value) {\n  const keys = Object.keys(value);\n  const unprefixedKeys = keys.filter(op => op[0] !== '$');\n\n  if (unprefixedKeys.length > 0 || !keys.length) {\n    // Literal (possibly empty) object ( or empty object )\n    // Don't allow mixing '$'-prefixed with non-'$'-prefixed fields\n    if (keys.length !== unprefixedKeys.length) {\n      throw new Error(`unknown operator: ${unprefixedKeys[0]}`);\n    }\n\n    validateObject(value, key);\n    insertIntoDocument(document, key, value);\n  } else {\n    Object.keys(value).forEach(op => {\n      const object = value[op];\n\n      if (op === '$eq') {\n        populateDocumentWithKeyValue(document, key, object);\n      } else if (op === '$all') {\n        // every value for $all should be dealt with as separate $eq-s\n        object.forEach(element =>\n          populateDocumentWithKeyValue(document, key, element)\n        );\n      }\n    });\n  }\n}\n\n// Fills a document with certain fields from an upsert selector\nexport function populateDocumentWithQueryFields(query, document = {}) {\n  if (Object.getPrototypeOf(query) === Object.prototype) {\n    // handle implicit $and\n    Object.keys(query).forEach(key => {\n      const value = query[key];\n\n      if (key === '$and') {\n        // handle explicit $and\n        value.forEach(element =>\n          populateDocumentWithQueryFields(element, document)\n        );\n      } else if (key === '$or') {\n        // handle $or nodes with exactly 1 child\n        if (value.length === 1) {\n          populateDocumentWithQueryFields(value[0], document);\n        }\n      } else if (key[0] !== '$') {\n        // Ignore other '$'-prefixed logical selectors\n        populateDocumentWithKeyValue(document, key, value);\n      }\n    });\n  } else {\n    // Handle meteor-specific shortcut for selecting _id\n    if (LocalCollection._selectorIsId(query)) {\n      insertIntoDocument(document, '_id', query);\n    }\n  }\n\n  return document;\n}\n\n// Traverses the keys of passed projection and constructs a tree where all\n// leaves are either all True or all False\n// @returns Object:\n//  - tree - Object - tree representation of keys involved in projection\n//  (exception for '_id' as it is a special case handled separately)\n//  - including - Boolean - \"take only certain fields\" type of projection\nexport function projectionDetails(fields) {\n  // Find the non-_id keys (_id is handled specially because it is included\n  // unless explicitly excluded). Sort the keys, so that our code to detect\n  // overlaps like 'foo' and 'foo.bar' can assume that 'foo' comes first.\n  let fieldsKeys = Object.keys(fields).sort();\n\n  // If _id is the only field in the projection, do not remove it, since it is\n  // required to determine if this is an exclusion or exclusion. Also keep an\n  // inclusive _id, since inclusive _id follows the normal rules about mixing\n  // inclusive and exclusive fields. If _id is not the only field in the\n  // projection and is exclusive, remove it so it can be handled later by a\n  // special case, since exclusive _id is always allowed.\n  if (!(fieldsKeys.length === 1 && fieldsKeys[0] === '_id') &&\n      !(fieldsKeys.includes('_id') && fields._id)) {\n    fieldsKeys = fieldsKeys.filter(key => key !== '_id');\n  }\n\n  let including = null; // Unknown\n\n  fieldsKeys.forEach(keyPath => {\n    const rule = !!fields[keyPath];\n\n    if (including === null) {\n      including = rule;\n    }\n\n    // This error message is copied from MongoDB shell\n    if (including !== rule) {\n      throw MinimongoError(\n        'You cannot currently mix including and excluding fields.'\n      );\n    }\n  });\n\n  const projectionRulesTree = pathsToTree(\n    fieldsKeys,\n    path => including,\n    (node, path, fullPath) => {\n      // Check passed projection fields' keys: If you have two rules such as\n      // 'foo.bar' and 'foo.bar.baz', then the result becomes ambiguous. If\n      // that happens, there is a probability you are doing something wrong,\n      // framework should notify you about such mistake earlier on cursor\n      // compilation step than later during runtime.  Note, that real mongo\n      // doesn't do anything about it and the later rule appears in projection\n      // project, more priority it takes.\n      //\n      // Example, assume following in mongo shell:\n      // > db.coll.insert({ a: { b: 23, c: 44 } })\n      // > db.coll.find({}, { 'a': 1, 'a.b': 1 })\n      // {\"_id\": ObjectId(\"520bfe456024608e8ef24af3\"), \"a\": {\"b\": 23}}\n      // > db.coll.find({}, { 'a.b': 1, 'a': 1 })\n      // {\"_id\": ObjectId(\"520bfe456024608e8ef24af3\"), \"a\": {\"b\": 23, \"c\": 44}}\n      //\n      // Note, how second time the return set of keys is different.\n      const currentPath = fullPath;\n      const anotherPath = path;\n      throw MinimongoError(\n        `both ${currentPath} and ${anotherPath} found in fields option, ` +\n        'using both of them may trigger unexpected behavior. Did you mean to ' +\n        'use only one of them?'\n      );\n    });\n\n  return {including, tree: projectionRulesTree};\n}\n\n// Takes a RegExp object and returns an element matcher.\nexport function regexpElementMatcher(regexp) {\n  return value => {\n    if (value instanceof RegExp) {\n      return value.toString() === regexp.toString();\n    }\n\n    // Regexps only work against strings.\n    if (typeof value !== 'string') {\n      return false;\n    }\n\n    // Reset regexp's state to avoid inconsistent matching for objects with the\n    // same value on consecutive calls of regexp.test. This happens only if the\n    // regexp has the 'g' flag. Also note that ES6 introduces a new flag 'y' for\n    // which we should *not* change the lastIndex but MongoDB doesn't support\n    // either of these flags.\n    regexp.lastIndex = 0;\n\n    return regexp.test(value);\n  };\n}\n\n// Validates the key in a path.\n// Objects that are nested more then 1 level cannot have dotted fields\n// or fields starting with '$'\nfunction validateKeyInPath(key, path) {\n  if (key.includes('.')) {\n    throw new Error(\n      `The dotted field '${key}' in '${path}.${key} is not valid for storage.`\n    );\n  }\n\n  if (key[0] === '$') {\n    throw new Error(\n      `The dollar ($) prefixed field  '${path}.${key} is not valid for storage.`\n    );\n  }\n}\n\n// Recursively validates an object that is nested more than one level deep\nfunction validateObject(object, path) {\n  if (object && Object.getPrototypeOf(object) === Object.prototype) {\n    Object.keys(object).forEach(key => {\n      validateKeyInPath(key, path);\n      validateObject(object[key], path + '.' + key);\n    });\n  }\n}\n"]},"sourceType":"module","hash":"767e4a770eca6d671b913e4842887a73b7311c35"}
