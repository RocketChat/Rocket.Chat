{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/weslley/Documents/projects/Rocket.Chat/packages/binary-heap/max-heap.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"packages/binary-heap/max-heap.js","filename":"/home/weslley/Documents/projects/Rocket.Chat/packages/binary-heap/max-heap.js","targets":{"android":"95.0.0","chrome":"95.0.0","edge":"95.0.0","firefox":"78.0.0","ie":"10.0.0","ios":"15.0.0","opera":"81.0.0","safari":"15.1.0","samsung":"14.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/home/weslley/Documents/projects/Rocket.Chat","root":"/home/weslley/Documents/projects/Rocket.Chat","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.16.5","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/home/weslley/Documents/projects/Rocket.Chat/packages/binary-heap/max-heap.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/binary-heap/max-heap.js"}},"code":"module.export({\n  MaxHeap: () => MaxHeap\n});\n\nclass MaxHeap {\n  constructor(comparator) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (typeof comparator !== 'function') {\n      throw new Error('Passed comparator is invalid, should be a comparison function');\n    } // a C-style comparator that is given two values and returns a number,\n    // negative if the first value is less than the second, positive if the second\n    // value is greater than the first and zero if they are equal.\n\n\n    this._comparator = comparator;\n\n    if (!options.IdMap) {\n      options.IdMap = IdMap;\n    } // _heapIdx maps an id to an index in the Heap array the corresponding value\n    // is located on.\n\n\n    this._heapIdx = new options.IdMap(); // The Heap data-structure implemented as a 0-based contiguous array where\n    // every item on index idx is a node in a complete binary tree. Every node can\n    // have children on indexes idx*2+1 and idx*2+2, except for the leaves. Every\n    // node has a parent on index (idx-1)/2;\n\n    this._heap = []; // If the initial array is passed, we can build the heap in linear time\n    // complexity (O(N)) compared to linearithmic time complexity (O(nlogn)) if\n    // we push elements one by one.\n\n    if (Array.isArray(options.initData)) {\n      this._initFromData(options.initData);\n    }\n  } // Builds a new heap in-place in linear time based on passed data\n\n\n  _initFromData(data) {\n    this._heap = data.map(_ref => {\n      let {\n        id,\n        value\n      } = _ref;\n      return {\n        id,\n        value\n      };\n    });\n    data.forEach((_ref2, i) => {\n      let {\n        id\n      } = _ref2;\n      return this._heapIdx.set(id, i);\n    });\n\n    if (!data.length) {\n      return;\n    } // start from the first non-leaf - the parent of the last leaf\n\n\n    for (let i = parentIdx(data.length - 1); i >= 0; i--) {\n      this._downHeap(i);\n    }\n  }\n\n  _downHeap(idx) {\n    while (leftChildIdx(idx) < this.size()) {\n      const left = leftChildIdx(idx);\n      const right = rightChildIdx(idx);\n      let largest = idx;\n\n      if (left < this.size()) {\n        largest = this._maxIndex(largest, left);\n      }\n\n      if (right < this.size()) {\n        largest = this._maxIndex(largest, right);\n      }\n\n      if (largest === idx) {\n        break;\n      }\n\n      this._swap(largest, idx);\n\n      idx = largest;\n    }\n  }\n\n  _upHeap(idx) {\n    while (idx > 0) {\n      const parent = parentIdx(idx);\n\n      if (this._maxIndex(parent, idx) === idx) {\n        this._swap(parent, idx);\n\n        idx = parent;\n      } else {\n        break;\n      }\n    }\n  }\n\n  _maxIndex(idxA, idxB) {\n    const valueA = this._get(idxA);\n\n    const valueB = this._get(idxB);\n\n    return this._comparator(valueA, valueB) >= 0 ? idxA : idxB;\n  } // Internal: gets raw data object placed on idxth place in heap\n\n\n  _get(idx) {\n    return this._heap[idx].value;\n  }\n\n  _swap(idxA, idxB) {\n    const recA = this._heap[idxA];\n    const recB = this._heap[idxB];\n\n    this._heapIdx.set(recA.id, idxB);\n\n    this._heapIdx.set(recB.id, idxA);\n\n    this._heap[idxA] = recB;\n    this._heap[idxB] = recA;\n  }\n\n  get(id) {\n    return this.has(id) ? this._get(this._heapIdx.get(id)) : null;\n  }\n\n  set(id, value) {\n    if (this.has(id)) {\n      if (this.get(id) === value) {\n        return;\n      }\n\n      const idx = this._heapIdx.get(id);\n\n      this._heap[idx].value = value; // Fix the new value's position\n      // Either bubble new value up if it is greater than its parent\n\n      this._upHeap(idx); // or bubble it down if it is smaller than one of its children\n\n\n      this._downHeap(idx);\n    } else {\n      this._heapIdx.set(id, this._heap.length);\n\n      this._heap.push({\n        id,\n        value\n      });\n\n      this._upHeap(this._heap.length - 1);\n    }\n  }\n\n  remove(id) {\n    if (this.has(id)) {\n      const last = this._heap.length - 1;\n\n      const idx = this._heapIdx.get(id);\n\n      if (idx !== last) {\n        this._swap(idx, last);\n\n        this._heap.pop();\n\n        this._heapIdx.remove(id); // Fix the swapped value's position\n\n\n        this._upHeap(idx);\n\n        this._downHeap(idx);\n      } else {\n        this._heap.pop();\n\n        this._heapIdx.remove(id);\n      }\n    }\n  }\n\n  has(id) {\n    return this._heapIdx.has(id);\n  }\n\n  empty() {\n    return !this.size();\n  }\n\n  clear() {\n    this._heap = [];\n\n    this._heapIdx.clear();\n  } // iterate over values in no particular order\n\n\n  forEach(iterator) {\n    this._heap.forEach(obj => iterator(obj.value, obj.id));\n  }\n\n  size() {\n    return this._heap.length;\n  }\n\n  setDefault(id, def) {\n    if (this.has(id)) {\n      return this.get(id);\n    }\n\n    this.set(id, def);\n    return def;\n  }\n\n  clone() {\n    const clone = new MaxHeap(this._comparator, this._heap);\n    return clone;\n  }\n\n  maxElementId() {\n    return this.size() ? this._heap[0].id : null;\n  }\n\n  _selfCheck() {\n    for (let i = 1; i < this._heap.length; i++) {\n      if (this._maxIndex(parentIdx(i), i) !== parentIdx(i)) {\n        throw new Error(\"An item with id \".concat(this._heap[i].id) + \" has a parent younger than it: \" + this._heap[parentIdx(i)].id);\n      }\n    }\n  }\n\n}\n\nconst leftChildIdx = i => i * 2 + 1;\n\nconst rightChildIdx = i => i * 2 + 2;\n\nconst parentIdx = i => i - 1 >> 1;","map":{"version":3,"sources":["packages/binary-heap/max-heap.js"],"names":["module","export","MaxHeap","constructor","comparator","options","Error","_comparator","IdMap","_heapIdx","_heap","Array","isArray","initData","_initFromData","data","map","id","value","forEach","i","set","length","parentIdx","_downHeap","idx","leftChildIdx","size","left","right","rightChildIdx","largest","_maxIndex","_swap","_upHeap","parent","idxA","idxB","valueA","_get","valueB","recA","recB","get","has","push","remove","last","pop","empty","clear","iterator","obj","setDefault","def","clone","maxElementId","_selfCheck"],"mappings":"AAAAA,MAAM,CAACC,MAAP,CAAc;AAACC,EAAAA,OAAO,EAAC,MAAIA;AAAb,CAAd;;AAUO,MAAMA,OAAN,CAAc;AACnBC,EAAAA,WAAW,CAACC,UAAD,EAA2B;AAAA,QAAdC,OAAc,uEAAJ,EAAI;;AACpC,QAAI,OAAOD,UAAP,KAAsB,UAA1B,EAAsC;AACpC,YAAM,IAAIE,KAAJ,CAAU,+DAAV,CAAN;AACD,KAHmC,CAKpC;AACA;AACA;;;AACA,SAAKC,WAAL,GAAmBH,UAAnB;;AAEA,QAAI,CAAEC,OAAO,CAACG,KAAd,EAAqB;AACnBH,MAAAA,OAAO,CAACG,KAAR,GAAgBA,KAAhB;AACD,KAZmC,CAcpC;AACA;;;AACA,SAAKC,QAAL,GAAgB,IAAIJ,OAAO,CAACG,KAAZ,EAAhB,CAhBoC,CAkBpC;AACA;AACA;AACA;;AACA,SAAKE,KAAL,GAAa,EAAb,CAtBoC,CAwBpC;AACA;AACA;;AACA,QAAIC,KAAK,CAACC,OAAN,CAAcP,OAAO,CAACQ,QAAtB,CAAJ,EAAqC;AACnC,WAAKC,aAAL,CAAmBT,OAAO,CAACQ,QAA3B;AACD;AACF,GA/BkB,CAiCnB;;;AACAC,EAAAA,aAAa,CAACC,IAAD,EAAO;AAClB,SAAKL,KAAL,GAAaK,IAAI,CAACC,GAAL,CAAS;AAAA,UAAC;AAAEC,QAAAA,EAAF;AAAMC,QAAAA;AAAN,OAAD;AAAA,aAAoB;AAAED,QAAAA,EAAF;AAAMC,QAAAA;AAAN,OAApB;AAAA,KAAT,CAAb;AAEAH,IAAAA,IAAI,CAACI,OAAL,CAAa,QAASC,CAAT;AAAA,UAAC;AAAEH,QAAAA;AAAF,OAAD;AAAA,aAAe,KAAKR,QAAL,CAAcY,GAAd,CAAkBJ,EAAlB,EAAsBG,CAAtB,CAAf;AAAA,KAAb;;AAEA,QAAI,CAAEL,IAAI,CAACO,MAAX,EAAmB;AACjB;AACD,KAPiB,CASlB;;;AACA,SAAK,IAAIF,CAAC,GAAGG,SAAS,CAACR,IAAI,CAACO,MAAL,GAAc,CAAf,CAAtB,EAAyCF,CAAC,IAAI,CAA9C,EAAiDA,CAAC,EAAlD,EAAsD;AACpD,WAAKI,SAAL,CAAeJ,CAAf;AACD;AACF;;AAEDI,EAAAA,SAAS,CAACC,GAAD,EAAM;AACb,WAAOC,YAAY,CAACD,GAAD,CAAZ,GAAoB,KAAKE,IAAL,EAA3B,EAAwC;AACtC,YAAMC,IAAI,GAAGF,YAAY,CAACD,GAAD,CAAzB;AACA,YAAMI,KAAK,GAAGC,aAAa,CAACL,GAAD,CAA3B;AACA,UAAIM,OAAO,GAAGN,GAAd;;AAEA,UAAIG,IAAI,GAAG,KAAKD,IAAL,EAAX,EAAwB;AACtBI,QAAAA,OAAO,GAAG,KAAKC,SAAL,CAAeD,OAAf,EAAwBH,IAAxB,CAAV;AACD;;AAED,UAAIC,KAAK,GAAG,KAAKF,IAAL,EAAZ,EAAyB;AACvBI,QAAAA,OAAO,GAAG,KAAKC,SAAL,CAAeD,OAAf,EAAwBF,KAAxB,CAAV;AACD;;AAED,UAAIE,OAAO,KAAKN,GAAhB,EAAqB;AACnB;AACD;;AAED,WAAKQ,KAAL,CAAWF,OAAX,EAAoBN,GAApB;;AACAA,MAAAA,GAAG,GAAGM,OAAN;AACD;AACF;;AAEDG,EAAAA,OAAO,CAACT,GAAD,EAAM;AACX,WAAOA,GAAG,GAAG,CAAb,EAAgB;AACd,YAAMU,MAAM,GAAGZ,SAAS,CAACE,GAAD,CAAxB;;AACA,UAAI,KAAKO,SAAL,CAAeG,MAAf,EAAuBV,GAAvB,MAAgCA,GAApC,EAAyC;AACvC,aAAKQ,KAAL,CAAWE,MAAX,EAAmBV,GAAnB;;AACAA,QAAAA,GAAG,GAAGU,MAAN;AACD,OAHD,MAGO;AACL;AACD;AACF;AACF;;AAEDH,EAAAA,SAAS,CAACI,IAAD,EAAOC,IAAP,EAAa;AACpB,UAAMC,MAAM,GAAG,KAAKC,IAAL,CAAUH,IAAV,CAAf;;AACA,UAAMI,MAAM,GAAG,KAAKD,IAAL,CAAUF,IAAV,CAAf;;AACA,WAAO,KAAK9B,WAAL,CAAiB+B,MAAjB,EAAyBE,MAAzB,KAAoC,CAApC,GAAwCJ,IAAxC,GAA+CC,IAAtD;AACD,GAxFkB,CA0FnB;;;AACAE,EAAAA,IAAI,CAACd,GAAD,EAAM;AACR,WAAO,KAAKf,KAAL,CAAWe,GAAX,EAAgBP,KAAvB;AACD;;AAEDe,EAAAA,KAAK,CAACG,IAAD,EAAOC,IAAP,EAAa;AAChB,UAAMI,IAAI,GAAG,KAAK/B,KAAL,CAAW0B,IAAX,CAAb;AACA,UAAMM,IAAI,GAAG,KAAKhC,KAAL,CAAW2B,IAAX,CAAb;;AAEA,SAAK5B,QAAL,CAAcY,GAAd,CAAkBoB,IAAI,CAACxB,EAAvB,EAA2BoB,IAA3B;;AACA,SAAK5B,QAAL,CAAcY,GAAd,CAAkBqB,IAAI,CAACzB,EAAvB,EAA2BmB,IAA3B;;AAEA,SAAK1B,KAAL,CAAW0B,IAAX,IAAmBM,IAAnB;AACA,SAAKhC,KAAL,CAAW2B,IAAX,IAAmBI,IAAnB;AACD;;AAEDE,EAAAA,GAAG,CAAC1B,EAAD,EAAK;AACN,WAAO,KAAK2B,GAAL,CAAS3B,EAAT,IACL,KAAKsB,IAAL,CAAU,KAAK9B,QAAL,CAAckC,GAAd,CAAkB1B,EAAlB,CAAV,CADK,GAEL,IAFF;AAGD;;AAEDI,EAAAA,GAAG,CAACJ,EAAD,EAAKC,KAAL,EAAY;AACb,QAAI,KAAK0B,GAAL,CAAS3B,EAAT,CAAJ,EAAkB;AAChB,UAAI,KAAK0B,GAAL,CAAS1B,EAAT,MAAiBC,KAArB,EAA4B;AAC1B;AACD;;AAED,YAAMO,GAAG,GAAG,KAAKhB,QAAL,CAAckC,GAAd,CAAkB1B,EAAlB,CAAZ;;AACA,WAAKP,KAAL,CAAWe,GAAX,EAAgBP,KAAhB,GAAwBA,KAAxB,CANgB,CAQhB;AACA;;AACA,WAAKgB,OAAL,CAAaT,GAAb,EAVgB,CAWhB;;;AACA,WAAKD,SAAL,CAAeC,GAAf;AACD,KAbD,MAaO;AACL,WAAKhB,QAAL,CAAcY,GAAd,CAAkBJ,EAAlB,EAAsB,KAAKP,KAAL,CAAWY,MAAjC;;AACA,WAAKZ,KAAL,CAAWmC,IAAX,CAAgB;AAAE5B,QAAAA,EAAF;AAAMC,QAAAA;AAAN,OAAhB;;AACA,WAAKgB,OAAL,CAAa,KAAKxB,KAAL,CAAWY,MAAX,GAAoB,CAAjC;AACD;AACF;;AAEDwB,EAAAA,MAAM,CAAC7B,EAAD,EAAK;AACT,QAAI,KAAK2B,GAAL,CAAS3B,EAAT,CAAJ,EAAkB;AAChB,YAAM8B,IAAI,GAAG,KAAKrC,KAAL,CAAWY,MAAX,GAAoB,CAAjC;;AACA,YAAMG,GAAG,GAAG,KAAKhB,QAAL,CAAckC,GAAd,CAAkB1B,EAAlB,CAAZ;;AAEA,UAAIQ,GAAG,KAAKsB,IAAZ,EAAkB;AAChB,aAAKd,KAAL,CAAWR,GAAX,EAAgBsB,IAAhB;;AACA,aAAKrC,KAAL,CAAWsC,GAAX;;AACA,aAAKvC,QAAL,CAAcqC,MAAd,CAAqB7B,EAArB,EAHgB,CAKhB;;;AACA,aAAKiB,OAAL,CAAaT,GAAb;;AACA,aAAKD,SAAL,CAAeC,GAAf;AACD,OARD,MAQO;AACL,aAAKf,KAAL,CAAWsC,GAAX;;AACA,aAAKvC,QAAL,CAAcqC,MAAd,CAAqB7B,EAArB;AACD;AACF;AACF;;AAED2B,EAAAA,GAAG,CAAC3B,EAAD,EAAK;AACN,WAAO,KAAKR,QAAL,CAAcmC,GAAd,CAAkB3B,EAAlB,CAAP;AACD;;AAEDgC,EAAAA,KAAK,GAAG;AACN,WAAO,CAAC,KAAKtB,IAAL,EAAR;AACD;;AAEDuB,EAAAA,KAAK,GAAG;AACN,SAAKxC,KAAL,GAAa,EAAb;;AACA,SAAKD,QAAL,CAAcyC,KAAd;AACD,GApKkB,CAsKnB;;;AACA/B,EAAAA,OAAO,CAACgC,QAAD,EAAW;AAChB,SAAKzC,KAAL,CAAWS,OAAX,CAAmBiC,GAAG,IAAID,QAAQ,CAACC,GAAG,CAAClC,KAAL,EAAYkC,GAAG,CAACnC,EAAhB,CAAlC;AACD;;AAEDU,EAAAA,IAAI,GAAG;AACL,WAAO,KAAKjB,KAAL,CAAWY,MAAlB;AACD;;AAED+B,EAAAA,UAAU,CAACpC,EAAD,EAAKqC,GAAL,EAAU;AAClB,QAAI,KAAKV,GAAL,CAAS3B,EAAT,CAAJ,EAAkB;AAChB,aAAO,KAAK0B,GAAL,CAAS1B,EAAT,CAAP;AACD;;AAED,SAAKI,GAAL,CAASJ,EAAT,EAAaqC,GAAb;AACA,WAAOA,GAAP;AACD;;AAEDC,EAAAA,KAAK,GAAG;AACN,UAAMA,KAAK,GAAG,IAAIrD,OAAJ,CAAY,KAAKK,WAAjB,EAA8B,KAAKG,KAAnC,CAAd;AACA,WAAO6C,KAAP;AACD;;AAEDC,EAAAA,YAAY,GAAG;AACb,WAAO,KAAK7B,IAAL,KAAc,KAAKjB,KAAL,CAAW,CAAX,EAAcO,EAA5B,GAAiC,IAAxC;AACD;;AAEDwC,EAAAA,UAAU,GAAG;AACX,SAAK,IAAIrC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKV,KAAL,CAAWY,MAA/B,EAAuCF,CAAC,EAAxC,EAA4C;AAC1C,UAAI,KAAKY,SAAL,CAAeT,SAAS,CAACH,CAAD,CAAxB,EAA6BA,CAA7B,MAAoCG,SAAS,CAACH,CAAD,CAAjD,EAAsD;AAClD,cAAM,IAAId,KAAJ,CAAU,0BAAmB,KAAKI,KAAL,CAAWU,CAAX,EAAcH,EAAjC,IACA,iCADA,GAEA,KAAKP,KAAL,CAAWa,SAAS,CAACH,CAAD,CAApB,EAAyBH,EAFnC,CAAN;AAGH;AACF;AACF;;AAzMkB;;AA4MrB,MAAMS,YAAY,GAAGN,CAAC,IAAIA,CAAC,GAAG,CAAJ,GAAQ,CAAlC;;AACA,MAAMU,aAAa,GAAGV,CAAC,IAAIA,CAAC,GAAG,CAAJ,GAAQ,CAAnC;;AACA,MAAMG,SAAS,GAAGH,CAAC,IAAKA,CAAC,GAAG,CAAL,IAAW,CAAlC","sourcesContent":["// Constructor of Heap\n// - comparator - Function - given two items returns a number\n// - options:\n//   - initData - Array - Optional - the initial data in a format:\n//        Object:\n//          - id - String - unique id of the item\n//          - value - Any - the data value\n//      each value is retained\n//   - IdMap - Constructor - Optional - custom IdMap class to store id->index\n//       mappings internally. Standard IdMap is used by default.\nexport class MaxHeap { \n  constructor(comparator, options = {}) {\n    if (typeof comparator !== 'function') {\n      throw new Error('Passed comparator is invalid, should be a comparison function');\n    }\n\n    // a C-style comparator that is given two values and returns a number,\n    // negative if the first value is less than the second, positive if the second\n    // value is greater than the first and zero if they are equal.\n    this._comparator = comparator;\n\n    if (! options.IdMap) {\n      options.IdMap = IdMap;\n    }\n\n    // _heapIdx maps an id to an index in the Heap array the corresponding value\n    // is located on.\n    this._heapIdx = new options.IdMap;\n\n    // The Heap data-structure implemented as a 0-based contiguous array where\n    // every item on index idx is a node in a complete binary tree. Every node can\n    // have children on indexes idx*2+1 and idx*2+2, except for the leaves. Every\n    // node has a parent on index (idx-1)/2;\n    this._heap = [];\n\n    // If the initial array is passed, we can build the heap in linear time\n    // complexity (O(N)) compared to linearithmic time complexity (O(nlogn)) if\n    // we push elements one by one.\n    if (Array.isArray(options.initData)) {\n      this._initFromData(options.initData);\n    }\n  }\n\n  // Builds a new heap in-place in linear time based on passed data\n  _initFromData(data) {\n    this._heap = data.map(({ id, value }) => ({ id, value }));\n\n    data.forEach(({ id }, i) => this._heapIdx.set(id, i));\n\n    if (! data.length) {\n      return;\n    }\n\n    // start from the first non-leaf - the parent of the last leaf\n    for (let i = parentIdx(data.length - 1); i >= 0; i--) {\n      this._downHeap(i);\n    }\n  }\n\n  _downHeap(idx) {\n    while (leftChildIdx(idx) < this.size()) {\n      const left = leftChildIdx(idx);\n      const right = rightChildIdx(idx);\n      let largest = idx;\n\n      if (left < this.size()) {\n        largest = this._maxIndex(largest, left);\n      }\n\n      if (right < this.size()) {\n        largest = this._maxIndex(largest, right);\n      }\n\n      if (largest === idx) {\n        break;\n      }\n\n      this._swap(largest, idx);\n      idx = largest;\n    }\n  }\n\n  _upHeap(idx) {\n    while (idx > 0) {\n      const parent = parentIdx(idx);\n      if (this._maxIndex(parent, idx) === idx) {\n        this._swap(parent, idx)\n        idx = parent;\n      } else {\n        break;\n      }\n    }\n  }\n\n  _maxIndex(idxA, idxB) {\n    const valueA = this._get(idxA);\n    const valueB = this._get(idxB);\n    return this._comparator(valueA, valueB) >= 0 ? idxA : idxB;\n  }\n\n  // Internal: gets raw data object placed on idxth place in heap\n  _get(idx) {\n    return this._heap[idx].value;\n  }\n\n  _swap(idxA, idxB) {\n    const recA = this._heap[idxA];\n    const recB = this._heap[idxB];\n\n    this._heapIdx.set(recA.id, idxB);\n    this._heapIdx.set(recB.id, idxA);\n\n    this._heap[idxA] = recB;\n    this._heap[idxB] = recA;\n  }\n\n  get(id) {\n    return this.has(id) ?\n      this._get(this._heapIdx.get(id)) :\n      null;\n  }\n\n  set(id, value) {\n    if (this.has(id)) {\n      if (this.get(id) === value) {\n        return;\n      }\n\n      const idx = this._heapIdx.get(id);\n      this._heap[idx].value = value;\n\n      // Fix the new value's position\n      // Either bubble new value up if it is greater than its parent\n      this._upHeap(idx);\n      // or bubble it down if it is smaller than one of its children\n      this._downHeap(idx);\n    } else {\n      this._heapIdx.set(id, this._heap.length);\n      this._heap.push({ id, value });\n      this._upHeap(this._heap.length - 1);\n    }\n  }\n\n  remove(id) {\n    if (this.has(id)) {\n      const last = this._heap.length - 1;\n      const idx = this._heapIdx.get(id);\n\n      if (idx !== last) {\n        this._swap(idx, last);\n        this._heap.pop();\n        this._heapIdx.remove(id);\n\n        // Fix the swapped value's position\n        this._upHeap(idx);\n        this._downHeap(idx);\n      } else {\n        this._heap.pop();\n        this._heapIdx.remove(id);\n      }\n    }\n  }\n\n  has(id) {\n    return this._heapIdx.has(id);\n  }\n\n  empty() {\n    return !this.size();\n  }\n\n  clear() {\n    this._heap = [];\n    this._heapIdx.clear();\n  }\n\n  // iterate over values in no particular order\n  forEach(iterator) {\n    this._heap.forEach(obj => iterator(obj.value, obj.id));\n  }\n\n  size() {\n    return this._heap.length;\n  }\n\n  setDefault(id, def) {\n    if (this.has(id)) {\n      return this.get(id);\n    }\n\n    this.set(id, def);\n    return def;\n  }\n\n  clone() {\n    const clone = new MaxHeap(this._comparator, this._heap);\n    return clone;\n  }\n\n  maxElementId() {\n    return this.size() ? this._heap[0].id : null;\n  }\n\n  _selfCheck() {\n    for (let i = 1; i < this._heap.length; i++) {\n      if (this._maxIndex(parentIdx(i), i) !== parentIdx(i)) {\n          throw new Error(`An item with id ${this._heap[i].id}` +\n                          \" has a parent younger than it: \" +\n                          this._heap[parentIdx(i)].id);\n      }\n    }\n  }\n}\n\nconst leftChildIdx = i => i * 2 + 1;\nconst rightChildIdx = i => i * 2 + 2;\nconst parentIdx = i => (i - 1) >> 1;\n"]},"sourceType":"module","hash":"5032504e1718681247b2e866929c3d0d4db6305d"}
