{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/weslley/Documents/projects/Rocket.Chat/app/livechat/server/lib/Analytics.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"app/livechat/server/lib/Analytics.js","filename":"/home/weslley/Documents/projects/Rocket.Chat/app/livechat/server/lib/Analytics.js","targets":{"android":"95.0.0","chrome":"95.0.0","edge":"95.0.0","firefox":"78.0.0","ie":"10.0.0","ios":"15.0.0","opera":"81.0.0","safari":"15.1.0","samsung":"14.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/home/weslley/Documents/projects/Rocket.Chat","root":"/home/weslley/Documents/projects/Rocket.Chat","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.16.5","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/home/weslley/Documents/projects/Rocket.Chat/app/livechat/server/lib/Analytics.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"app/livechat/server/lib/Analytics.js"}},"code":"module.export({\n  Analytics: () => Analytics\n});\nlet TAPi18n;\nmodule.link(\"meteor/rocketchat:tap-i18n\", {\n  TAPi18n(v) {\n    TAPi18n = v;\n  }\n\n}, 0);\nlet moment;\nmodule.link(\"moment\", {\n  default(v) {\n    moment = v;\n  }\n\n}, 1);\nlet LivechatRooms;\nmodule.link(\"../../../models\", {\n  LivechatRooms(v) {\n    LivechatRooms = v;\n  }\n\n}, 2);\nlet LivechatRoomsRaw;\nmodule.link(\"../../../models/server/raw\", {\n  LivechatRooms(v) {\n    LivechatRoomsRaw = v;\n  }\n\n}, 3);\nlet secondsToHHMMSS;\nmodule.link(\"../../../utils/server\", {\n  secondsToHHMMSS(v) {\n    secondsToHHMMSS = v;\n  }\n\n}, 4);\nlet getTimezone;\nmodule.link(\"../../../utils/server/lib/getTimezone\", {\n  getTimezone(v) {\n    getTimezone = v;\n  }\n\n}, 5);\nlet Logger;\nmodule.link(\"../../../logger\", {\n  Logger(v) {\n    Logger = v;\n  }\n\n}, 6);\nconst HOURS_IN_DAY = 24;\nconst logger = new Logger('OmnichannelAnalytics');\nconst Analytics = {\n  getAgentOverviewData(options) {\n    const {\n      departmentId,\n      utcOffset,\n      daterange: {\n        from: fDate,\n        to: tDate\n      } = {},\n      chartOptions: {\n        name\n      } = {}\n    } = options;\n    const timezone = getTimezone({\n      utcOffset\n    });\n    const from = moment.tz(fDate, 'YYYY-MM-DD', timezone).startOf('day').utc();\n    const to = moment.tz(tDate, 'YYYY-MM-DD', timezone).endOf('day').utc();\n    logger.debug(\"getAgentOverviewData[\".concat(name, \"] -> Using timezone \").concat(timezone, \" with date range \").concat(from, \" - \").concat(to));\n\n    if (!(moment(from).isValid() && moment(to).isValid())) {\n      logger.error('livechat:getAgentOverviewData => Invalid dates');\n      return;\n    }\n\n    if (!this.AgentOverviewData[name]) {\n      logger.error(\"Method RocketChat.Livechat.Analytics.AgentOverviewData.\".concat(name, \" does NOT exist\"));\n      return;\n    }\n\n    return this.AgentOverviewData[name](from, to, departmentId);\n  },\n\n  getAnalyticsChartData(options) {\n    const {\n      utcOffset,\n      departmentId,\n      daterange: {\n        from: fDate,\n        to: tDate\n      } = {},\n      chartOptions: {\n        name: chartLabel\n      },\n      chartOptions: {\n        name\n      } = {}\n    } = options; // Check if function exists, prevent server error in case property altered\n\n    if (!this.ChartData[name]) {\n      logger.error(\"Method RocketChat.Livechat.Analytics.ChartData.\".concat(name, \" does NOT exist\"));\n      return;\n    }\n\n    const timezone = getTimezone({\n      utcOffset\n    });\n    const from = moment.tz(fDate, 'YYYY-MM-DD', timezone).startOf('day').utc();\n    const to = moment.tz(tDate, 'YYYY-MM-DD', timezone).endOf('day').utc();\n    const isSameDay = from.diff(to, 'days') === 0;\n    logger.debug(\"getAnalyticsChartData[\".concat(name, \"] -> Using timezone \").concat(timezone, \" with date range \").concat(from, \" - \").concat(to));\n\n    if (!(moment(from).isValid() && moment(to).isValid())) {\n      logger.error('livechat:getAnalyticsChartData => Invalid dates');\n      return;\n    }\n\n    const data = {\n      chartLabel,\n      dataLabels: [],\n      dataPoints: []\n    };\n\n    if (isSameDay) {\n      // data for single day\n      for (let m = moment(from), currentHour = 0; currentHour < HOURS_IN_DAY; currentHour++) {\n        const hour = m.add(currentHour ? 1 : 0, 'hour').format('H');\n        const label = {\n          from: moment.utc().set({\n            hour\n          }).tz(timezone).format('hA'),\n          to: moment.utc().set({\n            hour\n          }).add(1, 'hour').tz(timezone).format('hA')\n        };\n        data.dataLabels.push(\"\".concat(label.from, \"-\").concat(label.to));\n        const date = {\n          gte: m,\n          lt: moment(m).add(1, 'hours')\n        };\n        data.dataPoints.push(this.ChartData[name](date, departmentId));\n      }\n    } else {\n      for (let m = moment(from); m.diff(to, 'days') <= 0; m.add(1, 'days')) {\n        data.dataLabels.push(m.format('M/D'));\n        const date = {\n          gte: m,\n          lt: moment(m).add(1, 'days')\n        };\n        data.dataPoints.push(this.ChartData[name](date, departmentId));\n      }\n    }\n\n    return data;\n  },\n\n  getAnalyticsOverviewData(options) {\n    const {\n      departmentId,\n      utcOffset = 0,\n      language,\n      daterange: {\n        from: fDate,\n        to: tDate\n      } = {},\n      analyticsOptions: {\n        name\n      } = {}\n    } = options;\n    const timezone = getTimezone({\n      utcOffset\n    });\n    const from = moment.tz(fDate, 'YYYY-MM-DD', timezone).startOf('day').utc();\n    const to = moment.tz(tDate, 'YYYY-MM-DD', timezone).endOf('day').utc();\n    logger.debug(\"getAnalyticsOverviewData[\".concat(name, \"] -> Using timezone \").concat(timezone, \" with date range \").concat(from, \" - \").concat(to));\n\n    if (!(moment(from).isValid() && moment(to).isValid())) {\n      logger.error('livechat:getAnalyticsOverviewData => Invalid dates');\n      return;\n    }\n\n    if (!this.OverviewData[name]) {\n      logger.error(\"Method RocketChat.Livechat.Analytics.OverviewData.\".concat(name, \" does NOT exist\"));\n      return;\n    }\n\n    const t = s => TAPi18n.__(s, {\n      lng: language\n    });\n\n    return this.OverviewData[name](from, to, departmentId, timezone, t);\n  },\n\n  ChartData: {\n    /**\n     *\n     * @param {Object} date {gte: {Date}, lt: {Date}}\n     *\n     * @returns {Integer}\n     */\n    Total_conversations(date, departmentId) {\n      return LivechatRooms.getTotalConversationsBetweenDate('l', date, {\n        departmentId\n      });\n    },\n\n    Avg_chat_duration(date, departmentId) {\n      let total = 0;\n      let count = 0;\n      LivechatRooms.getAnalyticsMetricsBetweenDate('l', date, {\n        departmentId\n      }).forEach(_ref => {\n        let {\n          metrics\n        } = _ref;\n\n        if (metrics && metrics.chatDuration) {\n          total += metrics.chatDuration;\n          count++;\n        }\n      });\n      const avgCD = count ? total / count : 0;\n      return Math.round(avgCD * 100) / 100;\n    },\n\n    Total_messages(date, departmentId) {\n      let total = 0; // we don't want to count visitor messages\n\n      const extraFilter = {\n        $lte: ['$token', null]\n      };\n      const allConversations = Promise.await(LivechatRooms.getAnalyticsMetricsBetweenDateWithMessages('l', date, {\n        departmentId\n      }, extraFilter).toArray());\n      allConversations.map(_ref2 => {\n        let {\n          msgs\n        } = _ref2;\n\n        if (msgs) {\n          total += msgs;\n        }\n\n        return null;\n      });\n      return total;\n    },\n\n    /**\n     *\n     * @param {Object} date {gte: {Date}, lt: {Date}}\n     *\n     * @returns {Double}\n     */\n    Avg_first_response_time(date, departmentId) {\n      let frt = 0;\n      let count = 0;\n      LivechatRooms.getAnalyticsMetricsBetweenDate('l', date, {\n        departmentId\n      }).forEach(_ref3 => {\n        let {\n          metrics\n        } = _ref3;\n\n        if (metrics && metrics.response && metrics.response.ft) {\n          frt += metrics.response.ft;\n          count++;\n        }\n      });\n      const avgFrt = count ? frt / count : 0;\n      return Math.round(avgFrt * 100) / 100;\n    },\n\n    /**\n     *\n     * @param {Object} date {gte: {Date}, lt: {Date}}\n     *\n     * @returns {Double}\n     */\n    Best_first_response_time(date, departmentId) {\n      let maxFrt;\n      LivechatRooms.getAnalyticsMetricsBetweenDate('l', date, {\n        departmentId\n      }).forEach(_ref4 => {\n        let {\n          metrics\n        } = _ref4;\n\n        if (metrics && metrics.response && metrics.response.ft) {\n          maxFrt = maxFrt ? Math.min(maxFrt, metrics.response.ft) : metrics.response.ft;\n        }\n      });\n\n      if (!maxFrt) {\n        maxFrt = 0;\n      }\n\n      return Math.round(maxFrt * 100) / 100;\n    },\n\n    /**\n     *\n     * @param {Object} date {gte: {Date}, lt: {Date}}\n     *\n     * @returns {Double}\n     */\n    Avg_response_time(date, departmentId) {\n      let art = 0;\n      let count = 0;\n      LivechatRooms.getAnalyticsMetricsBetweenDate('l', date, {\n        departmentId\n      }).forEach(_ref5 => {\n        let {\n          metrics\n        } = _ref5;\n\n        if (metrics && metrics.response && metrics.response.avg) {\n          art += metrics.response.avg;\n          count++;\n        }\n      });\n      const avgArt = count ? art / count : 0;\n      return Math.round(avgArt * 100) / 100;\n    },\n\n    /**\n     *\n     * @param {Object} date {gte: {Date}, lt: {Date}}\n     *\n     * @returns {Double}\n     */\n    Avg_reaction_time(date, departmentId) {\n      let arnt = 0;\n      let count = 0;\n      LivechatRooms.getAnalyticsMetricsBetweenDate('l', date, {\n        departmentId\n      }).forEach(_ref6 => {\n        let {\n          metrics\n        } = _ref6;\n\n        if (metrics && metrics.reaction && metrics.reaction.ft) {\n          arnt += metrics.reaction.ft;\n          count++;\n        }\n      });\n      const avgArnt = count ? arnt / count : 0;\n      return Math.round(avgArnt * 100) / 100;\n    }\n\n  },\n  OverviewData: {\n    /**\n     *\n     * @param {Map} map\n     *\n     * @return {String}\n     */\n    getKeyHavingMaxValue(map, def) {\n      let maxValue = 0;\n      let maxKey = def; // default\n\n      map.forEach((value, key) => {\n        if (value > maxValue) {\n          maxValue = value;\n          maxKey = key;\n        }\n      });\n      return maxKey;\n    },\n\n    /**\n     *\n     * @param {Date} from\n     * @param {Date} to\n     *\n     * @returns {Array[Object]}\n     */\n    Conversations(from, to, departmentId, timezone) {\n      let t = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : v => v;\n      // TODO: most calls to db here can be done in one single call instead of one per day/hour\n      let totalConversations = 0; // Total conversations\n\n      let openConversations = 0; // open conversations\n\n      let totalMessages = 0; // total msgs\n\n      const totalMessagesOnWeekday = new Map(); // total messages on weekdays i.e Monday, Tuesday...\n\n      const totalMessagesInHour = new Map(); // total messages in hour 0, 1, ... 23 of weekday\n\n      const days = to.diff(from, 'days') + 1; // total days\n\n      const summarize = m => _ref7 => {\n        let {\n          metrics,\n          msgs,\n          onHold = false\n        } = _ref7;\n\n        if (metrics && !metrics.chatDuration && !onHold) {\n          openConversations++;\n        }\n\n        totalMessages += msgs;\n        const weekday = m.format('dddd'); // @string: Monday, Tuesday ...\n\n        totalMessagesOnWeekday.set(weekday, totalMessagesOnWeekday.has(weekday) ? totalMessagesOnWeekday.get(weekday) + msgs : msgs);\n      };\n\n      for (let m = moment.tz(from, timezone).startOf('day').utc(), daysProcessed = 0; daysProcessed < days; daysProcessed++) {\n        const clonedDate = m.clone();\n        const date = {\n          gte: clonedDate,\n          lt: m.add(1, 'days')\n        };\n        const result = Promise.await(LivechatRooms.getAnalyticsBetweenDate(date, {\n          departmentId\n        }).toArray());\n        totalConversations += result.length;\n        result.forEach(summarize(clonedDate));\n      }\n\n      const busiestDay = this.getKeyHavingMaxValue(totalMessagesOnWeekday, '-'); // returns key with max value\n      // TODO: this code assumes the busiest day is the same every week, which may not be true\n      // This means that for periods larger than 1 week, the busiest hour won't be the \"busiest hour\"\n      // on the period, but the busiest hour on the busiest day. (sorry for busiest excess)\n      // iterate through all busiestDay in given date-range and find busiest hour\n\n      for (let m = moment.tz(from, timezone).day(busiestDay).startOf('day').utc(); m <= to; m.add(7, 'days')) {\n        if (m < from) {\n          continue;\n        }\n\n        for (let h = moment(m), currentHour = 0; currentHour < 24; currentHour++) {\n          const date = {\n            gte: h.clone(),\n            lt: h.add(1, 'hours')\n          };\n          Promise.await(LivechatRooms.getAnalyticsBetweenDate(date, {\n            departmentId\n          }).toArray()).forEach(_ref8 => {\n            let {\n              msgs\n            } = _ref8;\n            const dayHour = h.format('H'); // @int : 0, 1, ... 23\n\n            totalMessagesInHour.set(dayHour, totalMessagesInHour.has(dayHour) ? totalMessagesInHour.get(dayHour) + msgs : msgs);\n          });\n        }\n      }\n\n      const utcBusiestHour = this.getKeyHavingMaxValue(totalMessagesInHour, -1);\n      const busiestHour = {\n        to: utcBusiestHour >= 0 ? moment.utc().set({\n          hour: utcBusiestHour\n        }).tz(timezone).format('hA') : '-',\n        from: utcBusiestHour >= 0 ? moment.utc().set({\n          hour: utcBusiestHour\n        }).subtract(1, 'hour').tz(timezone).format('hA') : ''\n      };\n      const onHoldConversations = Promise.await(LivechatRoomsRaw.getOnHoldConversationsBetweenDate(from, to, departmentId));\n      return [{\n        title: 'Total_conversations',\n        value: totalConversations\n      }, {\n        title: 'Open_conversations',\n        value: openConversations\n      }, {\n        title: 'On_Hold_conversations',\n        value: onHoldConversations\n      }, {\n        title: 'Total_messages',\n        value: totalMessages\n      }, {\n        title: 'Busiest_day',\n        value: t(busiestDay)\n      }, {\n        title: 'Conversations_per_day',\n        value: (totalConversations / days).toFixed(2)\n      }, {\n        title: 'Busiest_time',\n        value: \"\".concat(busiestHour.from).concat(busiestHour.to ? \"- \".concat(busiestHour.to) : '')\n      }];\n    },\n\n    /**\n     *\n     * @param {Date} from\n     * @param {Date} to\n     *\n     * @returns {Array[Object]}\n     */\n    Productivity(from, to, departmentId) {\n      let avgResponseTime = 0;\n      let firstResponseTime = 0;\n      let avgReactionTime = 0;\n      let count = 0;\n      const date = {\n        gte: from,\n        lt: to.add(1, 'days')\n      };\n      LivechatRooms.getAnalyticsMetricsBetweenDate('l', date, {\n        departmentId\n      }).forEach(_ref9 => {\n        let {\n          metrics\n        } = _ref9;\n\n        if (metrics && metrics.response && metrics.reaction) {\n          avgResponseTime += metrics.response.avg;\n          firstResponseTime += metrics.response.ft;\n          avgReactionTime += metrics.reaction.ft;\n          count++;\n        }\n      });\n\n      if (count) {\n        avgResponseTime /= count;\n        firstResponseTime /= count;\n        avgReactionTime /= count;\n      }\n\n      const data = [{\n        title: 'Avg_response_time',\n        value: secondsToHHMMSS(avgResponseTime.toFixed(2))\n      }, {\n        title: 'Avg_first_response_time',\n        value: secondsToHHMMSS(firstResponseTime.toFixed(2))\n      }, {\n        title: 'Avg_reaction_time',\n        value: secondsToHHMMSS(avgReactionTime.toFixed(2))\n      }];\n      return data;\n    }\n\n  },\n  AgentOverviewData: {\n    /**\n     * do operation equivalent to map[key] += value\n     *\n     */\n    updateMap(map, key, value) {\n      map.set(key, map.has(key) ? map.get(key) + value : value);\n    },\n\n    /**\n     * Sort array of objects by value property of object\n     * @param  {Array(Object)} data\n     * @param  {Boolean} [inv=false] reverse sort\n     */\n    sortByValue(data) {\n      let inv = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      data.sort(function (a, b) {\n        // sort array\n        if (parseFloat(a.value) > parseFloat(b.value)) {\n          return inv ? -1 : 1; // if inv, reverse sort\n        }\n\n        if (parseFloat(a.value) < parseFloat(b.value)) {\n          return inv ? 1 : -1;\n        }\n\n        return 0;\n      });\n    },\n\n    /**\n     *\n     * @param {Date} from\n     * @param {Date} to\n     *\n     * @returns {Array(Object), Array(Object)}\n     */\n    Total_conversations(from, to, departmentId) {\n      let total = 0;\n      const agentConversations = new Map(); // stores total conversations for each agent\n\n      const date = {\n        gte: from,\n        lt: to.add(1, 'days')\n      };\n      const data = {\n        head: [{\n          name: 'Agent'\n        }, {\n          name: '%_of_conversations'\n        }],\n        data: []\n      };\n      const allConversations = Promise.await(LivechatRooms.getAnalyticsMetricsBetweenDateWithMessages('l', date, {\n        departmentId\n      }).toArray());\n      allConversations.map(room => {\n        if (room.servedBy) {\n          this.updateMap(agentConversations, room.servedBy.username, 1);\n          total++;\n        }\n\n        return null;\n      });\n      agentConversations.forEach((value, key) => {\n        // calculate percentage\n        const percentage = (value / total * 100).toFixed(2);\n        data.data.push({\n          name: key,\n          value: percentage\n        });\n      });\n      this.sortByValue(data.data, true); // reverse sort array\n\n      data.data.forEach(value => {\n        value.value = \"\".concat(value.value, \"%\");\n      });\n      return data;\n    },\n\n    /**\n     *\n     * @param {Date} from\n     * @param {Date} to\n     *\n     * @returns {Array(Object), Array(Object)}\n     */\n    Avg_chat_duration(from, to, departmentId) {\n      const agentChatDurations = new Map(); // stores total conversations for each agent\n\n      const date = {\n        gte: from,\n        lt: to.add(1, 'days')\n      };\n      const data = {\n        head: [{\n          name: 'Agent'\n        }, {\n          name: 'Avg_chat_duration'\n        }],\n        data: []\n      };\n      LivechatRooms.getAnalyticsMetricsBetweenDate('l', date, {\n        departmentId\n      }).forEach(_ref10 => {\n        let {\n          metrics,\n          servedBy\n        } = _ref10;\n\n        if (servedBy && metrics && metrics.chatDuration) {\n          if (agentChatDurations.has(servedBy.username)) {\n            agentChatDurations.set(servedBy.username, {\n              chatDuration: agentChatDurations.get(servedBy.username).chatDuration + metrics.chatDuration,\n              total: agentChatDurations.get(servedBy.username).total + 1\n            });\n          } else {\n            agentChatDurations.set(servedBy.username, {\n              chatDuration: metrics.chatDuration,\n              total: 1\n            });\n          }\n        }\n      });\n      agentChatDurations.forEach((obj, key) => {\n        // calculate percentage\n        const avg = (obj.chatDuration / obj.total).toFixed(2);\n        data.data.push({\n          name: key,\n          value: avg\n        });\n      });\n      this.sortByValue(data.data, true); // reverse sort array\n\n      data.data.forEach(obj => {\n        obj.value = secondsToHHMMSS(obj.value);\n      });\n      return data;\n    },\n\n    /**\n     *\n     * @param {Date} from\n     * @param {Date} to\n     *\n     * @returns {Array(Object), Array(Object)}\n     */\n    Total_messages(from, to, departmentId) {\n      const agentMessages = new Map(); // stores total conversations for each agent\n\n      const date = {\n        gte: from,\n        lt: to.add(1, 'days')\n      };\n      const data = {\n        head: [{\n          name: 'Agent'\n        }, {\n          name: 'Total_messages'\n        }],\n        data: []\n      }; // we don't want to count visitor messages\n\n      const extraFilter = {\n        $lte: ['$token', null]\n      };\n      const allConversations = Promise.await(LivechatRooms.getAnalyticsMetricsBetweenDateWithMessages('l', date, {\n        departmentId\n      }, extraFilter).toArray());\n      allConversations.map(_ref11 => {\n        let {\n          servedBy,\n          msgs\n        } = _ref11;\n\n        if (servedBy) {\n          this.updateMap(agentMessages, servedBy.username, msgs);\n        }\n\n        return null;\n      });\n      agentMessages.forEach((value, key) => {\n        // calculate percentage\n        data.data.push({\n          name: key,\n          value\n        });\n      });\n      this.sortByValue(data.data, true); // reverse sort array\n\n      return data;\n    },\n\n    /**\n     *\n     * @param {Date} from\n     * @param {Date} to\n     *\n     * @returns {Array(Object), Array(Object)}\n     */\n    Avg_first_response_time(from, to, departmentId) {\n      const agentAvgRespTime = new Map(); // stores avg response time for each agent\n\n      const date = {\n        gte: from,\n        lt: to.add(1, 'days')\n      };\n      const data = {\n        head: [{\n          name: 'Agent'\n        }, {\n          name: 'Avg_first_response_time'\n        }],\n        data: []\n      };\n      LivechatRooms.getAnalyticsMetricsBetweenDate('l', date, {\n        departmentId\n      }).forEach(_ref12 => {\n        let {\n          metrics,\n          servedBy\n        } = _ref12;\n\n        if (servedBy && metrics && metrics.response && metrics.response.ft) {\n          if (agentAvgRespTime.has(servedBy.username)) {\n            agentAvgRespTime.set(servedBy.username, {\n              frt: agentAvgRespTime.get(servedBy.username).frt + metrics.response.ft,\n              total: agentAvgRespTime.get(servedBy.username).total + 1\n            });\n          } else {\n            agentAvgRespTime.set(servedBy.username, {\n              frt: metrics.response.ft,\n              total: 1\n            });\n          }\n        }\n      });\n      agentAvgRespTime.forEach((obj, key) => {\n        // calculate avg\n        const avg = obj.frt / obj.total;\n        data.data.push({\n          name: key,\n          value: avg.toFixed(2)\n        });\n      });\n      this.sortByValue(data.data, false); // sort array\n\n      data.data.forEach(obj => {\n        obj.value = secondsToHHMMSS(obj.value);\n      });\n      return data;\n    },\n\n    /**\n     *\n     * @param {Date} from\n     * @param {Date} to\n     *\n     * @returns {Array(Object), Array(Object)}\n     */\n    Best_first_response_time(from, to, departmentId) {\n      const agentFirstRespTime = new Map(); // stores avg response time for each agent\n\n      const date = {\n        gte: from,\n        lt: to.add(1, 'days')\n      };\n      const data = {\n        head: [{\n          name: 'Agent'\n        }, {\n          name: 'Best_first_response_time'\n        }],\n        data: []\n      };\n      LivechatRooms.getAnalyticsMetricsBetweenDate('l', date, {\n        departmentId\n      }).forEach(_ref13 => {\n        let {\n          metrics,\n          servedBy\n        } = _ref13;\n\n        if (servedBy && metrics && metrics.response && metrics.response.ft) {\n          if (agentFirstRespTime.has(servedBy.username)) {\n            agentFirstRespTime.set(servedBy.username, Math.min(agentFirstRespTime.get(servedBy.username), metrics.response.ft));\n          } else {\n            agentFirstRespTime.set(servedBy.username, metrics.response.ft);\n          }\n        }\n      });\n      agentFirstRespTime.forEach((value, key) => {\n        // calculate avg\n        data.data.push({\n          name: key,\n          value: value.toFixed(2)\n        });\n      });\n      this.sortByValue(data.data, false); // sort array\n\n      data.data.forEach(obj => {\n        obj.value = secondsToHHMMSS(obj.value);\n      });\n      return data;\n    },\n\n    /**\n     *\n     * @param {Date} from\n     * @param {Date} to\n     *\n     * @returns {Array(Object), Array(Object)}\n     */\n    Avg_response_time(from, to, departmentId) {\n      const agentAvgRespTime = new Map(); // stores avg response time for each agent\n\n      const date = {\n        gte: from,\n        lt: to.add(1, 'days')\n      };\n      const data = {\n        head: [{\n          name: 'Agent'\n        }, {\n          name: 'Avg_response_time'\n        }],\n        data: []\n      };\n      LivechatRooms.getAnalyticsMetricsBetweenDate('l', date, {\n        departmentId\n      }).forEach(_ref14 => {\n        let {\n          metrics,\n          servedBy\n        } = _ref14;\n\n        if (servedBy && metrics && metrics.response && metrics.response.avg) {\n          if (agentAvgRespTime.has(servedBy.username)) {\n            agentAvgRespTime.set(servedBy.username, {\n              avg: agentAvgRespTime.get(servedBy.username).avg + metrics.response.avg,\n              total: agentAvgRespTime.get(servedBy.username).total + 1\n            });\n          } else {\n            agentAvgRespTime.set(servedBy.username, {\n              avg: metrics.response.avg,\n              total: 1\n            });\n          }\n        }\n      });\n      agentAvgRespTime.forEach((obj, key) => {\n        // calculate avg\n        const avg = obj.avg / obj.total;\n        data.data.push({\n          name: key,\n          value: avg.toFixed(2)\n        });\n      });\n      this.sortByValue(data.data, false); // sort array\n\n      data.data.forEach(obj => {\n        obj.value = secondsToHHMMSS(obj.value);\n      });\n      return data;\n    },\n\n    /**\n     *\n     * @param {Date} from\n     * @param {Date} to\n     *\n     * @returns {Array(Object), Array(Object)}\n     */\n    Avg_reaction_time(from, to, departmentId) {\n      const agentAvgReactionTime = new Map(); // stores avg reaction time for each agent\n\n      const date = {\n        gte: from,\n        lt: to.add(1, 'days')\n      };\n      const data = {\n        head: [{\n          name: 'Agent'\n        }, {\n          name: 'Avg_reaction_time'\n        }],\n        data: []\n      };\n      LivechatRooms.getAnalyticsMetricsBetweenDate('l', date, {\n        departmentId\n      }).forEach(_ref15 => {\n        let {\n          metrics,\n          servedBy\n        } = _ref15;\n\n        if (servedBy && metrics && metrics.reaction && metrics.reaction.ft) {\n          if (agentAvgReactionTime.has(servedBy.username)) {\n            agentAvgReactionTime.set(servedBy.username, {\n              frt: agentAvgReactionTime.get(servedBy.username).frt + metrics.reaction.ft,\n              total: agentAvgReactionTime.get(servedBy.username).total + 1\n            });\n          } else {\n            agentAvgReactionTime.set(servedBy.username, {\n              frt: metrics.reaction.ft,\n              total: 1\n            });\n          }\n        }\n      });\n      agentAvgReactionTime.forEach((obj, key) => {\n        // calculate avg\n        const avg = obj.frt / obj.total;\n        data.data.push({\n          name: key,\n          value: avg.toFixed(2)\n        });\n      });\n      this.sortByValue(data.data, false); // sort array\n\n      data.data.forEach(obj => {\n        obj.value = secondsToHHMMSS(obj.value);\n      });\n      return data;\n    }\n\n  }\n};","map":{"version":3,"sources":["app/livechat/server/lib/Analytics.js"],"names":["module","export","Analytics","TAPi18n","link","v","moment","default","LivechatRooms","LivechatRoomsRaw","secondsToHHMMSS","getTimezone","Logger","HOURS_IN_DAY","logger","getAgentOverviewData","options","departmentId","utcOffset","daterange","from","fDate","to","tDate","chartOptions","name","timezone","tz","startOf","utc","endOf","debug","isValid","error","AgentOverviewData","getAnalyticsChartData","chartLabel","ChartData","isSameDay","diff","data","dataLabels","dataPoints","m","currentHour","hour","add","format","label","set","push","date","gte","lt","getAnalyticsOverviewData","language","analyticsOptions","OverviewData","t","s","__","lng","Total_conversations","getTotalConversationsBetweenDate","Avg_chat_duration","total","count","getAnalyticsMetricsBetweenDate","forEach","metrics","chatDuration","avgCD","Math","round","Total_messages","extraFilter","$lte","allConversations","Promise","await","getAnalyticsMetricsBetweenDateWithMessages","toArray","map","msgs","Avg_first_response_time","frt","response","ft","avgFrt","Best_first_response_time","maxFrt","min","Avg_response_time","art","avg","avgArt","Avg_reaction_time","arnt","reaction","avgArnt","getKeyHavingMaxValue","def","maxValue","maxKey","value","key","Conversations","totalConversations","openConversations","totalMessages","totalMessagesOnWeekday","Map","totalMessagesInHour","days","summarize","onHold","weekday","has","get","daysProcessed","clonedDate","clone","result","getAnalyticsBetweenDate","length","busiestDay","day","h","dayHour","utcBusiestHour","busiestHour","subtract","onHoldConversations","getOnHoldConversationsBetweenDate","title","toFixed","Productivity","avgResponseTime","firstResponseTime","avgReactionTime","updateMap","sortByValue","inv","sort","a","b","parseFloat","agentConversations","head","room","servedBy","username","percentage","agentChatDurations","obj","agentMessages","agentAvgRespTime","agentFirstRespTime","agentAvgReactionTime"],"mappings":"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","sourcesContent":["import { TAPi18n } from 'meteor/rocketchat:tap-i18n';\nimport moment from 'moment';\n\nimport { LivechatRooms } from '../../../models';\nimport { LivechatRooms as LivechatRoomsRaw } from '../../../models/server/raw';\nimport { secondsToHHMMSS } from '../../../utils/server';\nimport { getTimezone } from '../../../utils/server/lib/getTimezone';\nimport { Logger } from '../../../logger';\n\nconst HOURS_IN_DAY = 24;\nconst logger = new Logger('OmnichannelAnalytics');\n\nexport const Analytics = {\n\tgetAgentOverviewData(options) {\n\t\tconst { departmentId, utcOffset, daterange: { from: fDate, to: tDate } = {}, chartOptions: { name } = {} } = options;\n\t\tconst timezone = getTimezone({ utcOffset });\n\t\tconst from = moment.tz(fDate, 'YYYY-MM-DD', timezone).startOf('day').utc();\n\t\tconst to = moment.tz(tDate, 'YYYY-MM-DD', timezone).endOf('day').utc();\n\n\t\tlogger.debug(`getAgentOverviewData[${name}] -> Using timezone ${timezone} with date range ${from} - ${to}`);\n\n\t\tif (!(moment(from).isValid() && moment(to).isValid())) {\n\t\t\tlogger.error('livechat:getAgentOverviewData => Invalid dates');\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.AgentOverviewData[name]) {\n\t\t\tlogger.error(`Method RocketChat.Livechat.Analytics.AgentOverviewData.${name} does NOT exist`);\n\t\t\treturn;\n\t\t}\n\n\t\treturn this.AgentOverviewData[name](from, to, departmentId);\n\t},\n\n\tgetAnalyticsChartData(options) {\n\t\tconst {\n\t\t\tutcOffset,\n\t\t\tdepartmentId,\n\t\t\tdaterange: { from: fDate, to: tDate } = {},\n\t\t\tchartOptions: { name: chartLabel },\n\t\t\tchartOptions: { name } = {},\n\t\t} = options;\n\n\t\t// Check if function exists, prevent server error in case property altered\n\t\tif (!this.ChartData[name]) {\n\t\t\tlogger.error(`Method RocketChat.Livechat.Analytics.ChartData.${name} does NOT exist`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst timezone = getTimezone({ utcOffset });\n\t\tconst from = moment.tz(fDate, 'YYYY-MM-DD', timezone).startOf('day').utc();\n\t\tconst to = moment.tz(tDate, 'YYYY-MM-DD', timezone).endOf('day').utc();\n\t\tconst isSameDay = from.diff(to, 'days') === 0;\n\n\t\tlogger.debug(`getAnalyticsChartData[${name}] -> Using timezone ${timezone} with date range ${from} - ${to}`);\n\n\t\tif (!(moment(from).isValid() && moment(to).isValid())) {\n\t\t\tlogger.error('livechat:getAnalyticsChartData => Invalid dates');\n\t\t\treturn;\n\t\t}\n\n\t\tconst data = {\n\t\t\tchartLabel,\n\t\t\tdataLabels: [],\n\t\t\tdataPoints: [],\n\t\t};\n\n\t\tif (isSameDay) {\n\t\t\t// data for single day\n\t\t\tfor (let m = moment(from), currentHour = 0; currentHour < HOURS_IN_DAY; currentHour++) {\n\t\t\t\tconst hour = m.add(currentHour ? 1 : 0, 'hour').format('H');\n\t\t\t\tconst label = {\n\t\t\t\t\tfrom: moment.utc().set({ hour }).tz(timezone).format('hA'),\n\t\t\t\t\tto: moment.utc().set({ hour }).add(1, 'hour').tz(timezone).format('hA'),\n\t\t\t\t};\n\t\t\t\tdata.dataLabels.push(`${label.from}-${label.to}`);\n\n\t\t\t\tconst date = {\n\t\t\t\t\tgte: m,\n\t\t\t\t\tlt: moment(m).add(1, 'hours'),\n\t\t\t\t};\n\n\t\t\t\tdata.dataPoints.push(this.ChartData[name](date, departmentId));\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let m = moment(from); m.diff(to, 'days') <= 0; m.add(1, 'days')) {\n\t\t\t\tdata.dataLabels.push(m.format('M/D'));\n\n\t\t\t\tconst date = {\n\t\t\t\t\tgte: m,\n\t\t\t\t\tlt: moment(m).add(1, 'days'),\n\t\t\t\t};\n\n\t\t\t\tdata.dataPoints.push(this.ChartData[name](date, departmentId));\n\t\t\t}\n\t\t}\n\n\t\treturn data;\n\t},\n\n\tgetAnalyticsOverviewData(options) {\n\t\tconst { departmentId, utcOffset = 0, language, daterange: { from: fDate, to: tDate } = {}, analyticsOptions: { name } = {} } = options;\n\t\tconst timezone = getTimezone({ utcOffset });\n\t\tconst from = moment.tz(fDate, 'YYYY-MM-DD', timezone).startOf('day').utc();\n\t\tconst to = moment.tz(tDate, 'YYYY-MM-DD', timezone).endOf('day').utc();\n\n\t\tlogger.debug(`getAnalyticsOverviewData[${name}] -> Using timezone ${timezone} with date range ${from} - ${to}`);\n\n\t\tif (!(moment(from).isValid() && moment(to).isValid())) {\n\t\t\tlogger.error('livechat:getAnalyticsOverviewData => Invalid dates');\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.OverviewData[name]) {\n\t\t\tlogger.error(`Method RocketChat.Livechat.Analytics.OverviewData.${name} does NOT exist`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst t = (s) => TAPi18n.__(s, { lng: language });\n\n\t\treturn this.OverviewData[name](from, to, departmentId, timezone, t);\n\t},\n\n\tChartData: {\n\t\t/**\n\t\t *\n\t\t * @param {Object} date {gte: {Date}, lt: {Date}}\n\t\t *\n\t\t * @returns {Integer}\n\t\t */\n\t\tTotal_conversations(date, departmentId) {\n\t\t\treturn LivechatRooms.getTotalConversationsBetweenDate('l', date, { departmentId });\n\t\t},\n\n\t\tAvg_chat_duration(date, departmentId) {\n\t\t\tlet total = 0;\n\t\t\tlet count = 0;\n\n\t\t\tLivechatRooms.getAnalyticsMetricsBetweenDate('l', date, { departmentId }).forEach(({ metrics }) => {\n\t\t\t\tif (metrics && metrics.chatDuration) {\n\t\t\t\t\ttotal += metrics.chatDuration;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconst avgCD = count ? total / count : 0;\n\t\t\treturn Math.round(avgCD * 100) / 100;\n\t\t},\n\n\t\tTotal_messages(date, departmentId) {\n\t\t\tlet total = 0;\n\n\t\t\t// we don't want to count visitor messages\n\t\t\tconst extraFilter = { $lte: ['$token', null] };\n\t\t\tconst allConversations = Promise.await(\n\t\t\t\tLivechatRooms.getAnalyticsMetricsBetweenDateWithMessages('l', date, { departmentId }, extraFilter).toArray(),\n\t\t\t);\n\t\t\tallConversations.map(({ msgs }) => {\n\t\t\t\tif (msgs) {\n\t\t\t\t\ttotal += msgs;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t});\n\n\t\t\treturn total;\n\t\t},\n\n\t\t/**\n\t\t *\n\t\t * @param {Object} date {gte: {Date}, lt: {Date}}\n\t\t *\n\t\t * @returns {Double}\n\t\t */\n\t\tAvg_first_response_time(date, departmentId) {\n\t\t\tlet frt = 0;\n\t\t\tlet count = 0;\n\t\t\tLivechatRooms.getAnalyticsMetricsBetweenDate('l', date, { departmentId }).forEach(({ metrics }) => {\n\t\t\t\tif (metrics && metrics.response && metrics.response.ft) {\n\t\t\t\t\tfrt += metrics.response.ft;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconst avgFrt = count ? frt / count : 0;\n\t\t\treturn Math.round(avgFrt * 100) / 100;\n\t\t},\n\n\t\t/**\n\t\t *\n\t\t * @param {Object} date {gte: {Date}, lt: {Date}}\n\t\t *\n\t\t * @returns {Double}\n\t\t */\n\t\tBest_first_response_time(date, departmentId) {\n\t\t\tlet maxFrt;\n\n\t\t\tLivechatRooms.getAnalyticsMetricsBetweenDate('l', date, { departmentId }).forEach(({ metrics }) => {\n\t\t\t\tif (metrics && metrics.response && metrics.response.ft) {\n\t\t\t\t\tmaxFrt = maxFrt ? Math.min(maxFrt, metrics.response.ft) : metrics.response.ft;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (!maxFrt) {\n\t\t\t\tmaxFrt = 0;\n\t\t\t}\n\n\t\t\treturn Math.round(maxFrt * 100) / 100;\n\t\t},\n\n\t\t/**\n\t\t *\n\t\t * @param {Object} date {gte: {Date}, lt: {Date}}\n\t\t *\n\t\t * @returns {Double}\n\t\t */\n\t\tAvg_response_time(date, departmentId) {\n\t\t\tlet art = 0;\n\t\t\tlet count = 0;\n\t\t\tLivechatRooms.getAnalyticsMetricsBetweenDate('l', date, { departmentId }).forEach(({ metrics }) => {\n\t\t\t\tif (metrics && metrics.response && metrics.response.avg) {\n\t\t\t\t\tart += metrics.response.avg;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconst avgArt = count ? art / count : 0;\n\n\t\t\treturn Math.round(avgArt * 100) / 100;\n\t\t},\n\n\t\t/**\n\t\t *\n\t\t * @param {Object} date {gte: {Date}, lt: {Date}}\n\t\t *\n\t\t * @returns {Double}\n\t\t */\n\t\tAvg_reaction_time(date, departmentId) {\n\t\t\tlet arnt = 0;\n\t\t\tlet count = 0;\n\t\t\tLivechatRooms.getAnalyticsMetricsBetweenDate('l', date, { departmentId }).forEach(({ metrics }) => {\n\t\t\t\tif (metrics && metrics.reaction && metrics.reaction.ft) {\n\t\t\t\t\tarnt += metrics.reaction.ft;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconst avgArnt = count ? arnt / count : 0;\n\n\t\t\treturn Math.round(avgArnt * 100) / 100;\n\t\t},\n\t},\n\n\tOverviewData: {\n\t\t/**\n\t\t *\n\t\t * @param {Map} map\n\t\t *\n\t\t * @return {String}\n\t\t */\n\t\tgetKeyHavingMaxValue(map, def) {\n\t\t\tlet maxValue = 0;\n\t\t\tlet maxKey = def; // default\n\n\t\t\tmap.forEach((value, key) => {\n\t\t\t\tif (value > maxValue) {\n\t\t\t\t\tmaxValue = value;\n\t\t\t\t\tmaxKey = key;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn maxKey;\n\t\t},\n\n\t\t/**\n\t\t *\n\t\t * @param {Date} from\n\t\t * @param {Date} to\n\t\t *\n\t\t * @returns {Array[Object]}\n\t\t */\n\t\tConversations(from, to, departmentId, timezone, t = (v) => v) {\n\t\t\t// TODO: most calls to db here can be done in one single call instead of one per day/hour\n\t\t\tlet totalConversations = 0; // Total conversations\n\t\t\tlet openConversations = 0; // open conversations\n\t\t\tlet totalMessages = 0; // total msgs\n\t\t\tconst totalMessagesOnWeekday = new Map(); // total messages on weekdays i.e Monday, Tuesday...\n\t\t\tconst totalMessagesInHour = new Map(); // total messages in hour 0, 1, ... 23 of weekday\n\t\t\tconst days = to.diff(from, 'days') + 1; // total days\n\n\t\t\tconst summarize =\n\t\t\t\t(m) =>\n\t\t\t\t({ metrics, msgs, onHold = false }) => {\n\t\t\t\t\tif (metrics && !metrics.chatDuration && !onHold) {\n\t\t\t\t\t\topenConversations++;\n\t\t\t\t\t}\n\t\t\t\t\ttotalMessages += msgs;\n\n\t\t\t\t\tconst weekday = m.format('dddd'); // @string: Monday, Tuesday ...\n\t\t\t\t\ttotalMessagesOnWeekday.set(weekday, totalMessagesOnWeekday.has(weekday) ? totalMessagesOnWeekday.get(weekday) + msgs : msgs);\n\t\t\t\t};\n\n\t\t\tfor (let m = moment.tz(from, timezone).startOf('day').utc(), daysProcessed = 0; daysProcessed < days; daysProcessed++) {\n\t\t\t\tconst clonedDate = m.clone();\n\t\t\t\tconst date = {\n\t\t\t\t\tgte: clonedDate,\n\t\t\t\t\tlt: m.add(1, 'days'),\n\t\t\t\t};\n\t\t\t\tconst result = Promise.await(LivechatRooms.getAnalyticsBetweenDate(date, { departmentId }).toArray());\n\t\t\t\ttotalConversations += result.length;\n\n\t\t\t\tresult.forEach(summarize(clonedDate));\n\t\t\t}\n\n\t\t\tconst busiestDay = this.getKeyHavingMaxValue(totalMessagesOnWeekday, '-'); // returns key with max value\n\n\t\t\t// TODO: this code assumes the busiest day is the same every week, which may not be true\n\t\t\t// This means that for periods larger than 1 week, the busiest hour won't be the \"busiest hour\"\n\t\t\t// on the period, but the busiest hour on the busiest day. (sorry for busiest excess)\n\t\t\t// iterate through all busiestDay in given date-range and find busiest hour\n\t\t\tfor (let m = moment.tz(from, timezone).day(busiestDay).startOf('day').utc(); m <= to; m.add(7, 'days')) {\n\t\t\t\tif (m < from) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (let h = moment(m), currentHour = 0; currentHour < 24; currentHour++) {\n\t\t\t\t\tconst date = {\n\t\t\t\t\t\tgte: h.clone(),\n\t\t\t\t\t\tlt: h.add(1, 'hours'),\n\t\t\t\t\t};\n\t\t\t\t\tPromise.await(LivechatRooms.getAnalyticsBetweenDate(date, { departmentId }).toArray()).forEach(({ msgs }) => {\n\t\t\t\t\t\tconst dayHour = h.format('H'); // @int : 0, 1, ... 23\n\t\t\t\t\t\ttotalMessagesInHour.set(dayHour, totalMessagesInHour.has(dayHour) ? totalMessagesInHour.get(dayHour) + msgs : msgs);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst utcBusiestHour = this.getKeyHavingMaxValue(totalMessagesInHour, -1);\n\t\t\tconst busiestHour = {\n\t\t\t\tto: utcBusiestHour >= 0 ? moment.utc().set({ hour: utcBusiestHour }).tz(timezone).format('hA') : '-',\n\t\t\t\tfrom: utcBusiestHour >= 0 ? moment.utc().set({ hour: utcBusiestHour }).subtract(1, 'hour').tz(timezone).format('hA') : '',\n\t\t\t};\n\t\t\tconst onHoldConversations = Promise.await(LivechatRoomsRaw.getOnHoldConversationsBetweenDate(from, to, departmentId));\n\n\t\t\treturn [\n\t\t\t\t{\n\t\t\t\t\ttitle: 'Total_conversations',\n\t\t\t\t\tvalue: totalConversations,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttitle: 'Open_conversations',\n\t\t\t\t\tvalue: openConversations,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttitle: 'On_Hold_conversations',\n\t\t\t\t\tvalue: onHoldConversations,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttitle: 'Total_messages',\n\t\t\t\t\tvalue: totalMessages,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttitle: 'Busiest_day',\n\t\t\t\t\tvalue: t(busiestDay),\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttitle: 'Conversations_per_day',\n\t\t\t\t\tvalue: (totalConversations / days).toFixed(2),\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttitle: 'Busiest_time',\n\t\t\t\t\tvalue: `${busiestHour.from}${busiestHour.to ? `- ${busiestHour.to}` : ''}`,\n\t\t\t\t},\n\t\t\t];\n\t\t},\n\n\t\t/**\n\t\t *\n\t\t * @param {Date} from\n\t\t * @param {Date} to\n\t\t *\n\t\t * @returns {Array[Object]}\n\t\t */\n\t\tProductivity(from, to, departmentId) {\n\t\t\tlet avgResponseTime = 0;\n\t\t\tlet firstResponseTime = 0;\n\t\t\tlet avgReactionTime = 0;\n\t\t\tlet count = 0;\n\n\t\t\tconst date = {\n\t\t\t\tgte: from,\n\t\t\t\tlt: to.add(1, 'days'),\n\t\t\t};\n\n\t\t\tLivechatRooms.getAnalyticsMetricsBetweenDate('l', date, { departmentId }).forEach(({ metrics }) => {\n\t\t\t\tif (metrics && metrics.response && metrics.reaction) {\n\t\t\t\t\tavgResponseTime += metrics.response.avg;\n\t\t\t\t\tfirstResponseTime += metrics.response.ft;\n\t\t\t\t\tavgReactionTime += metrics.reaction.ft;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (count) {\n\t\t\t\tavgResponseTime /= count;\n\t\t\t\tfirstResponseTime /= count;\n\t\t\t\tavgReactionTime /= count;\n\t\t\t}\n\n\t\t\tconst data = [\n\t\t\t\t{\n\t\t\t\t\ttitle: 'Avg_response_time',\n\t\t\t\t\tvalue: secondsToHHMMSS(avgResponseTime.toFixed(2)),\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttitle: 'Avg_first_response_time',\n\t\t\t\t\tvalue: secondsToHHMMSS(firstResponseTime.toFixed(2)),\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttitle: 'Avg_reaction_time',\n\t\t\t\t\tvalue: secondsToHHMMSS(avgReactionTime.toFixed(2)),\n\t\t\t\t},\n\t\t\t];\n\n\t\t\treturn data;\n\t\t},\n\t},\n\n\tAgentOverviewData: {\n\t\t/**\n\t\t * do operation equivalent to map[key] += value\n\t\t *\n\t\t */\n\t\tupdateMap(map, key, value) {\n\t\t\tmap.set(key, map.has(key) ? map.get(key) + value : value);\n\t\t},\n\n\t\t/**\n\t\t * Sort array of objects by value property of object\n\t\t * @param  {Array(Object)} data\n\t\t * @param  {Boolean} [inv=false] reverse sort\n\t\t */\n\t\tsortByValue(data, inv = false) {\n\t\t\tdata.sort(function (a, b) {\n\t\t\t\t// sort array\n\t\t\t\tif (parseFloat(a.value) > parseFloat(b.value)) {\n\t\t\t\t\treturn inv ? -1 : 1; // if inv, reverse sort\n\t\t\t\t}\n\t\t\t\tif (parseFloat(a.value) < parseFloat(b.value)) {\n\t\t\t\t\treturn inv ? 1 : -1;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t *\n\t\t * @param {Date} from\n\t\t * @param {Date} to\n\t\t *\n\t\t * @returns {Array(Object), Array(Object)}\n\t\t */\n\t\tTotal_conversations(from, to, departmentId) {\n\t\t\tlet total = 0;\n\t\t\tconst agentConversations = new Map(); // stores total conversations for each agent\n\t\t\tconst date = {\n\t\t\t\tgte: from,\n\t\t\t\tlt: to.add(1, 'days'),\n\t\t\t};\n\n\t\t\tconst data = {\n\t\t\t\thead: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Agent',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: '%_of_conversations',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tdata: [],\n\t\t\t};\n\n\t\t\tconst allConversations = Promise.await(\n\t\t\t\tLivechatRooms.getAnalyticsMetricsBetweenDateWithMessages('l', date, {\n\t\t\t\t\tdepartmentId,\n\t\t\t\t}).toArray(),\n\t\t\t);\n\t\t\tallConversations.map((room) => {\n\t\t\t\tif (room.servedBy) {\n\t\t\t\t\tthis.updateMap(agentConversations, room.servedBy.username, 1);\n\t\t\t\t\ttotal++;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t});\n\n\t\t\tagentConversations.forEach((value, key) => {\n\t\t\t\t// calculate percentage\n\t\t\t\tconst percentage = ((value / total) * 100).toFixed(2);\n\n\t\t\t\tdata.data.push({\n\t\t\t\t\tname: key,\n\t\t\t\t\tvalue: percentage,\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tthis.sortByValue(data.data, true); // reverse sort array\n\n\t\t\tdata.data.forEach((value) => {\n\t\t\t\tvalue.value = `${value.value}%`;\n\t\t\t});\n\n\t\t\treturn data;\n\t\t},\n\n\t\t/**\n\t\t *\n\t\t * @param {Date} from\n\t\t * @param {Date} to\n\t\t *\n\t\t * @returns {Array(Object), Array(Object)}\n\t\t */\n\t\tAvg_chat_duration(from, to, departmentId) {\n\t\t\tconst agentChatDurations = new Map(); // stores total conversations for each agent\n\t\t\tconst date = {\n\t\t\t\tgte: from,\n\t\t\t\tlt: to.add(1, 'days'),\n\t\t\t};\n\n\t\t\tconst data = {\n\t\t\t\thead: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Agent',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Avg_chat_duration',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tdata: [],\n\t\t\t};\n\n\t\t\tLivechatRooms.getAnalyticsMetricsBetweenDate('l', date, { departmentId }).forEach(({ metrics, servedBy }) => {\n\t\t\t\tif (servedBy && metrics && metrics.chatDuration) {\n\t\t\t\t\tif (agentChatDurations.has(servedBy.username)) {\n\t\t\t\t\t\tagentChatDurations.set(servedBy.username, {\n\t\t\t\t\t\t\tchatDuration: agentChatDurations.get(servedBy.username).chatDuration + metrics.chatDuration,\n\t\t\t\t\t\t\ttotal: agentChatDurations.get(servedBy.username).total + 1,\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tagentChatDurations.set(servedBy.username, {\n\t\t\t\t\t\t\tchatDuration: metrics.chatDuration,\n\t\t\t\t\t\t\ttotal: 1,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tagentChatDurations.forEach((obj, key) => {\n\t\t\t\t// calculate percentage\n\t\t\t\tconst avg = (obj.chatDuration / obj.total).toFixed(2);\n\n\t\t\t\tdata.data.push({\n\t\t\t\t\tname: key,\n\t\t\t\t\tvalue: avg,\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tthis.sortByValue(data.data, true); // reverse sort array\n\n\t\t\tdata.data.forEach((obj) => {\n\t\t\t\tobj.value = secondsToHHMMSS(obj.value);\n\t\t\t});\n\n\t\t\treturn data;\n\t\t},\n\n\t\t/**\n\t\t *\n\t\t * @param {Date} from\n\t\t * @param {Date} to\n\t\t *\n\t\t * @returns {Array(Object), Array(Object)}\n\t\t */\n\t\tTotal_messages(from, to, departmentId) {\n\t\t\tconst agentMessages = new Map(); // stores total conversations for each agent\n\t\t\tconst date = {\n\t\t\t\tgte: from,\n\t\t\t\tlt: to.add(1, 'days'),\n\t\t\t};\n\n\t\t\tconst data = {\n\t\t\t\thead: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Agent',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Total_messages',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tdata: [],\n\t\t\t};\n\n\t\t\t// we don't want to count visitor messages\n\t\t\tconst extraFilter = { $lte: ['$token', null] };\n\t\t\tconst allConversations = Promise.await(\n\t\t\t\tLivechatRooms.getAnalyticsMetricsBetweenDateWithMessages('l', date, { departmentId }, extraFilter).toArray(),\n\t\t\t);\n\t\t\tallConversations.map(({ servedBy, msgs }) => {\n\t\t\t\tif (servedBy) {\n\t\t\t\t\tthis.updateMap(agentMessages, servedBy.username, msgs);\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t});\n\n\t\t\tagentMessages.forEach((value, key) => {\n\t\t\t\t// calculate percentage\n\t\t\t\tdata.data.push({\n\t\t\t\t\tname: key,\n\t\t\t\t\tvalue,\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tthis.sortByValue(data.data, true); // reverse sort array\n\n\t\t\treturn data;\n\t\t},\n\n\t\t/**\n\t\t *\n\t\t * @param {Date} from\n\t\t * @param {Date} to\n\t\t *\n\t\t * @returns {Array(Object), Array(Object)}\n\t\t */\n\t\tAvg_first_response_time(from, to, departmentId) {\n\t\t\tconst agentAvgRespTime = new Map(); // stores avg response time for each agent\n\t\t\tconst date = {\n\t\t\t\tgte: from,\n\t\t\t\tlt: to.add(1, 'days'),\n\t\t\t};\n\n\t\t\tconst data = {\n\t\t\t\thead: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Agent',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Avg_first_response_time',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tdata: [],\n\t\t\t};\n\n\t\t\tLivechatRooms.getAnalyticsMetricsBetweenDate('l', date, { departmentId }).forEach(({ metrics, servedBy }) => {\n\t\t\t\tif (servedBy && metrics && metrics.response && metrics.response.ft) {\n\t\t\t\t\tif (agentAvgRespTime.has(servedBy.username)) {\n\t\t\t\t\t\tagentAvgRespTime.set(servedBy.username, {\n\t\t\t\t\t\t\tfrt: agentAvgRespTime.get(servedBy.username).frt + metrics.response.ft,\n\t\t\t\t\t\t\ttotal: agentAvgRespTime.get(servedBy.username).total + 1,\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tagentAvgRespTime.set(servedBy.username, {\n\t\t\t\t\t\t\tfrt: metrics.response.ft,\n\t\t\t\t\t\t\ttotal: 1,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tagentAvgRespTime.forEach((obj, key) => {\n\t\t\t\t// calculate avg\n\t\t\t\tconst avg = obj.frt / obj.total;\n\n\t\t\t\tdata.data.push({\n\t\t\t\t\tname: key,\n\t\t\t\t\tvalue: avg.toFixed(2),\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tthis.sortByValue(data.data, false); // sort array\n\n\t\t\tdata.data.forEach((obj) => {\n\t\t\t\tobj.value = secondsToHHMMSS(obj.value);\n\t\t\t});\n\n\t\t\treturn data;\n\t\t},\n\n\t\t/**\n\t\t *\n\t\t * @param {Date} from\n\t\t * @param {Date} to\n\t\t *\n\t\t * @returns {Array(Object), Array(Object)}\n\t\t */\n\t\tBest_first_response_time(from, to, departmentId) {\n\t\t\tconst agentFirstRespTime = new Map(); // stores avg response time for each agent\n\t\t\tconst date = {\n\t\t\t\tgte: from,\n\t\t\t\tlt: to.add(1, 'days'),\n\t\t\t};\n\n\t\t\tconst data = {\n\t\t\t\thead: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Agent',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Best_first_response_time',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tdata: [],\n\t\t\t};\n\n\t\t\tLivechatRooms.getAnalyticsMetricsBetweenDate('l', date, { departmentId }).forEach(({ metrics, servedBy }) => {\n\t\t\t\tif (servedBy && metrics && metrics.response && metrics.response.ft) {\n\t\t\t\t\tif (agentFirstRespTime.has(servedBy.username)) {\n\t\t\t\t\t\tagentFirstRespTime.set(servedBy.username, Math.min(agentFirstRespTime.get(servedBy.username), metrics.response.ft));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tagentFirstRespTime.set(servedBy.username, metrics.response.ft);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tagentFirstRespTime.forEach((value, key) => {\n\t\t\t\t// calculate avg\n\t\t\t\tdata.data.push({\n\t\t\t\t\tname: key,\n\t\t\t\t\tvalue: value.toFixed(2),\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tthis.sortByValue(data.data, false); // sort array\n\n\t\t\tdata.data.forEach((obj) => {\n\t\t\t\tobj.value = secondsToHHMMSS(obj.value);\n\t\t\t});\n\n\t\t\treturn data;\n\t\t},\n\n\t\t/**\n\t\t *\n\t\t * @param {Date} from\n\t\t * @param {Date} to\n\t\t *\n\t\t * @returns {Array(Object), Array(Object)}\n\t\t */\n\t\tAvg_response_time(from, to, departmentId) {\n\t\t\tconst agentAvgRespTime = new Map(); // stores avg response time for each agent\n\t\t\tconst date = {\n\t\t\t\tgte: from,\n\t\t\t\tlt: to.add(1, 'days'),\n\t\t\t};\n\n\t\t\tconst data = {\n\t\t\t\thead: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Agent',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Avg_response_time',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tdata: [],\n\t\t\t};\n\n\t\t\tLivechatRooms.getAnalyticsMetricsBetweenDate('l', date, { departmentId }).forEach(({ metrics, servedBy }) => {\n\t\t\t\tif (servedBy && metrics && metrics.response && metrics.response.avg) {\n\t\t\t\t\tif (agentAvgRespTime.has(servedBy.username)) {\n\t\t\t\t\t\tagentAvgRespTime.set(servedBy.username, {\n\t\t\t\t\t\t\tavg: agentAvgRespTime.get(servedBy.username).avg + metrics.response.avg,\n\t\t\t\t\t\t\ttotal: agentAvgRespTime.get(servedBy.username).total + 1,\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tagentAvgRespTime.set(servedBy.username, {\n\t\t\t\t\t\t\tavg: metrics.response.avg,\n\t\t\t\t\t\t\ttotal: 1,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tagentAvgRespTime.forEach((obj, key) => {\n\t\t\t\t// calculate avg\n\t\t\t\tconst avg = obj.avg / obj.total;\n\n\t\t\t\tdata.data.push({\n\t\t\t\t\tname: key,\n\t\t\t\t\tvalue: avg.toFixed(2),\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tthis.sortByValue(data.data, false); // sort array\n\n\t\t\tdata.data.forEach((obj) => {\n\t\t\t\tobj.value = secondsToHHMMSS(obj.value);\n\t\t\t});\n\n\t\t\treturn data;\n\t\t},\n\n\t\t/**\n\t\t *\n\t\t * @param {Date} from\n\t\t * @param {Date} to\n\t\t *\n\t\t * @returns {Array(Object), Array(Object)}\n\t\t */\n\t\tAvg_reaction_time(from, to, departmentId) {\n\t\t\tconst agentAvgReactionTime = new Map(); // stores avg reaction time for each agent\n\t\t\tconst date = {\n\t\t\t\tgte: from,\n\t\t\t\tlt: to.add(1, 'days'),\n\t\t\t};\n\n\t\t\tconst data = {\n\t\t\t\thead: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Agent',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Avg_reaction_time',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tdata: [],\n\t\t\t};\n\n\t\t\tLivechatRooms.getAnalyticsMetricsBetweenDate('l', date, { departmentId }).forEach(({ metrics, servedBy }) => {\n\t\t\t\tif (servedBy && metrics && metrics.reaction && metrics.reaction.ft) {\n\t\t\t\t\tif (agentAvgReactionTime.has(servedBy.username)) {\n\t\t\t\t\t\tagentAvgReactionTime.set(servedBy.username, {\n\t\t\t\t\t\t\tfrt: agentAvgReactionTime.get(servedBy.username).frt + metrics.reaction.ft,\n\t\t\t\t\t\t\ttotal: agentAvgReactionTime.get(servedBy.username).total + 1,\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tagentAvgReactionTime.set(servedBy.username, {\n\t\t\t\t\t\t\tfrt: metrics.reaction.ft,\n\t\t\t\t\t\t\ttotal: 1,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tagentAvgReactionTime.forEach((obj, key) => {\n\t\t\t\t// calculate avg\n\t\t\t\tconst avg = obj.frt / obj.total;\n\n\t\t\t\tdata.data.push({\n\t\t\t\t\tname: key,\n\t\t\t\t\tvalue: avg.toFixed(2),\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tthis.sortByValue(data.data, false); // sort array\n\n\t\t\tdata.data.forEach((obj) => {\n\t\t\t\tobj.value = secondsToHHMMSS(obj.value);\n\t\t\t});\n\n\t\t\treturn data;\n\t\t},\n\t},\n};\n"]},"sourceType":"module","hash":"1687e126db41968850c4171bb92d059a8acb4e8e"}
