{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/weslley/Documents/projects/Rocket.Chat/app/integrations/server/lib/triggerHandler.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"app/integrations/server/lib/triggerHandler.js","filename":"/home/weslley/Documents/projects/Rocket.Chat/app/integrations/server/lib/triggerHandler.js","targets":{"android":"95.0.0","chrome":"95.0.0","edge":"95.0.0","firefox":"78.0.0","ie":"10.0.0","ios":"15.0.0","opera":"81.0.0","safari":"15.1.0","samsung":"14.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/home/weslley/Documents/projects/Rocket.Chat","root":"/home/weslley/Documents/projects/Rocket.Chat","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.16.5","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/home/weslley/Documents/projects/Rocket.Chat/app/integrations/server/lib/triggerHandler.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"app/integrations/server/lib/triggerHandler.js"}},"code":"let _objectSpread;\n\nmodule.link(\"@babel/runtime/helpers/objectSpread2\", {\n  default(v) {\n    _objectSpread = v;\n  }\n\n}, 0);\nmodule.export({\n  RocketChatIntegrationHandler: () => RocketChatIntegrationHandler,\n  integrations: () => integrations,\n  triggerHandler: () => triggerHandler\n});\nlet vm;\nmodule.link(\"vm\", {\n  default(v) {\n    vm = v;\n  }\n\n}, 0);\nlet Meteor;\nmodule.link(\"meteor/meteor\", {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 1);\nlet Random;\nmodule.link(\"meteor/random\", {\n  Random(v) {\n    Random = v;\n  }\n\n}, 2);\nlet fetch;\nmodule.link(\"meteor/fetch\", {\n  fetch(v) {\n    fetch = v;\n  }\n\n}, 3);\nlet HTTP;\nmodule.link(\"meteor/http\", {\n  HTTP(v) {\n    HTTP = v;\n  }\n\n}, 4);\n\nlet _;\n\nmodule.link(\"underscore\", {\n  default(v) {\n    _ = v;\n  }\n\n}, 5);\nlet s;\nmodule.link(\"underscore.string\", {\n  default(v) {\n    s = v;\n  }\n\n}, 6);\nlet moment;\nmodule.link(\"moment\", {\n  default(v) {\n    moment = v;\n  }\n\n}, 7);\nlet Fiber;\nmodule.link(\"fibers\", {\n  default(v) {\n    Fiber = v;\n  }\n\n}, 8);\nlet Future;\nmodule.link(\"fibers/future\", {\n  default(v) {\n    Future = v;\n  }\n\n}, 9);\nlet Models;\nmodule.link(\"../../../models/server\", {\n  \"*\"(v) {\n    Models = v;\n  }\n\n}, 10);\nlet Integrations, IntegrationHistory;\nmodule.link(\"../../../models/server/raw\", {\n  Integrations(v) {\n    Integrations = v;\n  },\n\n  IntegrationHistory(v) {\n    IntegrationHistory = v;\n  }\n\n}, 11);\nlet settings;\nmodule.link(\"../../../settings/server\", {\n  settings(v) {\n    settings = v;\n  }\n\n}, 12);\nlet getRoomByNameOrIdWithOptionToJoin, processWebhookMessage;\nmodule.link(\"../../../lib/server\", {\n  getRoomByNameOrIdWithOptionToJoin(v) {\n    getRoomByNameOrIdWithOptionToJoin = v;\n  },\n\n  processWebhookMessage(v) {\n    processWebhookMessage = v;\n  }\n\n}, 13);\nlet outgoingLogger;\nmodule.link(\"../logger\", {\n  outgoingLogger(v) {\n    outgoingLogger = v;\n  }\n\n}, 14);\nlet integrations;\nmodule.link(\"../../lib/rocketchat\", {\n  integrations(v) {\n    integrations = v;\n  }\n\n}, 15);\nlet getUnsafeAgent;\nmodule.link(\"../../../../server/lib/getUnsafeAgent\", {\n  getUnsafeAgent(v) {\n    getUnsafeAgent = v;\n  }\n\n}, 16);\n\nclass RocketChatIntegrationHandler {\n  constructor() {\n    this.vm = vm;\n    this.successResults = [200, 201, 202];\n    this.compiledScripts = {};\n    this.triggers = {};\n    Promise.await(Integrations.find({\n      type: 'webhook-outgoing'\n    }).forEach(data => this.addIntegration(data)));\n  }\n\n  addIntegration(record) {\n    outgoingLogger.debug(\"Adding the integration \".concat(record.name, \" of the event \").concat(record.event, \"!\"));\n    let channels;\n\n    if (record.event && !integrations.outgoingEvents[record.event].use.channel) {\n      outgoingLogger.debug('The integration doesnt rely on channels.'); // We don't use any channels, so it's special ;)\n\n      channels = ['__any'];\n    } else if (_.isEmpty(record.channel)) {\n      outgoingLogger.debug('The integration had an empty channel property, so it is going on all the public channels.');\n      channels = ['all_public_channels'];\n    } else {\n      outgoingLogger.debug('The integration is going on these channels:', record.channel);\n      channels = [].concat(record.channel);\n    }\n\n    for (const channel of channels) {\n      if (!this.triggers[channel]) {\n        this.triggers[channel] = {};\n      }\n\n      this.triggers[channel][record._id] = record;\n    }\n  }\n\n  removeIntegration(record) {\n    for (const trigger of Object.values(this.triggers)) {\n      delete trigger[record._id];\n    }\n  }\n\n  isTriggerEnabled(trigger) {\n    for (const trig of Object.values(this.triggers)) {\n      if (trig[trigger._id]) {\n        return trig[trigger._id].enabled;\n      }\n    }\n\n    return false;\n  }\n\n  updateHistory(_ref) {\n    let {\n      historyId,\n      step,\n      integration,\n      event,\n      data,\n      triggerWord,\n      ranPrepareScript,\n      prepareSentMessage,\n      processSentMessage,\n      resultMessage,\n      finished,\n      url,\n      httpCallData,\n      httpError,\n      httpResult,\n      error,\n      errorStack\n    } = _ref;\n    const history = {\n      type: 'outgoing-webhook',\n      step\n    }; // Usually is only added on initial insert\n\n    if (integration) {\n      history.integration = integration;\n    } // Usually is only added on initial insert\n\n\n    if (event) {\n      history.event = event;\n    }\n\n    if (data) {\n      history.data = _objectSpread({}, data);\n\n      if (data.user) {\n        history.data.user = _.omit(data.user, ['services']);\n      }\n\n      if (data.room) {\n        history.data.room = data.room;\n      }\n    }\n\n    if (triggerWord) {\n      history.triggerWord = triggerWord;\n    }\n\n    if (typeof ranPrepareScript !== 'undefined') {\n      history.ranPrepareScript = ranPrepareScript;\n    }\n\n    if (prepareSentMessage) {\n      history.prepareSentMessage = prepareSentMessage;\n    }\n\n    if (processSentMessage) {\n      history.processSentMessage = processSentMessage;\n    }\n\n    if (resultMessage) {\n      history.resultMessage = resultMessage;\n    }\n\n    if (typeof finished !== 'undefined') {\n      history.finished = finished;\n    }\n\n    if (url) {\n      history.url = url;\n    }\n\n    if (typeof httpCallData !== 'undefined') {\n      history.httpCallData = httpCallData;\n    }\n\n    if (httpError) {\n      history.httpError = httpError;\n    }\n\n    if (typeof httpResult !== 'undefined') {\n      history.httpResult = JSON.stringify(httpResult, null, 2);\n    }\n\n    if (typeof error !== 'undefined') {\n      history.error = error;\n    }\n\n    if (typeof errorStack !== 'undefined') {\n      history.errorStack = errorStack;\n    }\n\n    if (historyId) {\n      Promise.await(IntegrationHistory.updateOne({\n        _id: historyId\n      }, {\n        $set: history\n      }));\n      return historyId;\n    }\n\n    history._createdAt = new Date();\n\n    const _id = Random.id();\n\n    Promise.await(IntegrationHistory.insertOne(_objectSpread({\n      _id\n    }, history)));\n    return _id;\n  } // Trigger is the trigger, nameOrId is a string which is used to try and find a room, room is a room, message is a message, and data contains \"user_name\" if trigger.impersonateUser is truthful.\n\n\n  sendMessage(_ref2) {\n    let {\n      trigger,\n      nameOrId = '',\n      room,\n      message,\n      data\n    } = _ref2;\n    let user; // Try to find the user who we are impersonating\n\n    if (trigger.impersonateUser) {\n      user = Models.Users.findOneByUsernameIgnoringCase(data.user_name);\n    } // If they don't exist (aka the trigger didn't contain a user) then we set the user based upon the\n    // configured username for the integration since this is required at all times.\n\n\n    if (!user) {\n      user = Models.Users.findOneByUsernameIgnoringCase(trigger.username);\n    }\n\n    let tmpRoom;\n\n    if (nameOrId || trigger.targetRoom || message.channel) {\n      tmpRoom = getRoomByNameOrIdWithOptionToJoin({\n        currentUserId: user._id,\n        nameOrId: nameOrId || message.channel || trigger.targetRoom,\n        errorOnEmpty: false\n      }) || room;\n    } else {\n      tmpRoom = room;\n    } // If no room could be found, we won't be sending any messages but we'll warn in the logs\n\n\n    if (!tmpRoom) {\n      outgoingLogger.warn(\"The Integration \\\"\".concat(trigger.name, \"\\\" doesn't have a room configured nor did it provide a room to send the message to.\"));\n      return;\n    }\n\n    outgoingLogger.debug(\"Found a room for \".concat(trigger.name, \" which is: \").concat(tmpRoom.name, \" with a type of \").concat(tmpRoom.t));\n    message.bot = {\n      i: trigger._id\n    };\n    const defaultValues = {\n      alias: trigger.alias,\n      avatar: trigger.avatar,\n      emoji: trigger.emoji\n    };\n\n    if (tmpRoom.t === 'd') {\n      message.channel = \"@\".concat(tmpRoom._id);\n    } else {\n      message.channel = \"#\".concat(tmpRoom._id);\n    }\n\n    message = processWebhookMessage(message, user, defaultValues);\n    return message;\n  }\n\n  buildSandbox() {\n    let store = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const sandbox = {\n      scriptTimeout(reject) {\n        return setTimeout(() => reject('timed out'), 3000);\n      },\n\n      _,\n      s,\n      console,\n      moment,\n      Fiber,\n      Promise,\n      Store: {\n        set: (key, val) => {\n          store[key] = val;\n        },\n        get: key => store[key]\n      },\n      HTTP: (method, url, options) => {\n        try {\n          return {\n            result: HTTP.call(method, url, options)\n          };\n        } catch (error) {\n          return {\n            error\n          };\n        }\n      }\n    };\n    Object.keys(Models).filter(k => !k.startsWith('_')).forEach(k => {\n      sandbox[k] = Models[k];\n    });\n    return {\n      store,\n      sandbox\n    };\n  }\n\n  getIntegrationScript(integration) {\n    const compiledScript = this.compiledScripts[integration._id];\n\n    if (compiledScript && +compiledScript._updatedAt === +integration._updatedAt) {\n      return compiledScript.script;\n    }\n\n    const script = integration.scriptCompiled;\n    const {\n      store,\n      sandbox\n    } = this.buildSandbox();\n    let vmScript;\n\n    try {\n      outgoingLogger.info({\n        msg: 'Will evaluate script of Trigger',\n        name: integration.name\n      });\n      outgoingLogger.debug(script);\n      vmScript = this.vm.createScript(script, 'script.js');\n      vmScript.runInNewContext(sandbox);\n\n      if (sandbox.Script) {\n        this.compiledScripts[integration._id] = {\n          script: new sandbox.Script(),\n          store,\n          _updatedAt: integration._updatedAt\n        };\n        return this.compiledScripts[integration._id].script;\n      }\n    } catch (err) {\n      outgoingLogger.error({\n        msg: 'Error evaluating Script in Trigger',\n        name: integration.name,\n        script,\n        err\n      });\n      throw new Meteor.Error('error-evaluating-script');\n    }\n\n    if (!sandbox.Script) {\n      outgoingLogger.error(\"Class \\\"Script\\\" not in Trigger \".concat(integration.name, \":\"));\n      throw new Meteor.Error('class-script-not-found');\n    }\n  }\n\n  hasScriptAndMethod(integration, method) {\n    if (integration.scriptEnabled !== true || !integration.scriptCompiled || integration.scriptCompiled.trim() === '') {\n      return false;\n    }\n\n    let script;\n\n    try {\n      script = this.getIntegrationScript(integration);\n    } catch (e) {\n      return false;\n    }\n\n    return typeof script[method] !== 'undefined';\n  }\n\n  executeScript(integration, method, params, historyId) {\n    let script;\n\n    try {\n      script = this.getIntegrationScript(integration);\n    } catch (e) {\n      this.updateHistory({\n        historyId,\n        step: 'execute-script-getting-script',\n        error: true,\n        errorStack: e\n      });\n      return;\n    }\n\n    if (!script[method]) {\n      outgoingLogger.error(\"Method \\\"\".concat(method, \"\\\" no found in the Integration \\\"\").concat(integration.name, \"\\\"\"));\n      this.updateHistory({\n        historyId,\n        step: \"execute-script-no-method-\".concat(method)\n      });\n      return;\n    }\n\n    try {\n      const {\n        sandbox\n      } = this.buildSandbox(this.compiledScripts[integration._id].store);\n      sandbox.script = script;\n      sandbox.method = method;\n      sandbox.params = params;\n      this.updateHistory({\n        historyId,\n        step: \"execute-script-before-running-\".concat(method)\n      });\n      const result = Future.fromPromise(this.vm.runInNewContext(\"\\n\\t\\t\\t\\tnew Promise((resolve, reject) => {\\n\\t\\t\\t\\t\\tFiber(() => {\\n\\t\\t\\t\\t\\t\\tscriptTimeout(reject);\\n\\t\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\t\\tresolve(script[method](params))\\n\\t\\t\\t\\t\\t\\t} catch(e) {\\n\\t\\t\\t\\t\\t\\t\\treject(e);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}).run();\\n\\t\\t\\t\\t}).catch((error) => { throw new Error(error); });\\n\\t\\t\\t\", sandbox, {\n        timeout: 3000\n      })).wait();\n      outgoingLogger.debug({\n        msg: \"Script method \\\"\".concat(method, \"\\\" result of the Integration \\\"\").concat(integration.name, \"\\\" is:\"),\n        result\n      });\n      return result;\n    } catch (err) {\n      this.updateHistory({\n        historyId,\n        step: \"execute-script-error-running-\".concat(method),\n        error: true,\n        errorStack: err.stack.replace(/^/gm, '  ')\n      });\n      outgoingLogger.error({\n        msg: 'Error running Script in the Integration',\n        name: integration.name,\n        err\n      });\n      outgoingLogger.debug({\n        msg: 'Error running Script in the Integration',\n        name: integration.name,\n        script: integration.scriptCompiled\n      }); // Only output the compiled script if debugging is enabled, so the logs don't get spammed.\n    }\n  }\n\n  eventNameArgumentsToObject() {\n    const argObject = {\n      event: arguments.length <= 0 ? undefined : arguments[0]\n    };\n\n    switch (argObject.event) {\n      case 'sendMessage':\n        if (arguments.length >= 3) {\n          argObject.message = arguments.length <= 1 ? undefined : arguments[1];\n          argObject.room = arguments.length <= 2 ? undefined : arguments[2];\n        }\n\n        break;\n\n      case 'fileUploaded':\n        if (arguments.length >= 2) {\n          const arghhh = arguments.length <= 1 ? undefined : arguments[1];\n          argObject.user = arghhh.user;\n          argObject.room = arghhh.room;\n          argObject.message = arghhh.message;\n        }\n\n        break;\n\n      case 'roomArchived':\n        if (arguments.length >= 3) {\n          argObject.room = arguments.length <= 1 ? undefined : arguments[1];\n          argObject.user = arguments.length <= 2 ? undefined : arguments[2];\n        }\n\n        break;\n\n      case 'roomCreated':\n        if (arguments.length >= 3) {\n          argObject.owner = arguments.length <= 1 ? undefined : arguments[1];\n          argObject.room = arguments.length <= 2 ? undefined : arguments[2];\n        }\n\n        break;\n\n      case 'roomJoined':\n      case 'roomLeft':\n        if (arguments.length >= 3) {\n          argObject.user = arguments.length <= 1 ? undefined : arguments[1];\n          argObject.room = arguments.length <= 2 ? undefined : arguments[2];\n        }\n\n        break;\n\n      case 'userCreated':\n        if (arguments.length >= 2) {\n          argObject.user = arguments.length <= 1 ? undefined : arguments[1];\n        }\n\n        break;\n\n      default:\n        outgoingLogger.warn(\"An Unhandled Trigger Event was called: \".concat(argObject.event));\n        argObject.event = undefined;\n        break;\n    }\n\n    outgoingLogger.debug({\n      msg: \"Got the event arguments for the event: \".concat(argObject.event),\n      argObject\n    });\n    return argObject;\n  }\n\n  mapEventArgsToData(data, _ref3) {\n    let {\n      event,\n      message,\n      room,\n      owner,\n      user\n    } = _ref3;\n\n    switch (event) {\n      case 'sendMessage':\n        data.channel_id = room._id;\n        data.channel_name = room.name;\n        data.message_id = message._id;\n        data.timestamp = message.ts;\n        data.user_id = message.u._id;\n        data.user_name = message.u.username;\n        data.text = message.msg;\n        data.siteUrl = settings.get('Site_Url');\n\n        if (message.alias) {\n          data.alias = message.alias;\n        }\n\n        if (message.bot) {\n          data.bot = message.bot;\n        }\n\n        if (message.editedAt) {\n          data.isEdited = true;\n        }\n\n        if (message.tmid) {\n          data.tmid = message.tmid;\n        }\n\n        break;\n\n      case 'fileUploaded':\n        data.channel_id = room._id;\n        data.channel_name = room.name;\n        data.message_id = message._id;\n        data.timestamp = message.ts;\n        data.user_id = message.u._id;\n        data.user_name = message.u.username;\n        data.text = message.msg;\n        data.user = user;\n        data.room = room;\n        data.message = message;\n\n        if (message.alias) {\n          data.alias = message.alias;\n        }\n\n        if (message.bot) {\n          data.bot = message.bot;\n        }\n\n        break;\n\n      case 'roomCreated':\n        data.channel_id = room._id;\n        data.channel_name = room.name;\n        data.timestamp = room.ts;\n        data.user_id = owner._id;\n        data.user_name = owner.username;\n        data.owner = owner;\n        data.room = room;\n        break;\n\n      case 'roomArchived':\n      case 'roomJoined':\n      case 'roomLeft':\n        data.timestamp = new Date();\n        data.channel_id = room._id;\n        data.channel_name = room.name;\n        data.user_id = user._id;\n        data.user_name = user.username;\n        data.user = user;\n        data.room = room;\n\n        if (user.type === 'bot') {\n          data.bot = true;\n        }\n\n        break;\n\n      case 'userCreated':\n        data.timestamp = user.createdAt;\n        data.user_id = user._id;\n        data.user_name = user.username;\n        data.user = user;\n\n        if (user.type === 'bot') {\n          data.bot = true;\n        }\n\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  getTriggersToExecute(room, message) {\n    const triggersToExecute = new Set();\n\n    if (room) {\n      switch (room.t) {\n        case 'd':\n          if (this.triggers.all_direct_messages) {\n            for (const trigger of Object.values(this.triggers.all_direct_messages)) {\n              triggersToExecute.add(trigger);\n            }\n          }\n\n          room.uids.filter(uid => this.triggers[\"@\".concat(uid)]).forEach(uid => {\n            for (const trigger of Object.values(this.triggers[\"@\".concat(uid)])) {\n              triggersToExecute.add(trigger);\n            }\n          });\n          room.usernames.filter(username => username !== message.u.username && this.triggers[\"@\".concat(username)]).forEach(username => {\n            for (const trigger of Object.values(this.triggers[\"@\".concat(username)])) {\n              triggersToExecute.add(trigger);\n            }\n          });\n          break;\n\n        case 'c':\n          if (this.triggers.all_public_channels) {\n            for (const trigger of Object.values(this.triggers.all_public_channels)) {\n              triggersToExecute.add(trigger);\n            }\n          }\n\n          if (this.triggers[\"#\".concat(room._id)]) {\n            for (const trigger of Object.values(this.triggers[\"#\".concat(room._id)])) {\n              triggersToExecute.add(trigger);\n            }\n          }\n\n          if (room._id !== room.name && this.triggers[\"#\".concat(room.name)]) {\n            for (const trigger of Object.values(this.triggers[\"#\".concat(room.name)])) {\n              triggersToExecute.add(trigger);\n            }\n          }\n\n          break;\n\n        default:\n          if (this.triggers.all_private_groups) {\n            for (const trigger of Object.values(this.triggers.all_private_groups)) {\n              triggersToExecute.add(trigger);\n            }\n          }\n\n          if (this.triggers[\"#\".concat(room._id)]) {\n            for (const trigger of Object.values(this.triggers[\"#\".concat(room._id)])) {\n              triggersToExecute.add(trigger);\n            }\n          }\n\n          if (room._id !== room.name && this.triggers[\"#\".concat(room.name)]) {\n            for (const trigger of Object.values(this.triggers[\"#\".concat(room.name)])) {\n              triggersToExecute.add(trigger);\n            }\n          }\n\n          break;\n      }\n    }\n\n    return [...triggersToExecute];\n  }\n\n  executeTriggers() {\n    outgoingLogger.debug({\n      msg: 'Execute Trigger:',\n      arg: arguments.length <= 0 ? undefined : arguments[0]\n    });\n    const argObject = this.eventNameArgumentsToObject(...arguments);\n    const {\n      event,\n      message,\n      room\n    } = argObject; // Each type of event should have an event and a room attached, otherwise we\n    // wouldn't know how to handle the trigger nor would we have anywhere to send the\n    // result of the integration\n\n    if (!event) {\n      return;\n    }\n\n    outgoingLogger.debug(\"Starting search for triggers for the room: \".concat(room ? room._id : '__any'));\n    const triggersToExecute = this.getTriggersToExecute(room, message);\n\n    if (this.triggers.__any) {\n      // For outgoing integration which don't rely on rooms.\n      for (const trigger of Object.values(this.triggers.__any)) {\n        triggersToExecute.push(trigger);\n      }\n    }\n\n    outgoingLogger.debug(\"Found \".concat(triggersToExecute.length, \" to iterate over and see if the match the event.\"));\n\n    for (const triggerToExecute of triggersToExecute) {\n      outgoingLogger.debug(\"Is \\\"\".concat(triggerToExecute.name, \"\\\" enabled, \").concat(triggerToExecute.enabled, \", and what is the event? \").concat(triggerToExecute.event));\n\n      if (triggerToExecute.enabled === true && triggerToExecute.event === event) {\n        this.executeTrigger(triggerToExecute, argObject);\n      }\n    }\n  }\n\n  executeTrigger(trigger, argObject) {\n    for (const url of trigger.urls) {\n      this.executeTriggerUrl(url, trigger, argObject, 0);\n    }\n  }\n\n  executeTriggerUrl(url, trigger, _ref4, theHistoryId) {\n    let {\n      event,\n      message,\n      room,\n      owner,\n      user\n    } = _ref4;\n    let tries = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n\n    if (!this.isTriggerEnabled(trigger)) {\n      outgoingLogger.warn(\"The trigger \\\"\".concat(trigger.name, \"\\\" is no longer enabled, stopping execution of it at try: \").concat(tries));\n      return;\n    }\n\n    outgoingLogger.debug(\"Starting to execute trigger: \".concat(trigger.name, \" (\").concat(trigger._id, \")\"));\n    let word; // Not all triggers/events support triggerWords\n\n    if (integrations.outgoingEvents[event].use.triggerWords) {\n      if (trigger.triggerWords && trigger.triggerWords.length > 0) {\n        for (const triggerWord of trigger.triggerWords) {\n          if (!trigger.triggerWordAnywhere && message.msg.indexOf(triggerWord) === 0) {\n            word = triggerWord;\n            break;\n          } else if (trigger.triggerWordAnywhere && message.msg.includes(triggerWord)) {\n            word = triggerWord;\n            break;\n          }\n        } // Stop if there are triggerWords but none match\n\n\n        if (!word) {\n          outgoingLogger.debug(\"The trigger word which \\\"\".concat(trigger.name, \"\\\" was expecting could not be found, not executing.\"));\n          return;\n        }\n      }\n    }\n\n    if (message && message.editedAt && !trigger.runOnEdits) {\n      outgoingLogger.debug(\"The trigger \\\"\".concat(trigger.name, \"\\\"'s run on edits is disabled and the message was edited.\"));\n      return;\n    }\n\n    const historyId = this.updateHistory({\n      step: 'start-execute-trigger-url',\n      integration: trigger,\n      event\n    });\n    const data = {\n      token: trigger.token,\n      bot: false\n    };\n\n    if (word) {\n      data.trigger_word = word;\n    }\n\n    this.mapEventArgsToData(data, {\n      trigger,\n      event,\n      message,\n      room,\n      owner,\n      user\n    });\n    this.updateHistory({\n      historyId,\n      step: 'mapped-args-to-data',\n      data,\n      triggerWord: word\n    });\n    outgoingLogger.info(\"Will be executing the Integration \\\"\".concat(trigger.name, \"\\\" to the url: \").concat(url));\n    outgoingLogger.debug(data);\n    let opts = {\n      params: {},\n      method: 'POST',\n      url,\n      data,\n      auth: undefined,\n      headers: {\n        'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2227.0 Safari/537.36'\n      }\n    };\n\n    if (this.hasScriptAndMethod(trigger, 'prepare_outgoing_request')) {\n      opts = this.executeScript(trigger, 'prepare_outgoing_request', {\n        request: opts\n      }, historyId);\n    }\n\n    this.updateHistory({\n      historyId,\n      step: 'after-maybe-ran-prepare',\n      ranPrepareScript: true\n    });\n\n    if (!opts) {\n      this.updateHistory({\n        historyId,\n        step: 'after-prepare-no-opts',\n        finished: true\n      });\n      return;\n    }\n\n    if (opts.message) {\n      const prepareMessage = this.sendMessage({\n        trigger,\n        room,\n        message: opts.message,\n        data\n      });\n      this.updateHistory({\n        historyId,\n        step: 'after-prepare-send-message',\n        prepareSentMessage: prepareMessage\n      });\n    }\n\n    if (!opts.url || !opts.method) {\n      this.updateHistory({\n        historyId,\n        step: 'after-prepare-no-url_or_method',\n        finished: true\n      });\n      return;\n    } // based on HTTP.call implementation\n\n\n    if (opts.auth) {\n      if (opts.auth.indexOf(':') < 0) {\n        throw new Error('auth option should be of the form \"username:password\"');\n      }\n\n      const base64 = Buffer.from(opts.auth, 'ascii').toString('base64');\n      opts.headers.Authorization = \"Basic \".concat(base64);\n    }\n\n    this.updateHistory({\n      historyId,\n      step: 'pre-http-call',\n      url: opts.url,\n      httpCallData: opts.data\n    });\n\n    if (opts.data) {\n      opts.headers['Content-Type'] = 'application/json';\n    }\n\n    fetch(opts.url, _objectSpread(_objectSpread({\n      method: opts.method,\n      headers: opts.headers\n    }, settings.get('Allow_Invalid_SelfSigned_Certs') && {\n      agent: getUnsafeAgent(opts.url.startsWith('https:') ? 'https:' : 'http:')\n    }), opts.data && {\n      body: JSON.stringify(opts.data)\n    })).then(res => Promise.asyncApply(() => {\n      const content = Promise.await(res.text());\n\n      if (!content) {\n        outgoingLogger.warn(\"Result for the Integration \".concat(trigger.name, \" to \").concat(url, \" is empty\"));\n      } else {\n        outgoingLogger.info(\"Status code for the Integration \".concat(trigger.name, \" to \").concat(url, \" is \").concat(res.status));\n      }\n\n      const data = (() => {\n        const contentType = (res.headers.get('content-type') || '').split(';')[0];\n\n        if (!['application/json', 'text/javascript', 'application/javascript', 'application/x-javascript'].includes(contentType)) {\n          return null;\n        }\n\n        try {\n          return JSON.parse(content);\n        } catch (_error) {\n          return null;\n        }\n      })();\n\n      this.updateHistory({\n        historyId,\n        step: 'after-http-call',\n        httpError: null,\n        httpResult: content\n      });\n\n      if (this.hasScriptAndMethod(trigger, 'process_outgoing_response')) {\n        const sandbox = {\n          request: opts,\n          response: {\n            error: null,\n            status_code: res.status,\n            // These values will be undefined to close issues #4175, #5762, and #5896\n            content,\n            content_raw: content,\n            headers: Object.fromEntries(res.headers)\n          }\n        };\n        const scriptResult = this.executeScript(trigger, 'process_outgoing_response', sandbox, historyId);\n\n        if (scriptResult && scriptResult.content) {\n          const resultMessage = this.sendMessage({\n            trigger,\n            room,\n            message: scriptResult.content,\n            data\n          });\n          this.updateHistory({\n            historyId,\n            step: 'after-process-send-message',\n            processSentMessage: resultMessage,\n            finished: true\n          });\n          return;\n        }\n\n        if (scriptResult === false) {\n          this.updateHistory({\n            historyId,\n            step: 'after-process-false-result',\n            finished: true\n          });\n          return;\n        }\n      } // if the result contained nothing or wasn't a successful statusCode\n\n\n      if (!content || !this.successResults.includes(res.status)) {\n        if (content) {\n          outgoingLogger.error({\n            msg: \"Error for the Integration \\\"\".concat(trigger.name, \"\\\" to \").concat(url),\n            result: content\n          });\n\n          if (res.status === 410) {\n            this.updateHistory({\n              historyId,\n              step: 'after-process-http-status-410',\n              error: true\n            });\n            outgoingLogger.error(\"Disabling the Integration \\\"\".concat(trigger.name, \"\\\" because the status code was 401 (Gone).\"));\n            Promise.await(Integrations.updateOne({\n              _id: trigger._id\n            }, {\n              $set: {\n                enabled: false\n              }\n            }));\n            return;\n          }\n\n          if (res.status === 500) {\n            this.updateHistory({\n              historyId,\n              step: 'after-process-http-status-500',\n              error: true\n            });\n            outgoingLogger.error({\n              msg: \"Error \\\"500\\\" for the Integration \\\"\".concat(trigger.name, \"\\\" to \").concat(url, \".\"),\n              content\n            });\n            return;\n          }\n        }\n\n        if (trigger.retryFailedCalls) {\n          if (tries < trigger.retryCount && trigger.retryDelay) {\n            this.updateHistory({\n              historyId,\n              error: true,\n              step: \"going-to-retry-\".concat(tries + 1)\n            });\n            let waitTime;\n\n            switch (trigger.retryDelay) {\n              case 'powers-of-ten':\n                // Try again in 0.1s, 1s, 10s, 1m40s, 16m40s, 2h46m40s, 27h46m40s, etc\n                waitTime = Math.pow(10, tries + 2);\n                break;\n\n              case 'powers-of-two':\n                // 2 seconds, 4 seconds, 8 seconds\n                waitTime = Math.pow(2, tries + 1) * 1000;\n                break;\n\n              case 'increments-of-two':\n                // 2 second, 4 seconds, 6 seconds, etc\n                waitTime = (tries + 1) * 2 * 1000;\n                break;\n\n              default:\n                const er = new Error(\"The integration's retryDelay setting is invalid.\");\n                this.updateHistory({\n                  historyId,\n                  step: 'failed-and-retry-delay-is-invalid',\n                  error: true,\n                  errorStack: er.stack\n                });\n                return;\n            }\n\n            outgoingLogger.info(\"Trying the Integration \".concat(trigger.name, \" to \").concat(url, \" again in \").concat(waitTime, \" milliseconds.\"));\n            Meteor.setTimeout(() => {\n              this.executeTriggerUrl(url, trigger, {\n                event,\n                message,\n                room,\n                owner,\n                user\n              }, historyId, tries + 1);\n            }, waitTime);\n          } else {\n            this.updateHistory({\n              historyId,\n              step: 'too-many-retries',\n              error: true\n            });\n          }\n        } else {\n          this.updateHistory({\n            historyId,\n            step: 'failed-and-not-configured-to-retry',\n            error: true\n          });\n        }\n\n        return;\n      } // process outgoing webhook response as a new message\n\n\n      if (content && this.successResults.includes(res.status)) {\n        if (data !== null && data !== void 0 && data.text || data !== null && data !== void 0 && data.attachments) {\n          const resultMsg = this.sendMessage({\n            trigger,\n            room,\n            message: data,\n            data\n          });\n          this.updateHistory({\n            historyId,\n            step: 'url-response-sent-message',\n            resultMessage: resultMsg,\n            finished: true\n          });\n        }\n      }\n    })).catch(error => {\n      outgoingLogger.error(error);\n      this.updateHistory({\n        historyId,\n        step: 'after-http-call',\n        httpError: error,\n        httpResult: null\n      });\n    });\n  }\n\n  replay(integration, history) {\n    if (!integration || integration.type !== 'webhook-outgoing') {\n      throw new Meteor.Error('integration-type-must-be-outgoing', 'The integration type to replay must be an outgoing webhook.');\n    }\n\n    if (!history || !history.data) {\n      throw new Meteor.Error('history-data-must-be-defined', 'The history data must be defined to replay an integration.');\n    }\n\n    const {\n      event\n    } = history;\n    const message = Models.Messages.findOneById(history.data.message_id);\n    const room = Models.Rooms.findOneById(history.data.channel_id);\n    const user = Models.Users.findOneById(history.data.user_id);\n    let owner;\n\n    if (history.data.owner && history.data.owner._id) {\n      owner = Models.Users.findOneById(history.data.owner._id);\n    }\n\n    this.executeTriggerUrl(history.url, integration, {\n      event,\n      message,\n      room,\n      owner,\n      user\n    });\n  }\n\n}\n\nconst triggerHandler = new RocketChatIntegrationHandler();","map":{"version":3,"sources":["app/integrations/server/lib/triggerHandler.js"],"names":["_objectSpread","module","link","default","v","export","RocketChatIntegrationHandler","integrations","triggerHandler","vm","Meteor","Random","fetch","HTTP","_","s","moment","Fiber","Future","Models","Integrations","IntegrationHistory","settings","getRoomByNameOrIdWithOptionToJoin","processWebhookMessage","outgoingLogger","getUnsafeAgent","constructor","successResults","compiledScripts","triggers","Promise","await","find","type","forEach","data","addIntegration","record","debug","name","event","channels","outgoingEvents","use","channel","isEmpty","concat","_id","removeIntegration","trigger","Object","values","isTriggerEnabled","trig","enabled","updateHistory","historyId","step","integration","triggerWord","ranPrepareScript","prepareSentMessage","processSentMessage","resultMessage","finished","url","httpCallData","httpError","httpResult","error","errorStack","history","user","omit","room","JSON","stringify","updateOne","$set","_createdAt","Date","id","insertOne","sendMessage","nameOrId","message","impersonateUser","Users","findOneByUsernameIgnoringCase","user_name","username","tmpRoom","targetRoom","currentUserId","errorOnEmpty","warn","t","bot","i","defaultValues","alias","avatar","emoji","buildSandbox","store","sandbox","scriptTimeout","reject","setTimeout","console","Store","set","key","val","get","method","options","result","call","keys","filter","k","startsWith","getIntegrationScript","compiledScript","_updatedAt","script","scriptCompiled","vmScript","info","msg","createScript","runInNewContext","Script","err","Error","hasScriptAndMethod","scriptEnabled","trim","e","executeScript","params","fromPromise","timeout","wait","stack","replace","eventNameArgumentsToObject","argObject","length","arghhh","owner","undefined","mapEventArgsToData","channel_id","channel_name","message_id","timestamp","ts","user_id","u","text","siteUrl","editedAt","isEdited","tmid","createdAt","getTriggersToExecute","triggersToExecute","Set","all_direct_messages","add","uids","uid","usernames","all_public_channels","all_private_groups","executeTriggers","arg","__any","push","triggerToExecute","executeTrigger","urls","executeTriggerUrl","theHistoryId","tries","word","triggerWords","triggerWordAnywhere","indexOf","includes","runOnEdits","token","trigger_word","opts","auth","headers","request","prepareMessage","base64","Buffer","from","toString","Authorization","agent","body","then","res","content","status","contentType","split","parse","_error","response","status_code","content_raw","fromEntries","scriptResult","retryFailedCalls","retryCount","retryDelay","waitTime","Math","pow","er","attachments","resultMsg","catch","replay","Messages","findOneById","Rooms"],"mappings":"AAAA,IAAIA,aAAJ;;AAAkBC,MAAM,CAACC,IAAP,CAAY,sCAAZ,EAAmD;AAACC,EAAAA,OAAO,CAACC,CAAD,EAAG;AAACJ,IAAAA,aAAa,GAACI,CAAd;AAAgB;;AAA5B,CAAnD,EAAiF,CAAjF;AAAlBH,MAAM,CAACI,MAAP,CAAc;AAACC,EAAAA,4BAA4B,EAAC,MAAIA,4BAAlC;AAA+DC,EAAAA,YAAY,EAAC,MAAIA,YAAhF;AAA6FC,EAAAA,cAAc,EAAC,MAAIA;AAAhH,CAAd;AAA+I,IAAIC,EAAJ;AAAOR,MAAM,CAACC,IAAP,CAAY,IAAZ,EAAiB;AAACC,EAAAA,OAAO,CAACC,CAAD,EAAG;AAACK,IAAAA,EAAE,GAACL,CAAH;AAAK;;AAAjB,CAAjB,EAAoC,CAApC;AAAuC,IAAIM,MAAJ;AAAWT,MAAM,CAACC,IAAP,CAAY,eAAZ,EAA4B;AAACQ,EAAAA,MAAM,CAACN,CAAD,EAAG;AAACM,IAAAA,MAAM,GAACN,CAAP;AAAS;;AAApB,CAA5B,EAAkD,CAAlD;AAAqD,IAAIO,MAAJ;AAAWV,MAAM,CAACC,IAAP,CAAY,eAAZ,EAA4B;AAACS,EAAAA,MAAM,CAACP,CAAD,EAAG;AAACO,IAAAA,MAAM,GAACP,CAAP;AAAS;;AAApB,CAA5B,EAAkD,CAAlD;AAAqD,IAAIQ,KAAJ;AAAUX,MAAM,CAACC,IAAP,CAAY,cAAZ,EAA2B;AAACU,EAAAA,KAAK,CAACR,CAAD,EAAG;AAACQ,IAAAA,KAAK,GAACR,CAAN;AAAQ;;AAAlB,CAA3B,EAA+C,CAA/C;AAAkD,IAAIS,IAAJ;AAASZ,MAAM,CAACC,IAAP,CAAY,aAAZ,EAA0B;AAACW,EAAAA,IAAI,CAACT,CAAD,EAAG;AAACS,IAAAA,IAAI,GAACT,CAAL;AAAO;;AAAhB,CAA1B,EAA4C,CAA5C;;AAA+C,IAAIU,CAAJ;;AAAMb,MAAM,CAACC,IAAP,CAAY,YAAZ,EAAyB;AAACC,EAAAA,OAAO,CAACC,CAAD,EAAG;AAACU,IAAAA,CAAC,GAACV,CAAF;AAAI;;AAAhB,CAAzB,EAA2C,CAA3C;AAA8C,IAAIW,CAAJ;AAAMd,MAAM,CAACC,IAAP,CAAY,mBAAZ,EAAgC;AAACC,EAAAA,OAAO,CAACC,CAAD,EAAG;AAACW,IAAAA,CAAC,GAACX,CAAF;AAAI;;AAAhB,CAAhC,EAAkD,CAAlD;AAAqD,IAAIY,MAAJ;AAAWf,MAAM,CAACC,IAAP,CAAY,QAAZ,EAAqB;AAACC,EAAAA,OAAO,CAACC,CAAD,EAAG;AAACY,IAAAA,MAAM,GAACZ,CAAP;AAAS;;AAArB,CAArB,EAA4C,CAA5C;AAA+C,IAAIa,KAAJ;AAAUhB,MAAM,CAACC,IAAP,CAAY,QAAZ,EAAqB;AAACC,EAAAA,OAAO,CAACC,CAAD,EAAG;AAACa,IAAAA,KAAK,GAACb,CAAN;AAAQ;;AAApB,CAArB,EAA2C,CAA3C;AAA8C,IAAIc,MAAJ;AAAWjB,MAAM,CAACC,IAAP,CAAY,eAAZ,EAA4B;AAACC,EAAAA,OAAO,CAACC,CAAD,EAAG;AAACc,IAAAA,MAAM,GAACd,CAAP;AAAS;;AAArB,CAA5B,EAAmD,CAAnD;AAAsD,IAAIe,MAAJ;AAAWlB,MAAM,CAACC,IAAP,CAAY,wBAAZ,EAAqC;AAAC,MAAIE,CAAJ,EAAM;AAACe,IAAAA,MAAM,GAACf,CAAP;AAAS;;AAAjB,CAArC,EAAwD,EAAxD;AAA4D,IAAIgB,YAAJ,EAAiBC,kBAAjB;AAAoCpB,MAAM,CAACC,IAAP,CAAY,4BAAZ,EAAyC;AAACkB,EAAAA,YAAY,CAAChB,CAAD,EAAG;AAACgB,IAAAA,YAAY,GAAChB,CAAb;AAAe,GAAhC;;AAAiCiB,EAAAA,kBAAkB,CAACjB,CAAD,EAAG;AAACiB,IAAAA,kBAAkB,GAACjB,CAAnB;AAAqB;;AAA5E,CAAzC,EAAuH,EAAvH;AAA2H,IAAIkB,QAAJ;AAAarB,MAAM,CAACC,IAAP,CAAY,0BAAZ,EAAuC;AAACoB,EAAAA,QAAQ,CAAClB,CAAD,EAAG;AAACkB,IAAAA,QAAQ,GAAClB,CAAT;AAAW;;AAAxB,CAAvC,EAAiE,EAAjE;AAAqE,IAAImB,iCAAJ,EAAsCC,qBAAtC;AAA4DvB,MAAM,CAACC,IAAP,CAAY,qBAAZ,EAAkC;AAACqB,EAAAA,iCAAiC,CAACnB,CAAD,EAAG;AAACmB,IAAAA,iCAAiC,GAACnB,CAAlC;AAAoC,GAA1E;;AAA2EoB,EAAAA,qBAAqB,CAACpB,CAAD,EAAG;AAACoB,IAAAA,qBAAqB,GAACpB,CAAtB;AAAwB;;AAA5H,CAAlC,EAAgK,EAAhK;AAAoK,IAAIqB,cAAJ;AAAmBxB,MAAM,CAACC,IAAP,CAAY,WAAZ,EAAwB;AAACuB,EAAAA,cAAc,CAACrB,CAAD,EAAG;AAACqB,IAAAA,cAAc,GAACrB,CAAf;AAAiB;;AAApC,CAAxB,EAA8D,EAA9D;AAAkE,IAAIG,YAAJ;AAAiBN,MAAM,CAACC,IAAP,CAAY,sBAAZ,EAAmC;AAACK,EAAAA,YAAY,CAACH,CAAD,EAAG;AAACG,IAAAA,YAAY,GAACH,CAAb;AAAe;;AAAhC,CAAnC,EAAqE,EAArE;AAAyE,IAAIsB,cAAJ;AAAmBzB,MAAM,CAACC,IAAP,CAAY,uCAAZ,EAAoD;AAACwB,EAAAA,cAAc,CAACtB,CAAD,EAAG;AAACsB,IAAAA,cAAc,GAACtB,CAAf;AAAiB;;AAApC,CAApD,EAA0F,EAA1F;;AAoBt6C,MAAME,4BAAN,CAAmC;AACzCqB,EAAAA,WAAW,GAAG;AACb,SAAKlB,EAAL,GAAUA,EAAV;AACA,SAAKmB,cAAL,GAAsB,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,CAAtB;AACA,SAAKC,eAAL,GAAuB,EAAvB;AACA,SAAKC,QAAL,GAAgB,EAAhB;AAEAC,IAAAA,OAAO,CAACC,KAAR,CAAcZ,YAAY,CAACa,IAAb,CAAkB;AAAEC,MAAAA,IAAI,EAAE;AAAR,KAAlB,EAAgDC,OAAhD,CAAyDC,IAAD,IAAU,KAAKC,cAAL,CAAoBD,IAApB,CAAlE,CAAd;AACA;;AAEDC,EAAAA,cAAc,CAACC,MAAD,EAAS;AACtBb,IAAAA,cAAc,CAACc,KAAf,kCAA+CD,MAAM,CAACE,IAAtD,2BAA2EF,MAAM,CAACG,KAAlF;AACA,QAAIC,QAAJ;;AACA,QAAIJ,MAAM,CAACG,KAAP,IAAgB,CAAClC,YAAY,CAACoC,cAAb,CAA4BL,MAAM,CAACG,KAAnC,EAA0CG,GAA1C,CAA8CC,OAAnE,EAA4E;AAC3EpB,MAAAA,cAAc,CAACc,KAAf,CAAqB,0CAArB,EAD2E,CAE3E;;AACAG,MAAAA,QAAQ,GAAG,CAAC,OAAD,CAAX;AACA,KAJD,MAIO,IAAI5B,CAAC,CAACgC,OAAF,CAAUR,MAAM,CAACO,OAAjB,CAAJ,EAA+B;AACrCpB,MAAAA,cAAc,CAACc,KAAf,CAAqB,2FAArB;AACAG,MAAAA,QAAQ,GAAG,CAAC,qBAAD,CAAX;AACA,KAHM,MAGA;AACNjB,MAAAA,cAAc,CAACc,KAAf,CAAqB,6CAArB,EAAoED,MAAM,CAACO,OAA3E;AACAH,MAAAA,QAAQ,GAAG,GAAGK,MAAH,CAAUT,MAAM,CAACO,OAAjB,CAAX;AACA;;AAED,SAAK,MAAMA,OAAX,IAAsBH,QAAtB,EAAgC;AAC/B,UAAI,CAAC,KAAKZ,QAAL,CAAce,OAAd,CAAL,EAA6B;AAC5B,aAAKf,QAAL,CAAce,OAAd,IAAyB,EAAzB;AACA;;AAED,WAAKf,QAAL,CAAce,OAAd,EAAuBP,MAAM,CAACU,GAA9B,IAAqCV,MAArC;AACA;AACD;;AAEDW,EAAAA,iBAAiB,CAACX,MAAD,EAAS;AACzB,SAAK,MAAMY,OAAX,IAAsBC,MAAM,CAACC,MAAP,CAAc,KAAKtB,QAAnB,CAAtB,EAAoD;AACnD,aAAOoB,OAAO,CAACZ,MAAM,CAACU,GAAR,CAAd;AACA;AACD;;AAEDK,EAAAA,gBAAgB,CAACH,OAAD,EAAU;AACzB,SAAK,MAAMI,IAAX,IAAmBH,MAAM,CAACC,MAAP,CAAc,KAAKtB,QAAnB,CAAnB,EAAiD;AAChD,UAAIwB,IAAI,CAACJ,OAAO,CAACF,GAAT,CAAR,EAAuB;AACtB,eAAOM,IAAI,CAACJ,OAAO,CAACF,GAAT,CAAJ,CAAkBO,OAAzB;AACA;AACD;;AAED,WAAO,KAAP;AACA;;AAEDC,EAAAA,aAAa,OAkBV;AAAA,QAlBW;AACbC,MAAAA,SADa;AAEbC,MAAAA,IAFa;AAGbC,MAAAA,WAHa;AAIblB,MAAAA,KAJa;AAKbL,MAAAA,IALa;AAMbwB,MAAAA,WANa;AAObC,MAAAA,gBAPa;AAQbC,MAAAA,kBARa;AASbC,MAAAA,kBATa;AAUbC,MAAAA,aAVa;AAWbC,MAAAA,QAXa;AAYbC,MAAAA,GAZa;AAabC,MAAAA,YAba;AAcbC,MAAAA,SAda;AAebC,MAAAA,UAfa;AAgBbC,MAAAA,KAhBa;AAiBbC,MAAAA;AAjBa,KAkBX;AACF,UAAMC,OAAO,GAAG;AACftC,MAAAA,IAAI,EAAE,kBADS;AAEfwB,MAAAA;AAFe,KAAhB,CADE,CAMF;;AACA,QAAIC,WAAJ,EAAiB;AAChBa,MAAAA,OAAO,CAACb,WAAR,GAAsBA,WAAtB;AACA,KATC,CAWF;;;AACA,QAAIlB,KAAJ,EAAW;AACV+B,MAAAA,OAAO,CAAC/B,KAAR,GAAgBA,KAAhB;AACA;;AAED,QAAIL,IAAJ,EAAU;AACToC,MAAAA,OAAO,CAACpC,IAAR,qBAAoBA,IAApB;;AAEA,UAAIA,IAAI,CAACqC,IAAT,EAAe;AACdD,QAAAA,OAAO,CAACpC,IAAR,CAAaqC,IAAb,GAAoB3D,CAAC,CAAC4D,IAAF,CAAOtC,IAAI,CAACqC,IAAZ,EAAkB,CAAC,UAAD,CAAlB,CAApB;AACA;;AAED,UAAIrC,IAAI,CAACuC,IAAT,EAAe;AACdH,QAAAA,OAAO,CAACpC,IAAR,CAAauC,IAAb,GAAoBvC,IAAI,CAACuC,IAAzB;AACA;AACD;;AAED,QAAIf,WAAJ,EAAiB;AAChBY,MAAAA,OAAO,CAACZ,WAAR,GAAsBA,WAAtB;AACA;;AAED,QAAI,OAAOC,gBAAP,KAA4B,WAAhC,EAA6C;AAC5CW,MAAAA,OAAO,CAACX,gBAAR,GAA2BA,gBAA3B;AACA;;AAED,QAAIC,kBAAJ,EAAwB;AACvBU,MAAAA,OAAO,CAACV,kBAAR,GAA6BA,kBAA7B;AACA;;AAED,QAAIC,kBAAJ,EAAwB;AACvBS,MAAAA,OAAO,CAACT,kBAAR,GAA6BA,kBAA7B;AACA;;AAED,QAAIC,aAAJ,EAAmB;AAClBQ,MAAAA,OAAO,CAACR,aAAR,GAAwBA,aAAxB;AACA;;AAED,QAAI,OAAOC,QAAP,KAAoB,WAAxB,EAAqC;AACpCO,MAAAA,OAAO,CAACP,QAAR,GAAmBA,QAAnB;AACA;;AAED,QAAIC,GAAJ,EAAS;AACRM,MAAAA,OAAO,CAACN,GAAR,GAAcA,GAAd;AACA;;AAED,QAAI,OAAOC,YAAP,KAAwB,WAA5B,EAAyC;AACxCK,MAAAA,OAAO,CAACL,YAAR,GAAuBA,YAAvB;AACA;;AAED,QAAIC,SAAJ,EAAe;AACdI,MAAAA,OAAO,CAACJ,SAAR,GAAoBA,SAApB;AACA;;AAED,QAAI,OAAOC,UAAP,KAAsB,WAA1B,EAAuC;AACtCG,MAAAA,OAAO,CAACH,UAAR,GAAqBO,IAAI,CAACC,SAAL,CAAeR,UAAf,EAA2B,IAA3B,EAAiC,CAAjC,CAArB;AACA;;AAED,QAAI,OAAOC,KAAP,KAAiB,WAArB,EAAkC;AACjCE,MAAAA,OAAO,CAACF,KAAR,GAAgBA,KAAhB;AACA;;AAED,QAAI,OAAOC,UAAP,KAAsB,WAA1B,EAAuC;AACtCC,MAAAA,OAAO,CAACD,UAAR,GAAqBA,UAArB;AACA;;AAED,QAAId,SAAJ,EAAe;AACd1B,MAAAA,OAAO,CAACC,KAAR,CAAcX,kBAAkB,CAACyD,SAAnB,CAA6B;AAAE9B,QAAAA,GAAG,EAAES;AAAP,OAA7B,EAAiD;AAAEsB,QAAAA,IAAI,EAAEP;AAAR,OAAjD,CAAd;AACA,aAAOf,SAAP;AACA;;AAEDe,IAAAA,OAAO,CAACQ,UAAR,GAAqB,IAAIC,IAAJ,EAArB;;AAEA,UAAMjC,GAAG,GAAGrC,MAAM,CAACuE,EAAP,EAAZ;;AAEAnD,IAAAA,OAAO,CAACC,KAAR,CAAcX,kBAAkB,CAAC8D,SAAnB;AAA+BnC,MAAAA;AAA/B,OAAuCwB,OAAvC,EAAd;AAEA,WAAOxB,GAAP;AACA,GA5JwC,CA8JzC;;;AACAoC,EAAAA,WAAW,QAAkD;AAAA,QAAjD;AAAElC,MAAAA,OAAF;AAAWmC,MAAAA,QAAQ,GAAG,EAAtB;AAA0BV,MAAAA,IAA1B;AAAgCW,MAAAA,OAAhC;AAAyClD,MAAAA;AAAzC,KAAiD;AAC5D,QAAIqC,IAAJ,CAD4D,CAE5D;;AACA,QAAIvB,OAAO,CAACqC,eAAZ,EAA6B;AAC5Bd,MAAAA,IAAI,GAAGtD,MAAM,CAACqE,KAAP,CAAaC,6BAAb,CAA2CrD,IAAI,CAACsD,SAAhD,CAAP;AACA,KAL2D,CAO5D;AACA;;;AACA,QAAI,CAACjB,IAAL,EAAW;AACVA,MAAAA,IAAI,GAAGtD,MAAM,CAACqE,KAAP,CAAaC,6BAAb,CAA2CvC,OAAO,CAACyC,QAAnD,CAAP;AACA;;AAED,QAAIC,OAAJ;;AACA,QAAIP,QAAQ,IAAInC,OAAO,CAAC2C,UAApB,IAAkCP,OAAO,CAACzC,OAA9C,EAAuD;AACtD+C,MAAAA,OAAO,GACNrE,iCAAiC,CAAC;AACjCuE,QAAAA,aAAa,EAAErB,IAAI,CAACzB,GADa;AAEjCqC,QAAAA,QAAQ,EAAEA,QAAQ,IAAIC,OAAO,CAACzC,OAApB,IAA+BK,OAAO,CAAC2C,UAFhB;AAGjCE,QAAAA,YAAY,EAAE;AAHmB,OAAD,CAAjC,IAIMpB,IALP;AAMA,KAPD,MAOO;AACNiB,MAAAA,OAAO,GAAGjB,IAAV;AACA,KAvB2D,CAyB5D;;;AACA,QAAI,CAACiB,OAAL,EAAc;AACbnE,MAAAA,cAAc,CAACuE,IAAf,6BACqB9C,OAAO,CAACV,IAD7B;AAGA;AACA;;AAEDf,IAAAA,cAAc,CAACc,KAAf,4BAAyCW,OAAO,CAACV,IAAjD,wBAAmEoD,OAAO,CAACpD,IAA3E,6BAAkGoD,OAAO,CAACK,CAA1G;AAEAX,IAAAA,OAAO,CAACY,GAAR,GAAc;AAAEC,MAAAA,CAAC,EAAEjD,OAAO,CAACF;AAAb,KAAd;AAEA,UAAMoD,aAAa,GAAG;AACrBC,MAAAA,KAAK,EAAEnD,OAAO,CAACmD,KADM;AAErBC,MAAAA,MAAM,EAAEpD,OAAO,CAACoD,MAFK;AAGrBC,MAAAA,KAAK,EAAErD,OAAO,CAACqD;AAHM,KAAtB;;AAMA,QAAIX,OAAO,CAACK,CAAR,KAAc,GAAlB,EAAuB;AACtBX,MAAAA,OAAO,CAACzC,OAAR,cAAsB+C,OAAO,CAAC5C,GAA9B;AACA,KAFD,MAEO;AACNsC,MAAAA,OAAO,CAACzC,OAAR,cAAsB+C,OAAO,CAAC5C,GAA9B;AACA;;AAEDsC,IAAAA,OAAO,GAAG9D,qBAAqB,CAAC8D,OAAD,EAAUb,IAAV,EAAgB2B,aAAhB,CAA/B;AACA,WAAOd,OAAP;AACA;;AAEDkB,EAAAA,YAAY,GAAa;AAAA,QAAZC,KAAY,uEAAJ,EAAI;AACxB,UAAMC,OAAO,GAAG;AACfC,MAAAA,aAAa,CAACC,MAAD,EAAS;AACrB,eAAOC,UAAU,CAAC,MAAMD,MAAM,CAAC,WAAD,CAAb,EAA4B,IAA5B,CAAjB;AACA,OAHc;;AAIf9F,MAAAA,CAJe;AAKfC,MAAAA,CALe;AAMf+F,MAAAA,OANe;AAOf9F,MAAAA,MAPe;AAQfC,MAAAA,KARe;AASfc,MAAAA,OATe;AAUfgF,MAAAA,KAAK,EAAE;AACNC,QAAAA,GAAG,EAAE,CAACC,GAAD,EAAMC,GAAN,KAAc;AAClBT,UAAAA,KAAK,CAACQ,GAAD,CAAL,GAAaC,GAAb;AACA,SAHK;AAINC,QAAAA,GAAG,EAAGF,GAAD,IAASR,KAAK,CAACQ,GAAD;AAJb,OAVQ;AAgBfpG,MAAAA,IAAI,EAAE,CAACuG,MAAD,EAASlD,GAAT,EAAcmD,OAAd,KAA0B;AAC/B,YAAI;AACH,iBAAO;AACNC,YAAAA,MAAM,EAAEzG,IAAI,CAAC0G,IAAL,CAAUH,MAAV,EAAkBlD,GAAlB,EAAuBmD,OAAvB;AADF,WAAP;AAGA,SAJD,CAIE,OAAO/C,KAAP,EAAc;AACf,iBAAO;AAAEA,YAAAA;AAAF,WAAP;AACA;AACD;AAxBc,KAAhB;AA2BAnB,IAAAA,MAAM,CAACqE,IAAP,CAAYrG,MAAZ,EACEsG,MADF,CACUC,CAAD,IAAO,CAACA,CAAC,CAACC,UAAF,CAAa,GAAb,CADjB,EAEExF,OAFF,CAEWuF,CAAD,IAAO;AACfhB,MAAAA,OAAO,CAACgB,CAAD,CAAP,GAAavG,MAAM,CAACuG,CAAD,CAAnB;AACA,KAJF;AAMA,WAAO;AAAEjB,MAAAA,KAAF;AAASC,MAAAA;AAAT,KAAP;AACA;;AAEDkB,EAAAA,oBAAoB,CAACjE,WAAD,EAAc;AACjC,UAAMkE,cAAc,GAAG,KAAKhG,eAAL,CAAqB8B,WAAW,CAACX,GAAjC,CAAvB;;AACA,QAAI6E,cAAc,IAAI,CAACA,cAAc,CAACC,UAAhB,KAA+B,CAACnE,WAAW,CAACmE,UAAlE,EAA8E;AAC7E,aAAOD,cAAc,CAACE,MAAtB;AACA;;AAED,UAAMA,MAAM,GAAGpE,WAAW,CAACqE,cAA3B;AACA,UAAM;AAAEvB,MAAAA,KAAF;AAASC,MAAAA;AAAT,QAAqB,KAAKF,YAAL,EAA3B;AAEA,QAAIyB,QAAJ;;AACA,QAAI;AACHxG,MAAAA,cAAc,CAACyG,IAAf,CAAoB;AAAEC,QAAAA,GAAG,EAAE,iCAAP;AAA0C3F,QAAAA,IAAI,EAAEmB,WAAW,CAACnB;AAA5D,OAApB;AACAf,MAAAA,cAAc,CAACc,KAAf,CAAqBwF,MAArB;AAEAE,MAAAA,QAAQ,GAAG,KAAKxH,EAAL,CAAQ2H,YAAR,CAAqBL,MAArB,EAA6B,WAA7B,CAAX;AAEAE,MAAAA,QAAQ,CAACI,eAAT,CAAyB3B,OAAzB;;AAEA,UAAIA,OAAO,CAAC4B,MAAZ,EAAoB;AACnB,aAAKzG,eAAL,CAAqB8B,WAAW,CAACX,GAAjC,IAAwC;AACvC+E,UAAAA,MAAM,EAAE,IAAIrB,OAAO,CAAC4B,MAAZ,EAD+B;AAEvC7B,UAAAA,KAFuC;AAGvCqB,UAAAA,UAAU,EAAEnE,WAAW,CAACmE;AAHe,SAAxC;AAMA,eAAO,KAAKjG,eAAL,CAAqB8B,WAAW,CAACX,GAAjC,EAAsC+E,MAA7C;AACA;AACD,KAjBD,CAiBE,OAAOQ,GAAP,EAAY;AACb9G,MAAAA,cAAc,CAAC6C,KAAf,CAAqB;AACpB6D,QAAAA,GAAG,EAAE,oCADe;AAEpB3F,QAAAA,IAAI,EAAEmB,WAAW,CAACnB,IAFE;AAGpBuF,QAAAA,MAHoB;AAIpBQ,QAAAA;AAJoB,OAArB;AAMA,YAAM,IAAI7H,MAAM,CAAC8H,KAAX,CAAiB,yBAAjB,CAAN;AACA;;AAED,QAAI,CAAC9B,OAAO,CAAC4B,MAAb,EAAqB;AACpB7G,MAAAA,cAAc,CAAC6C,KAAf,2CAAsDX,WAAW,CAACnB,IAAlE;AACA,YAAM,IAAI9B,MAAM,CAAC8H,KAAX,CAAiB,wBAAjB,CAAN;AACA;AACD;;AAEDC,EAAAA,kBAAkB,CAAC9E,WAAD,EAAcyD,MAAd,EAAsB;AACvC,QAAIzD,WAAW,CAAC+E,aAAZ,KAA8B,IAA9B,IAAsC,CAAC/E,WAAW,CAACqE,cAAnD,IAAqErE,WAAW,CAACqE,cAAZ,CAA2BW,IAA3B,OAAsC,EAA/G,EAAmH;AAClH,aAAO,KAAP;AACA;;AAED,QAAIZ,MAAJ;;AACA,QAAI;AACHA,MAAAA,MAAM,GAAG,KAAKH,oBAAL,CAA0BjE,WAA1B,CAAT;AACA,KAFD,CAEE,OAAOiF,CAAP,EAAU;AACX,aAAO,KAAP;AACA;;AAED,WAAO,OAAOb,MAAM,CAACX,MAAD,CAAb,KAA0B,WAAjC;AACA;;AAEDyB,EAAAA,aAAa,CAAClF,WAAD,EAAcyD,MAAd,EAAsB0B,MAAtB,EAA8BrF,SAA9B,EAAyC;AACrD,QAAIsE,MAAJ;;AACA,QAAI;AACHA,MAAAA,MAAM,GAAG,KAAKH,oBAAL,CAA0BjE,WAA1B,CAAT;AACA,KAFD,CAEE,OAAOiF,CAAP,EAAU;AACX,WAAKpF,aAAL,CAAmB;AAClBC,QAAAA,SADkB;AAElBC,QAAAA,IAAI,EAAE,+BAFY;AAGlBY,QAAAA,KAAK,EAAE,IAHW;AAIlBC,QAAAA,UAAU,EAAEqE;AAJM,OAAnB;AAMA;AACA;;AAED,QAAI,CAACb,MAAM,CAACX,MAAD,CAAX,EAAqB;AACpB3F,MAAAA,cAAc,CAAC6C,KAAf,oBAAgC8C,MAAhC,8CAAwEzD,WAAW,CAACnB,IAApF;AACA,WAAKgB,aAAL,CAAmB;AAAEC,QAAAA,SAAF;AAAaC,QAAAA,IAAI,qCAA8B0D,MAA9B;AAAjB,OAAnB;AACA;AACA;;AAED,QAAI;AACH,YAAM;AAAEV,QAAAA;AAAF,UAAc,KAAKF,YAAL,CAAkB,KAAK3E,eAAL,CAAqB8B,WAAW,CAACX,GAAjC,EAAsCyD,KAAxD,CAApB;AACAC,MAAAA,OAAO,CAACqB,MAAR,GAAiBA,MAAjB;AACArB,MAAAA,OAAO,CAACU,MAAR,GAAiBA,MAAjB;AACAV,MAAAA,OAAO,CAACoC,MAAR,GAAiBA,MAAjB;AAEA,WAAKtF,aAAL,CAAmB;AAAEC,QAAAA,SAAF;AAAaC,QAAAA,IAAI,0CAAmC0D,MAAnC;AAAjB,OAAnB;AAEA,YAAME,MAAM,GAAGpG,MAAM,CAAC6H,WAAP,CACd,KAAKtI,EAAL,CAAQ4H,eAAR,2UAaC3B,OAbD,EAcC;AACCsC,QAAAA,OAAO,EAAE;AADV,OAdD,CADc,EAmBbC,IAnBa,EAAf;AAqBAxH,MAAAA,cAAc,CAACc,KAAf,CAAqB;AACpB4F,QAAAA,GAAG,4BAAoBf,MAApB,4CAA0DzD,WAAW,CAACnB,IAAtE,WADiB;AAEpB8E,QAAAA;AAFoB,OAArB;AAKA,aAAOA,MAAP;AACA,KAnCD,CAmCE,OAAOiB,GAAP,EAAY;AACb,WAAK/E,aAAL,CAAmB;AAClBC,QAAAA,SADkB;AAElBC,QAAAA,IAAI,yCAAkC0D,MAAlC,CAFc;AAGlB9C,QAAAA,KAAK,EAAE,IAHW;AAIlBC,QAAAA,UAAU,EAAEgE,GAAG,CAACW,KAAJ,CAAUC,OAAV,CAAkB,KAAlB,EAAyB,IAAzB;AAJM,OAAnB;AAMA1H,MAAAA,cAAc,CAAC6C,KAAf,CAAqB;AACpB6D,QAAAA,GAAG,EAAE,yCADe;AAEpB3F,QAAAA,IAAI,EAAEmB,WAAW,CAACnB,IAFE;AAGpB+F,QAAAA;AAHoB,OAArB;AAKA9G,MAAAA,cAAc,CAACc,KAAf,CAAqB;AACpB4F,QAAAA,GAAG,EAAE,yCADe;AAEpB3F,QAAAA,IAAI,EAAEmB,WAAW,CAACnB,IAFE;AAGpBuF,QAAAA,MAAM,EAAEpE,WAAW,CAACqE;AAHA,OAArB,EAZa,CAgBT;AACJ;AACD;;AAEDoB,EAAAA,0BAA0B,GAAU;AACnC,UAAMC,SAAS,GAAG;AACjB5G,MAAAA,KAAK;AADY,KAAlB;;AAIA,YAAQ4G,SAAS,CAAC5G,KAAlB;AACC,WAAK,aAAL;AACC,YAAI,UAAK6G,MAAL,IAAe,CAAnB,EAAsB;AACrBD,UAAAA,SAAS,CAAC/D,OAAV;AACA+D,UAAAA,SAAS,CAAC1E,IAAV;AACA;;AACD;;AACD,WAAK,cAAL;AACC,YAAI,UAAK2E,MAAL,IAAe,CAAnB,EAAsB;AACrB,gBAAMC,MAAM,mDAAZ;AACAF,UAAAA,SAAS,CAAC5E,IAAV,GAAiB8E,MAAM,CAAC9E,IAAxB;AACA4E,UAAAA,SAAS,CAAC1E,IAAV,GAAiB4E,MAAM,CAAC5E,IAAxB;AACA0E,UAAAA,SAAS,CAAC/D,OAAV,GAAoBiE,MAAM,CAACjE,OAA3B;AACA;;AACD;;AACD,WAAK,cAAL;AACC,YAAI,UAAKgE,MAAL,IAAe,CAAnB,EAAsB;AACrBD,UAAAA,SAAS,CAAC1E,IAAV;AACA0E,UAAAA,SAAS,CAAC5E,IAAV;AACA;;AACD;;AACD,WAAK,aAAL;AACC,YAAI,UAAK6E,MAAL,IAAe,CAAnB,EAAsB;AACrBD,UAAAA,SAAS,CAACG,KAAV;AACAH,UAAAA,SAAS,CAAC1E,IAAV;AACA;;AACD;;AACD,WAAK,YAAL;AACA,WAAK,UAAL;AACC,YAAI,UAAK2E,MAAL,IAAe,CAAnB,EAAsB;AACrBD,UAAAA,SAAS,CAAC5E,IAAV;AACA4E,UAAAA,SAAS,CAAC1E,IAAV;AACA;;AACD;;AACD,WAAK,aAAL;AACC,YAAI,UAAK2E,MAAL,IAAe,CAAnB,EAAsB;AACrBD,UAAAA,SAAS,CAAC5E,IAAV;AACA;;AACD;;AACD;AACChD,QAAAA,cAAc,CAACuE,IAAf,kDAA8DqD,SAAS,CAAC5G,KAAxE;AACA4G,QAAAA,SAAS,CAAC5G,KAAV,GAAkBgH,SAAlB;AACA;AA1CF;;AA6CAhI,IAAAA,cAAc,CAACc,KAAf,CAAqB;AACpB4F,MAAAA,GAAG,mDAA4CkB,SAAS,CAAC5G,KAAtD,CADiB;AAEpB4G,MAAAA;AAFoB,KAArB;AAKA,WAAOA,SAAP;AACA;;AAEDK,EAAAA,kBAAkB,CAACtH,IAAD,SAA8C;AAAA,QAAvC;AAAEK,MAAAA,KAAF;AAAS6C,MAAAA,OAAT;AAAkBX,MAAAA,IAAlB;AAAwB6E,MAAAA,KAAxB;AAA+B/E,MAAAA;AAA/B,KAAuC;;AAC/D,YAAQhC,KAAR;AACC,WAAK,aAAL;AACCL,QAAAA,IAAI,CAACuH,UAAL,GAAkBhF,IAAI,CAAC3B,GAAvB;AACAZ,QAAAA,IAAI,CAACwH,YAAL,GAAoBjF,IAAI,CAACnC,IAAzB;AACAJ,QAAAA,IAAI,CAACyH,UAAL,GAAkBvE,OAAO,CAACtC,GAA1B;AACAZ,QAAAA,IAAI,CAAC0H,SAAL,GAAiBxE,OAAO,CAACyE,EAAzB;AACA3H,QAAAA,IAAI,CAAC4H,OAAL,GAAe1E,OAAO,CAAC2E,CAAR,CAAUjH,GAAzB;AACAZ,QAAAA,IAAI,CAACsD,SAAL,GAAiBJ,OAAO,CAAC2E,CAAR,CAAUtE,QAA3B;AACAvD,QAAAA,IAAI,CAAC8H,IAAL,GAAY5E,OAAO,CAAC6C,GAApB;AACA/F,QAAAA,IAAI,CAAC+H,OAAL,GAAe7I,QAAQ,CAAC6F,GAAT,CAAa,UAAb,CAAf;;AAEA,YAAI7B,OAAO,CAACe,KAAZ,EAAmB;AAClBjE,UAAAA,IAAI,CAACiE,KAAL,GAAaf,OAAO,CAACe,KAArB;AACA;;AAED,YAAIf,OAAO,CAACY,GAAZ,EAAiB;AAChB9D,UAAAA,IAAI,CAAC8D,GAAL,GAAWZ,OAAO,CAACY,GAAnB;AACA;;AAED,YAAIZ,OAAO,CAAC8E,QAAZ,EAAsB;AACrBhI,UAAAA,IAAI,CAACiI,QAAL,GAAgB,IAAhB;AACA;;AAED,YAAI/E,OAAO,CAACgF,IAAZ,EAAkB;AACjBlI,UAAAA,IAAI,CAACkI,IAAL,GAAYhF,OAAO,CAACgF,IAApB;AACA;;AACD;;AACD,WAAK,cAAL;AACClI,QAAAA,IAAI,CAACuH,UAAL,GAAkBhF,IAAI,CAAC3B,GAAvB;AACAZ,QAAAA,IAAI,CAACwH,YAAL,GAAoBjF,IAAI,CAACnC,IAAzB;AACAJ,QAAAA,IAAI,CAACyH,UAAL,GAAkBvE,OAAO,CAACtC,GAA1B;AACAZ,QAAAA,IAAI,CAAC0H,SAAL,GAAiBxE,OAAO,CAACyE,EAAzB;AACA3H,QAAAA,IAAI,CAAC4H,OAAL,GAAe1E,OAAO,CAAC2E,CAAR,CAAUjH,GAAzB;AACAZ,QAAAA,IAAI,CAACsD,SAAL,GAAiBJ,OAAO,CAAC2E,CAAR,CAAUtE,QAA3B;AACAvD,QAAAA,IAAI,CAAC8H,IAAL,GAAY5E,OAAO,CAAC6C,GAApB;AACA/F,QAAAA,IAAI,CAACqC,IAAL,GAAYA,IAAZ;AACArC,QAAAA,IAAI,CAACuC,IAAL,GAAYA,IAAZ;AACAvC,QAAAA,IAAI,CAACkD,OAAL,GAAeA,OAAf;;AAEA,YAAIA,OAAO,CAACe,KAAZ,EAAmB;AAClBjE,UAAAA,IAAI,CAACiE,KAAL,GAAaf,OAAO,CAACe,KAArB;AACA;;AAED,YAAIf,OAAO,CAACY,GAAZ,EAAiB;AAChB9D,UAAAA,IAAI,CAAC8D,GAAL,GAAWZ,OAAO,CAACY,GAAnB;AACA;;AACD;;AACD,WAAK,aAAL;AACC9D,QAAAA,IAAI,CAACuH,UAAL,GAAkBhF,IAAI,CAAC3B,GAAvB;AACAZ,QAAAA,IAAI,CAACwH,YAAL,GAAoBjF,IAAI,CAACnC,IAAzB;AACAJ,QAAAA,IAAI,CAAC0H,SAAL,GAAiBnF,IAAI,CAACoF,EAAtB;AACA3H,QAAAA,IAAI,CAAC4H,OAAL,GAAeR,KAAK,CAACxG,GAArB;AACAZ,QAAAA,IAAI,CAACsD,SAAL,GAAiB8D,KAAK,CAAC7D,QAAvB;AACAvD,QAAAA,IAAI,CAACoH,KAAL,GAAaA,KAAb;AACApH,QAAAA,IAAI,CAACuC,IAAL,GAAYA,IAAZ;AACA;;AACD,WAAK,cAAL;AACA,WAAK,YAAL;AACA,WAAK,UAAL;AACCvC,QAAAA,IAAI,CAAC0H,SAAL,GAAiB,IAAI7E,IAAJ,EAAjB;AACA7C,QAAAA,IAAI,CAACuH,UAAL,GAAkBhF,IAAI,CAAC3B,GAAvB;AACAZ,QAAAA,IAAI,CAACwH,YAAL,GAAoBjF,IAAI,CAACnC,IAAzB;AACAJ,QAAAA,IAAI,CAAC4H,OAAL,GAAevF,IAAI,CAACzB,GAApB;AACAZ,QAAAA,IAAI,CAACsD,SAAL,GAAiBjB,IAAI,CAACkB,QAAtB;AACAvD,QAAAA,IAAI,CAACqC,IAAL,GAAYA,IAAZ;AACArC,QAAAA,IAAI,CAACuC,IAAL,GAAYA,IAAZ;;AAEA,YAAIF,IAAI,CAACvC,IAAL,KAAc,KAAlB,EAAyB;AACxBE,UAAAA,IAAI,CAAC8D,GAAL,GAAW,IAAX;AACA;;AACD;;AACD,WAAK,aAAL;AACC9D,QAAAA,IAAI,CAAC0H,SAAL,GAAiBrF,IAAI,CAAC8F,SAAtB;AACAnI,QAAAA,IAAI,CAAC4H,OAAL,GAAevF,IAAI,CAACzB,GAApB;AACAZ,QAAAA,IAAI,CAACsD,SAAL,GAAiBjB,IAAI,CAACkB,QAAtB;AACAvD,QAAAA,IAAI,CAACqC,IAAL,GAAYA,IAAZ;;AAEA,YAAIA,IAAI,CAACvC,IAAL,KAAc,KAAlB,EAAyB;AACxBE,UAAAA,IAAI,CAAC8D,GAAL,GAAW,IAAX;AACA;;AACD;;AACD;AACC;AAlFF;AAoFA;;AAEDsE,EAAAA,oBAAoB,CAAC7F,IAAD,EAAOW,OAAP,EAAgB;AACnC,UAAMmF,iBAAiB,GAAG,IAAIC,GAAJ,EAA1B;;AACA,QAAI/F,IAAJ,EAAU;AACT,cAAQA,IAAI,CAACsB,CAAb;AACC,aAAK,GAAL;AACC,cAAI,KAAKnE,QAAL,CAAc6I,mBAAlB,EAAuC;AACtC,iBAAK,MAAMzH,OAAX,IAAsBC,MAAM,CAACC,MAAP,CAAc,KAAKtB,QAAL,CAAc6I,mBAA5B,CAAtB,EAAwE;AACvEF,cAAAA,iBAAiB,CAACG,GAAlB,CAAsB1H,OAAtB;AACA;AACD;;AAEDyB,UAAAA,IAAI,CAACkG,IAAL,CACEpD,MADF,CACUqD,GAAD,IAAS,KAAKhJ,QAAL,YAAkBgJ,GAAlB,EADlB,EAEE3I,OAFF,CAEW2I,GAAD,IAAS;AACjB,iBAAK,MAAM5H,OAAX,IAAsBC,MAAM,CAACC,MAAP,CAAc,KAAKtB,QAAL,YAAkBgJ,GAAlB,EAAd,CAAtB,EAA+D;AAC9DL,cAAAA,iBAAiB,CAACG,GAAlB,CAAsB1H,OAAtB;AACA;AACD,WANF;AAQAyB,UAAAA,IAAI,CAACoG,SAAL,CACEtD,MADF,CACU9B,QAAD,IAAcA,QAAQ,KAAKL,OAAO,CAAC2E,CAAR,CAAUtE,QAAvB,IAAmC,KAAK7D,QAAL,YAAkB6D,QAAlB,EAD1D,EAEExD,OAFF,CAEWwD,QAAD,IAAc;AACtB,iBAAK,MAAMzC,OAAX,IAAsBC,MAAM,CAACC,MAAP,CAAc,KAAKtB,QAAL,YAAkB6D,QAAlB,EAAd,CAAtB,EAAoE;AACnE8E,cAAAA,iBAAiB,CAACG,GAAlB,CAAsB1H,OAAtB;AACA;AACD,WANF;AAOA;;AACD,aAAK,GAAL;AACC,cAAI,KAAKpB,QAAL,CAAckJ,mBAAlB,EAAuC;AACtC,iBAAK,MAAM9H,OAAX,IAAsBC,MAAM,CAACC,MAAP,CAAc,KAAKtB,QAAL,CAAckJ,mBAA5B,CAAtB,EAAwE;AACvEP,cAAAA,iBAAiB,CAACG,GAAlB,CAAsB1H,OAAtB;AACA;AACD;;AAED,cAAI,KAAKpB,QAAL,YAAkB6C,IAAI,CAAC3B,GAAvB,EAAJ,EAAmC;AAClC,iBAAK,MAAME,OAAX,IAAsBC,MAAM,CAACC,MAAP,CAAc,KAAKtB,QAAL,YAAkB6C,IAAI,CAAC3B,GAAvB,EAAd,CAAtB,EAAoE;AACnEyH,cAAAA,iBAAiB,CAACG,GAAlB,CAAsB1H,OAAtB;AACA;AACD;;AAED,cAAIyB,IAAI,CAAC3B,GAAL,KAAa2B,IAAI,CAACnC,IAAlB,IAA0B,KAAKV,QAAL,YAAkB6C,IAAI,CAACnC,IAAvB,EAA9B,EAA8D;AAC7D,iBAAK,MAAMU,OAAX,IAAsBC,MAAM,CAACC,MAAP,CAAc,KAAKtB,QAAL,YAAkB6C,IAAI,CAACnC,IAAvB,EAAd,CAAtB,EAAqE;AACpEiI,cAAAA,iBAAiB,CAACG,GAAlB,CAAsB1H,OAAtB;AACA;AACD;;AACD;;AAED;AACC,cAAI,KAAKpB,QAAL,CAAcmJ,kBAAlB,EAAsC;AACrC,iBAAK,MAAM/H,OAAX,IAAsBC,MAAM,CAACC,MAAP,CAAc,KAAKtB,QAAL,CAAcmJ,kBAA5B,CAAtB,EAAuE;AACtER,cAAAA,iBAAiB,CAACG,GAAlB,CAAsB1H,OAAtB;AACA;AACD;;AAED,cAAI,KAAKpB,QAAL,YAAkB6C,IAAI,CAAC3B,GAAvB,EAAJ,EAAmC;AAClC,iBAAK,MAAME,OAAX,IAAsBC,MAAM,CAACC,MAAP,CAAc,KAAKtB,QAAL,YAAkB6C,IAAI,CAAC3B,GAAvB,EAAd,CAAtB,EAAoE;AACnEyH,cAAAA,iBAAiB,CAACG,GAAlB,CAAsB1H,OAAtB;AACA;AACD;;AAED,cAAIyB,IAAI,CAAC3B,GAAL,KAAa2B,IAAI,CAACnC,IAAlB,IAA0B,KAAKV,QAAL,YAAkB6C,IAAI,CAACnC,IAAvB,EAA9B,EAA8D;AAC7D,iBAAK,MAAMU,OAAX,IAAsBC,MAAM,CAACC,MAAP,CAAc,KAAKtB,QAAL,YAAkB6C,IAAI,CAACnC,IAAvB,EAAd,CAAtB,EAAqE;AACpEiI,cAAAA,iBAAiB,CAACG,GAAlB,CAAsB1H,OAAtB;AACA;AACD;;AACD;AA9DF;AAgEA;;AACD,WAAO,CAAC,GAAGuH,iBAAJ,CAAP;AACA;;AAEDS,EAAAA,eAAe,GAAU;AACxBzJ,IAAAA,cAAc,CAACc,KAAf,CAAqB;AAAE4F,MAAAA,GAAG,EAAE,kBAAP;AAA2BgD,MAAAA,GAAG;AAA9B,KAArB;AAEA,UAAM9B,SAAS,GAAG,KAAKD,0BAAL,CAAgC,YAAhC,CAAlB;AACA,UAAM;AAAE3G,MAAAA,KAAF;AAAS6C,MAAAA,OAAT;AAAkBX,MAAAA;AAAlB,QAA2B0E,SAAjC,CAJwB,CAMxB;AACA;AACA;;AACA,QAAI,CAAC5G,KAAL,EAAY;AACX;AACA;;AAEDhB,IAAAA,cAAc,CAACc,KAAf,sDAAmEoC,IAAI,GAAGA,IAAI,CAAC3B,GAAR,GAAc,OAArF;AAEA,UAAMyH,iBAAiB,GAAG,KAAKD,oBAAL,CAA0B7F,IAA1B,EAAgCW,OAAhC,CAA1B;;AAEA,QAAI,KAAKxD,QAAL,CAAcsJ,KAAlB,EAAyB;AACxB;AACA,WAAK,MAAMlI,OAAX,IAAsBC,MAAM,CAACC,MAAP,CAAc,KAAKtB,QAAL,CAAcsJ,KAA5B,CAAtB,EAA0D;AACzDX,QAAAA,iBAAiB,CAACY,IAAlB,CAAuBnI,OAAvB;AACA;AACD;;AAEDzB,IAAAA,cAAc,CAACc,KAAf,iBAA8BkI,iBAAiB,CAACnB,MAAhD;;AAEA,SAAK,MAAMgC,gBAAX,IAA+Bb,iBAA/B,EAAkD;AACjDhJ,MAAAA,cAAc,CAACc,KAAf,gBACQ+I,gBAAgB,CAAC9I,IADzB,yBAC2C8I,gBAAgB,CAAC/H,OAD5D,sCAC+F+H,gBAAgB,CAAC7I,KADhH;;AAGA,UAAI6I,gBAAgB,CAAC/H,OAAjB,KAA6B,IAA7B,IAAqC+H,gBAAgB,CAAC7I,KAAjB,KAA2BA,KAApE,EAA2E;AAC1E,aAAK8I,cAAL,CAAoBD,gBAApB,EAAsCjC,SAAtC;AACA;AACD;AACD;;AAEDkC,EAAAA,cAAc,CAACrI,OAAD,EAAUmG,SAAV,EAAqB;AAClC,SAAK,MAAMnF,GAAX,IAAkBhB,OAAO,CAACsI,IAA1B,EAAgC;AAC/B,WAAKC,iBAAL,CAAuBvH,GAAvB,EAA4BhB,OAA5B,EAAqCmG,SAArC,EAAgD,CAAhD;AACA;AACD;;AAEDoC,EAAAA,iBAAiB,CAACvH,GAAD,EAAMhB,OAAN,SAAsDwI,YAAtD,EAA+E;AAAA,QAAhE;AAAEjJ,MAAAA,KAAF;AAAS6C,MAAAA,OAAT;AAAkBX,MAAAA,IAAlB;AAAwB6E,MAAAA,KAAxB;AAA+B/E,MAAAA;AAA/B,KAAgE;AAAA,QAAXkH,KAAW,uEAAH,CAAG;;AAC/F,QAAI,CAAC,KAAKtI,gBAAL,CAAsBH,OAAtB,CAAL,EAAqC;AACpCzB,MAAAA,cAAc,CAACuE,IAAf,yBAAoC9C,OAAO,CAACV,IAA5C,uEAA4GmJ,KAA5G;AACA;AACA;;AAEDlK,IAAAA,cAAc,CAACc,KAAf,wCAAqDW,OAAO,CAACV,IAA7D,eAAsEU,OAAO,CAACF,GAA9E;AAEA,QAAI4I,IAAJ,CAR+F,CAS/F;;AACA,QAAIrL,YAAY,CAACoC,cAAb,CAA4BF,KAA5B,EAAmCG,GAAnC,CAAuCiJ,YAA3C,EAAyD;AACxD,UAAI3I,OAAO,CAAC2I,YAAR,IAAwB3I,OAAO,CAAC2I,YAAR,CAAqBvC,MAArB,GAA8B,CAA1D,EAA6D;AAC5D,aAAK,MAAM1F,WAAX,IAA0BV,OAAO,CAAC2I,YAAlC,EAAgD;AAC/C,cAAI,CAAC3I,OAAO,CAAC4I,mBAAT,IAAgCxG,OAAO,CAAC6C,GAAR,CAAY4D,OAAZ,CAAoBnI,WAApB,MAAqC,CAAzE,EAA4E;AAC3EgI,YAAAA,IAAI,GAAGhI,WAAP;AACA;AACA,WAHD,MAGO,IAAIV,OAAO,CAAC4I,mBAAR,IAA+BxG,OAAO,CAAC6C,GAAR,CAAY6D,QAAZ,CAAqBpI,WAArB,CAAnC,EAAsE;AAC5EgI,YAAAA,IAAI,GAAGhI,WAAP;AACA;AACA;AACD,SAT2D,CAW5D;;;AACA,YAAI,CAACgI,IAAL,EAAW;AACVnK,UAAAA,cAAc,CAACc,KAAf,oCAAgDW,OAAO,CAACV,IAAxD;AACA;AACA;AACD;AACD;;AAED,QAAI8C,OAAO,IAAIA,OAAO,CAAC8E,QAAnB,IAA+B,CAAClH,OAAO,CAAC+I,UAA5C,EAAwD;AACvDxK,MAAAA,cAAc,CAACc,KAAf,yBAAqCW,OAAO,CAACV,IAA7C;AACA;AACA;;AAED,UAAMiB,SAAS,GAAG,KAAKD,aAAL,CAAmB;AACpCE,MAAAA,IAAI,EAAE,2BAD8B;AAEpCC,MAAAA,WAAW,EAAET,OAFuB;AAGpCT,MAAAA;AAHoC,KAAnB,CAAlB;AAMA,UAAML,IAAI,GAAG;AACZ8J,MAAAA,KAAK,EAAEhJ,OAAO,CAACgJ,KADH;AAEZhG,MAAAA,GAAG,EAAE;AAFO,KAAb;;AAKA,QAAI0F,IAAJ,EAAU;AACTxJ,MAAAA,IAAI,CAAC+J,YAAL,GAAoBP,IAApB;AACA;;AAED,SAAKlC,kBAAL,CAAwBtH,IAAxB,EAA8B;AAAEc,MAAAA,OAAF;AAAWT,MAAAA,KAAX;AAAkB6C,MAAAA,OAAlB;AAA2BX,MAAAA,IAA3B;AAAiC6E,MAAAA,KAAjC;AAAwC/E,MAAAA;AAAxC,KAA9B;AACA,SAAKjB,aAAL,CAAmB;AAAEC,MAAAA,SAAF;AAAaC,MAAAA,IAAI,EAAE,qBAAnB;AAA0CtB,MAAAA,IAA1C;AAAgDwB,MAAAA,WAAW,EAAEgI;AAA7D,KAAnB;AAEAnK,IAAAA,cAAc,CAACyG,IAAf,+CAA0DhF,OAAO,CAACV,IAAlE,4BAAuF0B,GAAvF;AACAzC,IAAAA,cAAc,CAACc,KAAf,CAAqBH,IAArB;AAEA,QAAIgK,IAAI,GAAG;AACVtD,MAAAA,MAAM,EAAE,EADE;AAEV1B,MAAAA,MAAM,EAAE,MAFE;AAGVlD,MAAAA,GAHU;AAIV9B,MAAAA,IAJU;AAKViK,MAAAA,IAAI,EAAE5C,SALI;AAMV6C,MAAAA,OAAO,EAAE;AACR,sBAAc;AADN;AANC,KAAX;;AAWA,QAAI,KAAK7D,kBAAL,CAAwBvF,OAAxB,EAAiC,0BAAjC,CAAJ,EAAkE;AACjEkJ,MAAAA,IAAI,GAAG,KAAKvD,aAAL,CAAmB3F,OAAnB,EAA4B,0BAA5B,EAAwD;AAAEqJ,QAAAA,OAAO,EAAEH;AAAX,OAAxD,EAA2E3I,SAA3E,CAAP;AACA;;AAED,SAAKD,aAAL,CAAmB;AAAEC,MAAAA,SAAF;AAAaC,MAAAA,IAAI,EAAE,yBAAnB;AAA8CG,MAAAA,gBAAgB,EAAE;AAAhE,KAAnB;;AAEA,QAAI,CAACuI,IAAL,EAAW;AACV,WAAK5I,aAAL,CAAmB;AAAEC,QAAAA,SAAF;AAAaC,QAAAA,IAAI,EAAE,uBAAnB;AAA4CO,QAAAA,QAAQ,EAAE;AAAtD,OAAnB;AACA;AACA;;AAED,QAAImI,IAAI,CAAC9G,OAAT,EAAkB;AACjB,YAAMkH,cAAc,GAAG,KAAKpH,WAAL,CAAiB;AAAElC,QAAAA,OAAF;AAAWyB,QAAAA,IAAX;AAAiBW,QAAAA,OAAO,EAAE8G,IAAI,CAAC9G,OAA/B;AAAwClD,QAAAA;AAAxC,OAAjB,CAAvB;AACA,WAAKoB,aAAL,CAAmB;AAClBC,QAAAA,SADkB;AAElBC,QAAAA,IAAI,EAAE,4BAFY;AAGlBI,QAAAA,kBAAkB,EAAE0I;AAHF,OAAnB;AAKA;;AAED,QAAI,CAACJ,IAAI,CAAClI,GAAN,IAAa,CAACkI,IAAI,CAAChF,MAAvB,EAA+B;AAC9B,WAAK5D,aAAL,CAAmB;AAAEC,QAAAA,SAAF;AAAaC,QAAAA,IAAI,EAAE,gCAAnB;AAAqDO,QAAAA,QAAQ,EAAE;AAA/D,OAAnB;AACA;AACA,KA1F8F,CA4F/F;;;AACA,QAAImI,IAAI,CAACC,IAAT,EAAe;AACd,UAAID,IAAI,CAACC,IAAL,CAAUN,OAAV,CAAkB,GAAlB,IAAyB,CAA7B,EAAgC;AAC/B,cAAM,IAAIvD,KAAJ,CAAU,uDAAV,CAAN;AACA;;AAED,YAAMiE,MAAM,GAAGC,MAAM,CAACC,IAAP,CAAYP,IAAI,CAACC,IAAjB,EAAuB,OAAvB,EAAgCO,QAAhC,CAAyC,QAAzC,CAAf;AACAR,MAAAA,IAAI,CAACE,OAAL,CAAaO,aAAb,mBAAsCJ,MAAtC;AACA;;AAED,SAAKjJ,aAAL,CAAmB;AAClBC,MAAAA,SADkB;AAElBC,MAAAA,IAAI,EAAE,eAFY;AAGlBQ,MAAAA,GAAG,EAAEkI,IAAI,CAAClI,GAHQ;AAIlBC,MAAAA,YAAY,EAAEiI,IAAI,CAAChK;AAJD,KAAnB;;AAOA,QAAIgK,IAAI,CAAChK,IAAT,EAAe;AACdgK,MAAAA,IAAI,CAACE,OAAL,CAAa,cAAb,IAA+B,kBAA/B;AACA;;AAED1L,IAAAA,KAAK,CAACwL,IAAI,CAAClI,GAAN;AACJkD,MAAAA,MAAM,EAAEgF,IAAI,CAAChF,MADT;AAEJkF,MAAAA,OAAO,EAAEF,IAAI,CAACE;AAFV,OAGAhL,QAAQ,CAAC6F,GAAT,CAAa,gCAAb,KAAkD;AACrD2F,MAAAA,KAAK,EAAEpL,cAAc,CAAC0K,IAAI,CAAClI,GAAL,CAASyD,UAAT,CAAoB,QAApB,IAAgC,QAAhC,GAA2C,OAA5C;AADgC,KAHlD,GAMAyE,IAAI,CAAChK,IAAL,IAAa;AAAE2K,MAAAA,IAAI,EAAEnI,IAAI,CAACC,SAAL,CAAeuH,IAAI,CAAChK,IAApB;AAAR,KANb,EAAL,CAQE4K,IARF,CAQcC,GAAP,6BAAe;AACpB,YAAMC,OAAO,iBAASD,GAAG,CAAC/C,IAAJ,EAAT,CAAb;;AACA,UAAI,CAACgD,OAAL,EAAc;AACbzL,QAAAA,cAAc,CAACuE,IAAf,sCAAkD9C,OAAO,CAACV,IAA1D,iBAAqE0B,GAArE;AACA,OAFD,MAEO;AACNzC,QAAAA,cAAc,CAACyG,IAAf,2CAAuDhF,OAAO,CAACV,IAA/D,iBAA0E0B,GAA1E,iBAAoF+I,GAAG,CAACE,MAAxF;AACA;;AAED,YAAM/K,IAAI,GAAG,CAAC,MAAM;AACnB,cAAMgL,WAAW,GAAG,CAACH,GAAG,CAACX,OAAJ,CAAYnF,GAAZ,CAAgB,cAAhB,KAAmC,EAApC,EAAwCkG,KAAxC,CAA8C,GAA9C,EAAmD,CAAnD,CAApB;;AACA,YAAI,CAAC,CAAC,kBAAD,EAAqB,iBAArB,EAAwC,wBAAxC,EAAkE,0BAAlE,EAA8FrB,QAA9F,CAAuGoB,WAAvG,CAAL,EAA0H;AACzH,iBAAO,IAAP;AACA;;AAED,YAAI;AACH,iBAAOxI,IAAI,CAAC0I,KAAL,CAAWJ,OAAX,CAAP;AACA,SAFD,CAEE,OAAOK,MAAP,EAAe;AAChB,iBAAO,IAAP;AACA;AACD,OAXY,GAAb;;AAaA,WAAK/J,aAAL,CAAmB;AAClBC,QAAAA,SADkB;AAElBC,QAAAA,IAAI,EAAE,iBAFY;AAGlBU,QAAAA,SAAS,EAAE,IAHO;AAIlBC,QAAAA,UAAU,EAAE6I;AAJM,OAAnB;;AAOA,UAAI,KAAKzE,kBAAL,CAAwBvF,OAAxB,EAAiC,2BAAjC,CAAJ,EAAmE;AAClE,cAAMwD,OAAO,GAAG;AACf6F,UAAAA,OAAO,EAAEH,IADM;AAEfoB,UAAAA,QAAQ,EAAE;AACTlJ,YAAAA,KAAK,EAAE,IADE;AAETmJ,YAAAA,WAAW,EAAER,GAAG,CAACE,MAFR;AAEgB;AACzBD,YAAAA,OAHS;AAITQ,YAAAA,WAAW,EAAER,OAJJ;AAKTZ,YAAAA,OAAO,EAAEnJ,MAAM,CAACwK,WAAP,CAAmBV,GAAG,CAACX,OAAvB;AALA;AAFK,SAAhB;AAWA,cAAMsB,YAAY,GAAG,KAAK/E,aAAL,CAAmB3F,OAAnB,EAA4B,2BAA5B,EAAyDwD,OAAzD,EAAkEjD,SAAlE,CAArB;;AAEA,YAAImK,YAAY,IAAIA,YAAY,CAACV,OAAjC,EAA0C;AACzC,gBAAMlJ,aAAa,GAAG,KAAKoB,WAAL,CAAiB;AACtClC,YAAAA,OADsC;AAEtCyB,YAAAA,IAFsC;AAGtCW,YAAAA,OAAO,EAAEsI,YAAY,CAACV,OAHgB;AAItC9K,YAAAA;AAJsC,WAAjB,CAAtB;AAMA,eAAKoB,aAAL,CAAmB;AAClBC,YAAAA,SADkB;AAElBC,YAAAA,IAAI,EAAE,4BAFY;AAGlBK,YAAAA,kBAAkB,EAAEC,aAHF;AAIlBC,YAAAA,QAAQ,EAAE;AAJQ,WAAnB;AAMA;AACA;;AAED,YAAI2J,YAAY,KAAK,KAArB,EAA4B;AAC3B,eAAKpK,aAAL,CAAmB;AAAEC,YAAAA,SAAF;AAAaC,YAAAA,IAAI,EAAE,4BAAnB;AAAiDO,YAAAA,QAAQ,EAAE;AAA3D,WAAnB;AACA;AACA;AACD,OA9DmB,CAgEpB;;;AACA,UAAI,CAACiJ,OAAD,IAAY,CAAC,KAAKtL,cAAL,CAAoBoK,QAApB,CAA6BiB,GAAG,CAACE,MAAjC,CAAjB,EAA2D;AAC1D,YAAID,OAAJ,EAAa;AACZzL,UAAAA,cAAc,CAAC6C,KAAf,CAAqB;AACpB6D,YAAAA,GAAG,wCAAgCjF,OAAO,CAACV,IAAxC,mBAAoD0B,GAApD,CADiB;AAEpBoD,YAAAA,MAAM,EAAE4F;AAFY,WAArB;;AAKA,cAAID,GAAG,CAACE,MAAJ,KAAe,GAAnB,EAAwB;AACvB,iBAAK3J,aAAL,CAAmB;AAAEC,cAAAA,SAAF;AAAaC,cAAAA,IAAI,EAAE,+BAAnB;AAAoDY,cAAAA,KAAK,EAAE;AAA3D,aAAnB;AACA7C,YAAAA,cAAc,CAAC6C,KAAf,uCAAmDpB,OAAO,CAACV,IAA3D;AACA,0BAAMpB,YAAY,CAAC0D,SAAb,CAAuB;AAAE9B,cAAAA,GAAG,EAAEE,OAAO,CAACF;AAAf,aAAvB,EAA6C;AAAE+B,cAAAA,IAAI,EAAE;AAAExB,gBAAAA,OAAO,EAAE;AAAX;AAAR,aAA7C,CAAN;AACA;AACA;;AAED,cAAI0J,GAAG,CAACE,MAAJ,KAAe,GAAnB,EAAwB;AACvB,iBAAK3J,aAAL,CAAmB;AAAEC,cAAAA,SAAF;AAAaC,cAAAA,IAAI,EAAE,+BAAnB;AAAoDY,cAAAA,KAAK,EAAE;AAA3D,aAAnB;AACA7C,YAAAA,cAAc,CAAC6C,KAAf,CAAqB;AACpB6D,cAAAA,GAAG,gDAAsCjF,OAAO,CAACV,IAA9C,mBAA0D0B,GAA1D,MADiB;AAEpBgJ,cAAAA;AAFoB,aAArB;AAIA;AACA;AACD;;AAED,YAAIhK,OAAO,CAAC2K,gBAAZ,EAA8B;AAC7B,cAAIlC,KAAK,GAAGzI,OAAO,CAAC4K,UAAhB,IAA8B5K,OAAO,CAAC6K,UAA1C,EAAsD;AACrD,iBAAKvK,aAAL,CAAmB;AAAEC,cAAAA,SAAF;AAAaa,cAAAA,KAAK,EAAE,IAApB;AAA0BZ,cAAAA,IAAI,2BAAoBiI,KAAK,GAAG,CAA5B;AAA9B,aAAnB;AAEA,gBAAIqC,QAAJ;;AAEA,oBAAQ9K,OAAO,CAAC6K,UAAhB;AACC,mBAAK,eAAL;AACC;AACAC,gBAAAA,QAAQ,GAAGC,IAAI,CAACC,GAAL,CAAS,EAAT,EAAavC,KAAK,GAAG,CAArB,CAAX;AACA;;AACD,mBAAK,eAAL;AACC;AACAqC,gBAAAA,QAAQ,GAAGC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYvC,KAAK,GAAG,CAApB,IAAyB,IAApC;AACA;;AACD,mBAAK,mBAAL;AACC;AACAqC,gBAAAA,QAAQ,GAAG,CAACrC,KAAK,GAAG,CAAT,IAAc,CAAd,GAAkB,IAA7B;AACA;;AACD;AACC,sBAAMwC,EAAE,GAAG,IAAI3F,KAAJ,CAAU,kDAAV,CAAX;AACA,qBAAKhF,aAAL,CAAmB;AAClBC,kBAAAA,SADkB;AAElBC,kBAAAA,IAAI,EAAE,mCAFY;AAGlBY,kBAAAA,KAAK,EAAE,IAHW;AAIlBC,kBAAAA,UAAU,EAAE4J,EAAE,CAACjF;AAJG,iBAAnB;AAMA;AArBF;;AAwBAzH,YAAAA,cAAc,CAACyG,IAAf,kCAA8ChF,OAAO,CAACV,IAAtD,iBAAiE0B,GAAjE,uBAAiF8J,QAAjF;AACAtN,YAAAA,MAAM,CAACmG,UAAP,CAAkB,MAAM;AACvB,mBAAK4E,iBAAL,CAAuBvH,GAAvB,EAA4BhB,OAA5B,EAAqC;AAAET,gBAAAA,KAAF;AAAS6C,gBAAAA,OAAT;AAAkBX,gBAAAA,IAAlB;AAAwB6E,gBAAAA,KAAxB;AAA+B/E,gBAAAA;AAA/B,eAArC,EAA4EhB,SAA5E,EAAuFkI,KAAK,GAAG,CAA/F;AACA,aAFD,EAEGqC,QAFH;AAGA,WAjCD,MAiCO;AACN,iBAAKxK,aAAL,CAAmB;AAAEC,cAAAA,SAAF;AAAaC,cAAAA,IAAI,EAAE,kBAAnB;AAAuCY,cAAAA,KAAK,EAAE;AAA9C,aAAnB;AACA;AACD,SArCD,MAqCO;AACN,eAAKd,aAAL,CAAmB;AAClBC,YAAAA,SADkB;AAElBC,YAAAA,IAAI,EAAE,oCAFY;AAGlBY,YAAAA,KAAK,EAAE;AAHW,WAAnB;AAKA;;AAED;AACA,OAvImB,CAyIpB;;;AACA,UAAI4I,OAAO,IAAI,KAAKtL,cAAL,CAAoBoK,QAApB,CAA6BiB,GAAG,CAACE,MAAjC,CAAf,EAAyD;AACxD,YAAI/K,IAAI,SAAJ,IAAAA,IAAI,WAAJ,IAAAA,IAAI,CAAE8H,IAAN,IAAc9H,IAAd,aAAcA,IAAd,eAAcA,IAAI,CAAEgM,WAAxB,EAAqC;AACpC,gBAAMC,SAAS,GAAG,KAAKjJ,WAAL,CAAiB;AAAElC,YAAAA,OAAF;AAAWyB,YAAAA,IAAX;AAAiBW,YAAAA,OAAO,EAAElD,IAA1B;AAAgCA,YAAAA;AAAhC,WAAjB,CAAlB;AACA,eAAKoB,aAAL,CAAmB;AAClBC,YAAAA,SADkB;AAElBC,YAAAA,IAAI,EAAE,2BAFY;AAGlBM,YAAAA,aAAa,EAAEqK,SAHG;AAIlBpK,YAAAA,QAAQ,EAAE;AAJQ,WAAnB;AAMA;AACD;AACD,KArJK,CARP,EA8JEqK,KA9JF,CA8JShK,KAAD,IAAW;AACjB7C,MAAAA,cAAc,CAAC6C,KAAf,CAAqBA,KAArB;AACA,WAAKd,aAAL,CAAmB;AAClBC,QAAAA,SADkB;AAElBC,QAAAA,IAAI,EAAE,iBAFY;AAGlBU,QAAAA,SAAS,EAAEE,KAHO;AAIlBD,QAAAA,UAAU,EAAE;AAJM,OAAnB;AAMA,KAtKF;AAuKA;;AAEDkK,EAAAA,MAAM,CAAC5K,WAAD,EAAca,OAAd,EAAuB;AAC5B,QAAI,CAACb,WAAD,IAAgBA,WAAW,CAACzB,IAAZ,KAAqB,kBAAzC,EAA6D;AAC5D,YAAM,IAAIxB,MAAM,CAAC8H,KAAX,CAAiB,mCAAjB,EAAsD,6DAAtD,CAAN;AACA;;AAED,QAAI,CAAChE,OAAD,IAAY,CAACA,OAAO,CAACpC,IAAzB,EAA+B;AAC9B,YAAM,IAAI1B,MAAM,CAAC8H,KAAX,CAAiB,8BAAjB,EAAiD,4DAAjD,CAAN;AACA;;AAED,UAAM;AAAE/F,MAAAA;AAAF,QAAY+B,OAAlB;AACA,UAAMc,OAAO,GAAGnE,MAAM,CAACqN,QAAP,CAAgBC,WAAhB,CAA4BjK,OAAO,CAACpC,IAAR,CAAayH,UAAzC,CAAhB;AACA,UAAMlF,IAAI,GAAGxD,MAAM,CAACuN,KAAP,CAAaD,WAAb,CAAyBjK,OAAO,CAACpC,IAAR,CAAauH,UAAtC,CAAb;AACA,UAAMlF,IAAI,GAAGtD,MAAM,CAACqE,KAAP,CAAaiJ,WAAb,CAAyBjK,OAAO,CAACpC,IAAR,CAAa4H,OAAtC,CAAb;AACA,QAAIR,KAAJ;;AAEA,QAAIhF,OAAO,CAACpC,IAAR,CAAaoH,KAAb,IAAsBhF,OAAO,CAACpC,IAAR,CAAaoH,KAAb,CAAmBxG,GAA7C,EAAkD;AACjDwG,MAAAA,KAAK,GAAGrI,MAAM,CAACqE,KAAP,CAAaiJ,WAAb,CAAyBjK,OAAO,CAACpC,IAAR,CAAaoH,KAAb,CAAmBxG,GAA5C,CAAR;AACA;;AAED,SAAKyI,iBAAL,CAAuBjH,OAAO,CAACN,GAA/B,EAAoCP,WAApC,EAAiD;AAAElB,MAAAA,KAAF;AAAS6C,MAAAA,OAAT;AAAkBX,MAAAA,IAAlB;AAAwB6E,MAAAA,KAAxB;AAA+B/E,MAAAA;AAA/B,KAAjD;AACA;;AA96BwC;;AAg7B1C,MAAMjE,cAAc,GAAG,IAAIF,4BAAJ,EAAvB","sourcesContent":["import vm from 'vm';\n\nimport { Meteor } from 'meteor/meteor';\nimport { Random } from 'meteor/random';\nimport { fetch } from 'meteor/fetch';\nimport { HTTP } from 'meteor/http';\nimport _ from 'underscore';\nimport s from 'underscore.string';\nimport moment from 'moment';\nimport Fiber from 'fibers';\nimport Future from 'fibers/future';\n\nimport * as Models from '../../../models/server';\nimport { Integrations, IntegrationHistory } from '../../../models/server/raw';\nimport { settings } from '../../../settings/server';\nimport { getRoomByNameOrIdWithOptionToJoin, processWebhookMessage } from '../../../lib/server';\nimport { outgoingLogger } from '../logger';\nimport { integrations } from '../../lib/rocketchat';\nimport { getUnsafeAgent } from '../../../../server/lib/getUnsafeAgent';\n\nexport class RocketChatIntegrationHandler {\n\tconstructor() {\n\t\tthis.vm = vm;\n\t\tthis.successResults = [200, 201, 202];\n\t\tthis.compiledScripts = {};\n\t\tthis.triggers = {};\n\n\t\tPromise.await(Integrations.find({ type: 'webhook-outgoing' }).forEach((data) => this.addIntegration(data)));\n\t}\n\n\taddIntegration(record) {\n\t\toutgoingLogger.debug(`Adding the integration ${record.name} of the event ${record.event}!`);\n\t\tlet channels;\n\t\tif (record.event && !integrations.outgoingEvents[record.event].use.channel) {\n\t\t\toutgoingLogger.debug('The integration doesnt rely on channels.');\n\t\t\t// We don't use any channels, so it's special ;)\n\t\t\tchannels = ['__any'];\n\t\t} else if (_.isEmpty(record.channel)) {\n\t\t\toutgoingLogger.debug('The integration had an empty channel property, so it is going on all the public channels.');\n\t\t\tchannels = ['all_public_channels'];\n\t\t} else {\n\t\t\toutgoingLogger.debug('The integration is going on these channels:', record.channel);\n\t\t\tchannels = [].concat(record.channel);\n\t\t}\n\n\t\tfor (const channel of channels) {\n\t\t\tif (!this.triggers[channel]) {\n\t\t\t\tthis.triggers[channel] = {};\n\t\t\t}\n\n\t\t\tthis.triggers[channel][record._id] = record;\n\t\t}\n\t}\n\n\tremoveIntegration(record) {\n\t\tfor (const trigger of Object.values(this.triggers)) {\n\t\t\tdelete trigger[record._id];\n\t\t}\n\t}\n\n\tisTriggerEnabled(trigger) {\n\t\tfor (const trig of Object.values(this.triggers)) {\n\t\t\tif (trig[trigger._id]) {\n\t\t\t\treturn trig[trigger._id].enabled;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tupdateHistory({\n\t\thistoryId,\n\t\tstep,\n\t\tintegration,\n\t\tevent,\n\t\tdata,\n\t\ttriggerWord,\n\t\tranPrepareScript,\n\t\tprepareSentMessage,\n\t\tprocessSentMessage,\n\t\tresultMessage,\n\t\tfinished,\n\t\turl,\n\t\thttpCallData,\n\t\thttpError,\n\t\thttpResult,\n\t\terror,\n\t\terrorStack,\n\t}) {\n\t\tconst history = {\n\t\t\ttype: 'outgoing-webhook',\n\t\t\tstep,\n\t\t};\n\n\t\t// Usually is only added on initial insert\n\t\tif (integration) {\n\t\t\thistory.integration = integration;\n\t\t}\n\n\t\t// Usually is only added on initial insert\n\t\tif (event) {\n\t\t\thistory.event = event;\n\t\t}\n\n\t\tif (data) {\n\t\t\thistory.data = { ...data };\n\n\t\t\tif (data.user) {\n\t\t\t\thistory.data.user = _.omit(data.user, ['services']);\n\t\t\t}\n\n\t\t\tif (data.room) {\n\t\t\t\thistory.data.room = data.room;\n\t\t\t}\n\t\t}\n\n\t\tif (triggerWord) {\n\t\t\thistory.triggerWord = triggerWord;\n\t\t}\n\n\t\tif (typeof ranPrepareScript !== 'undefined') {\n\t\t\thistory.ranPrepareScript = ranPrepareScript;\n\t\t}\n\n\t\tif (prepareSentMessage) {\n\t\t\thistory.prepareSentMessage = prepareSentMessage;\n\t\t}\n\n\t\tif (processSentMessage) {\n\t\t\thistory.processSentMessage = processSentMessage;\n\t\t}\n\n\t\tif (resultMessage) {\n\t\t\thistory.resultMessage = resultMessage;\n\t\t}\n\n\t\tif (typeof finished !== 'undefined') {\n\t\t\thistory.finished = finished;\n\t\t}\n\n\t\tif (url) {\n\t\t\thistory.url = url;\n\t\t}\n\n\t\tif (typeof httpCallData !== 'undefined') {\n\t\t\thistory.httpCallData = httpCallData;\n\t\t}\n\n\t\tif (httpError) {\n\t\t\thistory.httpError = httpError;\n\t\t}\n\n\t\tif (typeof httpResult !== 'undefined') {\n\t\t\thistory.httpResult = JSON.stringify(httpResult, null, 2);\n\t\t}\n\n\t\tif (typeof error !== 'undefined') {\n\t\t\thistory.error = error;\n\t\t}\n\n\t\tif (typeof errorStack !== 'undefined') {\n\t\t\thistory.errorStack = errorStack;\n\t\t}\n\n\t\tif (historyId) {\n\t\t\tPromise.await(IntegrationHistory.updateOne({ _id: historyId }, { $set: history }));\n\t\t\treturn historyId;\n\t\t}\n\n\t\thistory._createdAt = new Date();\n\n\t\tconst _id = Random.id();\n\n\t\tPromise.await(IntegrationHistory.insertOne({ _id, ...history }));\n\n\t\treturn _id;\n\t}\n\n\t// Trigger is the trigger, nameOrId is a string which is used to try and find a room, room is a room, message is a message, and data contains \"user_name\" if trigger.impersonateUser is truthful.\n\tsendMessage({ trigger, nameOrId = '', room, message, data }) {\n\t\tlet user;\n\t\t// Try to find the user who we are impersonating\n\t\tif (trigger.impersonateUser) {\n\t\t\tuser = Models.Users.findOneByUsernameIgnoringCase(data.user_name);\n\t\t}\n\n\t\t// If they don't exist (aka the trigger didn't contain a user) then we set the user based upon the\n\t\t// configured username for the integration since this is required at all times.\n\t\tif (!user) {\n\t\t\tuser = Models.Users.findOneByUsernameIgnoringCase(trigger.username);\n\t\t}\n\n\t\tlet tmpRoom;\n\t\tif (nameOrId || trigger.targetRoom || message.channel) {\n\t\t\ttmpRoom =\n\t\t\t\tgetRoomByNameOrIdWithOptionToJoin({\n\t\t\t\t\tcurrentUserId: user._id,\n\t\t\t\t\tnameOrId: nameOrId || message.channel || trigger.targetRoom,\n\t\t\t\t\terrorOnEmpty: false,\n\t\t\t\t}) || room;\n\t\t} else {\n\t\t\ttmpRoom = room;\n\t\t}\n\n\t\t// If no room could be found, we won't be sending any messages but we'll warn in the logs\n\t\tif (!tmpRoom) {\n\t\t\toutgoingLogger.warn(\n\t\t\t\t`The Integration \"${trigger.name}\" doesn't have a room configured nor did it provide a room to send the message to.`,\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\toutgoingLogger.debug(`Found a room for ${trigger.name} which is: ${tmpRoom.name} with a type of ${tmpRoom.t}`);\n\n\t\tmessage.bot = { i: trigger._id };\n\n\t\tconst defaultValues = {\n\t\t\talias: trigger.alias,\n\t\t\tavatar: trigger.avatar,\n\t\t\temoji: trigger.emoji,\n\t\t};\n\n\t\tif (tmpRoom.t === 'd') {\n\t\t\tmessage.channel = `@${tmpRoom._id}`;\n\t\t} else {\n\t\t\tmessage.channel = `#${tmpRoom._id}`;\n\t\t}\n\n\t\tmessage = processWebhookMessage(message, user, defaultValues);\n\t\treturn message;\n\t}\n\n\tbuildSandbox(store = {}) {\n\t\tconst sandbox = {\n\t\t\tscriptTimeout(reject) {\n\t\t\t\treturn setTimeout(() => reject('timed out'), 3000);\n\t\t\t},\n\t\t\t_,\n\t\t\ts,\n\t\t\tconsole,\n\t\t\tmoment,\n\t\t\tFiber,\n\t\t\tPromise,\n\t\t\tStore: {\n\t\t\t\tset: (key, val) => {\n\t\t\t\t\tstore[key] = val;\n\t\t\t\t},\n\t\t\t\tget: (key) => store[key],\n\t\t\t},\n\t\t\tHTTP: (method, url, options) => {\n\t\t\t\ttry {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tresult: HTTP.call(method, url, options),\n\t\t\t\t\t};\n\t\t\t\t} catch (error) {\n\t\t\t\t\treturn { error };\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\n\t\tObject.keys(Models)\n\t\t\t.filter((k) => !k.startsWith('_'))\n\t\t\t.forEach((k) => {\n\t\t\t\tsandbox[k] = Models[k];\n\t\t\t});\n\n\t\treturn { store, sandbox };\n\t}\n\n\tgetIntegrationScript(integration) {\n\t\tconst compiledScript = this.compiledScripts[integration._id];\n\t\tif (compiledScript && +compiledScript._updatedAt === +integration._updatedAt) {\n\t\t\treturn compiledScript.script;\n\t\t}\n\n\t\tconst script = integration.scriptCompiled;\n\t\tconst { store, sandbox } = this.buildSandbox();\n\n\t\tlet vmScript;\n\t\ttry {\n\t\t\toutgoingLogger.info({ msg: 'Will evaluate script of Trigger', name: integration.name });\n\t\t\toutgoingLogger.debug(script);\n\n\t\t\tvmScript = this.vm.createScript(script, 'script.js');\n\n\t\t\tvmScript.runInNewContext(sandbox);\n\n\t\t\tif (sandbox.Script) {\n\t\t\t\tthis.compiledScripts[integration._id] = {\n\t\t\t\t\tscript: new sandbox.Script(),\n\t\t\t\t\tstore,\n\t\t\t\t\t_updatedAt: integration._updatedAt,\n\t\t\t\t};\n\n\t\t\t\treturn this.compiledScripts[integration._id].script;\n\t\t\t}\n\t\t} catch (err) {\n\t\t\toutgoingLogger.error({\n\t\t\t\tmsg: 'Error evaluating Script in Trigger',\n\t\t\t\tname: integration.name,\n\t\t\t\tscript,\n\t\t\t\terr,\n\t\t\t});\n\t\t\tthrow new Meteor.Error('error-evaluating-script');\n\t\t}\n\n\t\tif (!sandbox.Script) {\n\t\t\toutgoingLogger.error(`Class \"Script\" not in Trigger ${integration.name}:`);\n\t\t\tthrow new Meteor.Error('class-script-not-found');\n\t\t}\n\t}\n\n\thasScriptAndMethod(integration, method) {\n\t\tif (integration.scriptEnabled !== true || !integration.scriptCompiled || integration.scriptCompiled.trim() === '') {\n\t\t\treturn false;\n\t\t}\n\n\t\tlet script;\n\t\ttry {\n\t\t\tscript = this.getIntegrationScript(integration);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn typeof script[method] !== 'undefined';\n\t}\n\n\texecuteScript(integration, method, params, historyId) {\n\t\tlet script;\n\t\ttry {\n\t\t\tscript = this.getIntegrationScript(integration);\n\t\t} catch (e) {\n\t\t\tthis.updateHistory({\n\t\t\t\thistoryId,\n\t\t\t\tstep: 'execute-script-getting-script',\n\t\t\t\terror: true,\n\t\t\t\terrorStack: e,\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tif (!script[method]) {\n\t\t\toutgoingLogger.error(`Method \"${method}\" no found in the Integration \"${integration.name}\"`);\n\t\t\tthis.updateHistory({ historyId, step: `execute-script-no-method-${method}` });\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tconst { sandbox } = this.buildSandbox(this.compiledScripts[integration._id].store);\n\t\t\tsandbox.script = script;\n\t\t\tsandbox.method = method;\n\t\t\tsandbox.params = params;\n\n\t\t\tthis.updateHistory({ historyId, step: `execute-script-before-running-${method}` });\n\n\t\t\tconst result = Future.fromPromise(\n\t\t\t\tthis.vm.runInNewContext(\n\t\t\t\t\t`\n\t\t\t\tnew Promise((resolve, reject) => {\n\t\t\t\t\tFiber(() => {\n\t\t\t\t\t\tscriptTimeout(reject);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresolve(script[method](params))\n\t\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\t\treject(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}).run();\n\t\t\t\t}).catch((error) => { throw new Error(error); });\n\t\t\t`,\n\t\t\t\t\tsandbox,\n\t\t\t\t\t{\n\t\t\t\t\t\ttimeout: 3000,\n\t\t\t\t\t},\n\t\t\t\t),\n\t\t\t).wait();\n\n\t\t\toutgoingLogger.debug({\n\t\t\t\tmsg: `Script method \"${method}\" result of the Integration \"${integration.name}\" is:`,\n\t\t\t\tresult,\n\t\t\t});\n\n\t\t\treturn result;\n\t\t} catch (err) {\n\t\t\tthis.updateHistory({\n\t\t\t\thistoryId,\n\t\t\t\tstep: `execute-script-error-running-${method}`,\n\t\t\t\terror: true,\n\t\t\t\terrorStack: err.stack.replace(/^/gm, '  '),\n\t\t\t});\n\t\t\toutgoingLogger.error({\n\t\t\t\tmsg: 'Error running Script in the Integration',\n\t\t\t\tname: integration.name,\n\t\t\t\terr,\n\t\t\t});\n\t\t\toutgoingLogger.debug({\n\t\t\t\tmsg: 'Error running Script in the Integration',\n\t\t\t\tname: integration.name,\n\t\t\t\tscript: integration.scriptCompiled,\n\t\t\t}); // Only output the compiled script if debugging is enabled, so the logs don't get spammed.\n\t\t}\n\t}\n\n\teventNameArgumentsToObject(...args) {\n\t\tconst argObject = {\n\t\t\tevent: args[0],\n\t\t};\n\n\t\tswitch (argObject.event) {\n\t\t\tcase 'sendMessage':\n\t\t\t\tif (args.length >= 3) {\n\t\t\t\t\targObject.message = args[1];\n\t\t\t\t\targObject.room = args[2];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'fileUploaded':\n\t\t\t\tif (args.length >= 2) {\n\t\t\t\t\tconst arghhh = args[1];\n\t\t\t\t\targObject.user = arghhh.user;\n\t\t\t\t\targObject.room = arghhh.room;\n\t\t\t\t\targObject.message = arghhh.message;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'roomArchived':\n\t\t\t\tif (args.length >= 3) {\n\t\t\t\t\targObject.room = args[1];\n\t\t\t\t\targObject.user = args[2];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'roomCreated':\n\t\t\t\tif (args.length >= 3) {\n\t\t\t\t\targObject.owner = args[1];\n\t\t\t\t\targObject.room = args[2];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'roomJoined':\n\t\t\tcase 'roomLeft':\n\t\t\t\tif (args.length >= 3) {\n\t\t\t\t\targObject.user = args[1];\n\t\t\t\t\targObject.room = args[2];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'userCreated':\n\t\t\t\tif (args.length >= 2) {\n\t\t\t\t\targObject.user = args[1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\toutgoingLogger.warn(`An Unhandled Trigger Event was called: ${argObject.event}`);\n\t\t\t\targObject.event = undefined;\n\t\t\t\tbreak;\n\t\t}\n\n\t\toutgoingLogger.debug({\n\t\t\tmsg: `Got the event arguments for the event: ${argObject.event}`,\n\t\t\targObject,\n\t\t});\n\n\t\treturn argObject;\n\t}\n\n\tmapEventArgsToData(data, { event, message, room, owner, user }) {\n\t\tswitch (event) {\n\t\t\tcase 'sendMessage':\n\t\t\t\tdata.channel_id = room._id;\n\t\t\t\tdata.channel_name = room.name;\n\t\t\t\tdata.message_id = message._id;\n\t\t\t\tdata.timestamp = message.ts;\n\t\t\t\tdata.user_id = message.u._id;\n\t\t\t\tdata.user_name = message.u.username;\n\t\t\t\tdata.text = message.msg;\n\t\t\t\tdata.siteUrl = settings.get('Site_Url');\n\n\t\t\t\tif (message.alias) {\n\t\t\t\t\tdata.alias = message.alias;\n\t\t\t\t}\n\n\t\t\t\tif (message.bot) {\n\t\t\t\t\tdata.bot = message.bot;\n\t\t\t\t}\n\n\t\t\t\tif (message.editedAt) {\n\t\t\t\t\tdata.isEdited = true;\n\t\t\t\t}\n\n\t\t\t\tif (message.tmid) {\n\t\t\t\t\tdata.tmid = message.tmid;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'fileUploaded':\n\t\t\t\tdata.channel_id = room._id;\n\t\t\t\tdata.channel_name = room.name;\n\t\t\t\tdata.message_id = message._id;\n\t\t\t\tdata.timestamp = message.ts;\n\t\t\t\tdata.user_id = message.u._id;\n\t\t\t\tdata.user_name = message.u.username;\n\t\t\t\tdata.text = message.msg;\n\t\t\t\tdata.user = user;\n\t\t\t\tdata.room = room;\n\t\t\t\tdata.message = message;\n\n\t\t\t\tif (message.alias) {\n\t\t\t\t\tdata.alias = message.alias;\n\t\t\t\t}\n\n\t\t\t\tif (message.bot) {\n\t\t\t\t\tdata.bot = message.bot;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'roomCreated':\n\t\t\t\tdata.channel_id = room._id;\n\t\t\t\tdata.channel_name = room.name;\n\t\t\t\tdata.timestamp = room.ts;\n\t\t\t\tdata.user_id = owner._id;\n\t\t\t\tdata.user_name = owner.username;\n\t\t\t\tdata.owner = owner;\n\t\t\t\tdata.room = room;\n\t\t\t\tbreak;\n\t\t\tcase 'roomArchived':\n\t\t\tcase 'roomJoined':\n\t\t\tcase 'roomLeft':\n\t\t\t\tdata.timestamp = new Date();\n\t\t\t\tdata.channel_id = room._id;\n\t\t\t\tdata.channel_name = room.name;\n\t\t\t\tdata.user_id = user._id;\n\t\t\t\tdata.user_name = user.username;\n\t\t\t\tdata.user = user;\n\t\t\t\tdata.room = room;\n\n\t\t\t\tif (user.type === 'bot') {\n\t\t\t\t\tdata.bot = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'userCreated':\n\t\t\t\tdata.timestamp = user.createdAt;\n\t\t\t\tdata.user_id = user._id;\n\t\t\t\tdata.user_name = user.username;\n\t\t\t\tdata.user = user;\n\n\t\t\t\tif (user.type === 'bot') {\n\t\t\t\t\tdata.bot = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tgetTriggersToExecute(room, message) {\n\t\tconst triggersToExecute = new Set();\n\t\tif (room) {\n\t\t\tswitch (room.t) {\n\t\t\t\tcase 'd':\n\t\t\t\t\tif (this.triggers.all_direct_messages) {\n\t\t\t\t\t\tfor (const trigger of Object.values(this.triggers.all_direct_messages)) {\n\t\t\t\t\t\t\ttriggersToExecute.add(trigger);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\troom.uids\n\t\t\t\t\t\t.filter((uid) => this.triggers[`@${uid}`])\n\t\t\t\t\t\t.forEach((uid) => {\n\t\t\t\t\t\t\tfor (const trigger of Object.values(this.triggers[`@${uid}`])) {\n\t\t\t\t\t\t\t\ttriggersToExecute.add(trigger);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\troom.usernames\n\t\t\t\t\t\t.filter((username) => username !== message.u.username && this.triggers[`@${username}`])\n\t\t\t\t\t\t.forEach((username) => {\n\t\t\t\t\t\t\tfor (const trigger of Object.values(this.triggers[`@${username}`])) {\n\t\t\t\t\t\t\t\ttriggersToExecute.add(trigger);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'c':\n\t\t\t\t\tif (this.triggers.all_public_channels) {\n\t\t\t\t\t\tfor (const trigger of Object.values(this.triggers.all_public_channels)) {\n\t\t\t\t\t\t\ttriggersToExecute.add(trigger);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.triggers[`#${room._id}`]) {\n\t\t\t\t\t\tfor (const trigger of Object.values(this.triggers[`#${room._id}`])) {\n\t\t\t\t\t\t\ttriggersToExecute.add(trigger);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (room._id !== room.name && this.triggers[`#${room.name}`]) {\n\t\t\t\t\t\tfor (const trigger of Object.values(this.triggers[`#${room.name}`])) {\n\t\t\t\t\t\t\ttriggersToExecute.add(trigger);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tif (this.triggers.all_private_groups) {\n\t\t\t\t\t\tfor (const trigger of Object.values(this.triggers.all_private_groups)) {\n\t\t\t\t\t\t\ttriggersToExecute.add(trigger);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.triggers[`#${room._id}`]) {\n\t\t\t\t\t\tfor (const trigger of Object.values(this.triggers[`#${room._id}`])) {\n\t\t\t\t\t\t\ttriggersToExecute.add(trigger);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (room._id !== room.name && this.triggers[`#${room.name}`]) {\n\t\t\t\t\t\tfor (const trigger of Object.values(this.triggers[`#${room.name}`])) {\n\t\t\t\t\t\t\ttriggersToExecute.add(trigger);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn [...triggersToExecute];\n\t}\n\n\texecuteTriggers(...args) {\n\t\toutgoingLogger.debug({ msg: 'Execute Trigger:', arg: args[0] });\n\n\t\tconst argObject = this.eventNameArgumentsToObject(...args);\n\t\tconst { event, message, room } = argObject;\n\n\t\t// Each type of event should have an event and a room attached, otherwise we\n\t\t// wouldn't know how to handle the trigger nor would we have anywhere to send the\n\t\t// result of the integration\n\t\tif (!event) {\n\t\t\treturn;\n\t\t}\n\n\t\toutgoingLogger.debug(`Starting search for triggers for the room: ${room ? room._id : '__any'}`);\n\n\t\tconst triggersToExecute = this.getTriggersToExecute(room, message);\n\n\t\tif (this.triggers.__any) {\n\t\t\t// For outgoing integration which don't rely on rooms.\n\t\t\tfor (const trigger of Object.values(this.triggers.__any)) {\n\t\t\t\ttriggersToExecute.push(trigger);\n\t\t\t}\n\t\t}\n\n\t\toutgoingLogger.debug(`Found ${triggersToExecute.length} to iterate over and see if the match the event.`);\n\n\t\tfor (const triggerToExecute of triggersToExecute) {\n\t\t\toutgoingLogger.debug(\n\t\t\t\t`Is \"${triggerToExecute.name}\" enabled, ${triggerToExecute.enabled}, and what is the event? ${triggerToExecute.event}`,\n\t\t\t);\n\t\t\tif (triggerToExecute.enabled === true && triggerToExecute.event === event) {\n\t\t\t\tthis.executeTrigger(triggerToExecute, argObject);\n\t\t\t}\n\t\t}\n\t}\n\n\texecuteTrigger(trigger, argObject) {\n\t\tfor (const url of trigger.urls) {\n\t\t\tthis.executeTriggerUrl(url, trigger, argObject, 0);\n\t\t}\n\t}\n\n\texecuteTriggerUrl(url, trigger, { event, message, room, owner, user }, theHistoryId, tries = 0) {\n\t\tif (!this.isTriggerEnabled(trigger)) {\n\t\t\toutgoingLogger.warn(`The trigger \"${trigger.name}\" is no longer enabled, stopping execution of it at try: ${tries}`);\n\t\t\treturn;\n\t\t}\n\n\t\toutgoingLogger.debug(`Starting to execute trigger: ${trigger.name} (${trigger._id})`);\n\n\t\tlet word;\n\t\t// Not all triggers/events support triggerWords\n\t\tif (integrations.outgoingEvents[event].use.triggerWords) {\n\t\t\tif (trigger.triggerWords && trigger.triggerWords.length > 0) {\n\t\t\t\tfor (const triggerWord of trigger.triggerWords) {\n\t\t\t\t\tif (!trigger.triggerWordAnywhere && message.msg.indexOf(triggerWord) === 0) {\n\t\t\t\t\t\tword = triggerWord;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (trigger.triggerWordAnywhere && message.msg.includes(triggerWord)) {\n\t\t\t\t\t\tword = triggerWord;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Stop if there are triggerWords but none match\n\t\t\t\tif (!word) {\n\t\t\t\t\toutgoingLogger.debug(`The trigger word which \"${trigger.name}\" was expecting could not be found, not executing.`);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (message && message.editedAt && !trigger.runOnEdits) {\n\t\t\toutgoingLogger.debug(`The trigger \"${trigger.name}\"'s run on edits is disabled and the message was edited.`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst historyId = this.updateHistory({\n\t\t\tstep: 'start-execute-trigger-url',\n\t\t\tintegration: trigger,\n\t\t\tevent,\n\t\t});\n\n\t\tconst data = {\n\t\t\ttoken: trigger.token,\n\t\t\tbot: false,\n\t\t};\n\n\t\tif (word) {\n\t\t\tdata.trigger_word = word;\n\t\t}\n\n\t\tthis.mapEventArgsToData(data, { trigger, event, message, room, owner, user });\n\t\tthis.updateHistory({ historyId, step: 'mapped-args-to-data', data, triggerWord: word });\n\n\t\toutgoingLogger.info(`Will be executing the Integration \"${trigger.name}\" to the url: ${url}`);\n\t\toutgoingLogger.debug(data);\n\n\t\tlet opts = {\n\t\t\tparams: {},\n\t\t\tmethod: 'POST',\n\t\t\turl,\n\t\t\tdata,\n\t\t\tauth: undefined,\n\t\t\theaders: {\n\t\t\t\t'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2227.0 Safari/537.36',\n\t\t\t},\n\t\t};\n\n\t\tif (this.hasScriptAndMethod(trigger, 'prepare_outgoing_request')) {\n\t\t\topts = this.executeScript(trigger, 'prepare_outgoing_request', { request: opts }, historyId);\n\t\t}\n\n\t\tthis.updateHistory({ historyId, step: 'after-maybe-ran-prepare', ranPrepareScript: true });\n\n\t\tif (!opts) {\n\t\t\tthis.updateHistory({ historyId, step: 'after-prepare-no-opts', finished: true });\n\t\t\treturn;\n\t\t}\n\n\t\tif (opts.message) {\n\t\t\tconst prepareMessage = this.sendMessage({ trigger, room, message: opts.message, data });\n\t\t\tthis.updateHistory({\n\t\t\t\thistoryId,\n\t\t\t\tstep: 'after-prepare-send-message',\n\t\t\t\tprepareSentMessage: prepareMessage,\n\t\t\t});\n\t\t}\n\n\t\tif (!opts.url || !opts.method) {\n\t\t\tthis.updateHistory({ historyId, step: 'after-prepare-no-url_or_method', finished: true });\n\t\t\treturn;\n\t\t}\n\n\t\t// based on HTTP.call implementation\n\t\tif (opts.auth) {\n\t\t\tif (opts.auth.indexOf(':') < 0) {\n\t\t\t\tthrow new Error('auth option should be of the form \"username:password\"');\n\t\t\t}\n\n\t\t\tconst base64 = Buffer.from(opts.auth, 'ascii').toString('base64');\n\t\t\topts.headers.Authorization = `Basic ${base64}`;\n\t\t}\n\n\t\tthis.updateHistory({\n\t\t\thistoryId,\n\t\t\tstep: 'pre-http-call',\n\t\t\turl: opts.url,\n\t\t\thttpCallData: opts.data,\n\t\t});\n\n\t\tif (opts.data) {\n\t\t\topts.headers['Content-Type'] = 'application/json';\n\t\t}\n\n\t\tfetch(opts.url, {\n\t\t\tmethod: opts.method,\n\t\t\theaders: opts.headers,\n\t\t\t...(settings.get('Allow_Invalid_SelfSigned_Certs') && {\n\t\t\t\tagent: getUnsafeAgent(opts.url.startsWith('https:') ? 'https:' : 'http:'),\n\t\t\t}),\n\t\t\t...(opts.data && { body: JSON.stringify(opts.data) }),\n\t\t})\n\t\t\t.then(async (res) => {\n\t\t\t\tconst content = await res.text();\n\t\t\t\tif (!content) {\n\t\t\t\t\toutgoingLogger.warn(`Result for the Integration ${trigger.name} to ${url} is empty`);\n\t\t\t\t} else {\n\t\t\t\t\toutgoingLogger.info(`Status code for the Integration ${trigger.name} to ${url} is ${res.status}`);\n\t\t\t\t}\n\n\t\t\t\tconst data = (() => {\n\t\t\t\t\tconst contentType = (res.headers.get('content-type') || '').split(';')[0];\n\t\t\t\t\tif (!['application/json', 'text/javascript', 'application/javascript', 'application/x-javascript'].includes(contentType)) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn JSON.parse(content);\n\t\t\t\t\t} catch (_error) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t})();\n\n\t\t\t\tthis.updateHistory({\n\t\t\t\t\thistoryId,\n\t\t\t\t\tstep: 'after-http-call',\n\t\t\t\t\thttpError: null,\n\t\t\t\t\thttpResult: content,\n\t\t\t\t});\n\n\t\t\t\tif (this.hasScriptAndMethod(trigger, 'process_outgoing_response')) {\n\t\t\t\t\tconst sandbox = {\n\t\t\t\t\t\trequest: opts,\n\t\t\t\t\t\tresponse: {\n\t\t\t\t\t\t\terror: null,\n\t\t\t\t\t\t\tstatus_code: res.status, // These values will be undefined to close issues #4175, #5762, and #5896\n\t\t\t\t\t\t\tcontent,\n\t\t\t\t\t\t\tcontent_raw: content,\n\t\t\t\t\t\t\theaders: Object.fromEntries(res.headers),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\n\t\t\t\t\tconst scriptResult = this.executeScript(trigger, 'process_outgoing_response', sandbox, historyId);\n\n\t\t\t\t\tif (scriptResult && scriptResult.content) {\n\t\t\t\t\t\tconst resultMessage = this.sendMessage({\n\t\t\t\t\t\t\ttrigger,\n\t\t\t\t\t\t\troom,\n\t\t\t\t\t\t\tmessage: scriptResult.content,\n\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t});\n\t\t\t\t\t\tthis.updateHistory({\n\t\t\t\t\t\t\thistoryId,\n\t\t\t\t\t\t\tstep: 'after-process-send-message',\n\t\t\t\t\t\t\tprocessSentMessage: resultMessage,\n\t\t\t\t\t\t\tfinished: true,\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (scriptResult === false) {\n\t\t\t\t\t\tthis.updateHistory({ historyId, step: 'after-process-false-result', finished: true });\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if the result contained nothing or wasn't a successful statusCode\n\t\t\t\tif (!content || !this.successResults.includes(res.status)) {\n\t\t\t\t\tif (content) {\n\t\t\t\t\t\toutgoingLogger.error({\n\t\t\t\t\t\t\tmsg: `Error for the Integration \"${trigger.name}\" to ${url}`,\n\t\t\t\t\t\t\tresult: content,\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tif (res.status === 410) {\n\t\t\t\t\t\t\tthis.updateHistory({ historyId, step: 'after-process-http-status-410', error: true });\n\t\t\t\t\t\t\toutgoingLogger.error(`Disabling the Integration \"${trigger.name}\" because the status code was 401 (Gone).`);\n\t\t\t\t\t\t\tawait Integrations.updateOne({ _id: trigger._id }, { $set: { enabled: false } });\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (res.status === 500) {\n\t\t\t\t\t\t\tthis.updateHistory({ historyId, step: 'after-process-http-status-500', error: true });\n\t\t\t\t\t\t\toutgoingLogger.error({\n\t\t\t\t\t\t\t\tmsg: `Error \"500\" for the Integration \"${trigger.name}\" to ${url}.`,\n\t\t\t\t\t\t\t\tcontent,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (trigger.retryFailedCalls) {\n\t\t\t\t\t\tif (tries < trigger.retryCount && trigger.retryDelay) {\n\t\t\t\t\t\t\tthis.updateHistory({ historyId, error: true, step: `going-to-retry-${tries + 1}` });\n\n\t\t\t\t\t\t\tlet waitTime;\n\n\t\t\t\t\t\t\tswitch (trigger.retryDelay) {\n\t\t\t\t\t\t\t\tcase 'powers-of-ten':\n\t\t\t\t\t\t\t\t\t// Try again in 0.1s, 1s, 10s, 1m40s, 16m40s, 2h46m40s, 27h46m40s, etc\n\t\t\t\t\t\t\t\t\twaitTime = Math.pow(10, tries + 2);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'powers-of-two':\n\t\t\t\t\t\t\t\t\t// 2 seconds, 4 seconds, 8 seconds\n\t\t\t\t\t\t\t\t\twaitTime = Math.pow(2, tries + 1) * 1000;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'increments-of-two':\n\t\t\t\t\t\t\t\t\t// 2 second, 4 seconds, 6 seconds, etc\n\t\t\t\t\t\t\t\t\twaitTime = (tries + 1) * 2 * 1000;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tconst er = new Error(\"The integration's retryDelay setting is invalid.\");\n\t\t\t\t\t\t\t\t\tthis.updateHistory({\n\t\t\t\t\t\t\t\t\t\thistoryId,\n\t\t\t\t\t\t\t\t\t\tstep: 'failed-and-retry-delay-is-invalid',\n\t\t\t\t\t\t\t\t\t\terror: true,\n\t\t\t\t\t\t\t\t\t\terrorStack: er.stack,\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\toutgoingLogger.info(`Trying the Integration ${trigger.name} to ${url} again in ${waitTime} milliseconds.`);\n\t\t\t\t\t\t\tMeteor.setTimeout(() => {\n\t\t\t\t\t\t\t\tthis.executeTriggerUrl(url, trigger, { event, message, room, owner, user }, historyId, tries + 1);\n\t\t\t\t\t\t\t}, waitTime);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.updateHistory({ historyId, step: 'too-many-retries', error: true });\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.updateHistory({\n\t\t\t\t\t\t\thistoryId,\n\t\t\t\t\t\t\tstep: 'failed-and-not-configured-to-retry',\n\t\t\t\t\t\t\terror: true,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// process outgoing webhook response as a new message\n\t\t\t\tif (content && this.successResults.includes(res.status)) {\n\t\t\t\t\tif (data?.text || data?.attachments) {\n\t\t\t\t\t\tconst resultMsg = this.sendMessage({ trigger, room, message: data, data });\n\t\t\t\t\t\tthis.updateHistory({\n\t\t\t\t\t\t\thistoryId,\n\t\t\t\t\t\t\tstep: 'url-response-sent-message',\n\t\t\t\t\t\t\tresultMessage: resultMsg,\n\t\t\t\t\t\t\tfinished: true,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.catch((error) => {\n\t\t\t\toutgoingLogger.error(error);\n\t\t\t\tthis.updateHistory({\n\t\t\t\t\thistoryId,\n\t\t\t\t\tstep: 'after-http-call',\n\t\t\t\t\thttpError: error,\n\t\t\t\t\thttpResult: null,\n\t\t\t\t});\n\t\t\t});\n\t}\n\n\treplay(integration, history) {\n\t\tif (!integration || integration.type !== 'webhook-outgoing') {\n\t\t\tthrow new Meteor.Error('integration-type-must-be-outgoing', 'The integration type to replay must be an outgoing webhook.');\n\t\t}\n\n\t\tif (!history || !history.data) {\n\t\t\tthrow new Meteor.Error('history-data-must-be-defined', 'The history data must be defined to replay an integration.');\n\t\t}\n\n\t\tconst { event } = history;\n\t\tconst message = Models.Messages.findOneById(history.data.message_id);\n\t\tconst room = Models.Rooms.findOneById(history.data.channel_id);\n\t\tconst user = Models.Users.findOneById(history.data.user_id);\n\t\tlet owner;\n\n\t\tif (history.data.owner && history.data.owner._id) {\n\t\t\towner = Models.Users.findOneById(history.data.owner._id);\n\t\t}\n\n\t\tthis.executeTriggerUrl(history.url, integration, { event, message, room, owner, user });\n\t}\n}\nconst triggerHandler = new RocketChatIntegrationHandler();\nexport { integrations, triggerHandler };\n"]},"sourceType":"module","hash":"1cbd896e5cbce076470aa0afb85b1d97d5807a1a"}
