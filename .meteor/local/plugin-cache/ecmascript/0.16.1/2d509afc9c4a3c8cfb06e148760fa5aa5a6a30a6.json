{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/weslley/Documents/projects/Rocket.Chat/packages/ddp-server/livedata_server.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"packages/ddp-server/livedata_server.js","filename":"/home/weslley/Documents/projects/Rocket.Chat/packages/ddp-server/livedata_server.js","targets":{"android":"95.0.0","chrome":"95.0.0","edge":"95.0.0","firefox":"78.0.0","ie":"10.0.0","ios":"15.0.0","opera":"81.0.0","safari":"15.1.0","samsung":"14.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/home/weslley/Documents/projects/Rocket.Chat","root":"/home/weslley/Documents/projects/Rocket.Chat","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.16.5","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/home/weslley/Documents/projects/Rocket.Chat/packages/ddp-server/livedata_server.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/ddp-server/livedata_server.js"}},"code":"let _objectSpread;\n\nmodule.link(\"@babel/runtime/helpers/objectSpread2\", {\n  default(v) {\n    _objectSpread = v;\n  }\n\n}, 0);\nDDPServer = {};\n\nvar Fiber = Npm.require('fibers'); // Publication strategies define how we handle data from published cursors at the collection level\n// This allows someone to:\n// - Choose a trade-off between client-server bandwidth and server memory usage\n// - Implement special (non-mongo) collections like volatile message queues\n\n\nconst publicationStrategies = {\n  // SERVER_MERGE is the default strategy.\n  // When using this strategy, the server maintains a copy of all data a connection is subscribed to.\n  // This allows us to only send deltas over multiple publications.\n  SERVER_MERGE: {\n    useCollectionView: true,\n    doAccountingForCollection: true\n  },\n  // The NO_MERGE_NO_HISTORY strategy results in the server sending all publication data\n  // directly to the client. It does not remember what it has previously sent\n  // to it will not trigger removed messages when a subscription is stopped.\n  // This should only be chosen for special use cases like send-and-forget queues.\n  NO_MERGE_NO_HISTORY: {\n    useCollectionView: false,\n    doAccountingForCollection: false\n  },\n  // NO_MERGE is similar to NO_MERGE_NO_HISTORY but the server will remember the IDs it has\n  // sent to the client so it can remove them when a subscription is stopped.\n  // This strategy can be used when a collection is only used in a single publication.\n  NO_MERGE: {\n    useCollectionView: false,\n    doAccountingForCollection: true\n  }\n};\nDDPServer.publicationStrategies = publicationStrategies; // This file contains classes:\n// * Session - The server's connection to a single DDP client\n// * Subscription - A single subscription for a single client\n// * Server - An entire server that may talk to > 1 client. A DDP endpoint.\n//\n// Session and Subscription are file scope. For now, until we freeze\n// the interface, Server is package scope (in the future it should be\n// exported).\n// Represents a single document in a SessionCollectionView\n\nvar SessionDocumentView = function () {\n  var self = this;\n  self.existsIn = new Set(); // set of subscriptionHandle\n\n  self.dataByKey = new Map(); // key-> [ {subscriptionHandle, value} by precedence]\n};\n\nDDPServer._SessionDocumentView = SessionDocumentView;\n\n_.extend(SessionDocumentView.prototype, {\n  getFields: function () {\n    var self = this;\n    var ret = {};\n    self.dataByKey.forEach(function (precedenceList, key) {\n      ret[key] = precedenceList[0].value;\n    });\n    return ret;\n  },\n  clearField: function (subscriptionHandle, key, changeCollector) {\n    var self = this; // Publish API ignores _id if present in fields\n\n    if (key === \"_id\") return;\n    var precedenceList = self.dataByKey.get(key); // It's okay to clear fields that didn't exist. No need to throw\n    // an error.\n\n    if (!precedenceList) return;\n    var removedValue = undefined;\n\n    for (var i = 0; i < precedenceList.length; i++) {\n      var precedence = precedenceList[i];\n\n      if (precedence.subscriptionHandle === subscriptionHandle) {\n        // The view's value can only change if this subscription is the one that\n        // used to have precedence.\n        if (i === 0) removedValue = precedence.value;\n        precedenceList.splice(i, 1);\n        break;\n      }\n    }\n\n    if (precedenceList.length === 0) {\n      self.dataByKey.delete(key);\n      changeCollector[key] = undefined;\n    } else if (removedValue !== undefined && !EJSON.equals(removedValue, precedenceList[0].value)) {\n      changeCollector[key] = precedenceList[0].value;\n    }\n  },\n  changeField: function (subscriptionHandle, key, value, changeCollector, isAdd) {\n    var self = this; // Publish API ignores _id if present in fields\n\n    if (key === \"_id\") return; // Don't share state with the data passed in by the user.\n\n    value = EJSON.clone(value);\n\n    if (!self.dataByKey.has(key)) {\n      self.dataByKey.set(key, [{\n        subscriptionHandle: subscriptionHandle,\n        value: value\n      }]);\n      changeCollector[key] = value;\n      return;\n    }\n\n    var precedenceList = self.dataByKey.get(key);\n    var elt;\n\n    if (!isAdd) {\n      elt = precedenceList.find(function (precedence) {\n        return precedence.subscriptionHandle === subscriptionHandle;\n      });\n    }\n\n    if (elt) {\n      if (elt === precedenceList[0] && !EJSON.equals(value, elt.value)) {\n        // this subscription is changing the value of this field.\n        changeCollector[key] = value;\n      }\n\n      elt.value = value;\n    } else {\n      // this subscription is newly caring about this field\n      precedenceList.push({\n        subscriptionHandle: subscriptionHandle,\n        value: value\n      });\n    }\n  }\n});\n/**\n * Represents a client's view of a single collection\n * @param {String} collectionName Name of the collection it represents\n * @param {Object.<String, Function>} sessionCallbacks The callbacks for added, changed, removed\n * @class SessionCollectionView\n */\n\n\nvar SessionCollectionView = function (collectionName, sessionCallbacks) {\n  var self = this;\n  self.collectionName = collectionName;\n  self.documents = new Map();\n  self.callbacks = sessionCallbacks;\n};\n\nDDPServer._SessionCollectionView = SessionCollectionView;\nObject.assign(SessionCollectionView.prototype, {\n  isEmpty: function () {\n    var self = this;\n    return self.documents.size === 0;\n  },\n  diff: function (previous) {\n    var self = this;\n    DiffSequence.diffMaps(previous.documents, self.documents, {\n      both: _.bind(self.diffDocument, self),\n      rightOnly: function (id, nowDV) {\n        self.callbacks.added(self.collectionName, id, nowDV.getFields());\n      },\n      leftOnly: function (id, prevDV) {\n        self.callbacks.removed(self.collectionName, id);\n      }\n    });\n  },\n  diffDocument: function (id, prevDV, nowDV) {\n    var self = this;\n    var fields = {};\n    DiffSequence.diffObjects(prevDV.getFields(), nowDV.getFields(), {\n      both: function (key, prev, now) {\n        if (!EJSON.equals(prev, now)) fields[key] = now;\n      },\n      rightOnly: function (key, now) {\n        fields[key] = now;\n      },\n      leftOnly: function (key, prev) {\n        fields[key] = undefined;\n      }\n    });\n    self.callbacks.changed(self.collectionName, id, fields);\n  },\n  added: function (subscriptionHandle, id, fields) {\n    var self = this;\n    var docView = self.documents.get(id);\n    var added = false;\n\n    if (!docView) {\n      added = true;\n      docView = new SessionDocumentView();\n      self.documents.set(id, docView);\n    }\n\n    docView.existsIn.add(subscriptionHandle);\n    var changeCollector = {};\n\n    _.each(fields, function (value, key) {\n      docView.changeField(subscriptionHandle, key, value, changeCollector, true);\n    });\n\n    if (added) self.callbacks.added(self.collectionName, id, changeCollector);else self.callbacks.changed(self.collectionName, id, changeCollector);\n  },\n  changed: function (subscriptionHandle, id, changed) {\n    var self = this;\n    var changedResult = {};\n    var docView = self.documents.get(id);\n    if (!docView) throw new Error(\"Could not find element with id \" + id + \" to change\");\n\n    _.each(changed, function (value, key) {\n      if (value === undefined) docView.clearField(subscriptionHandle, key, changedResult);else docView.changeField(subscriptionHandle, key, value, changedResult);\n    });\n\n    self.callbacks.changed(self.collectionName, id, changedResult);\n  },\n  removed: function (subscriptionHandle, id) {\n    var self = this;\n    var docView = self.documents.get(id);\n\n    if (!docView) {\n      var err = new Error(\"Removed nonexistent document \" + id);\n      throw err;\n    }\n\n    docView.existsIn.delete(subscriptionHandle);\n\n    if (docView.existsIn.size === 0) {\n      // it is gone from everyone\n      self.callbacks.removed(self.collectionName, id);\n      self.documents.delete(id);\n    } else {\n      var changed = {}; // remove this subscription from every precedence list\n      // and record the changes\n\n      docView.dataByKey.forEach(function (precedenceList, key) {\n        docView.clearField(subscriptionHandle, key, changed);\n      });\n      self.callbacks.changed(self.collectionName, id, changed);\n    }\n  }\n});\n/******************************************************************************/\n\n/* Session                                                                    */\n\n/******************************************************************************/\n\nvar Session = function (server, version, socket, options) {\n  var self = this;\n  self.id = Random.id();\n  self.server = server;\n  self.version = version;\n  self.initialized = false;\n  self.socket = socket; // Set to null when the session is destroyed. Multiple places below\n  // use this to determine if the session is alive or not.\n\n  self.inQueue = new Meteor._DoubleEndedQueue();\n  self.blocked = false;\n  self.workerRunning = false;\n  self.cachedUnblock = null; // Sub objects for active subscriptions\n\n  self._namedSubs = new Map();\n  self._universalSubs = [];\n  self.userId = null;\n  self.collectionViews = new Map(); // Set this to false to not send messages when collectionViews are\n  // modified. This is done when rerunning subs in _setUserId and those messages\n  // are calculated via a diff instead.\n\n  self._isSending = true; // If this is true, don't start a newly-created universal publisher on this\n  // session. The session will take care of starting it when appropriate.\n\n  self._dontStartNewUniversalSubs = false; // When we are rerunning subscriptions, any ready messages\n  // we want to buffer up for when we are done rerunning subscriptions\n\n  self._pendingReady = []; // List of callbacks to call when this connection is closed.\n\n  self._closeCallbacks = []; // XXX HACK: If a sockjs connection, save off the URL. This is\n  // temporary and will go away in the near future.\n\n  self._socketUrl = socket.url; // Allow tests to disable responding to pings.\n\n  self._respondToPings = options.respondToPings; // This object is the public interface to the session. In the public\n  // API, it is called the `connection` object.  Internally we call it\n  // a `connectionHandle` to avoid ambiguity.\n\n  self.connectionHandle = {\n    id: self.id,\n    close: function () {\n      self.close();\n    },\n    onClose: function (fn) {\n      var cb = Meteor.bindEnvironment(fn, \"connection onClose callback\");\n\n      if (self.inQueue) {\n        self._closeCallbacks.push(cb);\n      } else {\n        // if we're already closed, call the callback.\n        Meteor.defer(cb);\n      }\n    },\n    clientAddress: self._clientAddress(),\n    httpHeaders: self.socket.headers\n  };\n  self.send({\n    msg: 'connected',\n    session: self.id\n  }); // On initial connect, spin up all the universal publishers.\n\n  Fiber(function () {\n    self.startUniversalSubs();\n  }).run();\n\n  if (version !== 'pre1' && options.heartbeatInterval !== 0) {\n    // We no longer need the low level timeout because we have heartbeats.\n    socket.setWebsocketTimeout(0);\n    self.heartbeat = new DDPCommon.Heartbeat({\n      heartbeatInterval: options.heartbeatInterval,\n      heartbeatTimeout: options.heartbeatTimeout,\n      onTimeout: function () {\n        self.close();\n      },\n      sendPing: function () {\n        self.send({\n          msg: 'ping'\n        });\n      }\n    });\n    self.heartbeat.start();\n  }\n\n  Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"livedata\", \"sessions\", 1);\n};\n\nObject.assign(Session.prototype, {\n  sendReady: function (subscriptionIds) {\n    var self = this;\n    if (self._isSending) self.send({\n      msg: \"ready\",\n      subs: subscriptionIds\n    });else {\n      _.each(subscriptionIds, function (subscriptionId) {\n        self._pendingReady.push(subscriptionId);\n      });\n    }\n  },\n\n  _canSend(collectionName) {\n    return this._isSending || !this.server.getPublicationStrategy(collectionName).useCollectionView;\n  },\n\n  sendAdded(collectionName, id, fields) {\n    if (this._canSend(collectionName)) this.send({\n      msg: \"added\",\n      collection: collectionName,\n      id,\n      fields\n    });\n  },\n\n  sendChanged(collectionName, id, fields) {\n    if (_.isEmpty(fields)) return;\n\n    if (this._canSend(collectionName)) {\n      this.send({\n        msg: \"changed\",\n        collection: collectionName,\n        id,\n        fields\n      });\n    }\n  },\n\n  sendRemoved(collectionName, id) {\n    if (this._canSend(collectionName)) this.send({\n      msg: \"removed\",\n      collection: collectionName,\n      id\n    });\n  },\n\n  getSendCallbacks: function () {\n    var self = this;\n    return {\n      added: _.bind(self.sendAdded, self),\n      changed: _.bind(self.sendChanged, self),\n      removed: _.bind(self.sendRemoved, self)\n    };\n  },\n  getCollectionView: function (collectionName) {\n    var self = this;\n    var ret = self.collectionViews.get(collectionName);\n\n    if (!ret) {\n      ret = new SessionCollectionView(collectionName, self.getSendCallbacks());\n      self.collectionViews.set(collectionName, ret);\n    }\n\n    return ret;\n  },\n\n  added(subscriptionHandle, collectionName, id, fields) {\n    if (this.server.getPublicationStrategy(collectionName).useCollectionView) {\n      const view = this.getCollectionView(collectionName);\n      view.added(subscriptionHandle, id, fields);\n    } else {\n      this.sendAdded(collectionName, id, fields);\n    }\n  },\n\n  removed(subscriptionHandle, collectionName, id) {\n    if (this.server.getPublicationStrategy(collectionName).useCollectionView) {\n      const view = this.getCollectionView(collectionName);\n      view.removed(subscriptionHandle, id);\n\n      if (view.isEmpty()) {\n        this.collectionViews.delete(collectionName);\n      }\n    } else {\n      this.sendRemoved(collectionName, id);\n    }\n  },\n\n  changed(subscriptionHandle, collectionName, id, fields) {\n    if (this.server.getPublicationStrategy(collectionName).useCollectionView) {\n      const view = this.getCollectionView(collectionName);\n      view.changed(subscriptionHandle, id, fields);\n    } else {\n      this.sendChanged(collectionName, id, fields);\n    }\n  },\n\n  startUniversalSubs: function () {\n    var self = this; // Make a shallow copy of the set of universal handlers and start them. If\n    // additional universal publishers start while we're running them (due to\n    // yielding), they will run separately as part of Server.publish.\n\n    var handlers = _.clone(self.server.universal_publish_handlers);\n\n    _.each(handlers, function (handler) {\n      self._startSubscription(handler);\n    });\n  },\n  // Destroy this session and unregister it at the server.\n  close: function () {\n    var self = this; // Destroy this session, even if it's not registered at the\n    // server. Stop all processing and tear everything down. If a socket\n    // was attached, close it.\n    // Already destroyed.\n\n    if (!self.inQueue) return; // Drop the merge box data immediately.\n\n    self.inQueue = null;\n    self.collectionViews = new Map();\n\n    if (self.heartbeat) {\n      self.heartbeat.stop();\n      self.heartbeat = null;\n    }\n\n    if (self.socket) {\n      self.socket.close();\n      self.socket._meteorSession = null;\n    }\n\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"livedata\", \"sessions\", -1);\n    Meteor.defer(function () {\n      // Stop callbacks can yield, so we defer this on close.\n      // sub._isDeactivated() detects that we set inQueue to null and\n      // treats it as semi-deactivated (it will ignore incoming callbacks, etc).\n      self._deactivateAllSubscriptions(); // Defer calling the close callbacks, so that the caller closing\n      // the session isn't waiting for all the callbacks to complete.\n\n\n      _.each(self._closeCallbacks, function (callback) {\n        callback();\n      });\n    }); // Unregister the session.\n\n    self.server._removeSession(self);\n  },\n  // Send a message (doing nothing if no socket is connected right now).\n  // It should be a JSON object (it will be stringified).\n  send: function (msg) {\n    var self = this;\n\n    if (self.socket) {\n      if (Meteor._printSentDDP) Meteor._debug(\"Sent DDP\", DDPCommon.stringifyDDP(msg));\n      self.socket.send(DDPCommon.stringifyDDP(msg));\n    }\n  },\n  // Send a connection error.\n  sendError: function (reason, offendingMessage) {\n    var self = this;\n    var msg = {\n      msg: 'error',\n      reason: reason\n    };\n    if (offendingMessage) msg.offendingMessage = offendingMessage;\n    self.send(msg);\n  },\n  // Process 'msg' as an incoming message. As a guard against\n  // race conditions during reconnection, ignore the message if\n  // 'socket' is not the currently connected socket.\n  //\n  // We run the messages from the client one at a time, in the order\n  // given by the client. The message handler is passed an idempotent\n  // function 'unblock' which it may call to allow other messages to\n  // begin running in parallel in another fiber (for example, a method\n  // that wants to yield). Otherwise, it is automatically unblocked\n  // when it returns.\n  //\n  // Actually, we don't have to 'totally order' the messages in this\n  // way, but it's the easiest thing that's correct. (unsub needs to\n  // be ordered against sub, methods need to be ordered against each\n  // other).\n  processMessage: function (msg_in) {\n    var self = this;\n    if (!self.inQueue) // we have been destroyed.\n      return; // Respond to ping and pong messages immediately without queuing.\n    // If the negotiated DDP version is \"pre1\" which didn't support\n    // pings, preserve the \"pre1\" behavior of responding with a \"bad\n    // request\" for the unknown messages.\n    //\n    // Fibers are needed because heartbeats use Meteor.setTimeout, which\n    // needs a Fiber. We could actually use regular setTimeout and avoid\n    // these new fibers, but it is easier to just make everything use\n    // Meteor.setTimeout and not think too hard.\n    //\n    // Any message counts as receiving a pong, as it demonstrates that\n    // the client is still alive.\n\n    if (self.heartbeat) {\n      Fiber(function () {\n        self.heartbeat.messageReceived();\n      }).run();\n    }\n\n    if (self.version !== 'pre1' && msg_in.msg === 'ping') {\n      if (self._respondToPings) self.send({\n        msg: \"pong\",\n        id: msg_in.id\n      });\n      return;\n    }\n\n    if (self.version !== 'pre1' && msg_in.msg === 'pong') {\n      // Since everything is a pong, there is nothing to do\n      return;\n    }\n\n    self.inQueue.push(msg_in);\n    if (self.workerRunning) return;\n    self.workerRunning = true;\n\n    var processNext = function () {\n      var msg = self.inQueue && self.inQueue.shift();\n\n      if (!msg) {\n        self.workerRunning = false;\n        return;\n      }\n\n      Fiber(function () {\n        var blocked = true;\n\n        var unblock = function () {\n          if (!blocked) return; // idempotent\n\n          blocked = false;\n          processNext();\n        };\n\n        self.server.onMessageHook.each(function (callback) {\n          callback(msg, self);\n          return true;\n        });\n        if (_.has(self.protocol_handlers, msg.msg)) self.protocol_handlers[msg.msg].call(self, msg, unblock);else self.sendError('Bad request', msg);\n        unblock(); // in case the handler didn't already do it\n      }).run();\n    };\n\n    processNext();\n  },\n  protocol_handlers: {\n    sub: function (msg, unblock) {\n      var self = this; // cacheUnblock temporarly, so we can capture it later\n      // we will use unblock in current eventLoop, so this is safe\n\n      self.cachedUnblock = unblock; // reject malformed messages\n\n      if (typeof msg.id !== \"string\" || typeof msg.name !== \"string\" || 'params' in msg && !(msg.params instanceof Array)) {\n        self.sendError(\"Malformed subscription\", msg);\n        return;\n      }\n\n      if (!self.server.publish_handlers[msg.name]) {\n        self.send({\n          msg: 'nosub',\n          id: msg.id,\n          error: new Meteor.Error(404, \"Subscription '\".concat(msg.name, \"' not found\"))\n        });\n        return;\n      }\n\n      if (self._namedSubs.has(msg.id)) // subs are idempotent, or rather, they are ignored if a sub\n        // with that id already exists. this is important during\n        // reconnect.\n        return; // XXX It'd be much better if we had generic hooks where any package can\n      // hook into subscription handling, but in the mean while we special case\n      // ddp-rate-limiter package. This is also done for weak requirements to\n      // add the ddp-rate-limiter package in case we don't have Accounts. A\n      // user trying to use the ddp-rate-limiter must explicitly require it.\n\n      if (Package['ddp-rate-limiter']) {\n        var DDPRateLimiter = Package['ddp-rate-limiter'].DDPRateLimiter;\n        var rateLimiterInput = {\n          userId: self.userId,\n          clientAddress: self.connectionHandle.clientAddress,\n          type: \"subscription\",\n          name: msg.name,\n          connectionId: self.id\n        };\n\n        DDPRateLimiter._increment(rateLimiterInput);\n\n        var rateLimitResult = DDPRateLimiter._check(rateLimiterInput);\n\n        if (!rateLimitResult.allowed) {\n          self.send({\n            msg: 'nosub',\n            id: msg.id,\n            error: new Meteor.Error('too-many-requests', DDPRateLimiter.getErrorMessage(rateLimitResult), {\n              timeToReset: rateLimitResult.timeToReset\n            })\n          });\n          return;\n        }\n      }\n\n      var handler = self.server.publish_handlers[msg.name];\n\n      self._startSubscription(handler, msg.id, msg.params, msg.name); // cleaning cached unblock\n\n\n      self.cachedUnblock = null;\n    },\n    unsub: function (msg) {\n      var self = this;\n\n      self._stopSubscription(msg.id);\n    },\n    method: function (msg, unblock) {\n      var self = this; // Reject malformed messages.\n      // For now, we silently ignore unknown attributes,\n      // for forwards compatibility.\n\n      if (typeof msg.id !== \"string\" || typeof msg.method !== \"string\" || 'params' in msg && !(msg.params instanceof Array) || 'randomSeed' in msg && typeof msg.randomSeed !== \"string\") {\n        self.sendError(\"Malformed method invocation\", msg);\n        return;\n      }\n\n      var randomSeed = msg.randomSeed || null; // Set up to mark the method as satisfied once all observers\n      // (and subscriptions) have reacted to any writes that were\n      // done.\n\n      var fence = new DDPServer._WriteFence();\n      fence.onAllCommitted(function () {\n        // Retire the fence so that future writes are allowed.\n        // This means that callbacks like timers are free to use\n        // the fence, and if they fire before it's armed (for\n        // example, because the method waits for them) their\n        // writes will be included in the fence.\n        fence.retire();\n        self.send({\n          msg: 'updated',\n          methods: [msg.id]\n        });\n      }); // Find the handler\n\n      var handler = self.server.method_handlers[msg.method];\n\n      if (!handler) {\n        self.send({\n          msg: 'result',\n          id: msg.id,\n          error: new Meteor.Error(404, \"Method '\".concat(msg.method, \"' not found\"))\n        });\n        fence.arm();\n        return;\n      }\n\n      var setUserId = function (userId) {\n        self._setUserId(userId);\n      };\n\n      var invocation = new DDPCommon.MethodInvocation({\n        isSimulation: false,\n        userId: self.userId,\n        setUserId: setUserId,\n        unblock: unblock,\n        connection: self.connectionHandle,\n        randomSeed: randomSeed\n      });\n      const promise = new Promise((resolve, reject) => {\n        // XXX It'd be better if we could hook into method handlers better but\n        // for now, we need to check if the ddp-rate-limiter exists since we\n        // have a weak requirement for the ddp-rate-limiter package to be added\n        // to our application.\n        if (Package['ddp-rate-limiter']) {\n          var DDPRateLimiter = Package['ddp-rate-limiter'].DDPRateLimiter;\n          var rateLimiterInput = {\n            userId: self.userId,\n            clientAddress: self.connectionHandle.clientAddress,\n            type: \"method\",\n            name: msg.method,\n            connectionId: self.id\n          };\n\n          DDPRateLimiter._increment(rateLimiterInput);\n\n          var rateLimitResult = DDPRateLimiter._check(rateLimiterInput);\n\n          if (!rateLimitResult.allowed) {\n            reject(new Meteor.Error(\"too-many-requests\", DDPRateLimiter.getErrorMessage(rateLimitResult), {\n              timeToReset: rateLimitResult.timeToReset\n            }));\n            return;\n          }\n        }\n\n        resolve(DDPServer._CurrentWriteFence.withValue(fence, () => DDP._CurrentMethodInvocation.withValue(invocation, () => maybeAuditArgumentChecks(handler, invocation, msg.params, \"call to '\" + msg.method + \"'\"))));\n      });\n\n      function finish() {\n        fence.arm();\n        unblock();\n      }\n\n      const payload = {\n        msg: \"result\",\n        id: msg.id\n      };\n      promise.then(result => {\n        finish();\n\n        if (result !== undefined) {\n          payload.result = result;\n        }\n\n        self.send(payload);\n      }, exception => {\n        finish();\n        payload.error = wrapInternalException(exception, \"while invoking method '\".concat(msg.method, \"'\"));\n        self.send(payload);\n      });\n    }\n  },\n  _eachSub: function (f) {\n    var self = this;\n\n    self._namedSubs.forEach(f);\n\n    self._universalSubs.forEach(f);\n  },\n  _diffCollectionViews: function (beforeCVs) {\n    var self = this;\n    DiffSequence.diffMaps(beforeCVs, self.collectionViews, {\n      both: function (collectionName, leftValue, rightValue) {\n        rightValue.diff(leftValue);\n      },\n      rightOnly: function (collectionName, rightValue) {\n        rightValue.documents.forEach(function (docView, id) {\n          self.sendAdded(collectionName, id, docView.getFields());\n        });\n      },\n      leftOnly: function (collectionName, leftValue) {\n        leftValue.documents.forEach(function (doc, id) {\n          self.sendRemoved(collectionName, id);\n        });\n      }\n    });\n  },\n  // Sets the current user id in all appropriate contexts and reruns\n  // all subscriptions\n  _setUserId: function (userId) {\n    var self = this;\n    if (userId !== null && typeof userId !== \"string\") throw new Error(\"setUserId must be called on string or null, not \" + typeof userId); // Prevent newly-created universal subscriptions from being added to our\n    // session. They will be found below when we call startUniversalSubs.\n    //\n    // (We don't have to worry about named subscriptions, because we only add\n    // them when we process a 'sub' message. We are currently processing a\n    // 'method' message, and the method did not unblock, because it is illegal\n    // to call setUserId after unblock. Thus we cannot be concurrently adding a\n    // new named subscription).\n\n    self._dontStartNewUniversalSubs = true; // Prevent current subs from updating our collectionViews and call their\n    // stop callbacks. This may yield.\n\n    self._eachSub(function (sub) {\n      sub._deactivate();\n    }); // All subs should now be deactivated. Stop sending messages to the client,\n    // save the state of the published collections, reset to an empty view, and\n    // update the userId.\n\n\n    self._isSending = false;\n    var beforeCVs = self.collectionViews;\n    self.collectionViews = new Map();\n    self.userId = userId; // _setUserId is normally called from a Meteor method with\n    // DDP._CurrentMethodInvocation set. But DDP._CurrentMethodInvocation is not\n    // expected to be set inside a publish function, so we temporary unset it.\n    // Inside a publish function DDP._CurrentPublicationInvocation is set.\n\n    DDP._CurrentMethodInvocation.withValue(undefined, function () {\n      // Save the old named subs, and reset to having no subscriptions.\n      var oldNamedSubs = self._namedSubs;\n      self._namedSubs = new Map();\n      self._universalSubs = [];\n      oldNamedSubs.forEach(function (sub, subscriptionId) {\n        var newSub = sub._recreate();\n\n        self._namedSubs.set(subscriptionId, newSub); // nb: if the handler throws or calls this.error(), it will in fact\n        // immediately send its 'nosub'. This is OK, though.\n\n\n        newSub._runHandler();\n      }); // Allow newly-created universal subs to be started on our connection in\n      // parallel with the ones we're spinning up here, and spin up universal\n      // subs.\n\n      self._dontStartNewUniversalSubs = false;\n      self.startUniversalSubs();\n    }); // Start sending messages again, beginning with the diff from the previous\n    // state of the world to the current state. No yields are allowed during\n    // this diff, so that other changes cannot interleave.\n\n\n    Meteor._noYieldsAllowed(function () {\n      self._isSending = true;\n\n      self._diffCollectionViews(beforeCVs);\n\n      if (!_.isEmpty(self._pendingReady)) {\n        self.sendReady(self._pendingReady);\n        self._pendingReady = [];\n      }\n    });\n  },\n  _startSubscription: function (handler, subId, params, name) {\n    var self = this;\n    var sub = new Subscription(self, handler, subId, params, name);\n    let unblockHander = self.cachedUnblock; // _startSubscription may call from a lot places\n    // so cachedUnblock might be null in somecases\n    // assign the cachedUnblock\n\n    sub.unblock = unblockHander || (() => {});\n\n    if (subId) self._namedSubs.set(subId, sub);else self._universalSubs.push(sub);\n\n    sub._runHandler();\n  },\n  // Tear down specified subscription\n  _stopSubscription: function (subId, error) {\n    var self = this;\n    var subName = null;\n\n    if (subId) {\n      var maybeSub = self._namedSubs.get(subId);\n\n      if (maybeSub) {\n        subName = maybeSub._name;\n\n        maybeSub._removeAllDocuments();\n\n        maybeSub._deactivate();\n\n        self._namedSubs.delete(subId);\n      }\n    }\n\n    var response = {\n      msg: 'nosub',\n      id: subId\n    };\n\n    if (error) {\n      response.error = wrapInternalException(error, subName ? \"from sub \" + subName + \" id \" + subId : \"from sub id \" + subId);\n    }\n\n    self.send(response);\n  },\n  // Tear down all subscriptions. Note that this does NOT send removed or nosub\n  // messages, since we assume the client is gone.\n  _deactivateAllSubscriptions: function () {\n    var self = this;\n\n    self._namedSubs.forEach(function (sub, id) {\n      sub._deactivate();\n    });\n\n    self._namedSubs = new Map();\n\n    self._universalSubs.forEach(function (sub) {\n      sub._deactivate();\n    });\n\n    self._universalSubs = [];\n  },\n  // Determine the remote client's IP address, based on the\n  // HTTP_FORWARDED_COUNT environment variable representing how many\n  // proxies the server is behind.\n  _clientAddress: function () {\n    var self = this; // For the reported client address for a connection to be correct,\n    // the developer must set the HTTP_FORWARDED_COUNT environment\n    // variable to an integer representing the number of hops they\n    // expect in the `x-forwarded-for` header. E.g., set to \"1\" if the\n    // server is behind one proxy.\n    //\n    // This could be computed once at startup instead of every time.\n\n    var httpForwardedCount = parseInt(process.env['HTTP_FORWARDED_COUNT']) || 0;\n    if (httpForwardedCount === 0) return self.socket.remoteAddress;\n    var forwardedFor = self.socket.headers[\"x-forwarded-for\"];\n    if (!_.isString(forwardedFor)) return null;\n    forwardedFor = forwardedFor.trim().split(/\\s*,\\s*/); // Typically the first value in the `x-forwarded-for` header is\n    // the original IP address of the client connecting to the first\n    // proxy.  However, the end user can easily spoof the header, in\n    // which case the first value(s) will be the fake IP address from\n    // the user pretending to be a proxy reporting the original IP\n    // address value.  By counting HTTP_FORWARDED_COUNT back from the\n    // end of the list, we ensure that we get the IP address being\n    // reported by *our* first proxy.\n\n    if (httpForwardedCount < 0 || httpForwardedCount > forwardedFor.length) return null;\n    return forwardedFor[forwardedFor.length - httpForwardedCount];\n  }\n});\n/******************************************************************************/\n\n/* Subscription                                                               */\n\n/******************************************************************************/\n// Ctor for a sub handle: the input to each publish function\n// Instance name is this because it's usually referred to as this inside a\n// publish\n\n/**\n * @summary The server's side of a subscription\n * @class Subscription\n * @instanceName this\n * @showInstanceName true\n */\n\nvar Subscription = function (session, handler, subscriptionId, params, name) {\n  var self = this;\n  self._session = session; // type is Session\n\n  /**\n   * @summary Access inside the publish function. The incoming [connection](#meteor_onconnection) for this subscription.\n   * @locus Server\n   * @name  connection\n   * @memberOf Subscription\n   * @instance\n   */\n\n  self.connection = session.connectionHandle; // public API object\n\n  self._handler = handler; // My subscription ID (generated by client, undefined for universal subs).\n\n  self._subscriptionId = subscriptionId; // Undefined for universal subs\n\n  self._name = name;\n  self._params = params || []; // Only named subscriptions have IDs, but we need some sort of string\n  // internally to keep track of all subscriptions inside\n  // SessionDocumentViews. We use this subscriptionHandle for that.\n\n  if (self._subscriptionId) {\n    self._subscriptionHandle = 'N' + self._subscriptionId;\n  } else {\n    self._subscriptionHandle = 'U' + Random.id();\n  } // Has _deactivate been called?\n\n\n  self._deactivated = false; // Stop callbacks to g/c this sub.  called w/ zero arguments.\n\n  self._stopCallbacks = []; // The set of (collection, documentid) that this subscription has\n  // an opinion about.\n\n  self._documents = new Map(); // Remember if we are ready.\n\n  self._ready = false; // Part of the public API: the user of this sub.\n\n  /**\n   * @summary Access inside the publish function. The id of the logged-in user, or `null` if no user is logged in.\n   * @locus Server\n   * @memberOf Subscription\n   * @name  userId\n   * @instance\n   */\n\n  self.userId = session.userId; // For now, the id filter is going to default to\n  // the to/from DDP methods on MongoID, to\n  // specifically deal with mongo/minimongo ObjectIds.\n  // Later, you will be able to make this be \"raw\"\n  // if you want to publish a collection that you know\n  // just has strings for keys and no funny business, to\n  // a DDP consumer that isn't minimongo.\n\n  self._idFilter = {\n    idStringify: MongoID.idStringify,\n    idParse: MongoID.idParse\n  };\n  Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"livedata\", \"subscriptions\", 1);\n};\n\nObject.assign(Subscription.prototype, {\n  _runHandler: function () {\n    // XXX should we unblock() here? Either before running the publish\n    // function, or before running _publishCursor.\n    //\n    // Right now, each publish function blocks all future publishes and\n    // methods waiting on data from Mongo (or whatever else the function\n    // blocks on). This probably slows page load in common cases.\n    if (!this.unblock) {\n      this.unblock = () => {};\n    }\n\n    const self = this;\n    let resultOrThenable = null;\n\n    try {\n      resultOrThenable = DDP._CurrentPublicationInvocation.withValue(self, () => maybeAuditArgumentChecks(self._handler, self, EJSON.clone(self._params), // It's OK that this would look weird for universal subscriptions,\n      // because they have no arguments so there can never be an\n      // audit-argument-checks failure.\n      \"publisher '\" + self._name + \"'\"));\n    } catch (e) {\n      self.error(e);\n      return;\n    } // Did the handler call this.error or this.stop?\n\n\n    if (self._isDeactivated()) return; // Both conventional and async publish handler functions are supported.\n    // If an object is returned with a then() function, it is either a promise\n    // or thenable and will be resolved asynchronously.\n\n    const isThenable = resultOrThenable && typeof resultOrThenable.then === 'function';\n\n    if (isThenable) {\n      Promise.resolve(resultOrThenable).then(function () {\n        return self._publishHandlerResult.bind(self)(...arguments);\n      }, e => self.error(e));\n    } else {\n      self._publishHandlerResult(resultOrThenable);\n    }\n  },\n  _publishHandlerResult: function (res) {\n    // SPECIAL CASE: Instead of writing their own callbacks that invoke\n    // this.added/changed/ready/etc, the user can just return a collection\n    // cursor or array of cursors from the publish function; we call their\n    // _publishCursor method which starts observing the cursor and publishes the\n    // results. Note that _publishCursor does NOT call ready().\n    //\n    // XXX This uses an undocumented interface which only the Mongo cursor\n    // interface publishes. Should we make this interface public and encourage\n    // users to implement it themselves? Arguably, it's unnecessary; users can\n    // already write their own functions like\n    //   var publishMyReactiveThingy = function (name, handler) {\n    //     Meteor.publish(name, function () {\n    //       var reactiveThingy = handler();\n    //       reactiveThingy.publishMe();\n    //     });\n    //   };\n    var self = this;\n\n    var isCursor = function (c) {\n      return c && c._publishCursor;\n    };\n\n    if (isCursor(res)) {\n      try {\n        res._publishCursor(self);\n      } catch (e) {\n        self.error(e);\n        return;\n      } // _publishCursor only returns after the initial added callbacks have run.\n      // mark subscription as ready.\n\n\n      self.ready();\n    } else if (_.isArray(res)) {\n      // Check all the elements are cursors\n      if (!_.all(res, isCursor)) {\n        self.error(new Error(\"Publish function returned an array of non-Cursors\"));\n        return;\n      } // Find duplicate collection names\n      // XXX we should support overlapping cursors, but that would require the\n      // merge box to allow overlap within a subscription\n\n\n      var collectionNames = {};\n\n      for (var i = 0; i < res.length; ++i) {\n        var collectionName = res[i]._getCollectionName();\n\n        if (_.has(collectionNames, collectionName)) {\n          self.error(new Error(\"Publish function returned multiple cursors for collection \" + collectionName));\n          return;\n        }\n\n        collectionNames[collectionName] = true;\n      }\n\n      ;\n\n      try {\n        _.each(res, function (cur) {\n          cur._publishCursor(self);\n        });\n      } catch (e) {\n        self.error(e);\n        return;\n      }\n\n      self.ready();\n    } else if (res) {\n      // Truthy values other than cursors or arrays are probably a\n      // user mistake (possible returning a Mongo document via, say,\n      // `coll.findOne()`).\n      self.error(new Error(\"Publish function can only return a Cursor or \" + \"an array of Cursors\"));\n    }\n  },\n  // This calls all stop callbacks and prevents the handler from updating any\n  // SessionCollectionViews further. It's used when the user unsubscribes or\n  // disconnects, as well as during setUserId re-runs. It does *NOT* send\n  // removed messages for the published objects; if that is necessary, call\n  // _removeAllDocuments first.\n  _deactivate: function () {\n    var self = this;\n    if (self._deactivated) return;\n    self._deactivated = true;\n\n    self._callStopCallbacks();\n\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"livedata\", \"subscriptions\", -1);\n  },\n  _callStopCallbacks: function () {\n    var self = this; // Tell listeners, so they can clean up\n\n    var callbacks = self._stopCallbacks;\n    self._stopCallbacks = [];\n\n    _.each(callbacks, function (callback) {\n      callback();\n    });\n  },\n  // Send remove messages for every document.\n  _removeAllDocuments: function () {\n    var self = this;\n\n    Meteor._noYieldsAllowed(function () {\n      self._documents.forEach(function (collectionDocs, collectionName) {\n        collectionDocs.forEach(function (strId) {\n          self.removed(collectionName, self._idFilter.idParse(strId));\n        });\n      });\n    });\n  },\n  // Returns a new Subscription for the same session with the same\n  // initial creation parameters. This isn't a clone: it doesn't have\n  // the same _documents cache, stopped state or callbacks; may have a\n  // different _subscriptionHandle, and gets its userId from the\n  // session, not from this object.\n  _recreate: function () {\n    var self = this;\n    return new Subscription(self._session, self._handler, self._subscriptionId, self._params, self._name);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Stops this client's subscription, triggering a call on the client to the `onStop` callback passed to [`Meteor.subscribe`](#meteor_subscribe), if any. If `error` is not a [`Meteor.Error`](#meteor_error), it will be [sanitized](#meteor_error).\n   * @locus Server\n   * @param {Error} error The error to pass to the client.\n   * @instance\n   * @memberOf Subscription\n   */\n  error: function (error) {\n    var self = this;\n    if (self._isDeactivated()) return;\n\n    self._session._stopSubscription(self._subscriptionId, error);\n  },\n  // Note that while our DDP client will notice that you've called stop() on the\n  // server (and clean up its _subscriptions table) we don't actually provide a\n  // mechanism for an app to notice this (the subscribe onError callback only\n  // triggers if there is an error).\n\n  /**\n   * @summary Call inside the publish function.  Stops this client's subscription and invokes the client's `onStop` callback with no error.\n   * @locus Server\n   * @instance\n   * @memberOf Subscription\n   */\n  stop: function () {\n    var self = this;\n    if (self._isDeactivated()) return;\n\n    self._session._stopSubscription(self._subscriptionId);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Registers a callback function to run when the subscription is stopped.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {Function} func The callback function\n   */\n  onStop: function (callback) {\n    var self = this;\n    callback = Meteor.bindEnvironment(callback, 'onStop callback', self);\n    if (self._isDeactivated()) callback();else self._stopCallbacks.push(callback);\n  },\n  // This returns true if the sub has been deactivated, *OR* if the session was\n  // destroyed but the deferred call to _deactivateAllSubscriptions hasn't\n  // happened yet.\n  _isDeactivated: function () {\n    var self = this;\n    return self._deactivated || self._session.inQueue === null;\n  },\n\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that a document has been added to the record set.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {String} collection The name of the collection that contains the new document.\n   * @param {String} id The new document's ID.\n   * @param {Object} fields The fields in the new document.  If `_id` is present it is ignored.\n   */\n  added(collectionName, id, fields) {\n    if (this._isDeactivated()) return;\n    id = this._idFilter.idStringify(id);\n\n    if (this._session.server.getPublicationStrategy(collectionName).doAccountingForCollection) {\n      let ids = this._documents.get(collectionName);\n\n      if (ids == null) {\n        ids = new Set();\n\n        this._documents.set(collectionName, ids);\n      }\n\n      ids.add(id);\n    }\n\n    this._session.added(this._subscriptionHandle, collectionName, id, fields);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that a document in the record set has been modified.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {String} collection The name of the collection that contains the changed document.\n   * @param {String} id The changed document's ID.\n   * @param {Object} fields The fields in the document that have changed, together with their new values.  If a field is not present in `fields` it was left unchanged; if it is present in `fields` and has a value of `undefined` it was removed from the document.  If `_id` is present it is ignored.\n   */\n  changed(collectionName, id, fields) {\n    if (this._isDeactivated()) return;\n    id = this._idFilter.idStringify(id);\n\n    this._session.changed(this._subscriptionHandle, collectionName, id, fields);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that a document has been removed from the record set.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {String} collection The name of the collection that the document has been removed from.\n   * @param {String} id The ID of the document that has been removed.\n   */\n  removed(collectionName, id) {\n    if (this._isDeactivated()) return;\n    id = this._idFilter.idStringify(id);\n\n    if (this._session.server.getPublicationStrategy(collectionName).doAccountingForCollection) {\n      // We don't bother to delete sets of things in a collection if the\n      // collection is empty.  It could break _removeAllDocuments.\n      this._documents.get(collectionName).delete(id);\n    }\n\n    this._session.removed(this._subscriptionHandle, collectionName, id);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that an initial, complete snapshot of the record set has been sent.  This will trigger a call on the client to the `onReady` callback passed to  [`Meteor.subscribe`](#meteor_subscribe), if any.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   */\n  ready: function () {\n    var self = this;\n    if (self._isDeactivated()) return;\n    if (!self._subscriptionId) return; // Unnecessary but ignored for universal sub\n\n    if (!self._ready) {\n      self._session.sendReady([self._subscriptionId]);\n\n      self._ready = true;\n    }\n  }\n});\n/******************************************************************************/\n\n/* Server                                                                     */\n\n/******************************************************************************/\n\nServer = function () {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var self = this; // The default heartbeat interval is 30 seconds on the server and 35\n  // seconds on the client.  Since the client doesn't need to send a\n  // ping as long as it is receiving pings, this means that pings\n  // normally go from the server to the client.\n  //\n  // Note: Troposphere depends on the ability to mutate\n  // Meteor.server.options.heartbeatTimeout! This is a hack, but it's life.\n\n  self.options = _objectSpread({\n    heartbeatInterval: 15000,\n    heartbeatTimeout: 15000,\n    // For testing, allow responding to pings to be disabled.\n    respondToPings: true,\n    defaultPublicationStrategy: publicationStrategies.SERVER_MERGE\n  }, options); // Map of callbacks to call when a new connection comes in to the\n  // server and completes DDP version negotiation. Use an object instead\n  // of an array so we can safely remove one from the list while\n  // iterating over it.\n\n  self.onConnectionHook = new Hook({\n    debugPrintExceptions: \"onConnection callback\"\n  }); // Map of callbacks to call when a new message comes in.\n\n  self.onMessageHook = new Hook({\n    debugPrintExceptions: \"onMessage callback\"\n  });\n  self.publish_handlers = {};\n  self.universal_publish_handlers = [];\n  self.method_handlers = {};\n  self._publicationStrategies = {};\n  self.sessions = new Map(); // map from id to session\n\n  self.stream_server = new StreamServer();\n  self.stream_server.register(function (socket) {\n    // socket implements the SockJSConnection interface\n    socket._meteorSession = null;\n\n    var sendError = function (reason, offendingMessage) {\n      var msg = {\n        msg: 'error',\n        reason: reason\n      };\n      if (offendingMessage) msg.offendingMessage = offendingMessage;\n      socket.send(DDPCommon.stringifyDDP(msg));\n    };\n\n    socket.on('data', function (raw_msg) {\n      if (Meteor._printReceivedDDP) {\n        Meteor._debug(\"Received DDP\", raw_msg);\n      }\n\n      try {\n        try {\n          var msg = DDPCommon.parseDDP(raw_msg);\n        } catch (err) {\n          sendError('Parse error');\n          return;\n        }\n\n        if (msg === null || !msg.msg) {\n          sendError('Bad request', msg);\n          return;\n        }\n\n        if (msg.msg === 'connect') {\n          if (socket._meteorSession) {\n            sendError(\"Already connected\", msg);\n            return;\n          }\n\n          Fiber(function () {\n            self._handleConnect(socket, msg);\n          }).run();\n          return;\n        }\n\n        if (!socket._meteorSession) {\n          sendError('Must connect first', msg);\n          return;\n        }\n\n        socket._meteorSession.processMessage(msg);\n      } catch (e) {\n        // XXX print stack nicely\n        Meteor._debug(\"Internal exception while processing message\", msg, e);\n      }\n    });\n    socket.on('close', function () {\n      if (socket._meteorSession) {\n        Fiber(function () {\n          socket._meteorSession.close();\n        }).run();\n      }\n    });\n  });\n};\n\nObject.assign(Server.prototype, {\n  /**\n   * @summary Register a callback to be called when a new DDP connection is made to the server.\n   * @locus Server\n   * @param {function} callback The function to call when a new DDP connection is established.\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */\n  onConnection: function (fn) {\n    var self = this;\n    return self.onConnectionHook.register(fn);\n  },\n\n  /**\n   * @summary Set publication strategy for the given publication. Publications strategies are available from `DDPServer.publicationStrategies`. You call this method from `Meteor.server`, like `Meteor.server.setPublicationStrategy()`\n   * @locus Server\n   * @alias setPublicationStrategy\n   * @param publicationName {String}\n   * @param strategy {{useCollectionView: boolean, doAccountingForCollection: boolean}}\n   * @memberOf Meteor.server\n   * @importFromPackage meteor\n   */\n  setPublicationStrategy(publicationName, strategy) {\n    if (!Object.values(publicationStrategies).includes(strategy)) {\n      throw new Error(\"Invalid merge strategy: \".concat(strategy, \" \\n        for collection \").concat(publicationName));\n    }\n\n    this._publicationStrategies[publicationName] = strategy;\n  },\n\n  /**\n   * @summary Gets the publication strategy for the requested publication. You call this method from `Meteor.server`, like `Meteor.server.getPublicationStrategy()`\n   * @locus Server\n   * @alias getPublicationStrategy\n   * @param publicationName {String}\n   * @memberOf Meteor.server\n   * @importFromPackage meteor\n   * @return {{useCollectionView: boolean, doAccountingForCollection: boolean}}\n   */\n  getPublicationStrategy(publicationName) {\n    return this._publicationStrategies[publicationName] || this.options.defaultPublicationStrategy;\n  },\n\n  /**\n   * @summary Register a callback to be called when a new DDP message is received.\n   * @locus Server\n   * @param {function} callback The function to call when a new DDP message is received.\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */\n  onMessage: function (fn) {\n    var self = this;\n    return self.onMessageHook.register(fn);\n  },\n  _handleConnect: function (socket, msg) {\n    var self = this; // The connect message must specify a version and an array of supported\n    // versions, and it must claim to support what it is proposing.\n\n    if (!(typeof msg.version === 'string' && _.isArray(msg.support) && _.all(msg.support, _.isString) && _.contains(msg.support, msg.version))) {\n      socket.send(DDPCommon.stringifyDDP({\n        msg: 'failed',\n        version: DDPCommon.SUPPORTED_DDP_VERSIONS[0]\n      }));\n      socket.close();\n      return;\n    } // In the future, handle session resumption: something like:\n    //  socket._meteorSession = self.sessions[msg.session]\n\n\n    var version = calculateVersion(msg.support, DDPCommon.SUPPORTED_DDP_VERSIONS);\n\n    if (msg.version !== version) {\n      // The best version to use (according to the client's stated preferences)\n      // is not the one the client is trying to use. Inform them about the best\n      // version to use.\n      socket.send(DDPCommon.stringifyDDP({\n        msg: 'failed',\n        version: version\n      }));\n      socket.close();\n      return;\n    } // Yay, version matches! Create a new session.\n    // Note: Troposphere depends on the ability to mutate\n    // Meteor.server.options.heartbeatTimeout! This is a hack, but it's life.\n\n\n    socket._meteorSession = new Session(self, version, socket, self.options);\n    self.sessions.set(socket._meteorSession.id, socket._meteorSession);\n    self.onConnectionHook.each(function (callback) {\n      if (socket._meteorSession) callback(socket._meteorSession.connectionHandle);\n      return true;\n    });\n  },\n\n  /**\n   * Register a publish handler function.\n   *\n   * @param name {String} identifier for query\n   * @param handler {Function} publish handler\n   * @param options {Object}\n   *\n   * Server will call handler function on each new subscription,\n   * either when receiving DDP sub message for a named subscription, or on\n   * DDP connect for a universal subscription.\n   *\n   * If name is null, this will be a subscription that is\n   * automatically established and permanently on for all connected\n   * client, instead of a subscription that can be turned on and off\n   * with subscribe().\n   *\n   * options to contain:\n   *  - (mostly internal) is_auto: true if generated automatically\n   *    from an autopublish hook. this is for cosmetic purposes only\n   *    (it lets us determine whether to print a warning suggesting\n   *    that you turn off autopublish).\n   */\n\n  /**\n   * @summary Publish a record set.\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   * @locus Server\n   * @param {String|Object} name If String, name of the record set.  If Object, publications Dictionary of publish functions by name.  If `null`, the set has no name, and the record set is automatically sent to all connected clients.\n   * @param {Function} func Function called on the server each time a client subscribes.  Inside the function, `this` is the publish handler object, described below.  If the client passed arguments to `subscribe`, the function is called with the same arguments.\n   */\n  publish: function (name, handler, options) {\n    var self = this;\n\n    if (!_.isObject(name)) {\n      options = options || {};\n\n      if (name && name in self.publish_handlers) {\n        Meteor._debug(\"Ignoring duplicate publish named '\" + name + \"'\");\n\n        return;\n      }\n\n      if (Package.autopublish && !options.is_auto) {\n        // They have autopublish on, yet they're trying to manually\n        // pick stuff to publish. They probably should turn off\n        // autopublish. (This check isn't perfect -- if you create a\n        // publish before you turn on autopublish, it won't catch\n        // it, but this will definitely handle the simple case where\n        // you've added the autopublish package to your app, and are\n        // calling publish from your app code).\n        if (!self.warned_about_autopublish) {\n          self.warned_about_autopublish = true;\n\n          Meteor._debug(\"** You've set up some data subscriptions with Meteor.publish(), but\\n\" + \"** you still have autopublish turned on. Because autopublish is still\\n\" + \"** on, your Meteor.publish() calls won't have much effect. All data\\n\" + \"** will still be sent to all clients.\\n\" + \"**\\n\" + \"** Turn off autopublish by removing the autopublish package:\\n\" + \"**\\n\" + \"**   $ meteor remove autopublish\\n\" + \"**\\n\" + \"** .. and make sure you have Meteor.publish() and Meteor.subscribe() calls\\n\" + \"** for each collection that you want clients to see.\\n\");\n        }\n      }\n\n      if (name) self.publish_handlers[name] = handler;else {\n        self.universal_publish_handlers.push(handler); // Spin up the new publisher on any existing session too. Run each\n        // session's subscription in a new Fiber, so that there's no change for\n        // self.sessions to change while we're running this loop.\n\n        self.sessions.forEach(function (session) {\n          if (!session._dontStartNewUniversalSubs) {\n            Fiber(function () {\n              session._startSubscription(handler);\n            }).run();\n          }\n        });\n      }\n    } else {\n      _.each(name, function (value, key) {\n        self.publish(key, value, {});\n      });\n    }\n  },\n  _removeSession: function (session) {\n    var self = this;\n    self.sessions.delete(session.id);\n  },\n\n  /**\n   * @summary Defines functions that can be invoked over the network by clients.\n   * @locus Anywhere\n   * @param {Object} methods Dictionary whose keys are method names and values are functions.\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */\n  methods: function (methods) {\n    var self = this;\n\n    _.each(methods, function (func, name) {\n      if (typeof func !== 'function') throw new Error(\"Method '\" + name + \"' must be a function\");\n      if (self.method_handlers[name]) throw new Error(\"A method named '\" + name + \"' is already defined\");\n      self.method_handlers[name] = func;\n    });\n  },\n  call: function (name) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    if (args.length && typeof args[args.length - 1] === \"function\") {\n      // If it's a function, the last argument is the result callback, not\n      // a parameter to the remote method.\n      var callback = args.pop();\n    }\n\n    return this.apply(name, args, callback);\n  },\n  // A version of the call method that always returns a Promise.\n  callAsync: function (name) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    return this.applyAsync(name, args);\n  },\n  apply: function (name, args, options, callback) {\n    // We were passed 3 arguments. They may be either (name, args, options)\n    // or (name, args, callback)\n    if (!callback && typeof options === 'function') {\n      callback = options;\n      options = {};\n    } else {\n      options = options || {};\n    }\n\n    const promise = this.applyAsync(name, args, options); // Return the result in whichever way the caller asked for it. Note that we\n    // do NOT block on the write fence in an analogous way to how the client\n    // blocks on the relevant data being visible, so you are NOT guaranteed that\n    // cursor observe callbacks have fired when your callback is invoked. (We\n    // can change this if there's a real use case).\n\n    if (callback) {\n      promise.then(result => callback(undefined, result), exception => callback(exception));\n    } else {\n      return promise.await();\n    }\n  },\n  // @param options {Optional Object}\n  applyAsync: function (name, args, options) {\n    // Run the handler\n    var handler = this.method_handlers[name];\n\n    if (!handler) {\n      return Promise.reject(new Meteor.Error(404, \"Method '\".concat(name, \"' not found\")));\n    } // If this is a method call from within another method or publish function,\n    // get the user state from the outer method or publish function, otherwise\n    // don't allow setUserId to be called\n\n\n    var userId = null;\n\n    var setUserId = function () {\n      throw new Error(\"Can't call setUserId on a server initiated method call\");\n    };\n\n    var connection = null;\n\n    var currentMethodInvocation = DDP._CurrentMethodInvocation.get();\n\n    var currentPublicationInvocation = DDP._CurrentPublicationInvocation.get();\n\n    var randomSeed = null;\n\n    if (currentMethodInvocation) {\n      userId = currentMethodInvocation.userId;\n\n      setUserId = function (userId) {\n        currentMethodInvocation.setUserId(userId);\n      };\n\n      connection = currentMethodInvocation.connection;\n      randomSeed = DDPCommon.makeRpcSeed(currentMethodInvocation, name);\n    } else if (currentPublicationInvocation) {\n      userId = currentPublicationInvocation.userId;\n\n      setUserId = function (userId) {\n        currentPublicationInvocation._session._setUserId(userId);\n      };\n\n      connection = currentPublicationInvocation.connection;\n    }\n\n    var invocation = new DDPCommon.MethodInvocation({\n      isSimulation: false,\n      userId,\n      setUserId,\n      connection,\n      randomSeed\n    });\n    return new Promise(resolve => resolve(DDP._CurrentMethodInvocation.withValue(invocation, () => maybeAuditArgumentChecks(handler, invocation, EJSON.clone(args), \"internal call to '\" + name + \"'\")))).then(EJSON.clone);\n  },\n  _urlForSession: function (sessionId) {\n    var self = this;\n    var session = self.sessions.get(sessionId);\n    if (session) return session._socketUrl;else return null;\n  }\n});\n\nvar calculateVersion = function (clientSupportedVersions, serverSupportedVersions) {\n  var correctVersion = _.find(clientSupportedVersions, function (version) {\n    return _.contains(serverSupportedVersions, version);\n  });\n\n  if (!correctVersion) {\n    correctVersion = serverSupportedVersions[0];\n  }\n\n  return correctVersion;\n};\n\nDDPServer._calculateVersion = calculateVersion; // \"blind\" exceptions other than those that were deliberately thrown to signal\n// errors to the client\n\nvar wrapInternalException = function (exception, context) {\n  if (!exception) return exception; // To allow packages to throw errors intended for the client but not have to\n  // depend on the Meteor.Error class, `isClientSafe` can be set to true on any\n  // error before it is thrown.\n\n  if (exception.isClientSafe) {\n    if (!(exception instanceof Meteor.Error)) {\n      const originalMessage = exception.message;\n      exception = new Meteor.Error(exception.error, exception.reason, exception.details);\n      exception.message = originalMessage;\n    }\n\n    return exception;\n  } // Tests can set the '_expectedByTest' flag on an exception so it won't go to\n  // the server log.\n\n\n  if (!exception._expectedByTest) {\n    Meteor._debug(\"Exception \" + context, exception.stack);\n\n    if (exception.sanitizedError) {\n      Meteor._debug(\"Sanitized and reported to the client as:\", exception.sanitizedError);\n\n      Meteor._debug();\n    }\n  } // Did the error contain more details that could have been useful if caught in\n  // server code (or if thrown from non-client-originated code), but also\n  // provided a \"sanitized\" version with more context than 500 Internal server\n  // error? Use that.\n\n\n  if (exception.sanitizedError) {\n    if (exception.sanitizedError.isClientSafe) return exception.sanitizedError;\n\n    Meteor._debug(\"Exception \" + context + \" provides a sanitizedError that \" + \"does not have isClientSafe property set; ignoring\");\n  }\n\n  return new Meteor.Error(500, \"Internal server error\");\n}; // Audit argument checks, if the audit-argument-checks package exists (it is a\n// weak dependency of this package).\n\n\nvar maybeAuditArgumentChecks = function (f, context, args, description) {\n  args = args || [];\n\n  if (Package['audit-argument-checks']) {\n    return Match._failIfArgumentsAreNotAllChecked(f, context, args, description);\n  }\n\n  return f.apply(context, args);\n};","map":{"version":3,"sources":["packages/ddp-server/livedata_server.js"],"names":["_objectSpread","module","link","default","v","DDPServer","Fiber","Npm","require","publicationStrategies","SERVER_MERGE","useCollectionView","doAccountingForCollection","NO_MERGE_NO_HISTORY","NO_MERGE","SessionDocumentView","self","existsIn","Set","dataByKey","Map","_SessionDocumentView","_","extend","prototype","getFields","ret","forEach","precedenceList","key","value","clearField","subscriptionHandle","changeCollector","get","removedValue","undefined","i","length","precedence","splice","delete","EJSON","equals","changeField","isAdd","clone","has","set","elt","find","push","SessionCollectionView","collectionName","sessionCallbacks","documents","callbacks","_SessionCollectionView","Object","assign","isEmpty","size","diff","previous","DiffSequence","diffMaps","both","bind","diffDocument","rightOnly","id","nowDV","added","leftOnly","prevDV","removed","fields","diffObjects","prev","now","changed","docView","add","each","changedResult","Error","err","Session","server","version","socket","options","Random","initialized","inQueue","Meteor","_DoubleEndedQueue","blocked","workerRunning","cachedUnblock","_namedSubs","_universalSubs","userId","collectionViews","_isSending","_dontStartNewUniversalSubs","_pendingReady","_closeCallbacks","_socketUrl","url","_respondToPings","respondToPings","connectionHandle","close","onClose","fn","cb","bindEnvironment","defer","clientAddress","_clientAddress","httpHeaders","headers","send","msg","session","startUniversalSubs","run","heartbeatInterval","setWebsocketTimeout","heartbeat","DDPCommon","Heartbeat","heartbeatTimeout","onTimeout","sendPing","start","Package","Facts","incrementServerFact","sendReady","subscriptionIds","subs","subscriptionId","_canSend","getPublicationStrategy","sendAdded","collection","sendChanged","sendRemoved","getSendCallbacks","getCollectionView","view","handlers","universal_publish_handlers","handler","_startSubscription","stop","_meteorSession","_deactivateAllSubscriptions","callback","_removeSession","_printSentDDP","_debug","stringifyDDP","sendError","reason","offendingMessage","processMessage","msg_in","messageReceived","processNext","shift","unblock","onMessageHook","protocol_handlers","call","sub","name","params","Array","publish_handlers","error","DDPRateLimiter","rateLimiterInput","type","connectionId","_increment","rateLimitResult","_check","allowed","getErrorMessage","timeToReset","unsub","_stopSubscription","method","randomSeed","fence","_WriteFence","onAllCommitted","retire","methods","method_handlers","arm","setUserId","_setUserId","invocation","MethodInvocation","isSimulation","connection","promise","Promise","resolve","reject","_CurrentWriteFence","withValue","DDP","_CurrentMethodInvocation","maybeAuditArgumentChecks","finish","payload","then","result","exception","wrapInternalException","_eachSub","f","_diffCollectionViews","beforeCVs","leftValue","rightValue","doc","_deactivate","oldNamedSubs","newSub","_recreate","_runHandler","_noYieldsAllowed","subId","Subscription","unblockHander","subName","maybeSub","_name","_removeAllDocuments","response","httpForwardedCount","parseInt","process","env","remoteAddress","forwardedFor","isString","trim","split","_session","_handler","_subscriptionId","_params","_subscriptionHandle","_deactivated","_stopCallbacks","_documents","_ready","_idFilter","idStringify","MongoID","idParse","resultOrThenable","_CurrentPublicationInvocation","e","_isDeactivated","isThenable","_publishHandlerResult","res","isCursor","c","_publishCursor","ready","isArray","all","collectionNames","_getCollectionName","cur","_callStopCallbacks","collectionDocs","strId","onStop","ids","Server","defaultPublicationStrategy","onConnectionHook","Hook","debugPrintExceptions","_publicationStrategies","sessions","stream_server","StreamServer","register","on","raw_msg","_printReceivedDDP","parseDDP","_handleConnect","onConnection","setPublicationStrategy","publicationName","strategy","values","includes","onMessage","support","contains","SUPPORTED_DDP_VERSIONS","calculateVersion","publish","isObject","autopublish","is_auto","warned_about_autopublish","func","args","pop","apply","callAsync","applyAsync","await","currentMethodInvocation","currentPublicationInvocation","makeRpcSeed","_urlForSession","sessionId","clientSupportedVersions","serverSupportedVersions","correctVersion","_calculateVersion","context","isClientSafe","originalMessage","message","details","_expectedByTest","stack","sanitizedError","description","Match","_failIfArgumentsAreNotAllChecked"],"mappings":"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","sourcesContent":["DDPServer = {};\n\nvar Fiber = Npm.require('fibers');\n\n// Publication strategies define how we handle data from published cursors at the collection level\n// This allows someone to:\n// - Choose a trade-off between client-server bandwidth and server memory usage\n// - Implement special (non-mongo) collections like volatile message queues\nconst publicationStrategies = {\n  // SERVER_MERGE is the default strategy.\n  // When using this strategy, the server maintains a copy of all data a connection is subscribed to.\n  // This allows us to only send deltas over multiple publications.\n  SERVER_MERGE: {\n    useCollectionView: true,\n    doAccountingForCollection: true,\n  },\n  // The NO_MERGE_NO_HISTORY strategy results in the server sending all publication data\n  // directly to the client. It does not remember what it has previously sent\n  // to it will not trigger removed messages when a subscription is stopped.\n  // This should only be chosen for special use cases like send-and-forget queues.\n  NO_MERGE_NO_HISTORY: {\n    useCollectionView: false,\n    doAccountingForCollection: false,\n  },\n  // NO_MERGE is similar to NO_MERGE_NO_HISTORY but the server will remember the IDs it has\n  // sent to the client so it can remove them when a subscription is stopped.\n  // This strategy can be used when a collection is only used in a single publication.\n  NO_MERGE: {\n    useCollectionView: false,\n    doAccountingForCollection: true,\n  }\n};\n\nDDPServer.publicationStrategies = publicationStrategies;\n\n// This file contains classes:\n// * Session - The server's connection to a single DDP client\n// * Subscription - A single subscription for a single client\n// * Server - An entire server that may talk to > 1 client. A DDP endpoint.\n//\n// Session and Subscription are file scope. For now, until we freeze\n// the interface, Server is package scope (in the future it should be\n// exported).\n\n// Represents a single document in a SessionCollectionView\nvar SessionDocumentView = function () {\n  var self = this;\n  self.existsIn = new Set(); // set of subscriptionHandle\n  self.dataByKey = new Map(); // key-> [ {subscriptionHandle, value} by precedence]\n};\n\nDDPServer._SessionDocumentView = SessionDocumentView;\n\n\n_.extend(SessionDocumentView.prototype, {\n\n  getFields: function () {\n    var self = this;\n    var ret = {};\n    self.dataByKey.forEach(function (precedenceList, key) {\n      ret[key] = precedenceList[0].value;\n    });\n    return ret;\n  },\n\n  clearField: function (subscriptionHandle, key, changeCollector) {\n    var self = this;\n    // Publish API ignores _id if present in fields\n    if (key === \"_id\")\n      return;\n    var precedenceList = self.dataByKey.get(key);\n\n    // It's okay to clear fields that didn't exist. No need to throw\n    // an error.\n    if (!precedenceList)\n      return;\n\n    var removedValue = undefined;\n    for (var i = 0; i < precedenceList.length; i++) {\n      var precedence = precedenceList[i];\n      if (precedence.subscriptionHandle === subscriptionHandle) {\n        // The view's value can only change if this subscription is the one that\n        // used to have precedence.\n        if (i === 0)\n          removedValue = precedence.value;\n        precedenceList.splice(i, 1);\n        break;\n      }\n    }\n    if (precedenceList.length === 0) {\n      self.dataByKey.delete(key);\n      changeCollector[key] = undefined;\n    } else if (removedValue !== undefined &&\n               !EJSON.equals(removedValue, precedenceList[0].value)) {\n      changeCollector[key] = precedenceList[0].value;\n    }\n  },\n\n  changeField: function (subscriptionHandle, key, value,\n                         changeCollector, isAdd) {\n    var self = this;\n    // Publish API ignores _id if present in fields\n    if (key === \"_id\")\n      return;\n\n    // Don't share state with the data passed in by the user.\n    value = EJSON.clone(value);\n\n    if (!self.dataByKey.has(key)) {\n      self.dataByKey.set(key, [{subscriptionHandle: subscriptionHandle,\n                                value: value}]);\n      changeCollector[key] = value;\n      return;\n    }\n    var precedenceList = self.dataByKey.get(key);\n    var elt;\n    if (!isAdd) {\n      elt = precedenceList.find(function (precedence) {\n          return precedence.subscriptionHandle === subscriptionHandle;\n      });\n    }\n\n    if (elt) {\n      if (elt === precedenceList[0] && !EJSON.equals(value, elt.value)) {\n        // this subscription is changing the value of this field.\n        changeCollector[key] = value;\n      }\n      elt.value = value;\n    } else {\n      // this subscription is newly caring about this field\n      precedenceList.push({subscriptionHandle: subscriptionHandle, value: value});\n    }\n\n  }\n});\n\n/**\n * Represents a client's view of a single collection\n * @param {String} collectionName Name of the collection it represents\n * @param {Object.<String, Function>} sessionCallbacks The callbacks for added, changed, removed\n * @class SessionCollectionView\n */\nvar SessionCollectionView = function (collectionName, sessionCallbacks) {\n  var self = this;\n  self.collectionName = collectionName;\n  self.documents = new Map();\n  self.callbacks = sessionCallbacks;\n};\n\nDDPServer._SessionCollectionView = SessionCollectionView;\n\n\nObject.assign(SessionCollectionView.prototype, {\n\n  isEmpty: function () {\n    var self = this;\n    return self.documents.size === 0;\n  },\n\n  diff: function (previous) {\n    var self = this;\n    DiffSequence.diffMaps(previous.documents, self.documents, {\n      both: _.bind(self.diffDocument, self),\n\n      rightOnly: function (id, nowDV) {\n        self.callbacks.added(self.collectionName, id, nowDV.getFields());\n      },\n\n      leftOnly: function (id, prevDV) {\n        self.callbacks.removed(self.collectionName, id);\n      }\n    });\n  },\n\n  diffDocument: function (id, prevDV, nowDV) {\n    var self = this;\n    var fields = {};\n    DiffSequence.diffObjects(prevDV.getFields(), nowDV.getFields(), {\n      both: function (key, prev, now) {\n        if (!EJSON.equals(prev, now))\n          fields[key] = now;\n      },\n      rightOnly: function (key, now) {\n        fields[key] = now;\n      },\n      leftOnly: function(key, prev) {\n        fields[key] = undefined;\n      }\n    });\n    self.callbacks.changed(self.collectionName, id, fields);\n  },\n\n  added: function (subscriptionHandle, id, fields) {\n    var self = this;\n    var docView = self.documents.get(id);\n    var added = false;\n    if (!docView) {\n      added = true;\n      docView = new SessionDocumentView();\n      self.documents.set(id, docView);\n    }\n    docView.existsIn.add(subscriptionHandle);\n    var changeCollector = {};\n    _.each(fields, function (value, key) {\n      docView.changeField(\n        subscriptionHandle, key, value, changeCollector, true);\n    });\n    if (added)\n      self.callbacks.added(self.collectionName, id, changeCollector);\n    else\n      self.callbacks.changed(self.collectionName, id, changeCollector);\n  },\n\n  changed: function (subscriptionHandle, id, changed) {\n    var self = this;\n    var changedResult = {};\n    var docView = self.documents.get(id);\n    if (!docView)\n      throw new Error(\"Could not find element with id \" + id + \" to change\");\n    _.each(changed, function (value, key) {\n      if (value === undefined)\n        docView.clearField(subscriptionHandle, key, changedResult);\n      else\n        docView.changeField(subscriptionHandle, key, value, changedResult);\n    });\n    self.callbacks.changed(self.collectionName, id, changedResult);\n  },\n\n  removed: function (subscriptionHandle, id) {\n    var self = this;\n    var docView = self.documents.get(id);\n    if (!docView) {\n      var err = new Error(\"Removed nonexistent document \" + id);\n      throw err;\n    }\n    docView.existsIn.delete(subscriptionHandle);\n    if (docView.existsIn.size === 0) {\n      // it is gone from everyone\n      self.callbacks.removed(self.collectionName, id);\n      self.documents.delete(id);\n    } else {\n      var changed = {};\n      // remove this subscription from every precedence list\n      // and record the changes\n      docView.dataByKey.forEach(function (precedenceList, key) {\n        docView.clearField(subscriptionHandle, key, changed);\n      });\n\n      self.callbacks.changed(self.collectionName, id, changed);\n    }\n  }\n});\n\n/******************************************************************************/\n/* Session                                                                    */\n/******************************************************************************/\n\nvar Session = function (server, version, socket, options) {\n  var self = this;\n  self.id = Random.id();\n\n  self.server = server;\n  self.version = version;\n\n  self.initialized = false;\n  self.socket = socket;\n\n  // Set to null when the session is destroyed. Multiple places below\n  // use this to determine if the session is alive or not.\n  self.inQueue = new Meteor._DoubleEndedQueue();\n\n  self.blocked = false;\n  self.workerRunning = false;\n\n  self.cachedUnblock = null;\n\n  // Sub objects for active subscriptions\n  self._namedSubs = new Map();\n  self._universalSubs = [];\n\n  self.userId = null;\n\n  self.collectionViews = new Map();\n\n  // Set this to false to not send messages when collectionViews are\n  // modified. This is done when rerunning subs in _setUserId and those messages\n  // are calculated via a diff instead.\n  self._isSending = true;\n\n  // If this is true, don't start a newly-created universal publisher on this\n  // session. The session will take care of starting it when appropriate.\n  self._dontStartNewUniversalSubs = false;\n\n  // When we are rerunning subscriptions, any ready messages\n  // we want to buffer up for when we are done rerunning subscriptions\n  self._pendingReady = [];\n\n  // List of callbacks to call when this connection is closed.\n  self._closeCallbacks = [];\n\n\n  // XXX HACK: If a sockjs connection, save off the URL. This is\n  // temporary and will go away in the near future.\n  self._socketUrl = socket.url;\n\n  // Allow tests to disable responding to pings.\n  self._respondToPings = options.respondToPings;\n\n  // This object is the public interface to the session. In the public\n  // API, it is called the `connection` object.  Internally we call it\n  // a `connectionHandle` to avoid ambiguity.\n  self.connectionHandle = {\n    id: self.id,\n    close: function () {\n      self.close();\n    },\n    onClose: function (fn) {\n      var cb = Meteor.bindEnvironment(fn, \"connection onClose callback\");\n      if (self.inQueue) {\n        self._closeCallbacks.push(cb);\n      } else {\n        // if we're already closed, call the callback.\n        Meteor.defer(cb);\n      }\n    },\n    clientAddress: self._clientAddress(),\n    httpHeaders: self.socket.headers\n  };\n\n  self.send({ msg: 'connected', session: self.id });\n\n  // On initial connect, spin up all the universal publishers.\n  Fiber(function () {\n    self.startUniversalSubs();\n  }).run();\n\n  if (version !== 'pre1' && options.heartbeatInterval !== 0) {\n    // We no longer need the low level timeout because we have heartbeats.\n    socket.setWebsocketTimeout(0);\n\n    self.heartbeat = new DDPCommon.Heartbeat({\n      heartbeatInterval: options.heartbeatInterval,\n      heartbeatTimeout: options.heartbeatTimeout,\n      onTimeout: function () {\n        self.close();\n      },\n      sendPing: function () {\n        self.send({msg: 'ping'});\n      }\n    });\n    self.heartbeat.start();\n  }\n\n  Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n    \"livedata\", \"sessions\", 1);\n};\n\nObject.assign(Session.prototype, {\n\n  sendReady: function (subscriptionIds) {\n    var self = this;\n    if (self._isSending)\n      self.send({msg: \"ready\", subs: subscriptionIds});\n    else {\n      _.each(subscriptionIds, function (subscriptionId) {\n        self._pendingReady.push(subscriptionId);\n      });\n    }\n  },\n\n  _canSend(collectionName) {\n    return this._isSending || !this.server.getPublicationStrategy(collectionName).useCollectionView;\n  },\n\n\n  sendAdded(collectionName, id, fields) {\n    if (this._canSend(collectionName))\n      this.send({msg: \"added\", collection: collectionName, id, fields});\n  },\n\n  sendChanged(collectionName, id, fields) {\n    if (_.isEmpty(fields))\n      return;\n\n    if (this._canSend(collectionName)) {\n      this.send({\n        msg: \"changed\",\n        collection: collectionName,\n        id,\n        fields\n      });\n    }\n  },\n\n  sendRemoved(collectionName, id) {\n    if (this._canSend(collectionName))\n      this.send({msg: \"removed\", collection: collectionName, id});\n  },\n\n  getSendCallbacks: function () {\n    var self = this;\n    return {\n      added: _.bind(self.sendAdded, self),\n      changed: _.bind(self.sendChanged, self),\n      removed: _.bind(self.sendRemoved, self)\n    };\n  },\n\n  getCollectionView: function (collectionName) {\n    var self = this;\n    var ret = self.collectionViews.get(collectionName);\n    if (!ret) {\n      ret = new SessionCollectionView(collectionName,\n                                        self.getSendCallbacks());\n      self.collectionViews.set(collectionName, ret);\n    }\n    return ret;\n  },\n\n  added(subscriptionHandle, collectionName, id, fields) {\n    if (this.server.getPublicationStrategy(collectionName).useCollectionView) {\n      const view = this.getCollectionView(collectionName);\n      view.added(subscriptionHandle, id, fields);\n    } else {\n      this.sendAdded(collectionName, id, fields);\n    }\n  },\n\n  removed(subscriptionHandle, collectionName, id) {\n    if (this.server.getPublicationStrategy(collectionName).useCollectionView) {\n      const view = this.getCollectionView(collectionName);\n      view.removed(subscriptionHandle, id);\n      if (view.isEmpty()) {\n         this.collectionViews.delete(collectionName);\n      }\n    } else {\n      this.sendRemoved(collectionName, id);\n    }\n  },\n\n  changed(subscriptionHandle, collectionName, id, fields) {\n    if (this.server.getPublicationStrategy(collectionName).useCollectionView) {\n      const view = this.getCollectionView(collectionName);\n      view.changed(subscriptionHandle, id, fields);\n    } else {\n      this.sendChanged(collectionName, id, fields);\n    }\n  },\n\n  startUniversalSubs: function () {\n    var self = this;\n    // Make a shallow copy of the set of universal handlers and start them. If\n    // additional universal publishers start while we're running them (due to\n    // yielding), they will run separately as part of Server.publish.\n    var handlers = _.clone(self.server.universal_publish_handlers);\n    _.each(handlers, function (handler) {\n      self._startSubscription(handler);\n    });\n  },\n\n  // Destroy this session and unregister it at the server.\n  close: function () {\n    var self = this;\n\n    // Destroy this session, even if it's not registered at the\n    // server. Stop all processing and tear everything down. If a socket\n    // was attached, close it.\n\n    // Already destroyed.\n    if (! self.inQueue)\n      return;\n\n    // Drop the merge box data immediately.\n    self.inQueue = null;\n    self.collectionViews = new Map();\n\n    if (self.heartbeat) {\n      self.heartbeat.stop();\n      self.heartbeat = null;\n    }\n\n    if (self.socket) {\n      self.socket.close();\n      self.socket._meteorSession = null;\n    }\n\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n      \"livedata\", \"sessions\", -1);\n\n    Meteor.defer(function () {\n      // Stop callbacks can yield, so we defer this on close.\n      // sub._isDeactivated() detects that we set inQueue to null and\n      // treats it as semi-deactivated (it will ignore incoming callbacks, etc).\n      self._deactivateAllSubscriptions();\n\n      // Defer calling the close callbacks, so that the caller closing\n      // the session isn't waiting for all the callbacks to complete.\n      _.each(self._closeCallbacks, function (callback) {\n        callback();\n      });\n    });\n\n    // Unregister the session.\n    self.server._removeSession(self);\n  },\n\n  // Send a message (doing nothing if no socket is connected right now).\n  // It should be a JSON object (it will be stringified).\n  send: function (msg) {\n    var self = this;\n    if (self.socket) {\n      if (Meteor._printSentDDP)\n        Meteor._debug(\"Sent DDP\", DDPCommon.stringifyDDP(msg));\n      self.socket.send(DDPCommon.stringifyDDP(msg));\n    }\n  },\n\n  // Send a connection error.\n  sendError: function (reason, offendingMessage) {\n    var self = this;\n    var msg = {msg: 'error', reason: reason};\n    if (offendingMessage)\n      msg.offendingMessage = offendingMessage;\n    self.send(msg);\n  },\n\n  // Process 'msg' as an incoming message. As a guard against\n  // race conditions during reconnection, ignore the message if\n  // 'socket' is not the currently connected socket.\n  //\n  // We run the messages from the client one at a time, in the order\n  // given by the client. The message handler is passed an idempotent\n  // function 'unblock' which it may call to allow other messages to\n  // begin running in parallel in another fiber (for example, a method\n  // that wants to yield). Otherwise, it is automatically unblocked\n  // when it returns.\n  //\n  // Actually, we don't have to 'totally order' the messages in this\n  // way, but it's the easiest thing that's correct. (unsub needs to\n  // be ordered against sub, methods need to be ordered against each\n  // other).\n  processMessage: function (msg_in) {\n    var self = this;\n    if (!self.inQueue) // we have been destroyed.\n      return;\n\n    // Respond to ping and pong messages immediately without queuing.\n    // If the negotiated DDP version is \"pre1\" which didn't support\n    // pings, preserve the \"pre1\" behavior of responding with a \"bad\n    // request\" for the unknown messages.\n    //\n    // Fibers are needed because heartbeats use Meteor.setTimeout, which\n    // needs a Fiber. We could actually use regular setTimeout and avoid\n    // these new fibers, but it is easier to just make everything use\n    // Meteor.setTimeout and not think too hard.\n    //\n    // Any message counts as receiving a pong, as it demonstrates that\n    // the client is still alive.\n    if (self.heartbeat) {\n      Fiber(function () {\n        self.heartbeat.messageReceived();\n      }).run();\n    }\n\n    if (self.version !== 'pre1' && msg_in.msg === 'ping') {\n      if (self._respondToPings)\n        self.send({msg: \"pong\", id: msg_in.id});\n      return;\n    }\n    if (self.version !== 'pre1' && msg_in.msg === 'pong') {\n      // Since everything is a pong, there is nothing to do\n      return;\n    }\n\n    self.inQueue.push(msg_in);\n    if (self.workerRunning)\n      return;\n    self.workerRunning = true;\n\n    var processNext = function () {\n      var msg = self.inQueue && self.inQueue.shift();\n      if (!msg) {\n        self.workerRunning = false;\n        return;\n      }\n\n      Fiber(function () {\n        var blocked = true;\n\n        var unblock = function () {\n          if (!blocked)\n            return; // idempotent\n          blocked = false;\n          processNext();\n        };\n\n        self.server.onMessageHook.each(function (callback) {\n          callback(msg, self);\n          return true;\n        });\n\n        if (_.has(self.protocol_handlers, msg.msg))\n          self.protocol_handlers[msg.msg].call(self, msg, unblock);\n        else\n          self.sendError('Bad request', msg);\n        unblock(); // in case the handler didn't already do it\n      }).run();\n    };\n\n    processNext();\n  },\n\n  protocol_handlers: {\n    sub: function (msg, unblock) {\n      var self = this;\n\n      // cacheUnblock temporarly, so we can capture it later\n      // we will use unblock in current eventLoop, so this is safe\n      self.cachedUnblock = unblock;\n\n      // reject malformed messages\n      if (typeof (msg.id) !== \"string\" ||\n          typeof (msg.name) !== \"string\" ||\n          (('params' in msg) && !(msg.params instanceof Array))) {\n        self.sendError(\"Malformed subscription\", msg);\n        return;\n      }\n\n      if (!self.server.publish_handlers[msg.name]) {\n        self.send({\n          msg: 'nosub', id: msg.id,\n          error: new Meteor.Error(404, `Subscription '${msg.name}' not found`)});\n        return;\n      }\n\n      if (self._namedSubs.has(msg.id))\n        // subs are idempotent, or rather, they are ignored if a sub\n        // with that id already exists. this is important during\n        // reconnect.\n        return;\n\n      // XXX It'd be much better if we had generic hooks where any package can\n      // hook into subscription handling, but in the mean while we special case\n      // ddp-rate-limiter package. This is also done for weak requirements to\n      // add the ddp-rate-limiter package in case we don't have Accounts. A\n      // user trying to use the ddp-rate-limiter must explicitly require it.\n      if (Package['ddp-rate-limiter']) {\n        var DDPRateLimiter = Package['ddp-rate-limiter'].DDPRateLimiter;\n        var rateLimiterInput = {\n          userId: self.userId,\n          clientAddress: self.connectionHandle.clientAddress,\n          type: \"subscription\",\n          name: msg.name,\n          connectionId: self.id\n        };\n\n        DDPRateLimiter._increment(rateLimiterInput);\n        var rateLimitResult = DDPRateLimiter._check(rateLimiterInput);\n        if (!rateLimitResult.allowed) {\n          self.send({\n            msg: 'nosub', id: msg.id,\n            error: new Meteor.Error(\n              'too-many-requests',\n              DDPRateLimiter.getErrorMessage(rateLimitResult),\n              {timeToReset: rateLimitResult.timeToReset})\n          });\n          return;\n        }\n      }\n\n      var handler = self.server.publish_handlers[msg.name];\n\n      self._startSubscription(handler, msg.id, msg.params, msg.name);\n\n      // cleaning cached unblock\n      self.cachedUnblock = null;\n    },\n\n    unsub: function (msg) {\n      var self = this;\n\n      self._stopSubscription(msg.id);\n    },\n\n    method: function (msg, unblock) {\n      var self = this;\n\n      // Reject malformed messages.\n      // For now, we silently ignore unknown attributes,\n      // for forwards compatibility.\n      if (typeof (msg.id) !== \"string\" ||\n          typeof (msg.method) !== \"string\" ||\n          (('params' in msg) && !(msg.params instanceof Array)) ||\n          (('randomSeed' in msg) && (typeof msg.randomSeed !== \"string\"))) {\n        self.sendError(\"Malformed method invocation\", msg);\n        return;\n      }\n\n      var randomSeed = msg.randomSeed || null;\n\n      // Set up to mark the method as satisfied once all observers\n      // (and subscriptions) have reacted to any writes that were\n      // done.\n      var fence = new DDPServer._WriteFence;\n      fence.onAllCommitted(function () {\n        // Retire the fence so that future writes are allowed.\n        // This means that callbacks like timers are free to use\n        // the fence, and if they fire before it's armed (for\n        // example, because the method waits for them) their\n        // writes will be included in the fence.\n        fence.retire();\n        self.send({\n          msg: 'updated', methods: [msg.id]});\n      });\n\n      // Find the handler\n      var handler = self.server.method_handlers[msg.method];\n      if (!handler) {\n        self.send({\n          msg: 'result', id: msg.id,\n          error: new Meteor.Error(404, `Method '${msg.method}' not found`)});\n        fence.arm();\n        return;\n      }\n\n      var setUserId = function(userId) {\n        self._setUserId(userId);\n      };\n\n      var invocation = new DDPCommon.MethodInvocation({\n        isSimulation: false,\n        userId: self.userId,\n        setUserId: setUserId,\n        unblock: unblock,\n        connection: self.connectionHandle,\n        randomSeed: randomSeed\n      });\n\n      const promise = new Promise((resolve, reject) => {\n        // XXX It'd be better if we could hook into method handlers better but\n        // for now, we need to check if the ddp-rate-limiter exists since we\n        // have a weak requirement for the ddp-rate-limiter package to be added\n        // to our application.\n        if (Package['ddp-rate-limiter']) {\n          var DDPRateLimiter = Package['ddp-rate-limiter'].DDPRateLimiter;\n          var rateLimiterInput = {\n            userId: self.userId,\n            clientAddress: self.connectionHandle.clientAddress,\n            type: \"method\",\n            name: msg.method,\n            connectionId: self.id\n          };\n          DDPRateLimiter._increment(rateLimiterInput);\n          var rateLimitResult = DDPRateLimiter._check(rateLimiterInput)\n          if (!rateLimitResult.allowed) {\n            reject(new Meteor.Error(\n              \"too-many-requests\",\n              DDPRateLimiter.getErrorMessage(rateLimitResult),\n              {timeToReset: rateLimitResult.timeToReset}\n            ));\n            return;\n          }\n        }\n\n        resolve(DDPServer._CurrentWriteFence.withValue(\n          fence,\n          () => DDP._CurrentMethodInvocation.withValue(\n            invocation,\n            () => maybeAuditArgumentChecks(\n              handler, invocation, msg.params,\n              \"call to '\" + msg.method + \"'\"\n            )\n          )\n        ));\n      });\n\n      function finish() {\n        fence.arm();\n        unblock();\n      }\n\n      const payload = {\n        msg: \"result\",\n        id: msg.id\n      };\n\n      promise.then((result) => {\n        finish();\n        if (result !== undefined) {\n          payload.result = result;\n        }\n        self.send(payload);\n      }, (exception) => {\n        finish();\n        payload.error = wrapInternalException(\n          exception,\n          `while invoking method '${msg.method}'`\n        );\n        self.send(payload);\n      });\n    }\n  },\n\n  _eachSub: function (f) {\n    var self = this;\n    self._namedSubs.forEach(f);\n    self._universalSubs.forEach(f);\n  },\n\n  _diffCollectionViews: function (beforeCVs) {\n    var self = this;\n    DiffSequence.diffMaps(beforeCVs, self.collectionViews, {\n      both: function (collectionName, leftValue, rightValue) {\n        rightValue.diff(leftValue);\n      },\n      rightOnly: function (collectionName, rightValue) {\n        rightValue.documents.forEach(function (docView, id) {\n          self.sendAdded(collectionName, id, docView.getFields());\n        });\n      },\n      leftOnly: function (collectionName, leftValue) {\n        leftValue.documents.forEach(function (doc, id) {\n          self.sendRemoved(collectionName, id);\n        });\n      }\n    });\n  },\n\n  // Sets the current user id in all appropriate contexts and reruns\n  // all subscriptions\n  _setUserId: function(userId) {\n    var self = this;\n\n    if (userId !== null && typeof userId !== \"string\")\n      throw new Error(\"setUserId must be called on string or null, not \" +\n                      typeof userId);\n\n    // Prevent newly-created universal subscriptions from being added to our\n    // session. They will be found below when we call startUniversalSubs.\n    //\n    // (We don't have to worry about named subscriptions, because we only add\n    // them when we process a 'sub' message. We are currently processing a\n    // 'method' message, and the method did not unblock, because it is illegal\n    // to call setUserId after unblock. Thus we cannot be concurrently adding a\n    // new named subscription).\n    self._dontStartNewUniversalSubs = true;\n\n    // Prevent current subs from updating our collectionViews and call their\n    // stop callbacks. This may yield.\n    self._eachSub(function (sub) {\n      sub._deactivate();\n    });\n\n    // All subs should now be deactivated. Stop sending messages to the client,\n    // save the state of the published collections, reset to an empty view, and\n    // update the userId.\n    self._isSending = false;\n    var beforeCVs = self.collectionViews;\n    self.collectionViews = new Map();\n    self.userId = userId;\n\n    // _setUserId is normally called from a Meteor method with\n    // DDP._CurrentMethodInvocation set. But DDP._CurrentMethodInvocation is not\n    // expected to be set inside a publish function, so we temporary unset it.\n    // Inside a publish function DDP._CurrentPublicationInvocation is set.\n    DDP._CurrentMethodInvocation.withValue(undefined, function () {\n      // Save the old named subs, and reset to having no subscriptions.\n      var oldNamedSubs = self._namedSubs;\n      self._namedSubs = new Map();\n      self._universalSubs = [];\n\n      oldNamedSubs.forEach(function (sub, subscriptionId) {\n        var newSub = sub._recreate();\n        self._namedSubs.set(subscriptionId, newSub);\n        // nb: if the handler throws or calls this.error(), it will in fact\n        // immediately send its 'nosub'. This is OK, though.\n        newSub._runHandler();\n      });\n\n      // Allow newly-created universal subs to be started on our connection in\n      // parallel with the ones we're spinning up here, and spin up universal\n      // subs.\n      self._dontStartNewUniversalSubs = false;\n      self.startUniversalSubs();\n    });\n\n    // Start sending messages again, beginning with the diff from the previous\n    // state of the world to the current state. No yields are allowed during\n    // this diff, so that other changes cannot interleave.\n    Meteor._noYieldsAllowed(function () {\n      self._isSending = true;\n      self._diffCollectionViews(beforeCVs);\n      if (!_.isEmpty(self._pendingReady)) {\n        self.sendReady(self._pendingReady);\n        self._pendingReady = [];\n      }\n    });\n  },\n\n  _startSubscription: function (handler, subId, params, name) {\n    var self = this;\n\n    var sub = new Subscription(\n      self, handler, subId, params, name);\n\n    let unblockHander = self.cachedUnblock;\n    // _startSubscription may call from a lot places\n    // so cachedUnblock might be null in somecases\n    // assign the cachedUnblock\n    sub.unblock = unblockHander || (() => {});\n\n    if (subId)\n      self._namedSubs.set(subId, sub);\n    else\n      self._universalSubs.push(sub);\n\n    sub._runHandler();\n  },\n\n  // Tear down specified subscription\n  _stopSubscription: function (subId, error) {\n    var self = this;\n\n    var subName = null;\n    if (subId) {\n      var maybeSub = self._namedSubs.get(subId);\n      if (maybeSub) {\n        subName = maybeSub._name;\n        maybeSub._removeAllDocuments();\n        maybeSub._deactivate();\n        self._namedSubs.delete(subId);\n      }\n    }\n\n    var response = {msg: 'nosub', id: subId};\n\n    if (error) {\n      response.error = wrapInternalException(\n        error,\n        subName ? (\"from sub \" + subName + \" id \" + subId)\n          : (\"from sub id \" + subId));\n    }\n\n    self.send(response);\n  },\n\n  // Tear down all subscriptions. Note that this does NOT send removed or nosub\n  // messages, since we assume the client is gone.\n  _deactivateAllSubscriptions: function () {\n    var self = this;\n\n    self._namedSubs.forEach(function (sub, id) {\n      sub._deactivate();\n    });\n    self._namedSubs = new Map();\n\n    self._universalSubs.forEach(function (sub) {\n      sub._deactivate();\n    });\n    self._universalSubs = [];\n  },\n\n  // Determine the remote client's IP address, based on the\n  // HTTP_FORWARDED_COUNT environment variable representing how many\n  // proxies the server is behind.\n  _clientAddress: function () {\n    var self = this;\n\n    // For the reported client address for a connection to be correct,\n    // the developer must set the HTTP_FORWARDED_COUNT environment\n    // variable to an integer representing the number of hops they\n    // expect in the `x-forwarded-for` header. E.g., set to \"1\" if the\n    // server is behind one proxy.\n    //\n    // This could be computed once at startup instead of every time.\n    var httpForwardedCount = parseInt(process.env['HTTP_FORWARDED_COUNT']) || 0;\n\n    if (httpForwardedCount === 0)\n      return self.socket.remoteAddress;\n\n    var forwardedFor = self.socket.headers[\"x-forwarded-for\"];\n    if (! _.isString(forwardedFor))\n      return null;\n    forwardedFor = forwardedFor.trim().split(/\\s*,\\s*/);\n\n    // Typically the first value in the `x-forwarded-for` header is\n    // the original IP address of the client connecting to the first\n    // proxy.  However, the end user can easily spoof the header, in\n    // which case the first value(s) will be the fake IP address from\n    // the user pretending to be a proxy reporting the original IP\n    // address value.  By counting HTTP_FORWARDED_COUNT back from the\n    // end of the list, we ensure that we get the IP address being\n    // reported by *our* first proxy.\n\n    if (httpForwardedCount < 0 || httpForwardedCount > forwardedFor.length)\n      return null;\n\n    return forwardedFor[forwardedFor.length - httpForwardedCount];\n  }\n});\n\n/******************************************************************************/\n/* Subscription                                                               */\n/******************************************************************************/\n\n// Ctor for a sub handle: the input to each publish function\n\n// Instance name is this because it's usually referred to as this inside a\n// publish\n/**\n * @summary The server's side of a subscription\n * @class Subscription\n * @instanceName this\n * @showInstanceName true\n */\nvar Subscription = function (\n    session, handler, subscriptionId, params, name) {\n  var self = this;\n  self._session = session; // type is Session\n\n  /**\n   * @summary Access inside the publish function. The incoming [connection](#meteor_onconnection) for this subscription.\n   * @locus Server\n   * @name  connection\n   * @memberOf Subscription\n   * @instance\n   */\n  self.connection = session.connectionHandle; // public API object\n\n  self._handler = handler;\n\n  // My subscription ID (generated by client, undefined for universal subs).\n  self._subscriptionId = subscriptionId;\n  // Undefined for universal subs\n  self._name = name;\n\n  self._params = params || [];\n\n  // Only named subscriptions have IDs, but we need some sort of string\n  // internally to keep track of all subscriptions inside\n  // SessionDocumentViews. We use this subscriptionHandle for that.\n  if (self._subscriptionId) {\n    self._subscriptionHandle = 'N' + self._subscriptionId;\n  } else {\n    self._subscriptionHandle = 'U' + Random.id();\n  }\n\n  // Has _deactivate been called?\n  self._deactivated = false;\n\n  // Stop callbacks to g/c this sub.  called w/ zero arguments.\n  self._stopCallbacks = [];\n\n  // The set of (collection, documentid) that this subscription has\n  // an opinion about.\n  self._documents = new Map();\n\n  // Remember if we are ready.\n  self._ready = false;\n\n  // Part of the public API: the user of this sub.\n\n  /**\n   * @summary Access inside the publish function. The id of the logged-in user, or `null` if no user is logged in.\n   * @locus Server\n   * @memberOf Subscription\n   * @name  userId\n   * @instance\n   */\n  self.userId = session.userId;\n\n  // For now, the id filter is going to default to\n  // the to/from DDP methods on MongoID, to\n  // specifically deal with mongo/minimongo ObjectIds.\n\n  // Later, you will be able to make this be \"raw\"\n  // if you want to publish a collection that you know\n  // just has strings for keys and no funny business, to\n  // a DDP consumer that isn't minimongo.\n\n  self._idFilter = {\n    idStringify: MongoID.idStringify,\n    idParse: MongoID.idParse\n  };\n\n  Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n    \"livedata\", \"subscriptions\", 1);\n};\n\nObject.assign(Subscription.prototype, {\n  _runHandler: function() {\n    // XXX should we unblock() here? Either before running the publish\n    // function, or before running _publishCursor.\n    //\n    // Right now, each publish function blocks all future publishes and\n    // methods waiting on data from Mongo (or whatever else the function\n    // blocks on). This probably slows page load in common cases.\n\n    if (!this.unblock) {\n      this.unblock = () => {};\n    }\n\n    const self = this;\n    let resultOrThenable = null;\n    try {\n      resultOrThenable = DDP._CurrentPublicationInvocation.withValue(self, () =>\n        maybeAuditArgumentChecks(\n          self._handler,\n          self,\n          EJSON.clone(self._params),\n          // It's OK that this would look weird for universal subscriptions,\n          // because they have no arguments so there can never be an\n          // audit-argument-checks failure.\n          \"publisher '\" + self._name + \"'\"\n        )\n      );\n    } catch (e) {\n      self.error(e);\n      return;\n    }\n\n    // Did the handler call this.error or this.stop?\n    if (self._isDeactivated()) return;\n\n    // Both conventional and async publish handler functions are supported.\n    // If an object is returned with a then() function, it is either a promise\n    // or thenable and will be resolved asynchronously.\n    const isThenable =\n      resultOrThenable && typeof resultOrThenable.then === 'function';\n    if (isThenable) {\n      Promise.resolve(resultOrThenable).then(\n        (...args) => self._publishHandlerResult.bind(self)(...args),\n        e => self.error(e)\n      );\n    } else {\n      self._publishHandlerResult(resultOrThenable);\n    }\n  },\n\n  _publishHandlerResult: function (res) {\n    // SPECIAL CASE: Instead of writing their own callbacks that invoke\n    // this.added/changed/ready/etc, the user can just return a collection\n    // cursor or array of cursors from the publish function; we call their\n    // _publishCursor method which starts observing the cursor and publishes the\n    // results. Note that _publishCursor does NOT call ready().\n    //\n    // XXX This uses an undocumented interface which only the Mongo cursor\n    // interface publishes. Should we make this interface public and encourage\n    // users to implement it themselves? Arguably, it's unnecessary; users can\n    // already write their own functions like\n    //   var publishMyReactiveThingy = function (name, handler) {\n    //     Meteor.publish(name, function () {\n    //       var reactiveThingy = handler();\n    //       reactiveThingy.publishMe();\n    //     });\n    //   };\n\n    var self = this;\n    var isCursor = function (c) {\n      return c && c._publishCursor;\n    };\n    if (isCursor(res)) {\n      try {\n        res._publishCursor(self);\n      } catch (e) {\n        self.error(e);\n        return;\n      }\n      // _publishCursor only returns after the initial added callbacks have run.\n      // mark subscription as ready.\n      self.ready();\n    } else if (_.isArray(res)) {\n      // Check all the elements are cursors\n      if (! _.all(res, isCursor)) {\n        self.error(new Error(\"Publish function returned an array of non-Cursors\"));\n        return;\n      }\n      // Find duplicate collection names\n      // XXX we should support overlapping cursors, but that would require the\n      // merge box to allow overlap within a subscription\n      var collectionNames = {};\n      for (var i = 0; i < res.length; ++i) {\n        var collectionName = res[i]._getCollectionName();\n        if (_.has(collectionNames, collectionName)) {\n          self.error(new Error(\n            \"Publish function returned multiple cursors for collection \" +\n              collectionName));\n          return;\n        }\n        collectionNames[collectionName] = true;\n      };\n\n      try {\n        _.each(res, function (cur) {\n          cur._publishCursor(self);\n        });\n      } catch (e) {\n        self.error(e);\n        return;\n      }\n      self.ready();\n    } else if (res) {\n      // Truthy values other than cursors or arrays are probably a\n      // user mistake (possible returning a Mongo document via, say,\n      // `coll.findOne()`).\n      self.error(new Error(\"Publish function can only return a Cursor or \"\n                           + \"an array of Cursors\"));\n    }\n  },\n\n  // This calls all stop callbacks and prevents the handler from updating any\n  // SessionCollectionViews further. It's used when the user unsubscribes or\n  // disconnects, as well as during setUserId re-runs. It does *NOT* send\n  // removed messages for the published objects; if that is necessary, call\n  // _removeAllDocuments first.\n  _deactivate: function() {\n    var self = this;\n    if (self._deactivated)\n      return;\n    self._deactivated = true;\n    self._callStopCallbacks();\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n      \"livedata\", \"subscriptions\", -1);\n  },\n\n  _callStopCallbacks: function () {\n    var self = this;\n    // Tell listeners, so they can clean up\n    var callbacks = self._stopCallbacks;\n    self._stopCallbacks = [];\n    _.each(callbacks, function (callback) {\n      callback();\n    });\n  },\n\n  // Send remove messages for every document.\n  _removeAllDocuments: function () {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._documents.forEach(function (collectionDocs, collectionName) {\n        collectionDocs.forEach(function (strId) {\n          self.removed(collectionName, self._idFilter.idParse(strId));\n        });\n      });\n    });\n  },\n\n  // Returns a new Subscription for the same session with the same\n  // initial creation parameters. This isn't a clone: it doesn't have\n  // the same _documents cache, stopped state or callbacks; may have a\n  // different _subscriptionHandle, and gets its userId from the\n  // session, not from this object.\n  _recreate: function () {\n    var self = this;\n    return new Subscription(\n      self._session, self._handler, self._subscriptionId, self._params,\n      self._name);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Stops this client's subscription, triggering a call on the client to the `onStop` callback passed to [`Meteor.subscribe`](#meteor_subscribe), if any. If `error` is not a [`Meteor.Error`](#meteor_error), it will be [sanitized](#meteor_error).\n   * @locus Server\n   * @param {Error} error The error to pass to the client.\n   * @instance\n   * @memberOf Subscription\n   */\n  error: function (error) {\n    var self = this;\n    if (self._isDeactivated())\n      return;\n    self._session._stopSubscription(self._subscriptionId, error);\n  },\n\n  // Note that while our DDP client will notice that you've called stop() on the\n  // server (and clean up its _subscriptions table) we don't actually provide a\n  // mechanism for an app to notice this (the subscribe onError callback only\n  // triggers if there is an error).\n\n  /**\n   * @summary Call inside the publish function.  Stops this client's subscription and invokes the client's `onStop` callback with no error.\n   * @locus Server\n   * @instance\n   * @memberOf Subscription\n   */\n  stop: function () {\n    var self = this;\n    if (self._isDeactivated())\n      return;\n    self._session._stopSubscription(self._subscriptionId);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Registers a callback function to run when the subscription is stopped.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {Function} func The callback function\n   */\n  onStop: function (callback) {\n    var self = this;\n    callback = Meteor.bindEnvironment(callback, 'onStop callback', self);\n    if (self._isDeactivated())\n      callback();\n    else\n      self._stopCallbacks.push(callback);\n  },\n\n  // This returns true if the sub has been deactivated, *OR* if the session was\n  // destroyed but the deferred call to _deactivateAllSubscriptions hasn't\n  // happened yet.\n  _isDeactivated: function () {\n    var self = this;\n    return self._deactivated || self._session.inQueue === null;\n  },\n\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that a document has been added to the record set.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {String} collection The name of the collection that contains the new document.\n   * @param {String} id The new document's ID.\n   * @param {Object} fields The fields in the new document.  If `_id` is present it is ignored.\n   */\n  added (collectionName, id, fields) {\n    if (this._isDeactivated())\n      return;\n    id = this._idFilter.idStringify(id);\n\n    if (this._session.server.getPublicationStrategy(collectionName).doAccountingForCollection) {\n      let ids = this._documents.get(collectionName);\n      if (ids == null) {\n        ids = new Set();\n        this._documents.set(collectionName, ids);\n      }\n      ids.add(id);\n    }\n\n    this._session.added(this._subscriptionHandle, collectionName, id, fields);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that a document in the record set has been modified.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {String} collection The name of the collection that contains the changed document.\n   * @param {String} id The changed document's ID.\n   * @param {Object} fields The fields in the document that have changed, together with their new values.  If a field is not present in `fields` it was left unchanged; if it is present in `fields` and has a value of `undefined` it was removed from the document.  If `_id` is present it is ignored.\n   */\n  changed (collectionName, id, fields) {\n    if (this._isDeactivated())\n      return;\n    id = this._idFilter.idStringify(id);\n    this._session.changed(this._subscriptionHandle, collectionName, id, fields);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that a document has been removed from the record set.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {String} collection The name of the collection that the document has been removed from.\n   * @param {String} id The ID of the document that has been removed.\n   */\n  removed (collectionName, id) {\n    if (this._isDeactivated())\n      return;\n    id = this._idFilter.idStringify(id);\n\n    if (this._session.server.getPublicationStrategy(collectionName).doAccountingForCollection) {\n      // We don't bother to delete sets of things in a collection if the\n      // collection is empty.  It could break _removeAllDocuments.\n      this._documents.get(collectionName).delete(id);\n    }\n\n    this._session.removed(this._subscriptionHandle, collectionName, id);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that an initial, complete snapshot of the record set has been sent.  This will trigger a call on the client to the `onReady` callback passed to  [`Meteor.subscribe`](#meteor_subscribe), if any.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   */\n  ready: function () {\n    var self = this;\n    if (self._isDeactivated())\n      return;\n    if (!self._subscriptionId)\n      return;  // Unnecessary but ignored for universal sub\n    if (!self._ready) {\n      self._session.sendReady([self._subscriptionId]);\n      self._ready = true;\n    }\n  }\n});\n\n/******************************************************************************/\n/* Server                                                                     */\n/******************************************************************************/\n\nServer = function (options = {}) {\n  var self = this;\n\n  // The default heartbeat interval is 30 seconds on the server and 35\n  // seconds on the client.  Since the client doesn't need to send a\n  // ping as long as it is receiving pings, this means that pings\n  // normally go from the server to the client.\n  //\n  // Note: Troposphere depends on the ability to mutate\n  // Meteor.server.options.heartbeatTimeout! This is a hack, but it's life.\n  self.options = {\n    heartbeatInterval: 15000,\n    heartbeatTimeout: 15000,\n    // For testing, allow responding to pings to be disabled.\n    respondToPings: true,\n    defaultPublicationStrategy: publicationStrategies.SERVER_MERGE,\n    ...options,\n  };\n\n  // Map of callbacks to call when a new connection comes in to the\n  // server and completes DDP version negotiation. Use an object instead\n  // of an array so we can safely remove one from the list while\n  // iterating over it.\n  self.onConnectionHook = new Hook({\n    debugPrintExceptions: \"onConnection callback\"\n  });\n\n  // Map of callbacks to call when a new message comes in.\n  self.onMessageHook = new Hook({\n    debugPrintExceptions: \"onMessage callback\"\n  });\n\n  self.publish_handlers = {};\n  self.universal_publish_handlers = [];\n\n  self.method_handlers = {};\n\n  self._publicationStrategies = {};\n\n  self.sessions = new Map(); // map from id to session\n\n  self.stream_server = new StreamServer;\n\n  self.stream_server.register(function (socket) {\n    // socket implements the SockJSConnection interface\n    socket._meteorSession = null;\n\n    var sendError = function (reason, offendingMessage) {\n      var msg = {msg: 'error', reason: reason};\n      if (offendingMessage)\n        msg.offendingMessage = offendingMessage;\n      socket.send(DDPCommon.stringifyDDP(msg));\n    };\n\n    socket.on('data', function (raw_msg) {\n      if (Meteor._printReceivedDDP) {\n        Meteor._debug(\"Received DDP\", raw_msg);\n      }\n      try {\n        try {\n          var msg = DDPCommon.parseDDP(raw_msg);\n        } catch (err) {\n          sendError('Parse error');\n          return;\n        }\n        if (msg === null || !msg.msg) {\n          sendError('Bad request', msg);\n          return;\n        }\n\n        if (msg.msg === 'connect') {\n          if (socket._meteorSession) {\n            sendError(\"Already connected\", msg);\n            return;\n          }\n          Fiber(function () {\n            self._handleConnect(socket, msg);\n          }).run();\n          return;\n        }\n\n        if (!socket._meteorSession) {\n          sendError('Must connect first', msg);\n          return;\n        }\n        socket._meteorSession.processMessage(msg);\n      } catch (e) {\n        // XXX print stack nicely\n        Meteor._debug(\"Internal exception while processing message\", msg, e);\n      }\n    });\n\n    socket.on('close', function () {\n      if (socket._meteorSession) {\n        Fiber(function () {\n          socket._meteorSession.close();\n        }).run();\n      }\n    });\n  });\n};\n\nObject.assign(Server.prototype, {\n\n  /**\n   * @summary Register a callback to be called when a new DDP connection is made to the server.\n   * @locus Server\n   * @param {function} callback The function to call when a new DDP connection is established.\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */\n  onConnection: function (fn) {\n    var self = this;\n    return self.onConnectionHook.register(fn);\n  },\n\n  /**\n   * @summary Set publication strategy for the given publication. Publications strategies are available from `DDPServer.publicationStrategies`. You call this method from `Meteor.server`, like `Meteor.server.setPublicationStrategy()`\n   * @locus Server\n   * @alias setPublicationStrategy\n   * @param publicationName {String}\n   * @param strategy {{useCollectionView: boolean, doAccountingForCollection: boolean}}\n   * @memberOf Meteor.server\n   * @importFromPackage meteor\n   */\n  setPublicationStrategy(publicationName, strategy) {\n    if (!Object.values(publicationStrategies).includes(strategy)) {\n      throw new Error(`Invalid merge strategy: ${strategy} \n        for collection ${publicationName}`);\n    }\n    this._publicationStrategies[publicationName] = strategy;\n  },\n\n  /**\n   * @summary Gets the publication strategy for the requested publication. You call this method from `Meteor.server`, like `Meteor.server.getPublicationStrategy()`\n   * @locus Server\n   * @alias getPublicationStrategy\n   * @param publicationName {String}\n   * @memberOf Meteor.server\n   * @importFromPackage meteor\n   * @return {{useCollectionView: boolean, doAccountingForCollection: boolean}}\n   */\n  getPublicationStrategy(publicationName) {\n    return this._publicationStrategies[publicationName]\n      || this.options.defaultPublicationStrategy;\n  },\n\n  /**\n   * @summary Register a callback to be called when a new DDP message is received.\n   * @locus Server\n   * @param {function} callback The function to call when a new DDP message is received.\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */\n  onMessage: function (fn) {\n    var self = this;\n    return self.onMessageHook.register(fn);\n  },\n\n  _handleConnect: function (socket, msg) {\n    var self = this;\n\n    // The connect message must specify a version and an array of supported\n    // versions, and it must claim to support what it is proposing.\n    if (!(typeof (msg.version) === 'string' &&\n          _.isArray(msg.support) &&\n          _.all(msg.support, _.isString) &&\n          _.contains(msg.support, msg.version))) {\n      socket.send(DDPCommon.stringifyDDP({msg: 'failed',\n                                version: DDPCommon.SUPPORTED_DDP_VERSIONS[0]}));\n      socket.close();\n      return;\n    }\n\n    // In the future, handle session resumption: something like:\n    //  socket._meteorSession = self.sessions[msg.session]\n    var version = calculateVersion(msg.support, DDPCommon.SUPPORTED_DDP_VERSIONS);\n\n    if (msg.version !== version) {\n      // The best version to use (according to the client's stated preferences)\n      // is not the one the client is trying to use. Inform them about the best\n      // version to use.\n      socket.send(DDPCommon.stringifyDDP({msg: 'failed', version: version}));\n      socket.close();\n      return;\n    }\n\n    // Yay, version matches! Create a new session.\n    // Note: Troposphere depends on the ability to mutate\n    // Meteor.server.options.heartbeatTimeout! This is a hack, but it's life.\n    socket._meteorSession = new Session(self, version, socket, self.options);\n    self.sessions.set(socket._meteorSession.id, socket._meteorSession);\n    self.onConnectionHook.each(function (callback) {\n      if (socket._meteorSession)\n        callback(socket._meteorSession.connectionHandle);\n      return true;\n    });\n  },\n  /**\n   * Register a publish handler function.\n   *\n   * @param name {String} identifier for query\n   * @param handler {Function} publish handler\n   * @param options {Object}\n   *\n   * Server will call handler function on each new subscription,\n   * either when receiving DDP sub message for a named subscription, or on\n   * DDP connect for a universal subscription.\n   *\n   * If name is null, this will be a subscription that is\n   * automatically established and permanently on for all connected\n   * client, instead of a subscription that can be turned on and off\n   * with subscribe().\n   *\n   * options to contain:\n   *  - (mostly internal) is_auto: true if generated automatically\n   *    from an autopublish hook. this is for cosmetic purposes only\n   *    (it lets us determine whether to print a warning suggesting\n   *    that you turn off autopublish).\n   */\n\n  /**\n   * @summary Publish a record set.\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   * @locus Server\n   * @param {String|Object} name If String, name of the record set.  If Object, publications Dictionary of publish functions by name.  If `null`, the set has no name, and the record set is automatically sent to all connected clients.\n   * @param {Function} func Function called on the server each time a client subscribes.  Inside the function, `this` is the publish handler object, described below.  If the client passed arguments to `subscribe`, the function is called with the same arguments.\n   */\n  publish: function (name, handler, options) {\n    var self = this;\n\n    if (! _.isObject(name)) {\n      options = options || {};\n\n      if (name && name in self.publish_handlers) {\n        Meteor._debug(\"Ignoring duplicate publish named '\" + name + \"'\");\n        return;\n      }\n\n      if (Package.autopublish && !options.is_auto) {\n        // They have autopublish on, yet they're trying to manually\n        // pick stuff to publish. They probably should turn off\n        // autopublish. (This check isn't perfect -- if you create a\n        // publish before you turn on autopublish, it won't catch\n        // it, but this will definitely handle the simple case where\n        // you've added the autopublish package to your app, and are\n        // calling publish from your app code).\n        if (!self.warned_about_autopublish) {\n          self.warned_about_autopublish = true;\n          Meteor._debug(\n    \"** You've set up some data subscriptions with Meteor.publish(), but\\n\" +\n    \"** you still have autopublish turned on. Because autopublish is still\\n\" +\n    \"** on, your Meteor.publish() calls won't have much effect. All data\\n\" +\n    \"** will still be sent to all clients.\\n\" +\n    \"**\\n\" +\n    \"** Turn off autopublish by removing the autopublish package:\\n\" +\n    \"**\\n\" +\n    \"**   $ meteor remove autopublish\\n\" +\n    \"**\\n\" +\n    \"** .. and make sure you have Meteor.publish() and Meteor.subscribe() calls\\n\" +\n    \"** for each collection that you want clients to see.\\n\");\n        }\n      }\n\n      if (name)\n        self.publish_handlers[name] = handler;\n      else {\n        self.universal_publish_handlers.push(handler);\n        // Spin up the new publisher on any existing session too. Run each\n        // session's subscription in a new Fiber, so that there's no change for\n        // self.sessions to change while we're running this loop.\n        self.sessions.forEach(function (session) {\n          if (!session._dontStartNewUniversalSubs) {\n            Fiber(function() {\n              session._startSubscription(handler);\n            }).run();\n          }\n        });\n      }\n    }\n    else{\n      _.each(name, function(value, key) {\n        self.publish(key, value, {});\n      });\n    }\n  },\n\n  _removeSession: function (session) {\n    var self = this;\n    self.sessions.delete(session.id);\n  },\n\n  /**\n   * @summary Defines functions that can be invoked over the network by clients.\n   * @locus Anywhere\n   * @param {Object} methods Dictionary whose keys are method names and values are functions.\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */\n  methods: function (methods) {\n    var self = this;\n    _.each(methods, function (func, name) {\n      if (typeof func !== 'function')\n        throw new Error(\"Method '\" + name + \"' must be a function\");\n      if (self.method_handlers[name])\n        throw new Error(\"A method named '\" + name + \"' is already defined\");\n      self.method_handlers[name] = func;\n    });\n  },\n\n  call: function (name, ...args) {\n    if (args.length && typeof args[args.length - 1] === \"function\") {\n      // If it's a function, the last argument is the result callback, not\n      // a parameter to the remote method.\n      var callback = args.pop();\n    }\n\n    return this.apply(name, args, callback);\n  },\n\n  // A version of the call method that always returns a Promise.\n  callAsync: function (name, ...args) {\n    return this.applyAsync(name, args);\n  },\n\n  apply: function (name, args, options, callback) {\n    // We were passed 3 arguments. They may be either (name, args, options)\n    // or (name, args, callback)\n    if (! callback && typeof options === 'function') {\n      callback = options;\n      options = {};\n    } else {\n      options = options || {};\n    }\n\n    const promise = this.applyAsync(name, args, options);\n\n    // Return the result in whichever way the caller asked for it. Note that we\n    // do NOT block on the write fence in an analogous way to how the client\n    // blocks on the relevant data being visible, so you are NOT guaranteed that\n    // cursor observe callbacks have fired when your callback is invoked. (We\n    // can change this if there's a real use case).\n    if (callback) {\n      promise.then(\n        result => callback(undefined, result),\n        exception => callback(exception)\n      );\n    } else {\n      return promise.await();\n    }\n  },\n\n  // @param options {Optional Object}\n  applyAsync: function (name, args, options) {\n    // Run the handler\n    var handler = this.method_handlers[name];\n    if (! handler) {\n      return Promise.reject(\n        new Meteor.Error(404, `Method '${name}' not found`)\n      );\n    }\n\n    // If this is a method call from within another method or publish function,\n    // get the user state from the outer method or publish function, otherwise\n    // don't allow setUserId to be called\n    var userId = null;\n    var setUserId = function() {\n      throw new Error(\"Can't call setUserId on a server initiated method call\");\n    };\n    var connection = null;\n    var currentMethodInvocation = DDP._CurrentMethodInvocation.get();\n    var currentPublicationInvocation = DDP._CurrentPublicationInvocation.get();\n    var randomSeed = null;\n    if (currentMethodInvocation) {\n      userId = currentMethodInvocation.userId;\n      setUserId = function(userId) {\n        currentMethodInvocation.setUserId(userId);\n      };\n      connection = currentMethodInvocation.connection;\n      randomSeed = DDPCommon.makeRpcSeed(currentMethodInvocation, name);\n    } else if (currentPublicationInvocation) {\n      userId = currentPublicationInvocation.userId;\n      setUserId = function(userId) {\n        currentPublicationInvocation._session._setUserId(userId);\n      };\n      connection = currentPublicationInvocation.connection;\n    }\n\n    var invocation = new DDPCommon.MethodInvocation({\n      isSimulation: false,\n      userId,\n      setUserId,\n      connection,\n      randomSeed\n    });\n\n    return new Promise(resolve => resolve(\n      DDP._CurrentMethodInvocation.withValue(\n        invocation,\n        () => maybeAuditArgumentChecks(\n          handler, invocation, EJSON.clone(args),\n          \"internal call to '\" + name + \"'\"\n        )\n      )\n    )).then(EJSON.clone);\n  },\n\n  _urlForSession: function (sessionId) {\n    var self = this;\n    var session = self.sessions.get(sessionId);\n    if (session)\n      return session._socketUrl;\n    else\n      return null;\n  }\n});\n\nvar calculateVersion = function (clientSupportedVersions,\n                                 serverSupportedVersions) {\n  var correctVersion = _.find(clientSupportedVersions, function (version) {\n    return _.contains(serverSupportedVersions, version);\n  });\n  if (!correctVersion) {\n    correctVersion = serverSupportedVersions[0];\n  }\n  return correctVersion;\n};\n\nDDPServer._calculateVersion = calculateVersion;\n\n\n// \"blind\" exceptions other than those that were deliberately thrown to signal\n// errors to the client\nvar wrapInternalException = function (exception, context) {\n  if (!exception) return exception;\n\n  // To allow packages to throw errors intended for the client but not have to\n  // depend on the Meteor.Error class, `isClientSafe` can be set to true on any\n  // error before it is thrown.\n  if (exception.isClientSafe) {\n    if (!(exception instanceof Meteor.Error)) {\n      const originalMessage = exception.message;\n      exception = new Meteor.Error(exception.error, exception.reason, exception.details);\n      exception.message = originalMessage;\n    }\n    return exception;\n  }\n\n  // Tests can set the '_expectedByTest' flag on an exception so it won't go to\n  // the server log.\n  if (!exception._expectedByTest) {\n    Meteor._debug(\"Exception \" + context, exception.stack);\n    if (exception.sanitizedError) {\n      Meteor._debug(\"Sanitized and reported to the client as:\", exception.sanitizedError);\n      Meteor._debug();\n    }\n  }\n\n  // Did the error contain more details that could have been useful if caught in\n  // server code (or if thrown from non-client-originated code), but also\n  // provided a \"sanitized\" version with more context than 500 Internal server\n  // error? Use that.\n  if (exception.sanitizedError) {\n    if (exception.sanitizedError.isClientSafe)\n      return exception.sanitizedError;\n    Meteor._debug(\"Exception \" + context + \" provides a sanitizedError that \" +\n                  \"does not have isClientSafe property set; ignoring\");\n  }\n\n  return new Meteor.Error(500, \"Internal server error\");\n};\n\n\n// Audit argument checks, if the audit-argument-checks package exists (it is a\n// weak dependency of this package).\nvar maybeAuditArgumentChecks = function (f, context, args, description) {\n  args = args || [];\n  if (Package['audit-argument-checks']) {\n    return Match._failIfArgumentsAreNotAllChecked(\n      f, context, args, description);\n  }\n  return f.apply(context, args);\n};\n"]},"sourceType":"module","hash":"2d509afc9c4a3c8cfb06e148760fa5aa5a6a30a6"}
