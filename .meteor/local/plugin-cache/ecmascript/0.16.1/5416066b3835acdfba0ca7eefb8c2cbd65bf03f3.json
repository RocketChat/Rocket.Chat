{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/weslley/Documents/projects/Rocket.Chat/packages/mongo/doc_fetcher.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"packages/mongo/doc_fetcher.js","filename":"/home/weslley/Documents/projects/Rocket.Chat/packages/mongo/doc_fetcher.js","targets":{"android":"95.0.0","chrome":"95.0.0","edge":"95.0.0","firefox":"78.0.0","ie":"10.0.0","ios":"15.0.0","opera":"81.0.0","safari":"15.1.0","samsung":"14.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/home/weslley/Documents/projects/Rocket.Chat","root":"/home/weslley/Documents/projects/Rocket.Chat","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.16.5","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/home/weslley/Documents/projects/Rocket.Chat/packages/mongo/doc_fetcher.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/mongo/doc_fetcher.js"}},"code":"module.export({\n  DocFetcher: () => DocFetcher\n});\n\nvar Fiber = Npm.require('fibers');\n\nclass DocFetcher {\n  constructor(mongoConnection) {\n    this._mongoConnection = mongoConnection; // Map from op -> [callback]\n\n    this._callbacksForOp = new Map();\n  } // Fetches document \"id\" from collectionName, returning it or null if not\n  // found.\n  //\n  // If you make multiple calls to fetch() with the same op reference,\n  // DocFetcher may assume that they all return the same document. (It does\n  // not check to see if collectionName/id match.)\n  //\n  // You may assume that callback is never called synchronously (and in fact\n  // OplogObserveDriver does so).\n\n\n  fetch(collectionName, id, op, callback) {\n    const self = this;\n    check(collectionName, String);\n    check(op, Object); // If there's already an in-progress fetch for this cache key, yield until\n    // it's done and return whatever it returns.\n\n    if (self._callbacksForOp.has(op)) {\n      self._callbacksForOp.get(op).push(callback);\n\n      return;\n    }\n\n    const callbacks = [callback];\n\n    self._callbacksForOp.set(op, callbacks);\n\n    Fiber(function () {\n      try {\n        var doc = self._mongoConnection.findOne(collectionName, {\n          _id: id\n        }) || null; // Return doc to all relevant callbacks. Note that this array can\n        // continue to grow during callback excecution.\n\n        while (callbacks.length > 0) {\n          // Clone the document so that the various calls to fetch don't return\n          // objects that are intertwingled with each other. Clone before\n          // popping the future, so that if clone throws, the error gets passed\n          // to the next callback.\n          callbacks.pop()(null, EJSON.clone(doc));\n        }\n      } catch (e) {\n        while (callbacks.length > 0) {\n          callbacks.pop()(e);\n        }\n      } finally {\n        // XXX consider keeping the doc around for a period of time before\n        // removing from the cache\n        self._callbacksForOp.delete(op);\n      }\n    }).run();\n  }\n\n}","map":{"version":3,"sources":["packages/mongo/doc_fetcher.js"],"names":["module","export","DocFetcher","Fiber","Npm","require","constructor","mongoConnection","_mongoConnection","_callbacksForOp","Map","fetch","collectionName","id","op","callback","self","check","String","Object","has","get","push","callbacks","set","doc","findOne","_id","length","pop","EJSON","clone","e","delete","run"],"mappings":"AAAAA,MAAM,CAACC,MAAP,CAAc;AAACC,EAAAA,UAAU,EAAC,MAAIA;AAAhB,CAAd;;AAAA,IAAIC,KAAK,GAAGC,GAAG,CAACC,OAAJ,CAAY,QAAZ,CAAZ;;AAEO,MAAMH,UAAN,CAAiB;AACtBI,EAAAA,WAAW,CAACC,eAAD,EAAkB;AAC3B,SAAKC,gBAAL,GAAwBD,eAAxB,CAD2B,CAE3B;;AACA,SAAKE,eAAL,GAAuB,IAAIC,GAAJ,EAAvB;AACD,GALqB,CAOtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAC,EAAAA,KAAK,CAACC,cAAD,EAAiBC,EAAjB,EAAqBC,EAArB,EAAyBC,QAAzB,EAAmC;AACtC,UAAMC,IAAI,GAAG,IAAb;AAEAC,IAAAA,KAAK,CAACL,cAAD,EAAiBM,MAAjB,CAAL;AACAD,IAAAA,KAAK,CAACH,EAAD,EAAKK,MAAL,CAAL,CAJsC,CAMtC;AACA;;AACA,QAAIH,IAAI,CAACP,eAAL,CAAqBW,GAArB,CAAyBN,EAAzB,CAAJ,EAAkC;AAChCE,MAAAA,IAAI,CAACP,eAAL,CAAqBY,GAArB,CAAyBP,EAAzB,EAA6BQ,IAA7B,CAAkCP,QAAlC;;AACA;AACD;;AAED,UAAMQ,SAAS,GAAG,CAACR,QAAD,CAAlB;;AACAC,IAAAA,IAAI,CAACP,eAAL,CAAqBe,GAArB,CAAyBV,EAAzB,EAA6BS,SAA7B;;AAEApB,IAAAA,KAAK,CAAC,YAAY;AAChB,UAAI;AACF,YAAIsB,GAAG,GAAGT,IAAI,CAACR,gBAAL,CAAsBkB,OAAtB,CACRd,cADQ,EACQ;AAACe,UAAAA,GAAG,EAAEd;AAAN,SADR,KACsB,IADhC,CADE,CAGF;AACA;;AACA,eAAOU,SAAS,CAACK,MAAV,GAAmB,CAA1B,EAA6B;AAC3B;AACA;AACA;AACA;AACAL,UAAAA,SAAS,CAACM,GAAV,GAAgB,IAAhB,EAAsBC,KAAK,CAACC,KAAN,CAAYN,GAAZ,CAAtB;AACD;AACF,OAZD,CAYE,OAAOO,CAAP,EAAU;AACV,eAAOT,SAAS,CAACK,MAAV,GAAmB,CAA1B,EAA6B;AAC3BL,UAAAA,SAAS,CAACM,GAAV,GAAgBG,CAAhB;AACD;AACF,OAhBD,SAgBU;AACR;AACA;AACAhB,QAAAA,IAAI,CAACP,eAAL,CAAqBwB,MAArB,CAA4BnB,EAA5B;AACD;AACF,KAtBI,CAAL,CAsBGoB,GAtBH;AAuBD;;AAvDqB","sourcesContent":["var Fiber = Npm.require('fibers');\n\nexport class DocFetcher {\n  constructor(mongoConnection) {\n    this._mongoConnection = mongoConnection;\n    // Map from op -> [callback]\n    this._callbacksForOp = new Map;\n  }\n\n  // Fetches document \"id\" from collectionName, returning it or null if not\n  // found.\n  //\n  // If you make multiple calls to fetch() with the same op reference,\n  // DocFetcher may assume that they all return the same document. (It does\n  // not check to see if collectionName/id match.)\n  //\n  // You may assume that callback is never called synchronously (and in fact\n  // OplogObserveDriver does so).\n  fetch(collectionName, id, op, callback) {\n    const self = this;\n\n    check(collectionName, String);\n    check(op, Object);\n\n    // If there's already an in-progress fetch for this cache key, yield until\n    // it's done and return whatever it returns.\n    if (self._callbacksForOp.has(op)) {\n      self._callbacksForOp.get(op).push(callback);\n      return;\n    }\n\n    const callbacks = [callback];\n    self._callbacksForOp.set(op, callbacks);\n\n    Fiber(function () {\n      try {\n        var doc = self._mongoConnection.findOne(\n          collectionName, {_id: id}) || null;\n        // Return doc to all relevant callbacks. Note that this array can\n        // continue to grow during callback excecution.\n        while (callbacks.length > 0) {\n          // Clone the document so that the various calls to fetch don't return\n          // objects that are intertwingled with each other. Clone before\n          // popping the future, so that if clone throws, the error gets passed\n          // to the next callback.\n          callbacks.pop()(null, EJSON.clone(doc));\n        }\n      } catch (e) {\n        while (callbacks.length > 0) {\n          callbacks.pop()(e);\n        }\n      } finally {\n        // XXX consider keeping the doc around for a period of time before\n        // removing from the cache\n        self._callbacksForOp.delete(op);\n      }\n    }).run();\n  }\n}\n"]},"sourceType":"module","hash":"5416066b3835acdfba0ca7eefb8c2cbd65bf03f3"}
