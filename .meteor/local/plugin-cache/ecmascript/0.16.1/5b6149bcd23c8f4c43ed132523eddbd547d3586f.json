{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/packages/accounts-base/accounts_client.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser.legacy"},"sourceFileName":"packages/accounts-base/accounts_client.js","filename":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/packages/accounts-base/accounts_client.js","targets":{"android":"95.0.0","chrome":"95.0.0","edge":"95.0.0","firefox":"78.0.0","ie":"10.0.0","ios":"15.0.0","opera":"81.0.0","safari":"15.1.0","samsung":"14.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat","root":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":true,"enforceStrictMode":false,"dynamicImport":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.16.5","helpers":true,"useESModules":false,"corejs":false}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"base$0$3","visitor":{"FunctionExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$4","visitor":{"ForInStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-arrow-functions","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-block-scoped-functions","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-block-scoping","visitor":{"VariableDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"_exploded":true,"BlockStatement":{"enter":[null]},"SwitchStatement":{"enter":[null]},"Program":{"enter":[null]},"_verified":true,"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-classes","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-computed-properties","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-destructuring","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-object-super","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-shorthand-properties","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-spread","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-sticky-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-typeof-symbol","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"StaticBlock":{"enter":[null]},"TSModuleBlock":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectPattern":{"enter":[null]}},"options":{}},{"key":"transform-unicode-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-property-literals","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"regenerator-transform","visitor":{"_exploded":true,"_verified":true,"ObjectMethod":{"enter":[null],"exit":[null]},"ClassMethod":{"enter":[null],"exit":[null]},"ClassPrivateMethod":{"enter":[null],"exit":[null]},"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]}},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/packages/accounts-base/accounts_client.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/accounts-base/accounts_client.js"}},"code":"var _objectSpread;\n\nmodule.link(\"@babel/runtime/helpers/objectSpread2\", {\n  default: function (v) {\n    _objectSpread = v;\n  }\n}, 0);\n\nvar _inheritsLoose;\n\nmodule.link(\"@babel/runtime/helpers/inheritsLoose\", {\n  default: function (v) {\n    _inheritsLoose = v;\n  }\n}, 1);\nmodule.export({\n  AccountsClient: function () {\n    return AccountsClient;\n  },\n  AccountsTest: function () {\n    return AccountsTest;\n  }\n});\nvar AccountsCommon;\nmodule.link(\"./accounts_common.js\", {\n  AccountsCommon: function (v) {\n    AccountsCommon = v;\n  }\n}, 0);\n\nvar AccountsClient = /*#__PURE__*/function (_AccountsCommon) {\n  _inheritsLoose(AccountsClient, _AccountsCommon);\n\n  function AccountsClient(options) {\n    var _this;\n\n    _this = _AccountsCommon.call(this, options) || this;\n    _this._loggingIn = new ReactiveVar(false);\n    _this._loggingOut = new ReactiveVar(false);\n    _this._loginServicesHandle = _this.connection.subscribe(\"meteor.loginServiceConfiguration\");\n    _this._pageLoadLoginCallbacks = [];\n    _this._pageLoadLoginAttemptInfo = null;\n    _this.savedHash = window.location.hash;\n\n    _this._initUrlMatching(); // Defined in localstorage_token.js.\n\n\n    _this._initLocalStorage(); // This is for .registerClientLoginFunction & .callLoginFunction.\n\n\n    _this._loginFuncs = {}; // This tracks whether callbacks registered with\n    // Accounts.onLogin have been called\n\n    _this._loginCallbacksCalled = false;\n    return _this;\n  } ///\n  /// CURRENT USER\n  ///\n  // @override\n\n\n  var _proto = AccountsClient.prototype;\n\n  _proto.userId = function () {\n    function userId() {\n      return this.connection.userId();\n    }\n\n    return userId;\n  }() // This is mostly just called within this file, but Meteor.loginWithPassword\n  // also uses it to make loggingIn() be true during the beginPasswordExchange\n  // method call too.\n  ;\n\n  _proto._setLoggingIn = function () {\n    function _setLoggingIn(x) {\n      this._loggingIn.set(x);\n    }\n\n    return _setLoggingIn;\n  }()\n  /**\n   * @summary True if a login method (such as `Meteor.loginWithPassword`, `Meteor.loginWithFacebook`, or `Accounts.createUser`) is currently in progress. A reactive data source.\n   * @locus Client\n   */\n  ;\n\n  _proto.loggingIn = function () {\n    function loggingIn() {\n      return this._loggingIn.get();\n    }\n\n    return loggingIn;\n  }()\n  /**\n   * @summary True if a logout method (such as `Meteor.logout`) is currently in progress. A reactive data source.\n   * @locus Client\n   */\n  ;\n\n  _proto.loggingOut = function () {\n    function loggingOut() {\n      return this._loggingOut.get();\n    }\n\n    return loggingOut;\n  }()\n  /**\n   * @summary Register a new login function on the client. Intended for OAuth package authors. You can call the login function by using\n   `Accounts.callLoginFunction` or `Accounts.callLoginFunction`.\n   * @locus Client\n   * @param {String} funcName The name of your login function. Used by `Accounts.callLoginFunction` and `Accounts.applyLoginFunction`.\n   Should be the OAuth provider name accordingly.\n   * @param {Function} func The actual function you want to call. Just write it in the manner of `loginWithFoo`.\n   */\n  ;\n\n  _proto.registerClientLoginFunction = function () {\n    function registerClientLoginFunction(funcName, func) {\n      if (this._loginFuncs[funcName]) {\n        throw new Error(funcName + \" has been defined already\");\n      }\n\n      this._loginFuncs[funcName] = func;\n    }\n\n    return registerClientLoginFunction;\n  }()\n  /**\n   * @summary Call a login function defined using `Accounts.registerClientLoginFunction`. Excluding the first argument, all remaining\n   arguments are passed to the login function accordingly. Use `applyLoginFunction` if you want to pass in an arguments array that contains\n   all arguments for the login function.\n   * @locus Client\n   * @param {String} funcName The name of the login function you wanted to call.\n   */\n  ;\n\n  _proto.callLoginFunction = function () {\n    function callLoginFunction(funcName) {\n      if (!this._loginFuncs[funcName]) {\n        throw new Error(funcName + \" was not defined\");\n      }\n\n      for (var _len = arguments.length, funcArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        funcArgs[_key - 1] = arguments[_key];\n      }\n\n      return this._loginFuncs[funcName].apply(this, funcArgs);\n    }\n\n    return callLoginFunction;\n  }()\n  /**\n   * @summary Same as ``callLoginFunction` but accept an `arguments` which contains all arguments for the login\n   function.\n   * @locus Client\n   * @param {String} funcName The name of the login function you wanted to call.\n   * @param {Array} funcArgs The `arguments` for the login function.\n   */\n  ;\n\n  _proto.applyLoginFunction = function () {\n    function applyLoginFunction(funcName, funcArgs) {\n      if (!this._loginFuncs[funcName]) {\n        throw new Error(funcName + \" was not defined\");\n      }\n\n      return this._loginFuncs[funcName].apply(this, funcArgs);\n    }\n\n    return applyLoginFunction;\n  }()\n  /**\n   * @summary Log the user out.\n   * @locus Client\n   * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n   */\n  ;\n\n  _proto.logout = function () {\n    function logout(callback) {\n      var _this2 = this;\n\n      this._loggingOut.set(true);\n\n      this.connection.apply('logout', [], {\n        wait: true\n      }, function (error, result) {\n        _this2._loggingOut.set(false);\n\n        _this2._loginCallbacksCalled = false;\n\n        if (error) {\n          callback && callback(error);\n        } else {\n          _this2.makeClientLoggedOut();\n\n          callback && callback();\n        }\n      });\n    }\n\n    return logout;\n  }()\n  /**\n   * @summary Log out other clients logged in as the current user, but does not log out the client that calls this function.\n   * @locus Client\n   * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n   */\n  ;\n\n  _proto.logoutOtherClients = function () {\n    function logoutOtherClients(callback) {\n      var _this3 = this;\n\n      // We need to make two method calls: one to replace our current token,\n      // and another to remove all tokens except the current one. We want to\n      // call these two methods one after the other, without any other\n      // methods running between them. For example, we don't want `logout`\n      // to be called in between our two method calls (otherwise the second\n      // method call would return an error). Another example: we don't want\n      // logout to be called before the callback for `getNewToken`;\n      // otherwise we would momentarily log the user out and then write a\n      // new token to localStorage.\n      //\n      // To accomplish this, we make both calls as wait methods, and queue\n      // them one after the other, without spinning off the event loop in\n      // between. Even though we queue `removeOtherTokens` before\n      // `getNewToken`, we won't actually send the `removeOtherTokens` call\n      // until the `getNewToken` callback has finished running, because they\n      // are both wait methods.\n      this.connection.apply('getNewToken', [], {\n        wait: true\n      }, function (err, result) {\n        if (!err) {\n          _this3._storeLoginToken(_this3.userId(), result.token, result.tokenExpires);\n        }\n      });\n      this.connection.apply('removeOtherTokens', [], {\n        wait: true\n      }, function (err) {\n        return callback && callback(err);\n      });\n    }\n\n    return logoutOtherClients;\n  }() ///\n  /// LOGIN METHODS\n  ///\n  // Call a login method on the server.\n  //\n  // A login method is a method which on success calls `this.setUserId(id)` and\n  // `Accounts._setLoginToken` on the server and returns an object with fields\n  // 'id' (containing the user id), 'token' (containing a resume token), and\n  // optionally `tokenExpires`.\n  //\n  // This function takes care of:\n  //   - Updating the Meteor.loggingIn() reactive data source\n  //   - Calling the method in 'wait' mode\n  //   - On success, saving the resume token to localStorage\n  //   - On success, calling Accounts.connection.setUserId()\n  //   - Setting up an onReconnect handler which logs in with\n  //     the resume token\n  //\n  // Options:\n  // - methodName: The method to call (default 'login')\n  // - methodArguments: The arguments for the method\n  // - validateResult: If provided, will be called with the result of the\n  //                 method. If it throws, the client will not be logged in (and\n  //                 its error will be passed to the callback).\n  // - userCallback: Will be called with no arguments once the user is fully\n  //                 logged in, or with the error on error.\n  //\n  ;\n\n  _proto.callLoginMethod = function () {\n    function callLoginMethod(options) {\n      var _this4 = this;\n\n      options = _objectSpread({\n        methodName: 'login',\n        methodArguments: [{}],\n        _suppressLoggingIn: false\n      }, options); // Set defaults for callback arguments to no-op functions; make sure we\n      // override falsey values too.\n\n      ['validateResult', 'userCallback'].forEach(function (f) {\n        if (!options[f]) options[f] = function () {\n          return null;\n        };\n      });\n      var called; // Prepare callbacks: user provided and onLogin/onLoginFailure hooks.\n\n      var loginCallbacks = function (_ref) {\n        var error = _ref.error,\n            loginDetails = _ref.loginDetails;\n\n        if (!called) {\n          called = true;\n          _this4._loginCallbacksCalled = true;\n\n          if (!error) {\n            _this4._onLoginHook.each(function (callback) {\n              callback(loginDetails);\n              return true;\n            });\n          } else {\n            _this4._onLoginFailureHook.each(function (callback) {\n              callback({\n                error: error\n              });\n              return true;\n            });\n          }\n\n          options.userCallback(error, loginDetails);\n        }\n      };\n\n      var reconnected = false; // We want to set up onReconnect as soon as we get a result token back from\n      // the server, without having to wait for subscriptions to rerun. This is\n      // because if we disconnect and reconnect between getting the result and\n      // getting the results of subscription rerun, we WILL NOT re-send this\n      // method (because we never re-send methods whose results we've received)\n      // but we WILL call loggedInAndDataReadyCallback at \"reconnect quiesce\"\n      // time. This will lead to makeClientLoggedIn(result.id) even though we\n      // haven't actually sent a login method!\n      //\n      // But by making sure that we send this \"resume\" login in that case (and\n      // calling makeClientLoggedOut if it fails), we'll end up with an accurate\n      // client-side userId. (It's important that livedata_connection guarantees\n      // that the \"reconnect quiesce\"-time call to loggedInAndDataReadyCallback\n      // will occur before the callback from the resume login call.)\n\n      var onResultReceived = function (err, result) {\n        if (err || !result || !result.token) {// Leave onReconnect alone if there was an error, so that if the user was\n          // already logged in they will still get logged in on reconnect.\n          // See issue #4970.\n        } else {\n          // First clear out any previously set Acccounts login onReconnect\n          // callback (to make sure we don't keep piling up duplicate callbacks,\n          // which would then all be triggered when reconnecting).\n          if (_this4._reconnectStopper) {\n            _this4._reconnectStopper.stop();\n          }\n\n          _this4._reconnectStopper = DDP.onReconnect(function (conn) {\n            if (conn != _this4.connection) {\n              return;\n            }\n\n            reconnected = true; // If our token was updated in storage, use the latest one.\n\n            var storedToken = _this4._storedLoginToken();\n\n            if (storedToken) {\n              result = {\n                token: storedToken,\n                tokenExpires: _this4._storedLoginTokenExpires()\n              };\n            }\n\n            if (!result.tokenExpires) result.tokenExpires = _this4._tokenExpiration(new Date());\n\n            if (_this4._tokenExpiresSoon(result.tokenExpires)) {\n              _this4.makeClientLoggedOut();\n            } else {\n              _this4.callLoginMethod({\n                methodArguments: [{\n                  resume: result.token\n                }],\n                // Reconnect quiescence ensures that the user doesn't see an\n                // intermediate state before the login method finishes. So we don't\n                // need to show a logging-in animation.\n                _suppressLoggingIn: true,\n                userCallback: function (error, loginDetails) {\n                  var storedTokenNow = _this4._storedLoginToken();\n\n                  if (error) {\n                    // If we had a login error AND the current stored token is the\n                    // one that we tried to log in with, then declare ourselves\n                    // logged out. If there's a token in storage but it's not the\n                    // token that we tried to log in with, we don't know anything\n                    // about whether that token is valid or not, so do nothing. The\n                    // periodic localStorage poll will decide if we are logged in or\n                    // out with this token, if it hasn't already. Of course, even\n                    // with this check, another tab could insert a new valid token\n                    // immediately before we clear localStorage here, which would\n                    // lead to both tabs being logged out, but by checking the token\n                    // in storage right now we hope to make that unlikely to happen.\n                    //\n                    // If there is no token in storage right now, we don't have to\n                    // do anything; whatever code removed the token from storage was\n                    // responsible for calling `makeClientLoggedOut()`, or the\n                    // periodic localStorage poll will call `makeClientLoggedOut`\n                    // eventually if another tab wiped the token from storage.\n                    if (storedTokenNow && storedTokenNow === result.token) {\n                      _this4.makeClientLoggedOut();\n                    }\n                  } // Possibly a weird callback to call, but better than nothing if\n                  // there is a reconnect between \"login result received\" and \"data\n                  // ready\".\n\n\n                  loginCallbacks({\n                    error: error,\n                    loginDetails: loginDetails\n                  });\n                }\n              });\n            }\n          });\n        }\n      }; // This callback is called once the local cache of the current-user\n      // subscription (and all subscriptions, in fact) are guaranteed to be up to\n      // date.\n\n\n      var loggedInAndDataReadyCallback = function (error, result) {\n        // If the login method returns its result but the connection is lost\n        // before the data is in the local cache, it'll set an onReconnect (see\n        // above). The onReconnect will try to log in using the token, and *it*\n        // will call userCallback via its own version of this\n        // loggedInAndDataReadyCallback. So we don't have to do anything here.\n        if (reconnected) return; // Note that we need to call this even if _suppressLoggingIn is true,\n        // because it could be matching a _setLoggingIn(true) from a\n        // half-completed pre-reconnect login method.\n\n        _this4._setLoggingIn(false);\n\n        if (error || !result) {\n          error = error || new Error(\"No result from call to \" + options.methodName);\n          loginCallbacks({\n            error: error\n          });\n          return;\n        }\n\n        try {\n          options.validateResult(result);\n        } catch (e) {\n          loginCallbacks({\n            error: e\n          });\n          return;\n        } // Make the client logged in. (The user data should already be loaded!)\n\n\n        _this4.makeClientLoggedIn(result.id, result.token, result.tokenExpires);\n\n        loginCallbacks({\n          loginDetails: {\n            type: result.type\n          }\n        });\n      };\n\n      if (!options._suppressLoggingIn) {\n        this._setLoggingIn(true);\n      }\n\n      this.connection.apply(options.methodName, options.methodArguments, {\n        wait: true,\n        onResultReceived: onResultReceived\n      }, loggedInAndDataReadyCallback);\n    }\n\n    return callLoginMethod;\n  }();\n\n  _proto.makeClientLoggedOut = function () {\n    function makeClientLoggedOut() {\n      // Ensure client was successfully logged in before running logout hooks.\n      if (this.connection._userId) {\n        this._onLogoutHook.each(function (callback) {\n          callback();\n          return true;\n        });\n      }\n\n      this._unstoreLoginToken();\n\n      this.connection.setUserId(null);\n      this._reconnectStopper && this._reconnectStopper.stop();\n    }\n\n    return makeClientLoggedOut;\n  }();\n\n  _proto.makeClientLoggedIn = function () {\n    function makeClientLoggedIn(userId, token, tokenExpires) {\n      this._storeLoginToken(userId, token, tokenExpires);\n\n      this.connection.setUserId(userId);\n    }\n\n    return makeClientLoggedIn;\n  }() ///\n  /// LOGIN SERVICES\n  ///\n  // A reactive function returning whether the loginServiceConfiguration\n  // subscription is ready. Used by accounts-ui to hide the login button\n  // until we have all the configuration loaded\n  //\n  ;\n\n  _proto.loginServicesConfigured = function () {\n    function loginServicesConfigured() {\n      return this._loginServicesHandle.ready();\n    }\n\n    return loginServicesConfigured;\n  }();\n\n  // Some login services such as the redirect login flow or the resume\n  // login handler can log the user in at page load time.  The\n  // Meteor.loginWithX functions have a callback argument, but the\n  // callback function instance won't be in memory any longer if the\n  // page was reloaded.  The `onPageLoadLogin` function allows a\n  // callback to be registered for the case where the login was\n  // initiated in a previous VM, and we now have the result of the login\n  // attempt in a new VM.\n  // Register a callback to be called if we have information about a\n  // login attempt at page load time.  Call the callback immediately if\n  // we already have the page load login attempt info, otherwise stash\n  // the callback to be called if and when we do get the attempt info.\n  //\n  _proto.onPageLoadLogin = function () {\n    function onPageLoadLogin(f) {\n      if (this._pageLoadLoginAttemptInfo) {\n        f(this._pageLoadLoginAttemptInfo);\n      } else {\n        this._pageLoadLoginCallbacks.push(f);\n      }\n    }\n\n    return onPageLoadLogin;\n  }();\n\n  // Receive the information about the login attempt at page load time.\n  // Call registered callbacks, and also record the info in case\n  // someone's callback hasn't been registered yet.\n  //\n  _proto._pageLoadLogin = function () {\n    function _pageLoadLogin(attemptInfo) {\n      if (this._pageLoadLoginAttemptInfo) {\n        Meteor._debug('Ignoring unexpected duplicate page load login attempt info');\n\n        return;\n      }\n\n      this._pageLoadLoginCallbacks.forEach(function (callback) {\n        return callback(attemptInfo);\n      });\n\n      this._pageLoadLoginCallbacks = [];\n      this._pageLoadLoginAttemptInfo = attemptInfo;\n    }\n\n    return _pageLoadLogin;\n  }() // _startupCallback executes on onLogin callbacks\n  // at registration time if already logged in\n  // this can happen when new AccountsClient is created\n  // before callbacks are registered see #10157\n  ;\n\n  _proto._startupCallback = function () {\n    function _startupCallback(callback) {\n      // Are we already logged in?\n      if (this._loginCallbacksCalled) {\n        // If already logged in before handler is registered, it's safe to\n        // assume type is a 'resume', so we execute the callback at the end\n        // of the queue so that Meteor.startup can complete before any\n        // embedded onLogin callbacks would execute.\n        Meteor.setTimeout(function () {\n          return callback({\n            type: 'resume'\n          });\n        }, 0);\n      }\n    }\n\n    return _startupCallback;\n  }() ///\n  /// LOGIN TOKENS\n  ///\n  // These methods deal with storing a login token and user id in the\n  // browser's localStorage facility. It polls local storage every few\n  // seconds to synchronize login state between multiple tabs in the same\n  // browser.\n  ;\n\n  _proto.loginWithToken = function () {\n    function loginWithToken(token, callback) {\n      this.callLoginMethod({\n        methodArguments: [{\n          resume: token\n        }],\n        userCallback: callback\n      });\n    }\n\n    return loginWithToken;\n  }();\n\n  // Semi-internal API. Call this function to re-enable auto login after\n  // if it was disabled at startup.\n  _proto._enableAutoLogin = function () {\n    function _enableAutoLogin() {\n      this._autoLoginEnabled = true;\n\n      this._pollStoredLoginToken();\n    }\n\n    return _enableAutoLogin;\n  }();\n\n  ///\n  /// STORING\n  ///\n  // Call this from the top level of the test file for any test that does\n  // logging in and out, to protect multiple tabs running the same tests\n  // simultaneously from interfering with each others' localStorage.\n  _proto._isolateLoginTokenForTest = function () {\n    function _isolateLoginTokenForTest() {\n      this.LOGIN_TOKEN_KEY = this.LOGIN_TOKEN_KEY + Random.id();\n      this.USER_ID_KEY = this.USER_ID_KEY + Random.id();\n    }\n\n    return _isolateLoginTokenForTest;\n  }();\n\n  _proto._storeLoginToken = function () {\n    function _storeLoginToken(userId, token, tokenExpires) {\n      Meteor._localStorage.setItem(this.USER_ID_KEY, userId);\n\n      Meteor._localStorage.setItem(this.LOGIN_TOKEN_KEY, token);\n\n      if (!tokenExpires) tokenExpires = this._tokenExpiration(new Date());\n\n      Meteor._localStorage.setItem(this.LOGIN_TOKEN_EXPIRES_KEY, tokenExpires); // to ensure that the localstorage poller doesn't end up trying to\n      // connect a second time\n\n\n      this._lastLoginTokenWhenPolled = token;\n    }\n\n    return _storeLoginToken;\n  }();\n\n  _proto._unstoreLoginToken = function () {\n    function _unstoreLoginToken() {\n      Meteor._localStorage.removeItem(this.USER_ID_KEY);\n\n      Meteor._localStorage.removeItem(this.LOGIN_TOKEN_KEY);\n\n      Meteor._localStorage.removeItem(this.LOGIN_TOKEN_EXPIRES_KEY); // to ensure that the localstorage poller doesn't end up trying to\n      // connect a second time\n\n\n      this._lastLoginTokenWhenPolled = null;\n    }\n\n    return _unstoreLoginToken;\n  }();\n\n  // This is private, but it is exported for now because it is used by a\n  // test in accounts-password.\n  _proto._storedLoginToken = function () {\n    function _storedLoginToken() {\n      return Meteor._localStorage.getItem(this.LOGIN_TOKEN_KEY);\n    }\n\n    return _storedLoginToken;\n  }();\n\n  _proto._storedLoginTokenExpires = function () {\n    function _storedLoginTokenExpires() {\n      return Meteor._localStorage.getItem(this.LOGIN_TOKEN_EXPIRES_KEY);\n    }\n\n    return _storedLoginTokenExpires;\n  }();\n\n  _proto._storedUserId = function () {\n    function _storedUserId() {\n      return Meteor._localStorage.getItem(this.USER_ID_KEY);\n    }\n\n    return _storedUserId;\n  }();\n\n  _proto._unstoreLoginTokenIfExpiresSoon = function () {\n    function _unstoreLoginTokenIfExpiresSoon() {\n      var tokenExpires = this._storedLoginTokenExpires();\n\n      if (tokenExpires && this._tokenExpiresSoon(new Date(tokenExpires))) {\n        this._unstoreLoginToken();\n      }\n    }\n\n    return _unstoreLoginTokenIfExpiresSoon;\n  }();\n\n  ///\n  /// AUTO-LOGIN\n  ///\n  _proto._initLocalStorage = function () {\n    function _initLocalStorage() {\n      var _this5 = this;\n\n      // Key names to use in localStorage\n      this.LOGIN_TOKEN_KEY = \"Meteor.loginToken\";\n      this.LOGIN_TOKEN_EXPIRES_KEY = \"Meteor.loginTokenExpires\";\n      this.USER_ID_KEY = \"Meteor.userId\";\n      var rootUrlPathPrefix = __meteor_runtime_config__.ROOT_URL_PATH_PREFIX;\n\n      if (rootUrlPathPrefix || this.connection !== Meteor.connection) {\n        // We want to keep using the same keys for existing apps that do not\n        // set a custom ROOT_URL_PATH_PREFIX, so that most users will not have\n        // to log in again after an app updates to a version of Meteor that\n        // contains this code, but it's generally preferable to namespace the\n        // keys so that connections from distinct apps to distinct DDP URLs\n        // will be distinct in Meteor._localStorage.\n        var namespace = \":\" + this.connection._stream.rawUrl;\n\n        if (rootUrlPathPrefix) {\n          namespace += \":\" + rootUrlPathPrefix;\n        }\n\n        this.LOGIN_TOKEN_KEY += namespace;\n        this.LOGIN_TOKEN_EXPIRES_KEY += namespace;\n        this.USER_ID_KEY += namespace;\n      }\n\n      var token;\n\n      if (this._autoLoginEnabled) {\n        // Immediately try to log in via local storage, so that any DDP\n        // messages are sent after we have established our user account\n        this._unstoreLoginTokenIfExpiresSoon();\n\n        token = this._storedLoginToken();\n\n        if (token) {\n          // On startup, optimistically present us as logged in while the\n          // request is in flight. This reduces page flicker on startup.\n          var userId = this._storedUserId();\n\n          userId && this.connection.setUserId(userId);\n          this.loginWithToken(token, function (err) {\n            if (err) {\n              Meteor._debug(\"Error logging in with token: \" + err);\n\n              _this5.makeClientLoggedOut();\n            }\n\n            _this5._pageLoadLogin({\n              type: \"resume\",\n              allowed: !err,\n              error: err,\n              methodName: \"login\",\n              // XXX This is duplicate code with loginWithToken, but\n              // loginWithToken can also be called at other times besides\n              // page load.\n              methodArguments: [{\n                resume: token\n              }]\n            });\n          });\n        }\n      } // Poll local storage every 3 seconds to login if someone logged in in\n      // another tab\n\n\n      this._lastLoginTokenWhenPolled = token;\n\n      if (this._pollIntervalTimer) {\n        // Unlikely that _initLocalStorage will be called more than once for\n        // the same AccountsClient instance, but just in case...\n        clearInterval(this._pollIntervalTimer);\n      }\n\n      this._pollIntervalTimer = setInterval(function () {\n        _this5._pollStoredLoginToken();\n      }, 3000);\n    }\n\n    return _initLocalStorage;\n  }();\n\n  _proto._pollStoredLoginToken = function () {\n    function _pollStoredLoginToken() {\n      var _this6 = this;\n\n      if (!this._autoLoginEnabled) {\n        return;\n      }\n\n      var currentLoginToken = this._storedLoginToken(); // != instead of !== just to make sure undefined and null are treated the same\n\n\n      if (this._lastLoginTokenWhenPolled != currentLoginToken) {\n        if (currentLoginToken) {\n          this.loginWithToken(currentLoginToken, function (err) {\n            if (err) {\n              _this6.makeClientLoggedOut();\n            }\n          });\n        } else {\n          this.logout();\n        }\n      }\n\n      this._lastLoginTokenWhenPolled = currentLoginToken;\n    }\n\n    return _pollStoredLoginToken;\n  }();\n\n  ///\n  /// URLS\n  ///\n  _proto._initUrlMatching = function () {\n    function _initUrlMatching() {\n      // By default, allow the autologin process to happen.\n      this._autoLoginEnabled = true; // We only support one callback per URL.\n\n      this._accountsCallbacks = {}; // Try to match the saved value of window.location.hash.\n\n      this._attemptToMatchHash();\n    }\n\n    return _initUrlMatching;\n  }();\n\n  // Separate out this functionality for testing\n  _proto._attemptToMatchHash = function () {\n    function _attemptToMatchHash() {\n      attemptToMatchHash(this, this.savedHash, defaultSuccessHandler);\n    }\n\n    return _attemptToMatchHash;\n  }();\n\n  /**\n   * @summary Register a function to call when a reset password link is clicked\n   * in an email sent by\n   * [`Accounts.sendResetPasswordEmail`](#accounts_sendresetpasswordemail).\n   * This function should be called in top-level code, not inside\n   * `Meteor.startup()`.\n   * @memberof! Accounts\n   * @name onResetPasswordLink\n   * @param  {Function} callback The function to call. It is given two arguments:\n   *\n   * 1. `token`: A password reset token that can be passed to\n   * [`Accounts.resetPassword`](#accounts_resetpassword).\n   * 2. `done`: A function to call when the password reset UI flow is complete. The normal\n   * login process is suspended until this function is called, so that the\n   * password for user A can be reset even if user B was logged in.\n   * @locus Client\n   */\n  _proto.onResetPasswordLink = function () {\n    function onResetPasswordLink(callback) {\n      if (this._accountsCallbacks[\"reset-password\"]) {\n        Meteor._debug(\"Accounts.onResetPasswordLink was called more than once. \" + \"Only one callback added will be executed.\");\n      }\n\n      this._accountsCallbacks[\"reset-password\"] = callback;\n    }\n\n    return onResetPasswordLink;\n  }();\n\n  /**\n   * @summary Register a function to call when an email verification link is\n   * clicked in an email sent by\n   * [`Accounts.sendVerificationEmail`](#accounts_sendverificationemail).\n   * This function should be called in top-level code, not inside\n   * `Meteor.startup()`.\n   * @memberof! Accounts\n   * @name onEmailVerificationLink\n   * @param  {Function} callback The function to call. It is given two arguments:\n   *\n   * 1. `token`: An email verification token that can be passed to\n   * [`Accounts.verifyEmail`](#accounts_verifyemail).\n   * 2. `done`: A function to call when the email verification UI flow is complete.\n   * The normal login process is suspended until this function is called, so\n   * that the user can be notified that they are verifying their email before\n   * being logged in.\n   * @locus Client\n   */\n  _proto.onEmailVerificationLink = function () {\n    function onEmailVerificationLink(callback) {\n      if (this._accountsCallbacks[\"verify-email\"]) {\n        Meteor._debug(\"Accounts.onEmailVerificationLink was called more than once. \" + \"Only one callback added will be executed.\");\n      }\n\n      this._accountsCallbacks[\"verify-email\"] = callback;\n    }\n\n    return onEmailVerificationLink;\n  }();\n\n  /**\n   * @summary Register a function to call when an account enrollment link is\n   * clicked in an email sent by\n   * [`Accounts.sendEnrollmentEmail`](#accounts_sendenrollmentemail).\n   * This function should be called in top-level code, not inside\n   * `Meteor.startup()`.\n   * @memberof! Accounts\n   * @name onEnrollmentLink\n   * @param  {Function} callback The function to call. It is given two arguments:\n   *\n   * 1. `token`: A password reset token that can be passed to\n   * [`Accounts.resetPassword`](#accounts_resetpassword) to give the newly\n   * enrolled account a password.\n   * 2. `done`: A function to call when the enrollment UI flow is complete.\n   * The normal login process is suspended until this function is called, so that\n   * user A can be enrolled even if user B was logged in.\n   * @locus Client\n   */\n  _proto.onEnrollmentLink = function () {\n    function onEnrollmentLink(callback) {\n      if (this._accountsCallbacks[\"enroll-account\"]) {\n        Meteor._debug(\"Accounts.onEnrollmentLink was called more than once. \" + \"Only one callback added will be executed.\");\n      }\n\n      this._accountsCallbacks[\"enroll-account\"] = callback;\n    }\n\n    return onEnrollmentLink;\n  }();\n\n  return AccountsClient;\n}(AccountsCommon);\n\n;\n/**\n * @summary True if a login method (such as `Meteor.loginWithPassword`,\n * `Meteor.loginWithFacebook`, or `Accounts.createUser`) is currently in\n * progress. A reactive data source.\n * @locus Client\n * @importFromPackage meteor\n */\n\nMeteor.loggingIn = function () {\n  return Accounts.loggingIn();\n};\n/**\n * @summary True if a logout method (such as `Meteor.logout`) is currently in\n * progress. A reactive data source.\n * @locus Client\n * @importFromPackage meteor\n */\n\n\nMeteor.loggingOut = function () {\n  return Accounts.loggingOut();\n};\n/**\n * @summary Log the user out.\n * @locus Client\n * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n * @importFromPackage meteor\n */\n\n\nMeteor.logout = function (callback) {\n  return Accounts.logout(callback);\n};\n/**\n * @summary Log out other clients logged in as the current user, but does not log out the client that calls this function.\n * @locus Client\n * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n * @importFromPackage meteor\n */\n\n\nMeteor.logoutOtherClients = function (callback) {\n  return Accounts.logoutOtherClients(callback);\n};\n/**\n * @summary Login with a Meteor access token.\n * @locus Client\n * @param {Object} [token] Local storage token for use with login across\n * multiple tabs in the same browser.\n * @param {Function} [callback] Optional callback. Called with no arguments on\n * success.\n * @importFromPackage meteor\n */\n\n\nMeteor.loginWithToken = function (token, callback) {\n  return Accounts.loginWithToken(token, callback);\n}; ///\n/// HANDLEBARS HELPERS\n///\n// If our app has a Blaze, register the {{currentUser}} and {{loggingIn}}\n// global helpers.\n\n\nif (Package.blaze) {\n  var Template = Package.blaze.Blaze.Template;\n  /**\n   * @global\n   * @name  currentUser\n   * @isHelper true\n   * @summary Calls [Meteor.user()](#meteor_user). Use `{{#if currentUser}}` to check whether the user is logged in.\n   */\n\n  Template.registerHelper('currentUser', function () {\n    return Meteor.user();\n  });\n  /**\n   * @global\n   * @name  loggingIn\n   * @isHelper true\n   * @summary Calls [Meteor.loggingIn()](#meteor_loggingin).\n   */\n\n  Template.registerHelper('loggingIn', function () {\n    return Meteor.loggingIn();\n  });\n  /**\n   * @global\n   * @name  loggingOut\n   * @isHelper true\n   * @summary Calls [Meteor.loggingOut()](#meteor_loggingout).\n   */\n\n  Template.registerHelper('loggingOut', function () {\n    return Meteor.loggingOut();\n  });\n  /**\n   * @global\n   * @name  loggingInOrOut\n   * @isHelper true\n   * @summary Calls [Meteor.loggingIn()](#meteor_loggingin) or [Meteor.loggingOut()](#meteor_loggingout).\n   */\n\n  Template.registerHelper('loggingInOrOut', function () {\n    return Meteor.loggingIn() || Meteor.loggingOut();\n  });\n}\n\nvar defaultSuccessHandler = function (token, urlPart) {\n  var _this7 = this;\n\n  // put login in a suspended state to wait for the interaction to finish\n  this._autoLoginEnabled = false; // wait for other packages to register callbacks\n\n  Meteor.startup(function () {\n    // if a callback has been registered for this kind of token, call it\n    if (_this7._accountsCallbacks[urlPart]) {\n      _this7._accountsCallbacks[urlPart](token, function () {\n        return _this7._enableAutoLogin();\n      });\n    }\n  });\n}; // Note that both arguments are optional and are currently only passed by\n// accounts_url_tests.js.\n\n\nvar attemptToMatchHash = function (accounts, hash, success) {\n  // All of the special hash URLs we support for accounts interactions\n  [\"reset-password\", \"verify-email\", \"enroll-account\"].forEach(function (urlPart) {\n    var token;\n    var tokenRegex = new RegExp(\"^\\\\#\\\\/\" + urlPart + \"\\\\/(.*)$\");\n    var match = hash.match(tokenRegex);\n\n    if (match) {\n      token = match[1]; // XXX COMPAT WITH 0.9.3\n\n      if (urlPart === \"reset-password\") {\n        accounts._resetPasswordToken = token;\n      } else if (urlPart === \"verify-email\") {\n        accounts._verifyEmailToken = token;\n      } else if (urlPart === \"enroll-account\") {\n        accounts._enrollAccountToken = token;\n      }\n    } else {\n      return;\n    } // If no handlers match the hash, then maybe it's meant to be consumed\n    // by some entirely different code, so we only clear it the first time\n    // a handler successfully matches. Note that later handlers reuse the\n    // savedHash, so clearing window.location.hash here will not interfere\n    // with their needs.\n\n\n    window.location.hash = \"\"; // Do some stuff with the token we matched\n\n    success.call(accounts, token, urlPart);\n  });\n}; // Export for testing\n\n\nvar AccountsTest = {\n  attemptToMatchHash: function (hash, success) {\n    return attemptToMatchHash(Accounts, hash, success);\n  }\n};","map":{"version":3,"sources":["packages/accounts-base/accounts_client.js"],"names":["_objectSpread","module","link","default","v","_inheritsLoose","export","AccountsClient","AccountsTest","AccountsCommon","options","_loggingIn","ReactiveVar","_loggingOut","_loginServicesHandle","connection","subscribe","_pageLoadLoginCallbacks","_pageLoadLoginAttemptInfo","savedHash","window","location","hash","_initUrlMatching","_initLocalStorage","_loginFuncs","_loginCallbacksCalled","userId","_setLoggingIn","x","set","loggingIn","get","loggingOut","registerClientLoginFunction","funcName","func","Error","callLoginFunction","funcArgs","apply","applyLoginFunction","logout","callback","wait","error","result","makeClientLoggedOut","logoutOtherClients","err","_storeLoginToken","token","tokenExpires","callLoginMethod","methodName","methodArguments","_suppressLoggingIn","forEach","f","called","loginCallbacks","loginDetails","_onLoginHook","each","_onLoginFailureHook","userCallback","reconnected","onResultReceived","_reconnectStopper","stop","DDP","onReconnect","conn","storedToken","_storedLoginToken","_storedLoginTokenExpires","_tokenExpiration","Date","_tokenExpiresSoon","resume","storedTokenNow","loggedInAndDataReadyCallback","validateResult","e","makeClientLoggedIn","id","type","_userId","_onLogoutHook","_unstoreLoginToken","setUserId","loginServicesConfigured","ready","onPageLoadLogin","push","_pageLoadLogin","attemptInfo","Meteor","_debug","_startupCallback","setTimeout","loginWithToken","_enableAutoLogin","_autoLoginEnabled","_pollStoredLoginToken","_isolateLoginTokenForTest","LOGIN_TOKEN_KEY","Random","USER_ID_KEY","_localStorage","setItem","LOGIN_TOKEN_EXPIRES_KEY","_lastLoginTokenWhenPolled","removeItem","getItem","_storedUserId","_unstoreLoginTokenIfExpiresSoon","rootUrlPathPrefix","__meteor_runtime_config__","ROOT_URL_PATH_PREFIX","namespace","_stream","rawUrl","allowed","_pollIntervalTimer","clearInterval","setInterval","currentLoginToken","_accountsCallbacks","_attemptToMatchHash","attemptToMatchHash","defaultSuccessHandler","onResetPasswordLink","onEmailVerificationLink","onEnrollmentLink","Accounts","Package","blaze","Template","Blaze","registerHelper","user","urlPart","startup","accounts","success","tokenRegex","RegExp","match","_resetPasswordToken","_verifyEmailToken","_enrollAccountToken","call"],"mappings":"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","sourcesContent":["import {AccountsCommon} from \"./accounts_common.js\";\n\n/**\n * @summary Constructor for the `Accounts` object on the client.\n * @locus Client\n * @class AccountsClient\n * @extends AccountsCommon\n * @instancename accountsClient\n * @param {Object} options an object with fields:\n * @param {Object} options.connection Optional DDP connection to reuse.\n * @param {String} options.ddpUrl Optional URL for creating a new DDP connection.\n */\nexport class AccountsClient extends AccountsCommon {\n  constructor(options) {\n    super(options);\n\n    this._loggingIn = new ReactiveVar(false);\n    this._loggingOut = new ReactiveVar(false);\n\n    this._loginServicesHandle =\n      this.connection.subscribe(\"meteor.loginServiceConfiguration\");\n\n    this._pageLoadLoginCallbacks = [];\n    this._pageLoadLoginAttemptInfo = null;\n\n    this.savedHash = window.location.hash;\n    this._initUrlMatching();\n\n    // Defined in localstorage_token.js.\n    this._initLocalStorage();\n\n    // This is for .registerClientLoginFunction & .callLoginFunction.\n    this._loginFuncs = {};\n\n    // This tracks whether callbacks registered with\n    // Accounts.onLogin have been called\n    this._loginCallbacksCalled = false;\n  }\n\n  ///\n  /// CURRENT USER\n  ///\n\n  // @override\n  userId() {\n    return this.connection.userId();\n  }\n\n  // This is mostly just called within this file, but Meteor.loginWithPassword\n  // also uses it to make loggingIn() be true during the beginPasswordExchange\n  // method call too.\n  _setLoggingIn(x) {\n    this._loggingIn.set(x);\n  }\n\n  /**\n   * @summary True if a login method (such as `Meteor.loginWithPassword`, `Meteor.loginWithFacebook`, or `Accounts.createUser`) is currently in progress. A reactive data source.\n   * @locus Client\n   */\n  loggingIn() {\n    return this._loggingIn.get();\n  }\n\n  /**\n   * @summary True if a logout method (such as `Meteor.logout`) is currently in progress. A reactive data source.\n   * @locus Client\n   */\n  loggingOut() {\n    return this._loggingOut.get();\n  }\n\n  /**\n   * @summary Register a new login function on the client. Intended for OAuth package authors. You can call the login function by using\n   `Accounts.callLoginFunction` or `Accounts.callLoginFunction`.\n   * @locus Client\n   * @param {String} funcName The name of your login function. Used by `Accounts.callLoginFunction` and `Accounts.applyLoginFunction`.\n   Should be the OAuth provider name accordingly.\n   * @param {Function} func The actual function you want to call. Just write it in the manner of `loginWithFoo`.\n   */\n  registerClientLoginFunction(funcName, func) {\n    if (this._loginFuncs[funcName]) {\n      throw new Error(`${funcName} has been defined already`);\n    }\n    this._loginFuncs[funcName] = func;\n  }\n\n  /**\n   * @summary Call a login function defined using `Accounts.registerClientLoginFunction`. Excluding the first argument, all remaining\n   arguments are passed to the login function accordingly. Use `applyLoginFunction` if you want to pass in an arguments array that contains\n   all arguments for the login function.\n   * @locus Client\n   * @param {String} funcName The name of the login function you wanted to call.\n   */\n  callLoginFunction(funcName, ...funcArgs) {\n    if (!this._loginFuncs[funcName]) {\n      throw new Error(`${funcName} was not defined`);\n    }\n    return this._loginFuncs[funcName].apply(this, funcArgs);\n  }\n\n  /**\n   * @summary Same as ``callLoginFunction` but accept an `arguments` which contains all arguments for the login\n   function.\n   * @locus Client\n   * @param {String} funcName The name of the login function you wanted to call.\n   * @param {Array} funcArgs The `arguments` for the login function.\n   */\n  applyLoginFunction(funcName, funcArgs) {\n    if (!this._loginFuncs[funcName]) {\n      throw new Error(`${funcName} was not defined`);\n    }\n    return this._loginFuncs[funcName].apply(this, funcArgs);\n  }\n\n  /**\n   * @summary Log the user out.\n   * @locus Client\n   * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n   */\n  logout(callback) {\n    this._loggingOut.set(true);\n    this.connection.apply('logout', [], {\n      wait: true\n    }, (error, result) => {\n      this._loggingOut.set(false);\n      this._loginCallbacksCalled = false;\n      if (error) {\n        callback && callback(error);\n      } else {\n        this.makeClientLoggedOut();\n        callback && callback();\n      }\n    });\n  }\n\n  /**\n   * @summary Log out other clients logged in as the current user, but does not log out the client that calls this function.\n   * @locus Client\n   * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n   */\n  logoutOtherClients(callback) {\n    // We need to make two method calls: one to replace our current token,\n    // and another to remove all tokens except the current one. We want to\n    // call these two methods one after the other, without any other\n    // methods running between them. For example, we don't want `logout`\n    // to be called in between our two method calls (otherwise the second\n    // method call would return an error). Another example: we don't want\n    // logout to be called before the callback for `getNewToken`;\n    // otherwise we would momentarily log the user out and then write a\n    // new token to localStorage.\n    //\n    // To accomplish this, we make both calls as wait methods, and queue\n    // them one after the other, without spinning off the event loop in\n    // between. Even though we queue `removeOtherTokens` before\n    // `getNewToken`, we won't actually send the `removeOtherTokens` call\n    // until the `getNewToken` callback has finished running, because they\n    // are both wait methods.\n    this.connection.apply(\n      'getNewToken',\n      [],\n      { wait: true },\n      (err, result) => {\n        if (! err) {\n          this._storeLoginToken(\n            this.userId(),\n            result.token,\n            result.tokenExpires\n          );\n        }\n      }\n    );\n\n    this.connection.apply(\n      'removeOtherTokens',\n      [],\n      { wait: true },\n      err => callback && callback(err)\n    );\n  }\n\n  ///\n  /// LOGIN METHODS\n  ///\n\n  // Call a login method on the server.\n  //\n  // A login method is a method which on success calls `this.setUserId(id)` and\n  // `Accounts._setLoginToken` on the server and returns an object with fields\n  // 'id' (containing the user id), 'token' (containing a resume token), and\n  // optionally `tokenExpires`.\n  //\n  // This function takes care of:\n  //   - Updating the Meteor.loggingIn() reactive data source\n  //   - Calling the method in 'wait' mode\n  //   - On success, saving the resume token to localStorage\n  //   - On success, calling Accounts.connection.setUserId()\n  //   - Setting up an onReconnect handler which logs in with\n  //     the resume token\n  //\n  // Options:\n  // - methodName: The method to call (default 'login')\n  // - methodArguments: The arguments for the method\n  // - validateResult: If provided, will be called with the result of the\n  //                 method. If it throws, the client will not be logged in (and\n  //                 its error will be passed to the callback).\n  // - userCallback: Will be called with no arguments once the user is fully\n  //                 logged in, or with the error on error.\n  //\n  callLoginMethod(options) {\n    options = {\n      methodName: 'login',\n      methodArguments: [{}],\n      _suppressLoggingIn: false,\n      ...options,\n    };\n\n    // Set defaults for callback arguments to no-op functions; make sure we\n    // override falsey values too.\n    ['validateResult', 'userCallback'].forEach(f => {\n      if (!options[f])\n        options[f] = () => null;\n    })\n\n    let called;\n    // Prepare callbacks: user provided and onLogin/onLoginFailure hooks.\n    const loginCallbacks = ({ error, loginDetails }) => {\n      if (!called) {\n        called = true;\n        this._loginCallbacksCalled = true;\n        if (!error) {\n          this._onLoginHook.each(callback => {\n            callback(loginDetails);\n            return true;\n          });\n        } else {\n          this._onLoginFailureHook.each(callback => {\n            callback({ error });\n            return true;\n          });\n        }\n        options.userCallback(error, loginDetails);\n      }\n    }\n\n    let reconnected = false;\n\n    // We want to set up onReconnect as soon as we get a result token back from\n    // the server, without having to wait for subscriptions to rerun. This is\n    // because if we disconnect and reconnect between getting the result and\n    // getting the results of subscription rerun, we WILL NOT re-send this\n    // method (because we never re-send methods whose results we've received)\n    // but we WILL call loggedInAndDataReadyCallback at \"reconnect quiesce\"\n    // time. This will lead to makeClientLoggedIn(result.id) even though we\n    // haven't actually sent a login method!\n    //\n    // But by making sure that we send this \"resume\" login in that case (and\n    // calling makeClientLoggedOut if it fails), we'll end up with an accurate\n    // client-side userId. (It's important that livedata_connection guarantees\n    // that the \"reconnect quiesce\"-time call to loggedInAndDataReadyCallback\n    // will occur before the callback from the resume login call.)\n    const onResultReceived = (err, result) => {\n      if (err || !result || !result.token) {\n        // Leave onReconnect alone if there was an error, so that if the user was\n        // already logged in they will still get logged in on reconnect.\n        // See issue #4970.\n      } else {\n        // First clear out any previously set Acccounts login onReconnect\n        // callback (to make sure we don't keep piling up duplicate callbacks,\n        // which would then all be triggered when reconnecting).\n        if (this._reconnectStopper) {\n          this._reconnectStopper.stop();\n        }\n\n        this._reconnectStopper = DDP.onReconnect(conn => {\n          if (conn != this.connection) {\n            return;\n          }\n          reconnected = true;\n          // If our token was updated in storage, use the latest one.\n          const storedToken = this._storedLoginToken();\n          if (storedToken) {\n            result = {\n              token: storedToken,\n              tokenExpires: this._storedLoginTokenExpires()\n            };\n          }\n          if (!result.tokenExpires)\n            result.tokenExpires = this._tokenExpiration(new Date());\n          if (this._tokenExpiresSoon(result.tokenExpires)) {\n            this.makeClientLoggedOut();\n          } else {\n            this.callLoginMethod({\n              methodArguments: [{resume: result.token}],\n              // Reconnect quiescence ensures that the user doesn't see an\n              // intermediate state before the login method finishes. So we don't\n              // need to show a logging-in animation.\n              _suppressLoggingIn: true,\n              userCallback: (error, loginDetails) => {\n                const storedTokenNow = this._storedLoginToken();\n                if (error) {\n                  // If we had a login error AND the current stored token is the\n                  // one that we tried to log in with, then declare ourselves\n                  // logged out. If there's a token in storage but it's not the\n                  // token that we tried to log in with, we don't know anything\n                  // about whether that token is valid or not, so do nothing. The\n                  // periodic localStorage poll will decide if we are logged in or\n                  // out with this token, if it hasn't already. Of course, even\n                  // with this check, another tab could insert a new valid token\n                  // immediately before we clear localStorage here, which would\n                  // lead to both tabs being logged out, but by checking the token\n                  // in storage right now we hope to make that unlikely to happen.\n                  //\n                  // If there is no token in storage right now, we don't have to\n                  // do anything; whatever code removed the token from storage was\n                  // responsible for calling `makeClientLoggedOut()`, or the\n                  // periodic localStorage poll will call `makeClientLoggedOut`\n                  // eventually if another tab wiped the token from storage.\n                  if (storedTokenNow && storedTokenNow === result.token) {\n                    this.makeClientLoggedOut();\n                  }\n                }\n                // Possibly a weird callback to call, but better than nothing if\n                // there is a reconnect between \"login result received\" and \"data\n                // ready\".\n                loginCallbacks({ error, loginDetails });\n              }});\n          }\n        });\n      }\n    };\n\n    // This callback is called once the local cache of the current-user\n    // subscription (and all subscriptions, in fact) are guaranteed to be up to\n    // date.\n    const loggedInAndDataReadyCallback = (error, result) => {\n      // If the login method returns its result but the connection is lost\n      // before the data is in the local cache, it'll set an onReconnect (see\n      // above). The onReconnect will try to log in using the token, and *it*\n      // will call userCallback via its own version of this\n      // loggedInAndDataReadyCallback. So we don't have to do anything here.\n      if (reconnected)\n        return;\n\n      // Note that we need to call this even if _suppressLoggingIn is true,\n      // because it could be matching a _setLoggingIn(true) from a\n      // half-completed pre-reconnect login method.\n      this._setLoggingIn(false);\n      if (error || !result) {\n        error = error || new Error(\n          `No result from call to ${options.methodName}`\n        );\n        loginCallbacks({ error });\n        return;\n      }\n      try {\n        options.validateResult(result);\n      } catch (e) {\n        loginCallbacks({ error: e });\n        return;\n      }\n\n      // Make the client logged in. (The user data should already be loaded!)\n      this.makeClientLoggedIn(result.id, result.token, result.tokenExpires);\n      loginCallbacks({ loginDetails: { type: result.type } });\n    };\n\n    if (!options._suppressLoggingIn) {\n      this._setLoggingIn(true);\n    }\n    this.connection.apply(\n      options.methodName,\n      options.methodArguments,\n      { wait: true, onResultReceived: onResultReceived },\n      loggedInAndDataReadyCallback);\n  }\n\n  makeClientLoggedOut() {\n    // Ensure client was successfully logged in before running logout hooks.\n    if (this.connection._userId) {\n      this._onLogoutHook.each(callback => {\n        callback();\n        return true;\n      });\n    }\n    this._unstoreLoginToken();\n    this.connection.setUserId(null);\n    this._reconnectStopper && this._reconnectStopper.stop();\n  }\n\n  makeClientLoggedIn(userId, token, tokenExpires) {\n    this._storeLoginToken(userId, token, tokenExpires);\n    this.connection.setUserId(userId);\n  }\n\n  ///\n  /// LOGIN SERVICES\n  ///\n\n  // A reactive function returning whether the loginServiceConfiguration\n  // subscription is ready. Used by accounts-ui to hide the login button\n  // until we have all the configuration loaded\n  //\n  loginServicesConfigured() {\n    return this._loginServicesHandle.ready();\n  };\n\n  // Some login services such as the redirect login flow or the resume\n  // login handler can log the user in at page load time.  The\n  // Meteor.loginWithX functions have a callback argument, but the\n  // callback function instance won't be in memory any longer if the\n  // page was reloaded.  The `onPageLoadLogin` function allows a\n  // callback to be registered for the case where the login was\n  // initiated in a previous VM, and we now have the result of the login\n  // attempt in a new VM.\n\n  // Register a callback to be called if we have information about a\n  // login attempt at page load time.  Call the callback immediately if\n  // we already have the page load login attempt info, otherwise stash\n  // the callback to be called if and when we do get the attempt info.\n  //\n  onPageLoadLogin(f) {\n    if (this._pageLoadLoginAttemptInfo) {\n      f(this._pageLoadLoginAttemptInfo);\n    } else {\n      this._pageLoadLoginCallbacks.push(f);\n    }\n  };\n\n  // Receive the information about the login attempt at page load time.\n  // Call registered callbacks, and also record the info in case\n  // someone's callback hasn't been registered yet.\n  //\n  _pageLoadLogin(attemptInfo) {\n    if (this._pageLoadLoginAttemptInfo) {\n      Meteor._debug(\n        'Ignoring unexpected duplicate page load login attempt info'\n      );\n      return;\n    }\n\n    this._pageLoadLoginCallbacks.forEach(callback => callback(attemptInfo));\n    this._pageLoadLoginCallbacks = [];\n    this._pageLoadLoginAttemptInfo = attemptInfo;\n  }\n\n  // _startupCallback executes on onLogin callbacks\n  // at registration time if already logged in\n  // this can happen when new AccountsClient is created\n  // before callbacks are registered see #10157\n  _startupCallback(callback) {\n    // Are we already logged in?\n    if (this._loginCallbacksCalled) {\n      // If already logged in before handler is registered, it's safe to\n      // assume type is a 'resume', so we execute the callback at the end\n      // of the queue so that Meteor.startup can complete before any\n      // embedded onLogin callbacks would execute.\n      Meteor.setTimeout(() => callback({ type: 'resume' }), 0);\n    }\n  }\n\n  ///\n  /// LOGIN TOKENS\n  ///\n\n  // These methods deal with storing a login token and user id in the\n  // browser's localStorage facility. It polls local storage every few\n  // seconds to synchronize login state between multiple tabs in the same\n  // browser.\n\n  loginWithToken(token, callback) {\n    this.callLoginMethod({\n      methodArguments: [{\n        resume: token\n      }],\n      userCallback: callback\n    });\n  };\n\n  // Semi-internal API. Call this function to re-enable auto login after\n  // if it was disabled at startup.\n  _enableAutoLogin() {\n    this._autoLoginEnabled = true;\n    this._pollStoredLoginToken();\n  };\n\n  ///\n  /// STORING\n  ///\n\n  // Call this from the top level of the test file for any test that does\n  // logging in and out, to protect multiple tabs running the same tests\n  // simultaneously from interfering with each others' localStorage.\n  _isolateLoginTokenForTest() {\n    this.LOGIN_TOKEN_KEY = this.LOGIN_TOKEN_KEY + Random.id();\n    this.USER_ID_KEY = this.USER_ID_KEY + Random.id();\n  };\n\n  _storeLoginToken(userId, token, tokenExpires) {\n    Meteor._localStorage.setItem(this.USER_ID_KEY, userId);\n    Meteor._localStorage.setItem(this.LOGIN_TOKEN_KEY, token);\n    if (! tokenExpires)\n      tokenExpires = this._tokenExpiration(new Date());\n    Meteor._localStorage.setItem(this.LOGIN_TOKEN_EXPIRES_KEY, tokenExpires);\n\n    // to ensure that the localstorage poller doesn't end up trying to\n    // connect a second time\n    this._lastLoginTokenWhenPolled = token;\n  };\n\n  _unstoreLoginToken() {\n    Meteor._localStorage.removeItem(this.USER_ID_KEY);\n    Meteor._localStorage.removeItem(this.LOGIN_TOKEN_KEY);\n    Meteor._localStorage.removeItem(this.LOGIN_TOKEN_EXPIRES_KEY);\n\n    // to ensure that the localstorage poller doesn't end up trying to\n    // connect a second time\n    this._lastLoginTokenWhenPolled = null;\n  };\n\n  // This is private, but it is exported for now because it is used by a\n  // test in accounts-password.\n  _storedLoginToken() {\n    return Meteor._localStorage.getItem(this.LOGIN_TOKEN_KEY);\n  };\n\n  _storedLoginTokenExpires() {\n    return Meteor._localStorage.getItem(this.LOGIN_TOKEN_EXPIRES_KEY);\n  };\n\n  _storedUserId() {\n    return Meteor._localStorage.getItem(this.USER_ID_KEY);\n  };\n\n  _unstoreLoginTokenIfExpiresSoon() {\n    const tokenExpires = this._storedLoginTokenExpires();\n    if (tokenExpires && this._tokenExpiresSoon(new Date(tokenExpires))) {\n      this._unstoreLoginToken();\n    }\n  };\n\n  ///\n  /// AUTO-LOGIN\n  ///\n\n  _initLocalStorage() {\n    // Key names to use in localStorage\n    this.LOGIN_TOKEN_KEY = \"Meteor.loginToken\";\n    this.LOGIN_TOKEN_EXPIRES_KEY = \"Meteor.loginTokenExpires\";\n    this.USER_ID_KEY = \"Meteor.userId\";\n\n    const rootUrlPathPrefix = __meteor_runtime_config__.ROOT_URL_PATH_PREFIX;\n    if (rootUrlPathPrefix || this.connection !== Meteor.connection) {\n      // We want to keep using the same keys for existing apps that do not\n      // set a custom ROOT_URL_PATH_PREFIX, so that most users will not have\n      // to log in again after an app updates to a version of Meteor that\n      // contains this code, but it's generally preferable to namespace the\n      // keys so that connections from distinct apps to distinct DDP URLs\n      // will be distinct in Meteor._localStorage.\n      let namespace = `:${this.connection._stream.rawUrl}`;\n      if (rootUrlPathPrefix) {\n        namespace += `:${rootUrlPathPrefix}`;\n      }\n      this.LOGIN_TOKEN_KEY += namespace;\n      this.LOGIN_TOKEN_EXPIRES_KEY += namespace;\n      this.USER_ID_KEY += namespace;\n    }\n\n    let token;\n    if (this._autoLoginEnabled) {\n      // Immediately try to log in via local storage, so that any DDP\n      // messages are sent after we have established our user account\n      this._unstoreLoginTokenIfExpiresSoon();\n      token = this._storedLoginToken();\n      if (token) {\n        // On startup, optimistically present us as logged in while the\n        // request is in flight. This reduces page flicker on startup.\n        const userId = this._storedUserId();\n        userId && this.connection.setUserId(userId);\n        this.loginWithToken(token, err => {\n          if (err) {\n            Meteor._debug(`Error logging in with token: ${err}`);\n            this.makeClientLoggedOut();\n          }\n\n          this._pageLoadLogin({\n            type: \"resume\",\n            allowed: !err,\n            error: err,\n            methodName: \"login\",\n            // XXX This is duplicate code with loginWithToken, but\n            // loginWithToken can also be called at other times besides\n            // page load.\n            methodArguments: [{resume: token}]\n          });\n        });\n      }\n    }\n\n    // Poll local storage every 3 seconds to login if someone logged in in\n    // another tab\n    this._lastLoginTokenWhenPolled = token;\n\n    if (this._pollIntervalTimer) {\n      // Unlikely that _initLocalStorage will be called more than once for\n      // the same AccountsClient instance, but just in case...\n      clearInterval(this._pollIntervalTimer);\n    }\n\n    this._pollIntervalTimer = setInterval(() => {\n      this._pollStoredLoginToken();\n    }, 3000);\n  };\n\n  _pollStoredLoginToken() {\n    if (! this._autoLoginEnabled) {\n      return;\n    }\n\n    const currentLoginToken = this._storedLoginToken();\n\n    // != instead of !== just to make sure undefined and null are treated the same\n    if (this._lastLoginTokenWhenPolled != currentLoginToken) {\n      if (currentLoginToken) {\n        this.loginWithToken(currentLoginToken, (err) => {\n          if (err) {\n            this.makeClientLoggedOut();\n          }\n        });\n      } else {\n        this.logout();\n      }\n    }\n\n    this._lastLoginTokenWhenPolled = currentLoginToken;\n  };\n\n  ///\n  /// URLS\n  ///\n\n  _initUrlMatching() {\n    // By default, allow the autologin process to happen.\n    this._autoLoginEnabled = true;\n\n    // We only support one callback per URL.\n    this._accountsCallbacks = {};\n\n    // Try to match the saved value of window.location.hash.\n    this._attemptToMatchHash();\n  };\n\n  // Separate out this functionality for testing\n  _attemptToMatchHash() {\n    attemptToMatchHash(this, this.savedHash, defaultSuccessHandler);\n  };\n\n  /**\n   * @summary Register a function to call when a reset password link is clicked\n   * in an email sent by\n   * [`Accounts.sendResetPasswordEmail`](#accounts_sendresetpasswordemail).\n   * This function should be called in top-level code, not inside\n   * `Meteor.startup()`.\n   * @memberof! Accounts\n   * @name onResetPasswordLink\n   * @param  {Function} callback The function to call. It is given two arguments:\n   *\n   * 1. `token`: A password reset token that can be passed to\n   * [`Accounts.resetPassword`](#accounts_resetpassword).\n   * 2. `done`: A function to call when the password reset UI flow is complete. The normal\n   * login process is suspended until this function is called, so that the\n   * password for user A can be reset even if user B was logged in.\n   * @locus Client\n   */\n  onResetPasswordLink(callback) {\n    if (this._accountsCallbacks[\"reset-password\"]) {\n      Meteor._debug(\"Accounts.onResetPasswordLink was called more than once. \" +\n        \"Only one callback added will be executed.\");\n    }\n\n    this._accountsCallbacks[\"reset-password\"] = callback;\n  };\n\n  /**\n   * @summary Register a function to call when an email verification link is\n   * clicked in an email sent by\n   * [`Accounts.sendVerificationEmail`](#accounts_sendverificationemail).\n   * This function should be called in top-level code, not inside\n   * `Meteor.startup()`.\n   * @memberof! Accounts\n   * @name onEmailVerificationLink\n   * @param  {Function} callback The function to call. It is given two arguments:\n   *\n   * 1. `token`: An email verification token that can be passed to\n   * [`Accounts.verifyEmail`](#accounts_verifyemail).\n   * 2. `done`: A function to call when the email verification UI flow is complete.\n   * The normal login process is suspended until this function is called, so\n   * that the user can be notified that they are verifying their email before\n   * being logged in.\n   * @locus Client\n   */\n  onEmailVerificationLink(callback) {\n    if (this._accountsCallbacks[\"verify-email\"]) {\n      Meteor._debug(\"Accounts.onEmailVerificationLink was called more than once. \" +\n        \"Only one callback added will be executed.\");\n    }\n\n    this._accountsCallbacks[\"verify-email\"] = callback;\n  };\n\n  /**\n   * @summary Register a function to call when an account enrollment link is\n   * clicked in an email sent by\n   * [`Accounts.sendEnrollmentEmail`](#accounts_sendenrollmentemail).\n   * This function should be called in top-level code, not inside\n   * `Meteor.startup()`.\n   * @memberof! Accounts\n   * @name onEnrollmentLink\n   * @param  {Function} callback The function to call. It is given two arguments:\n   *\n   * 1. `token`: A password reset token that can be passed to\n   * [`Accounts.resetPassword`](#accounts_resetpassword) to give the newly\n   * enrolled account a password.\n   * 2. `done`: A function to call when the enrollment UI flow is complete.\n   * The normal login process is suspended until this function is called, so that\n   * user A can be enrolled even if user B was logged in.\n   * @locus Client\n   */\n  onEnrollmentLink(callback) {\n    if (this._accountsCallbacks[\"enroll-account\"]) {\n      Meteor._debug(\"Accounts.onEnrollmentLink was called more than once. \" +\n        \"Only one callback added will be executed.\");\n    }\n\n    this._accountsCallbacks[\"enroll-account\"] = callback;\n  };\n\n};\n\n/**\n * @summary True if a login method (such as `Meteor.loginWithPassword`,\n * `Meteor.loginWithFacebook`, or `Accounts.createUser`) is currently in\n * progress. A reactive data source.\n * @locus Client\n * @importFromPackage meteor\n */\nMeteor.loggingIn = () => Accounts.loggingIn();\n\n/**\n * @summary True if a logout method (such as `Meteor.logout`) is currently in\n * progress. A reactive data source.\n * @locus Client\n * @importFromPackage meteor\n */\nMeteor.loggingOut = () => Accounts.loggingOut();\n\n/**\n * @summary Log the user out.\n * @locus Client\n * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n * @importFromPackage meteor\n */\nMeteor.logout = callback => Accounts.logout(callback);\n\n/**\n * @summary Log out other clients logged in as the current user, but does not log out the client that calls this function.\n * @locus Client\n * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n * @importFromPackage meteor\n */\nMeteor.logoutOtherClients = callback => Accounts.logoutOtherClients(callback);\n\n/**\n * @summary Login with a Meteor access token.\n * @locus Client\n * @param {Object} [token] Local storage token for use with login across\n * multiple tabs in the same browser.\n * @param {Function} [callback] Optional callback. Called with no arguments on\n * success.\n * @importFromPackage meteor\n */\nMeteor.loginWithToken = (token, callback) =>\n  Accounts.loginWithToken(token, callback);\n\n///\n/// HANDLEBARS HELPERS\n///\n\n// If our app has a Blaze, register the {{currentUser}} and {{loggingIn}}\n// global helpers.\nif (Package.blaze) {\n  const { Template } = Package.blaze.Blaze;\n\n  /**\n   * @global\n   * @name  currentUser\n   * @isHelper true\n   * @summary Calls [Meteor.user()](#meteor_user). Use `{{#if currentUser}}` to check whether the user is logged in.\n   */\n  Template.registerHelper('currentUser', () => Meteor.user());\n\n  /**\n   * @global\n   * @name  loggingIn\n   * @isHelper true\n   * @summary Calls [Meteor.loggingIn()](#meteor_loggingin).\n   */\n  Template.registerHelper('loggingIn', () => Meteor.loggingIn());\n\n  /**\n   * @global\n   * @name  loggingOut\n   * @isHelper true\n   * @summary Calls [Meteor.loggingOut()](#meteor_loggingout).\n   */\n  Template.registerHelper('loggingOut', () => Meteor.loggingOut());\n\n  /**\n   * @global\n   * @name  loggingInOrOut\n   * @isHelper true\n   * @summary Calls [Meteor.loggingIn()](#meteor_loggingin) or [Meteor.loggingOut()](#meteor_loggingout).\n   */\n  Template.registerHelper(\n    'loggingInOrOut',\n    () => Meteor.loggingIn() || Meteor.loggingOut()\n  );\n}\n\nconst defaultSuccessHandler = function(token, urlPart) {\n  // put login in a suspended state to wait for the interaction to finish\n  this._autoLoginEnabled = false;\n\n  // wait for other packages to register callbacks\n  Meteor.startup(() => {\n    // if a callback has been registered for this kind of token, call it\n    if (this._accountsCallbacks[urlPart]) {\n      this._accountsCallbacks[urlPart](token, () => this._enableAutoLogin());\n    }\n  });\n}\n\n// Note that both arguments are optional and are currently only passed by\n// accounts_url_tests.js.\nconst attemptToMatchHash = (accounts, hash, success) => {\n  // All of the special hash URLs we support for accounts interactions\n  [\"reset-password\", \"verify-email\", \"enroll-account\"].forEach(urlPart => {\n    let token;\n\n    const tokenRegex = new RegExp(`^\\\\#\\\\/${urlPart}\\\\/(.*)$`);\n    const match = hash.match(tokenRegex);\n\n    if (match) {\n      token = match[1];\n\n      // XXX COMPAT WITH 0.9.3\n      if (urlPart === \"reset-password\") {\n        accounts._resetPasswordToken = token;\n      } else if (urlPart === \"verify-email\") {\n        accounts._verifyEmailToken = token;\n      } else if (urlPart === \"enroll-account\") {\n        accounts._enrollAccountToken = token;\n      }\n    } else {\n      return;\n    }\n\n    // If no handlers match the hash, then maybe it's meant to be consumed\n    // by some entirely different code, so we only clear it the first time\n    // a handler successfully matches. Note that later handlers reuse the\n    // savedHash, so clearing window.location.hash here will not interfere\n    // with their needs.\n    window.location.hash = \"\";\n\n    // Do some stuff with the token we matched\n    success.call(accounts, token, urlPart);\n  });\n}\n\n// Export for testing\nexport const AccountsTest = {\n  attemptToMatchHash: (hash, success) =>\n    attemptToMatchHash(Accounts, hash, success),\n};\n"]},"sourceType":"module","hash":"5b6149bcd23c8f4c43ed132523eddbd547d3586f"}
