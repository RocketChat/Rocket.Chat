{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/packages/minimongo/cursor.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"packages/minimongo/cursor.js","filename":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/packages/minimongo/cursor.js","targets":{"android":"95.0.0","chrome":"95.0.0","edge":"95.0.0","firefox":"78.0.0","ie":"10.0.0","ios":"15.0.0","opera":"81.0.0","safari":"15.1.0","samsung":"14.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat","root":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.16.5","helpers":true,"useESModules":false,"corejs":false}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/packages/minimongo/cursor.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/minimongo/cursor.js"}},"code":"module.export({\n  default: () => Cursor\n});\nlet LocalCollection;\nmodule.link(\"./local_collection.js\", {\n  default(v) {\n    LocalCollection = v;\n  }\n\n}, 0);\nlet hasOwn;\nmodule.link(\"./common.js\", {\n  hasOwn(v) {\n    hasOwn = v;\n  }\n\n}, 1);\n\nclass Cursor {\n  // don't call this ctor directly.  use LocalCollection.find().\n  constructor(collection, selector) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.collection = collection;\n    this.sorter = null;\n    this.matcher = new Minimongo.Matcher(selector);\n\n    if (LocalCollection._selectorIsIdPerhapsAsObject(selector)) {\n      // stash for fast _id and { _id }\n      this._selectorId = hasOwn.call(selector, '_id') ? selector._id : selector;\n    } else {\n      this._selectorId = undefined;\n\n      if (this.matcher.hasGeoQuery() || options.sort) {\n        this.sorter = new Minimongo.Sorter(options.sort || []);\n      }\n    }\n\n    this.skip = options.skip || 0;\n    this.limit = options.limit;\n    this.fields = options.fields;\n    this._projectionFn = LocalCollection._compileProjection(this.fields || {});\n    this._transform = LocalCollection.wrapTransform(options.transform); // by default, queries register w/ Tracker when it is available.\n\n    if (typeof Tracker !== 'undefined') {\n      this.reactive = options.reactive === undefined ? true : options.reactive;\n    }\n  }\n  /**\n   * @summary Returns the number of documents that match a query.\n   * @memberOf Mongo.Cursor\n   * @method  count\n   * @param {boolean} [applySkipLimit=true] If set to `false`, the value\n   *                                         returned will reflect the total\n   *                                         number of matching documents,\n   *                                         ignoring any value supplied for\n   *                                         limit\n   * @instance\n   * @locus Anywhere\n   * @returns {Number}\n   */\n\n\n  count() {\n    let applySkipLimit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n    if (this.reactive) {\n      // allow the observe to be unordered\n      this._depend({\n        added: true,\n        removed: true\n      }, true);\n    }\n\n    return this._getRawObjects({\n      ordered: true,\n      applySkipLimit\n    }).length;\n  }\n  /**\n   * @summary Return all matching documents as an Array.\n   * @memberOf Mongo.Cursor\n   * @method  fetch\n   * @instance\n   * @locus Anywhere\n   * @returns {Object[]}\n   */\n\n\n  fetch() {\n    const result = [];\n    this.forEach(doc => {\n      result.push(doc);\n    });\n    return result;\n  }\n\n  [Symbol.iterator]() {\n    if (this.reactive) {\n      this._depend({\n        addedBefore: true,\n        removed: true,\n        changed: true,\n        movedBefore: true\n      });\n    }\n\n    let index = 0;\n\n    const objects = this._getRawObjects({\n      ordered: true\n    });\n\n    return {\n      next: () => {\n        if (index < objects.length) {\n          // This doubles as a clone operation.\n          let element = this._projectionFn(objects[index++]);\n\n          if (this._transform) element = this._transform(element);\n          return {\n            value: element\n          };\n        }\n\n        return {\n          done: true\n        };\n      }\n    };\n  }\n  /**\n   * @callback IterationCallback\n   * @param {Object} doc\n   * @param {Number} index\n   */\n\n  /**\n   * @summary Call `callback` once for each matching document, sequentially and\n   *          synchronously.\n   * @locus Anywhere\n   * @method  forEach\n   * @instance\n   * @memberOf Mongo.Cursor\n   * @param {IterationCallback} callback Function to call. It will be called\n   *                                     with three arguments: the document, a\n   *                                     0-based index, and <em>cursor</em>\n   *                                     itself.\n   * @param {Any} [thisArg] An object which will be the value of `this` inside\n   *                        `callback`.\n   */\n\n\n  forEach(callback, thisArg) {\n    if (this.reactive) {\n      this._depend({\n        addedBefore: true,\n        removed: true,\n        changed: true,\n        movedBefore: true\n      });\n    }\n\n    this._getRawObjects({\n      ordered: true\n    }).forEach((element, i) => {\n      // This doubles as a clone operation.\n      element = this._projectionFn(element);\n\n      if (this._transform) {\n        element = this._transform(element);\n      }\n\n      callback.call(thisArg, element, i, this);\n    });\n  }\n\n  getTransform() {\n    return this._transform;\n  }\n  /**\n   * @summary Map callback over all matching documents.  Returns an Array.\n   * @locus Anywhere\n   * @method map\n   * @instance\n   * @memberOf Mongo.Cursor\n   * @param {IterationCallback} callback Function to call. It will be called\n   *                                     with three arguments: the document, a\n   *                                     0-based index, and <em>cursor</em>\n   *                                     itself.\n   * @param {Any} [thisArg] An object which will be the value of `this` inside\n   *                        `callback`.\n   */\n\n\n  map(callback, thisArg) {\n    const result = [];\n    this.forEach((doc, i) => {\n      result.push(callback.call(thisArg, doc, i, this));\n    });\n    return result;\n  } // options to contain:\n  //  * callbacks for observe():\n  //    - addedAt (document, atIndex)\n  //    - added (document)\n  //    - changedAt (newDocument, oldDocument, atIndex)\n  //    - changed (newDocument, oldDocument)\n  //    - removedAt (document, atIndex)\n  //    - removed (document)\n  //    - movedTo (document, oldIndex, newIndex)\n  //\n  // attributes available on returned query handle:\n  //  * stop(): end updates\n  //  * collection: the collection this query is querying\n  //\n  // iff x is a returned query handle, (x instanceof\n  // LocalCollection.ObserveHandle) is true\n  //\n  // initial results delivered through added callback\n  // XXX maybe callbacks should take a list of objects, to expose transactions?\n  // XXX maybe support field limiting (to limit what you're notified on)\n\n  /**\n   * @summary Watch a query.  Receive callbacks as the result set changes.\n   * @locus Anywhere\n   * @memberOf Mongo.Cursor\n   * @instance\n   * @param {Object} callbacks Functions to call to deliver the result set as it\n   *                           changes\n   */\n\n\n  observe(options) {\n    return LocalCollection._observeFromObserveChanges(this, options);\n  }\n  /**\n   * @summary Watch a query. Receive callbacks as the result set changes. Only\n   *          the differences between the old and new documents are passed to\n   *          the callbacks.\n   * @locus Anywhere\n   * @memberOf Mongo.Cursor\n   * @instance\n   * @param {Object} callbacks Functions to call to deliver the result set as it\n   *                           changes\n   */\n\n\n  observeChanges(options) {\n    const ordered = LocalCollection._observeChangesCallbacksAreOrdered(options); // there are several places that assume you aren't combining skip/limit with\n    // unordered observe.  eg, update's EJSON.clone, and the \"there are several\"\n    // comment in _modifyAndNotify\n    // XXX allow skip/limit with unordered observe\n\n\n    if (!options._allow_unordered && !ordered && (this.skip || this.limit)) {\n      throw new Error(\"Must use an ordered observe with skip or limit (i.e. 'addedBefore' \" + \"for observeChanges or 'addedAt' for observe, instead of 'added').\");\n    }\n\n    if (this.fields && (this.fields._id === 0 || this.fields._id === false)) {\n      throw Error('You may not observe a cursor with {fields: {_id: 0}}');\n    }\n\n    const distances = this.matcher.hasGeoQuery() && ordered && new LocalCollection._IdMap();\n    const query = {\n      cursor: this,\n      dirty: false,\n      distances,\n      matcher: this.matcher,\n      // not fast pathed\n      ordered,\n      projectionFn: this._projectionFn,\n      resultsSnapshot: null,\n      sorter: ordered && this.sorter\n    };\n    let qid; // Non-reactive queries call added[Before] and then never call anything\n    // else.\n\n    if (this.reactive) {\n      qid = this.collection.next_qid++;\n      this.collection.queries[qid] = query;\n    }\n\n    query.results = this._getRawObjects({\n      ordered,\n      distances: query.distances\n    });\n\n    if (this.collection.paused) {\n      query.resultsSnapshot = ordered ? [] : new LocalCollection._IdMap();\n    } // wrap callbacks we were passed. callbacks only fire when not paused and\n    // are never undefined\n    // Filters out blacklisted fields according to cursor's projection.\n    // XXX wrong place for this?\n    // furthermore, callbacks enqueue until the operation we're working on is\n    // done.\n\n\n    const wrapCallback = fn => {\n      if (!fn) {\n        return () => {};\n      }\n\n      const self = this;\n      return function\n        /* args*/\n      () {\n        if (self.collection.paused) {\n          return;\n        }\n\n        const args = arguments;\n\n        self.collection._observeQueue.queueTask(() => {\n          fn.apply(this, args);\n        });\n      };\n    };\n\n    query.added = wrapCallback(options.added);\n    query.changed = wrapCallback(options.changed);\n    query.removed = wrapCallback(options.removed);\n\n    if (ordered) {\n      query.addedBefore = wrapCallback(options.addedBefore);\n      query.movedBefore = wrapCallback(options.movedBefore);\n    }\n\n    if (!options._suppress_initial && !this.collection.paused) {\n      query.results.forEach(doc => {\n        const fields = EJSON.clone(doc);\n        delete fields._id;\n\n        if (ordered) {\n          query.addedBefore(doc._id, this._projectionFn(fields), null);\n        }\n\n        query.added(doc._id, this._projectionFn(fields));\n      });\n    }\n\n    const handle = Object.assign(new LocalCollection.ObserveHandle(), {\n      collection: this.collection,\n      stop: () => {\n        if (this.reactive) {\n          delete this.collection.queries[qid];\n        }\n      }\n    });\n\n    if (this.reactive && Tracker.active) {\n      // XXX in many cases, the same observe will be recreated when\n      // the current autorun is rerun.  we could save work by\n      // letting it linger across rerun and potentially get\n      // repurposed if the same observe is performed, using logic\n      // similar to that of Meteor.subscribe.\n      Tracker.onInvalidate(() => {\n        handle.stop();\n      });\n    } // run the observe callbacks resulting from the initial contents\n    // before we leave the observe.\n\n\n    this.collection._observeQueue.drain();\n\n    return handle;\n  } // XXX Maybe we need a version of observe that just calls a callback if\n  // anything changed.\n\n\n  _depend(changers, _allow_unordered) {\n    if (Tracker.active) {\n      const dependency = new Tracker.Dependency();\n      const notify = dependency.changed.bind(dependency);\n      dependency.depend();\n      const options = {\n        _allow_unordered,\n        _suppress_initial: true\n      };\n      ['added', 'addedBefore', 'changed', 'movedBefore', 'removed'].forEach(fn => {\n        if (changers[fn]) {\n          options[fn] = notify;\n        }\n      }); // observeChanges will stop() when this computation is invalidated\n\n      this.observeChanges(options);\n    }\n  }\n\n  _getCollectionName() {\n    return this.collection.name;\n  } // Returns a collection of matching objects, but doesn't deep copy them.\n  //\n  // If ordered is set, returns a sorted array, respecting sorter, skip, and\n  // limit properties of the query provided that options.applySkipLimit is\n  // not set to false (#1201). If sorter is falsey, no sort -- you get the\n  // natural order.\n  //\n  // If ordered is not set, returns an object mapping from ID to doc (sorter,\n  // skip and limit should not be set).\n  //\n  // If ordered is set and this cursor is a $near geoquery, then this function\n  // will use an _IdMap to track each distance from the $near argument point in\n  // order to use it as a sort key. If an _IdMap is passed in the 'distances'\n  // argument, this function will clear it and use it for this purpose\n  // (otherwise it will just create its own _IdMap). The observeChanges\n  // implementation uses this to remember the distances after this function\n  // returns.\n\n\n  _getRawObjects() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // By default this method will respect skip and limit because .fetch(),\n    // .forEach() etc... expect this behaviour. It can be forced to ignore\n    // skip and limit by setting applySkipLimit to false (.count() does this,\n    // for example)\n    const applySkipLimit = options.applySkipLimit !== false; // XXX use OrderedDict instead of array, and make IdMap and OrderedDict\n    // compatible\n\n    const results = options.ordered ? [] : new LocalCollection._IdMap(); // fast path for single ID value\n\n    if (this._selectorId !== undefined) {\n      // If you have non-zero skip and ask for a single id, you get nothing.\n      // This is so it matches the behavior of the '{_id: foo}' path.\n      if (applySkipLimit && this.skip) {\n        return results;\n      }\n\n      const selectedDoc = this.collection._docs.get(this._selectorId);\n\n      if (selectedDoc) {\n        if (options.ordered) {\n          results.push(selectedDoc);\n        } else {\n          results.set(this._selectorId, selectedDoc);\n        }\n      }\n\n      return results;\n    } // slow path for arbitrary selector, sort, skip, limit\n    // in the observeChanges case, distances is actually part of the \"query\"\n    // (ie, live results set) object.  in other cases, distances is only used\n    // inside this function.\n\n\n    let distances;\n\n    if (this.matcher.hasGeoQuery() && options.ordered) {\n      if (options.distances) {\n        distances = options.distances;\n        distances.clear();\n      } else {\n        distances = new LocalCollection._IdMap();\n      }\n    }\n\n    this.collection._docs.forEach((doc, id) => {\n      const matchResult = this.matcher.documentMatches(doc);\n\n      if (matchResult.result) {\n        if (options.ordered) {\n          results.push(doc);\n\n          if (distances && matchResult.distance !== undefined) {\n            distances.set(id, matchResult.distance);\n          }\n        } else {\n          results.set(id, doc);\n        }\n      } // Override to ensure all docs are matched if ignoring skip & limit\n\n\n      if (!applySkipLimit) {\n        return true;\n      } // Fast path for limited unsorted queries.\n      // XXX 'length' check here seems wrong for ordered\n\n\n      return !this.limit || this.skip || this.sorter || results.length !== this.limit;\n    });\n\n    if (!options.ordered) {\n      return results;\n    }\n\n    if (this.sorter) {\n      results.sort(this.sorter.getComparator({\n        distances\n      }));\n    } // Return the full set of results if there is no skip or limit or if we're\n    // ignoring them\n\n\n    if (!applySkipLimit || !this.limit && !this.skip) {\n      return results;\n    }\n\n    return results.slice(this.skip, this.limit ? this.limit + this.skip : results.length);\n  }\n\n  _publishCursor(subscription) {\n    // XXX minimongo should not depend on mongo-livedata!\n    if (!Package.mongo) {\n      throw new Error('Can\\'t publish from Minimongo without the `mongo` package.');\n    }\n\n    if (!this.collection.name) {\n      throw new Error('Can\\'t publish a cursor from a collection without a name.');\n    }\n\n    return Package.mongo.Mongo.Collection._publishCursor(this, subscription, this.collection.name);\n  }\n\n}","map":{"version":3,"sources":["packages/minimongo/cursor.js"],"names":["module","export","default","Cursor","LocalCollection","link","v","hasOwn","constructor","collection","selector","options","sorter","matcher","Minimongo","Matcher","_selectorIsIdPerhapsAsObject","_selectorId","call","_id","undefined","hasGeoQuery","sort","Sorter","skip","limit","fields","_projectionFn","_compileProjection","_transform","wrapTransform","transform","Tracker","reactive","count","applySkipLimit","_depend","added","removed","_getRawObjects","ordered","length","fetch","result","forEach","doc","push","Symbol","iterator","addedBefore","changed","movedBefore","index","objects","next","element","value","done","callback","thisArg","i","getTransform","map","observe","_observeFromObserveChanges","observeChanges","_observeChangesCallbacksAreOrdered","_allow_unordered","Error","distances","_IdMap","query","cursor","dirty","projectionFn","resultsSnapshot","qid","next_qid","queries","results","paused","wrapCallback","fn","self","args","arguments","_observeQueue","queueTask","apply","_suppress_initial","EJSON","clone","handle","Object","assign","ObserveHandle","stop","active","onInvalidate","drain","changers","dependency","Dependency","notify","bind","depend","_getCollectionName","name","selectedDoc","_docs","get","set","clear","id","matchResult","documentMatches","distance","getComparator","slice","_publishCursor","subscription","Package","mongo","Mongo","Collection"],"mappings":"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","sourcesContent":["import LocalCollection from './local_collection.js';\nimport { hasOwn } from './common.js';\n\n// Cursor: a specification for a particular subset of documents, w/ a defined\n// order, limit, and offset.  creating a Cursor with LocalCollection.find(),\nexport default class Cursor {\n  // don't call this ctor directly.  use LocalCollection.find().\n  constructor(collection, selector, options = {}) {\n    this.collection = collection;\n    this.sorter = null;\n    this.matcher = new Minimongo.Matcher(selector);\n\n    if (LocalCollection._selectorIsIdPerhapsAsObject(selector)) {\n      // stash for fast _id and { _id }\n      this._selectorId = hasOwn.call(selector, '_id')\n        ? selector._id\n        : selector;\n    } else {\n      this._selectorId = undefined;\n\n      if (this.matcher.hasGeoQuery() || options.sort) {\n        this.sorter = new Minimongo.Sorter(options.sort || []);\n      }\n    }\n\n    this.skip = options.skip || 0;\n    this.limit = options.limit;\n    this.fields = options.fields;\n\n    this._projectionFn = LocalCollection._compileProjection(this.fields || {});\n\n    this._transform = LocalCollection.wrapTransform(options.transform);\n\n    // by default, queries register w/ Tracker when it is available.\n    if (typeof Tracker !== 'undefined') {\n      this.reactive = options.reactive === undefined ? true : options.reactive;\n    }\n  }\n\n  /**\n   * @summary Returns the number of documents that match a query.\n   * @memberOf Mongo.Cursor\n   * @method  count\n   * @param {boolean} [applySkipLimit=true] If set to `false`, the value\n   *                                         returned will reflect the total\n   *                                         number of matching documents,\n   *                                         ignoring any value supplied for\n   *                                         limit\n   * @instance\n   * @locus Anywhere\n   * @returns {Number}\n   */\n  count(applySkipLimit = true) {\n    if (this.reactive) {\n      // allow the observe to be unordered\n      this._depend({added: true, removed: true}, true);\n    }\n\n    return this._getRawObjects({\n      ordered: true,\n      applySkipLimit\n    }).length;\n  }\n\n  /**\n   * @summary Return all matching documents as an Array.\n   * @memberOf Mongo.Cursor\n   * @method  fetch\n   * @instance\n   * @locus Anywhere\n   * @returns {Object[]}\n   */\n  fetch() {\n    const result = [];\n\n    this.forEach(doc => {\n      result.push(doc);\n    });\n\n    return result;\n  }\n\n  [Symbol.iterator]() {\n    if (this.reactive) {\n      this._depend({\n        addedBefore: true,\n        removed: true,\n        changed: true,\n        movedBefore: true});\n    }\n\n    let index = 0;\n    const objects = this._getRawObjects({ordered: true});\n\n    return {\n      next: () => {\n        if (index < objects.length) {\n          // This doubles as a clone operation.\n          let element = this._projectionFn(objects[index++]);\n\n          if (this._transform)\n            element = this._transform(element);\n\n          return {value: element};\n        }\n\n        return {done: true};\n      }\n    };\n  }\n\n  /**\n   * @callback IterationCallback\n   * @param {Object} doc\n   * @param {Number} index\n   */\n  /**\n   * @summary Call `callback` once for each matching document, sequentially and\n   *          synchronously.\n   * @locus Anywhere\n   * @method  forEach\n   * @instance\n   * @memberOf Mongo.Cursor\n   * @param {IterationCallback} callback Function to call. It will be called\n   *                                     with three arguments: the document, a\n   *                                     0-based index, and <em>cursor</em>\n   *                                     itself.\n   * @param {Any} [thisArg] An object which will be the value of `this` inside\n   *                        `callback`.\n   */\n  forEach(callback, thisArg) {\n    if (this.reactive) {\n      this._depend({\n        addedBefore: true,\n        removed: true,\n        changed: true,\n        movedBefore: true});\n    }\n\n    this._getRawObjects({ordered: true}).forEach((element, i) => {\n      // This doubles as a clone operation.\n      element = this._projectionFn(element);\n\n      if (this._transform) {\n        element = this._transform(element);\n      }\n\n      callback.call(thisArg, element, i, this);\n    });\n  }\n\n  getTransform() {\n    return this._transform;\n  }\n\n  /**\n   * @summary Map callback over all matching documents.  Returns an Array.\n   * @locus Anywhere\n   * @method map\n   * @instance\n   * @memberOf Mongo.Cursor\n   * @param {IterationCallback} callback Function to call. It will be called\n   *                                     with three arguments: the document, a\n   *                                     0-based index, and <em>cursor</em>\n   *                                     itself.\n   * @param {Any} [thisArg] An object which will be the value of `this` inside\n   *                        `callback`.\n   */\n  map(callback, thisArg) {\n    const result = [];\n\n    this.forEach((doc, i) => {\n      result.push(callback.call(thisArg, doc, i, this));\n    });\n\n    return result;\n  }\n\n  // options to contain:\n  //  * callbacks for observe():\n  //    - addedAt (document, atIndex)\n  //    - added (document)\n  //    - changedAt (newDocument, oldDocument, atIndex)\n  //    - changed (newDocument, oldDocument)\n  //    - removedAt (document, atIndex)\n  //    - removed (document)\n  //    - movedTo (document, oldIndex, newIndex)\n  //\n  // attributes available on returned query handle:\n  //  * stop(): end updates\n  //  * collection: the collection this query is querying\n  //\n  // iff x is a returned query handle, (x instanceof\n  // LocalCollection.ObserveHandle) is true\n  //\n  // initial results delivered through added callback\n  // XXX maybe callbacks should take a list of objects, to expose transactions?\n  // XXX maybe support field limiting (to limit what you're notified on)\n\n  /**\n   * @summary Watch a query.  Receive callbacks as the result set changes.\n   * @locus Anywhere\n   * @memberOf Mongo.Cursor\n   * @instance\n   * @param {Object} callbacks Functions to call to deliver the result set as it\n   *                           changes\n   */\n  observe(options) {\n    return LocalCollection._observeFromObserveChanges(this, options);\n  }\n\n  /**\n   * @summary Watch a query. Receive callbacks as the result set changes. Only\n   *          the differences between the old and new documents are passed to\n   *          the callbacks.\n   * @locus Anywhere\n   * @memberOf Mongo.Cursor\n   * @instance\n   * @param {Object} callbacks Functions to call to deliver the result set as it\n   *                           changes\n   */\n  observeChanges(options) {\n    const ordered = LocalCollection._observeChangesCallbacksAreOrdered(options);\n\n    // there are several places that assume you aren't combining skip/limit with\n    // unordered observe.  eg, update's EJSON.clone, and the \"there are several\"\n    // comment in _modifyAndNotify\n    // XXX allow skip/limit with unordered observe\n    if (!options._allow_unordered && !ordered && (this.skip || this.limit)) {\n      throw new Error(\n        \"Must use an ordered observe with skip or limit (i.e. 'addedBefore' \" +\n        \"for observeChanges or 'addedAt' for observe, instead of 'added').\"\n      );\n    }\n\n    if (this.fields && (this.fields._id === 0 || this.fields._id === false)) {\n      throw Error('You may not observe a cursor with {fields: {_id: 0}}');\n    }\n\n    const distances = (\n      this.matcher.hasGeoQuery() &&\n      ordered &&\n      new LocalCollection._IdMap\n    );\n\n    const query = {\n      cursor: this,\n      dirty: false,\n      distances,\n      matcher: this.matcher, // not fast pathed\n      ordered,\n      projectionFn: this._projectionFn,\n      resultsSnapshot: null,\n      sorter: ordered && this.sorter\n    };\n\n    let qid;\n\n    // Non-reactive queries call added[Before] and then never call anything\n    // else.\n    if (this.reactive) {\n      qid = this.collection.next_qid++;\n      this.collection.queries[qid] = query;\n    }\n\n    query.results = this._getRawObjects({ordered, distances: query.distances});\n\n    if (this.collection.paused) {\n      query.resultsSnapshot = ordered ? [] : new LocalCollection._IdMap;\n    }\n\n    // wrap callbacks we were passed. callbacks only fire when not paused and\n    // are never undefined\n    // Filters out blacklisted fields according to cursor's projection.\n    // XXX wrong place for this?\n\n    // furthermore, callbacks enqueue until the operation we're working on is\n    // done.\n    const wrapCallback = fn => {\n      if (!fn) {\n        return () => {};\n      }\n\n      const self = this;\n      return function(/* args*/) {\n        if (self.collection.paused) {\n          return;\n        }\n\n        const args = arguments;\n\n        self.collection._observeQueue.queueTask(() => {\n          fn.apply(this, args);\n        });\n      };\n    };\n\n    query.added = wrapCallback(options.added);\n    query.changed = wrapCallback(options.changed);\n    query.removed = wrapCallback(options.removed);\n\n    if (ordered) {\n      query.addedBefore = wrapCallback(options.addedBefore);\n      query.movedBefore = wrapCallback(options.movedBefore);\n    }\n\n    if (!options._suppress_initial && !this.collection.paused) {\n      query.results.forEach(doc => {\n        const fields = EJSON.clone(doc);\n\n        delete fields._id;\n\n        if (ordered) {\n          query.addedBefore(doc._id, this._projectionFn(fields), null);\n        }\n\n        query.added(doc._id, this._projectionFn(fields));\n      });\n    }\n\n    const handle = Object.assign(new LocalCollection.ObserveHandle, {\n      collection: this.collection,\n      stop: () => {\n        if (this.reactive) {\n          delete this.collection.queries[qid];\n        }\n      }\n    });\n\n    if (this.reactive && Tracker.active) {\n      // XXX in many cases, the same observe will be recreated when\n      // the current autorun is rerun.  we could save work by\n      // letting it linger across rerun and potentially get\n      // repurposed if the same observe is performed, using logic\n      // similar to that of Meteor.subscribe.\n      Tracker.onInvalidate(() => {\n        handle.stop();\n      });\n    }\n\n    // run the observe callbacks resulting from the initial contents\n    // before we leave the observe.\n    this.collection._observeQueue.drain();\n\n    return handle;\n  }\n\n  // XXX Maybe we need a version of observe that just calls a callback if\n  // anything changed.\n  _depend(changers, _allow_unordered) {\n    if (Tracker.active) {\n      const dependency = new Tracker.Dependency;\n      const notify = dependency.changed.bind(dependency);\n\n      dependency.depend();\n\n      const options = {_allow_unordered, _suppress_initial: true};\n\n      ['added', 'addedBefore', 'changed', 'movedBefore', 'removed']\n        .forEach(fn => {\n          if (changers[fn]) {\n            options[fn] = notify;\n          }\n        });\n\n      // observeChanges will stop() when this computation is invalidated\n      this.observeChanges(options);\n    }\n  }\n\n  _getCollectionName() {\n    return this.collection.name;\n  }\n\n  // Returns a collection of matching objects, but doesn't deep copy them.\n  //\n  // If ordered is set, returns a sorted array, respecting sorter, skip, and\n  // limit properties of the query provided that options.applySkipLimit is\n  // not set to false (#1201). If sorter is falsey, no sort -- you get the\n  // natural order.\n  //\n  // If ordered is not set, returns an object mapping from ID to doc (sorter,\n  // skip and limit should not be set).\n  //\n  // If ordered is set and this cursor is a $near geoquery, then this function\n  // will use an _IdMap to track each distance from the $near argument point in\n  // order to use it as a sort key. If an _IdMap is passed in the 'distances'\n  // argument, this function will clear it and use it for this purpose\n  // (otherwise it will just create its own _IdMap). The observeChanges\n  // implementation uses this to remember the distances after this function\n  // returns.\n  _getRawObjects(options = {}) {\n    // By default this method will respect skip and limit because .fetch(),\n    // .forEach() etc... expect this behaviour. It can be forced to ignore\n    // skip and limit by setting applySkipLimit to false (.count() does this,\n    // for example)\n    const applySkipLimit = options.applySkipLimit !== false;\n\n    // XXX use OrderedDict instead of array, and make IdMap and OrderedDict\n    // compatible\n    const results = options.ordered ? [] : new LocalCollection._IdMap;\n\n    // fast path for single ID value\n    if (this._selectorId !== undefined) {\n      // If you have non-zero skip and ask for a single id, you get nothing.\n      // This is so it matches the behavior of the '{_id: foo}' path.\n      if (applySkipLimit && this.skip) {\n        return results;\n      }\n\n      const selectedDoc = this.collection._docs.get(this._selectorId);\n\n      if (selectedDoc) {\n        if (options.ordered) {\n          results.push(selectedDoc);\n        } else {\n          results.set(this._selectorId, selectedDoc);\n        }\n      }\n\n      return results;\n    }\n\n    // slow path for arbitrary selector, sort, skip, limit\n\n    // in the observeChanges case, distances is actually part of the \"query\"\n    // (ie, live results set) object.  in other cases, distances is only used\n    // inside this function.\n    let distances;\n    if (this.matcher.hasGeoQuery() && options.ordered) {\n      if (options.distances) {\n        distances = options.distances;\n        distances.clear();\n      } else {\n        distances = new LocalCollection._IdMap();\n      }\n    }\n\n    this.collection._docs.forEach((doc, id) => {\n      const matchResult = this.matcher.documentMatches(doc);\n\n      if (matchResult.result) {\n        if (options.ordered) {\n          results.push(doc);\n\n          if (distances && matchResult.distance !== undefined) {\n            distances.set(id, matchResult.distance);\n          }\n        } else {\n          results.set(id, doc);\n        }\n      }\n\n      // Override to ensure all docs are matched if ignoring skip & limit\n      if (!applySkipLimit) {\n        return true;\n      }\n\n      // Fast path for limited unsorted queries.\n      // XXX 'length' check here seems wrong for ordered\n      return (\n        !this.limit ||\n        this.skip ||\n        this.sorter ||\n        results.length !== this.limit\n      );\n    });\n\n    if (!options.ordered) {\n      return results;\n    }\n\n    if (this.sorter) {\n      results.sort(this.sorter.getComparator({distances}));\n    }\n\n    // Return the full set of results if there is no skip or limit or if we're\n    // ignoring them\n    if (!applySkipLimit || (!this.limit && !this.skip)) {\n      return results;\n    }\n\n    return results.slice(\n      this.skip,\n      this.limit ? this.limit + this.skip : results.length\n    );\n  }\n\n  _publishCursor(subscription) {\n    // XXX minimongo should not depend on mongo-livedata!\n    if (!Package.mongo) {\n      throw new Error(\n        'Can\\'t publish from Minimongo without the `mongo` package.'\n      );\n    }\n\n    if (!this.collection.name) {\n      throw new Error(\n        'Can\\'t publish a cursor from a collection without a name.'\n      );\n    }\n\n    return Package.mongo.Mongo.Collection._publishCursor(\n      this,\n      subscription,\n      this.collection.name\n    );\n  }\n}\n"]},"sourceType":"module","hash":"897c2cd2a5a07d37c658a1151f78b80922344e16"}
