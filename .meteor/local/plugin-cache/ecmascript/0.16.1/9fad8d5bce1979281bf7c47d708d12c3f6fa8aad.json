{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/packages/blaze/domrange.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"packages/blaze/domrange.js","filename":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/packages/blaze/domrange.js","targets":{"android":"95.0.0","chrome":"95.0.0","edge":"95.0.0","firefox":"78.0.0","ie":"10.0.0","ios":"15.0.0","opera":"81.0.0","safari":"15.1.0","samsung":"14.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat","root":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.16.5","helpers":true,"useESModules":false,"corejs":false}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/packages/blaze/domrange.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/blaze/domrange.js"}},"code":"// A constant empty array (frozen if the JS engine supports it).\nvar _emptyArray = Object.freeze ? Object.freeze([]) : []; // `[new] Blaze._DOMRange([nodeAndRangeArray])`\n//\n// A DOMRange consists of an array of consecutive nodes and DOMRanges,\n// which may be replaced at any time with a new array.  If the DOMRange\n// has been attached to the DOM at some location, then updating\n// the array will cause the DOM to be updated at that location.\n\n\nBlaze._DOMRange = function (nodeAndRangeArray) {\n  if (!(this instanceof DOMRange)) // called without `new`\n    return new DOMRange(nodeAndRangeArray);\n  var members = nodeAndRangeArray || _emptyArray;\n  if (!(members && typeof members.length === 'number')) throw new Error(\"Expected array\");\n\n  for (var i = 0; i < members.length; i++) this._memberIn(members[i]);\n\n  this.members = members;\n  this.emptyRangePlaceholder = null;\n  this.attached = false;\n  this.parentElement = null;\n  this.parentRange = null;\n  this.attachedCallbacks = _emptyArray;\n};\n\nvar DOMRange = Blaze._DOMRange; // In IE 8, don't use empty text nodes as placeholders\n// in empty DOMRanges, use comment nodes instead.  Using\n// empty text nodes in modern browsers is great because\n// it doesn't clutter the web inspector.  In IE 8, however,\n// it seems to lead in some roundabout way to the OAuth\n// pop-up crashing the browser completely.  In the past,\n// we didn't use empty text nodes on IE 8 because they\n// don't accept JS properties, so just use the same logic\n// even though we don't need to set properties on the\n// placeholder anymore.\n\nDOMRange._USE_COMMENT_PLACEHOLDERS = function () {\n  var result = false;\n  var textNode = document.createTextNode(\"\");\n\n  try {\n    textNode.someProp = true;\n  } catch (e) {\n    // IE 8\n    result = true;\n  }\n\n  return result;\n}(); // static methods\n\n\nDOMRange._insert = function (rangeOrNode, parentElement, nextNode, _isMove) {\n  var m = rangeOrNode;\n\n  if (m instanceof DOMRange) {\n    m.attach(parentElement, nextNode, _isMove);\n  } else {\n    if (_isMove) DOMRange._moveNodeWithHooks(m, parentElement, nextNode);else DOMRange._insertNodeWithHooks(m, parentElement, nextNode);\n  }\n};\n\nDOMRange._remove = function (rangeOrNode) {\n  var m = rangeOrNode;\n\n  if (m instanceof DOMRange) {\n    m.detach();\n  } else {\n    DOMRange._removeNodeWithHooks(m);\n  }\n};\n\nDOMRange._removeNodeWithHooks = function (n) {\n  if (!n.parentNode) return;\n\n  if (n.nodeType === 1 && n.parentNode._uihooks && n.parentNode._uihooks.removeElement) {\n    n.parentNode._uihooks.removeElement(n);\n  } else {\n    n.parentNode.removeChild(n);\n  }\n};\n\nDOMRange._insertNodeWithHooks = function (n, parent, next) {\n  // `|| null` because IE throws an error if 'next' is undefined\n  next = next || null;\n\n  if (n.nodeType === 1 && parent._uihooks && parent._uihooks.insertElement) {\n    parent._uihooks.insertElement(n, next);\n  } else {\n    parent.insertBefore(n, next);\n  }\n};\n\nDOMRange._moveNodeWithHooks = function (n, parent, next) {\n  if (n.parentNode !== parent) return; // `|| null` because IE throws an error if 'next' is undefined\n\n  next = next || null;\n\n  if (n.nodeType === 1 && parent._uihooks && parent._uihooks.moveElement) {\n    parent._uihooks.moveElement(n, next);\n  } else {\n    parent.insertBefore(n, next);\n  }\n};\n\nDOMRange.forElement = function (elem) {\n  if (elem.nodeType !== 1) throw new Error(\"Expected element, found: \" + elem);\n  var range = null;\n\n  while (elem && !range) {\n    range = elem.$blaze_range || null;\n    if (!range) elem = elem.parentNode;\n  }\n\n  return range;\n};\n\nDOMRange.prototype.attach = function (parentElement, nextNode, _isMove, _isReplace) {\n  // This method is called to insert the DOMRange into the DOM for\n  // the first time, but it's also used internally when\n  // updating the DOM.\n  //\n  // If _isMove is true, move this attached range to a different\n  // location under the same parentElement.\n  if (_isMove || _isReplace) {\n    if (!(this.parentElement === parentElement && this.attached)) throw new Error(\"Can only move or replace an attached DOMRange, and only under the same parent element\");\n  }\n\n  var members = this.members;\n\n  if (members.length) {\n    this.emptyRangePlaceholder = null;\n\n    for (var i = 0; i < members.length; i++) {\n      DOMRange._insert(members[i], parentElement, nextNode, _isMove);\n    }\n  } else {\n    var placeholder = DOMRange._USE_COMMENT_PLACEHOLDERS ? document.createComment(\"\") : document.createTextNode(\"\");\n    this.emptyRangePlaceholder = placeholder;\n    parentElement.insertBefore(placeholder, nextNode || null);\n  }\n\n  this.attached = true;\n  this.parentElement = parentElement;\n\n  if (!(_isMove || _isReplace)) {\n    for (var i = 0; i < this.attachedCallbacks.length; i++) {\n      var obj = this.attachedCallbacks[i];\n      obj.attached && obj.attached(this, parentElement);\n    }\n  }\n};\n\nDOMRange.prototype.setMembers = function (newNodeAndRangeArray) {\n  var newMembers = newNodeAndRangeArray;\n  if (!(newMembers && typeof newMembers.length === 'number')) throw new Error(\"Expected array\");\n  var oldMembers = this.members;\n\n  for (var i = 0; i < oldMembers.length; i++) this._memberOut(oldMembers[i]);\n\n  for (var i = 0; i < newMembers.length; i++) this._memberIn(newMembers[i]);\n\n  if (!this.attached) {\n    this.members = newMembers;\n  } else {\n    // don't do anything if we're going from empty to empty\n    if (newMembers.length || oldMembers.length) {\n      // detach the old members and insert the new members\n      var nextNode = this.lastNode().nextSibling;\n      var parentElement = this.parentElement; // Use detach/attach, but don't fire attached/detached hooks\n\n      this.detach(true\n      /*_isReplace*/\n      );\n      this.members = newMembers;\n      this.attach(parentElement, nextNode, false, true\n      /*_isReplace*/\n      );\n    }\n  }\n};\n\nDOMRange.prototype.firstNode = function () {\n  if (!this.attached) throw new Error(\"Must be attached\");\n  if (!this.members.length) return this.emptyRangePlaceholder;\n  var m = this.members[0];\n  return m instanceof DOMRange ? m.firstNode() : m;\n};\n\nDOMRange.prototype.lastNode = function () {\n  if (!this.attached) throw new Error(\"Must be attached\");\n  if (!this.members.length) return this.emptyRangePlaceholder;\n  var m = this.members[this.members.length - 1];\n  return m instanceof DOMRange ? m.lastNode() : m;\n};\n\nDOMRange.prototype.detach = function (_isReplace) {\n  if (!this.attached) throw new Error(\"Must be attached\");\n  var oldParentElement = this.parentElement;\n  var members = this.members;\n\n  if (members.length) {\n    for (var i = 0; i < members.length; i++) {\n      DOMRange._remove(members[i]);\n    }\n  } else {\n    var placeholder = this.emptyRangePlaceholder;\n    this.parentElement.removeChild(placeholder);\n    this.emptyRangePlaceholder = null;\n  }\n\n  if (!_isReplace) {\n    this.attached = false;\n    this.parentElement = null;\n\n    for (var i = 0; i < this.attachedCallbacks.length; i++) {\n      var obj = this.attachedCallbacks[i];\n      obj.detached && obj.detached(this, oldParentElement);\n    }\n  }\n};\n\nDOMRange.prototype.addMember = function (newMember, atIndex, _isMove) {\n  var members = this.members;\n  if (!(atIndex >= 0 && atIndex <= members.length)) throw new Error(\"Bad index in range.addMember: \" + atIndex);\n  if (!_isMove) this._memberIn(newMember);\n\n  if (!this.attached) {\n    // currently detached; just updated members\n    members.splice(atIndex, 0, newMember);\n  } else if (members.length === 0) {\n    // empty; use the empty-to-nonempty handling of setMembers\n    this.setMembers([newMember]);\n  } else {\n    var nextNode;\n\n    if (atIndex === members.length) {\n      // insert at end\n      nextNode = this.lastNode().nextSibling;\n    } else {\n      var m = members[atIndex];\n      nextNode = m instanceof DOMRange ? m.firstNode() : m;\n    }\n\n    members.splice(atIndex, 0, newMember);\n\n    DOMRange._insert(newMember, this.parentElement, nextNode, _isMove);\n  }\n};\n\nDOMRange.prototype.removeMember = function (atIndex, _isMove) {\n  var members = this.members;\n  if (!(atIndex >= 0 && atIndex < members.length)) throw new Error(\"Bad index in range.removeMember: \" + atIndex);\n\n  if (_isMove) {\n    members.splice(atIndex, 1);\n  } else {\n    var oldMember = members[atIndex];\n\n    this._memberOut(oldMember);\n\n    if (members.length === 1) {\n      // becoming empty; use the logic in setMembers\n      this.setMembers(_emptyArray);\n    } else {\n      members.splice(atIndex, 1);\n      if (this.attached) DOMRange._remove(oldMember);\n    }\n  }\n};\n\nDOMRange.prototype.moveMember = function (oldIndex, newIndex) {\n  var member = this.members[oldIndex];\n  this.removeMember(oldIndex, true\n  /*_isMove*/\n  );\n  this.addMember(member, newIndex, true\n  /*_isMove*/\n  );\n};\n\nDOMRange.prototype.getMember = function (atIndex) {\n  var members = this.members;\n  if (!(atIndex >= 0 && atIndex < members.length)) throw new Error(\"Bad index in range.getMember: \" + atIndex);\n  return this.members[atIndex];\n};\n\nDOMRange.prototype._memberIn = function (m) {\n  if (m instanceof DOMRange) m.parentRange = this;else if (m.nodeType === 1) // DOM Element\n    m.$blaze_range = this;\n};\n\nDOMRange._destroy = function (m, _skipNodes) {\n  if (m instanceof DOMRange) {\n    if (m.view) Blaze._destroyView(m.view, _skipNodes);\n  } else if (!_skipNodes && m.nodeType === 1) {\n    // DOM Element\n    if (m.$blaze_range) {\n      Blaze._destroyNode(m);\n\n      m.$blaze_range = null;\n    }\n  }\n};\n\nDOMRange.prototype._memberOut = DOMRange._destroy; // Tear down, but don't remove, the members.  Used when chunks\n// of DOM are being torn down or replaced.\n\nDOMRange.prototype.destroyMembers = function (_skipNodes) {\n  var members = this.members;\n\n  for (var i = 0; i < members.length; i++) this._memberOut(members[i], _skipNodes);\n};\n\nDOMRange.prototype.destroy = function (_skipNodes) {\n  DOMRange._destroy(this, _skipNodes);\n};\n\nDOMRange.prototype.containsElement = function (elem) {\n  if (!this.attached) throw new Error(\"Must be attached\"); // An element is contained in this DOMRange if it's possible to\n  // reach it by walking parent pointers, first through the DOM and\n  // then parentRange pointers.  In other words, the element or some\n  // ancestor of it is at our level of the DOM (a child of our\n  // parentElement), and this element is one of our members or\n  // is a member of a descendant Range.\n  // First check that elem is a descendant of this.parentElement,\n  // according to the DOM.\n\n  if (!Blaze._elementContains(this.parentElement, elem)) return false; // If elem is not an immediate child of this.parentElement,\n  // walk up to its ancestor that is.\n\n  while (elem.parentNode !== this.parentElement) elem = elem.parentNode;\n\n  var range = elem.$blaze_range;\n\n  while (range && range !== this) range = range.parentRange;\n\n  return range === this;\n};\n\nDOMRange.prototype.containsRange = function (range) {\n  if (!this.attached) throw new Error(\"Must be attached\");\n  if (!range.attached) return false; // A DOMRange is contained in this DOMRange if it's possible\n  // to reach this range by following parent pointers.  If the\n  // DOMRange has the same parentElement, then it should be\n  // a member, or a member of a member etc.  Otherwise, we must\n  // contain its parentElement.\n\n  if (range.parentElement !== this.parentElement) return this.containsElement(range.parentElement);\n  if (range === this) return false; // don't contain self\n\n  while (range && range !== this) range = range.parentRange;\n\n  return range === this;\n};\n\nDOMRange.prototype.onAttached = function (attached) {\n  this.onAttachedDetached({\n    attached: attached\n  });\n}; // callbacks are `attached(range, element)` and\n// `detached(range, element)`, and they may\n// access the `callbacks` object in `this`.\n// The arguments to `detached` are the same\n// range and element that were passed to `attached`.\n\n\nDOMRange.prototype.onAttachedDetached = function (callbacks) {\n  if (this.attachedCallbacks === _emptyArray) this.attachedCallbacks = [];\n  this.attachedCallbacks.push(callbacks);\n};\n\nDOMRange.prototype.$ = function (selector) {\n  var self = this;\n  var parentNode = this.parentElement;\n  if (!parentNode) throw new Error(\"Can't select in removed DomRange\"); // Strategy: Find all selector matches under parentNode,\n  // then filter out the ones that aren't in this DomRange\n  // using `DOMRange#containsElement`.  This is\n  // asymptotically slow in the presence of O(N) sibling\n  // content that is under parentNode but not in our range,\n  // so if performance is an issue, the selector should be\n  // run on a child element.\n  // Since jQuery can't run selectors on a DocumentFragment,\n  // we don't expect findBySelector to work.\n\n  if (parentNode.nodeType === 11\n  /* DocumentFragment */\n  ) throw new Error(\"Can't use $ on an offscreen range\");\n\n  var results = Blaze._DOMBackend.findBySelector(selector, parentNode); // We don't assume `results` has jQuery API; a plain array\n  // should do just as well.  However, if we do have a jQuery\n  // array, we want to end up with one also, so we use\n  // `.filter`.\n  // Function that selects only elements that are actually\n  // in this DomRange, rather than simply descending from\n  // `parentNode`.\n\n\n  var filterFunc = function (elem) {\n    // handle jQuery's arguments to filter, where the node\n    // is in `this` and the index is the first argument.\n    if (typeof elem === 'number') elem = this;\n    return self.containsElement(elem);\n  };\n\n  if (!results.filter) {\n    // not a jQuery array, and not a browser with\n    // Array.prototype.filter (e.g. IE <9)\n    var newResults = [];\n\n    for (var i = 0; i < results.length; i++) {\n      var x = results[i];\n      if (filterFunc(x)) newResults.push(x);\n    }\n\n    results = newResults;\n  } else {\n    // `results.filter` is either jQuery's or ECMAScript's `filter`\n    results = results.filter(filterFunc);\n  }\n\n  return results;\n}; // Returns true if element a contains node b and is not node b.\n//\n// The restriction that `a` be an element (not a document fragment,\n// say) is based on what's easy to implement cross-browser.\n\n\nBlaze._elementContains = function (a, b) {\n  if (a.nodeType !== 1) // ELEMENT\n    return false;\n  if (a === b) return false;\n\n  if (a.compareDocumentPosition) {\n    return a.compareDocumentPosition(b) & 0x10;\n  } else {\n    // Should be only old IE and maybe other old browsers here.\n    // Modern Safari has both functions but seems to get contains() wrong.\n    // IE can't handle b being a text node.  We work around this\n    // by doing a direct parent test now.\n    b = b.parentNode;\n    if (!(b && b.nodeType === 1)) // ELEMENT\n      return false;\n    if (a === b) return true;\n    return a.contains(b);\n  }\n};","map":{"version":3,"sources":["packages/blaze/domrange.js"],"names":["_emptyArray","Object","freeze","Blaze","_DOMRange","nodeAndRangeArray","DOMRange","members","length","Error","i","_memberIn","emptyRangePlaceholder","attached","parentElement","parentRange","attachedCallbacks","_USE_COMMENT_PLACEHOLDERS","result","textNode","document","createTextNode","someProp","e","_insert","rangeOrNode","nextNode","_isMove","m","attach","_moveNodeWithHooks","_insertNodeWithHooks","_remove","detach","_removeNodeWithHooks","n","parentNode","nodeType","_uihooks","removeElement","removeChild","parent","next","insertElement","insertBefore","moveElement","forElement","elem","range","$blaze_range","prototype","_isReplace","placeholder","createComment","obj","setMembers","newNodeAndRangeArray","newMembers","oldMembers","_memberOut","lastNode","nextSibling","firstNode","oldParentElement","detached","addMember","newMember","atIndex","splice","removeMember","oldMember","moveMember","oldIndex","newIndex","member","getMember","_destroy","_skipNodes","view","_destroyView","_destroyNode","destroyMembers","destroy","containsElement","_elementContains","containsRange","onAttached","onAttachedDetached","callbacks","push","$","selector","self","results","_DOMBackend","findBySelector","filterFunc","filter","newResults","x","a","b","compareDocumentPosition","contains"],"mappings":"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","sourcesContent":["\n// A constant empty array (frozen if the JS engine supports it).\nvar _emptyArray = Object.freeze ? Object.freeze([]) : [];\n\n// `[new] Blaze._DOMRange([nodeAndRangeArray])`\n//\n// A DOMRange consists of an array of consecutive nodes and DOMRanges,\n// which may be replaced at any time with a new array.  If the DOMRange\n// has been attached to the DOM at some location, then updating\n// the array will cause the DOM to be updated at that location.\nBlaze._DOMRange = function (nodeAndRangeArray) {\n  if (! (this instanceof DOMRange))\n    // called without `new`\n    return new DOMRange(nodeAndRangeArray);\n\n  var members = (nodeAndRangeArray || _emptyArray);\n  if (! (members && (typeof members.length) === 'number'))\n    throw new Error(\"Expected array\");\n\n  for (var i = 0; i < members.length; i++)\n    this._memberIn(members[i]);\n\n  this.members = members;\n  this.emptyRangePlaceholder = null;\n  this.attached = false;\n  this.parentElement = null;\n  this.parentRange = null;\n  this.attachedCallbacks = _emptyArray;\n};\nvar DOMRange = Blaze._DOMRange;\n\n// In IE 8, don't use empty text nodes as placeholders\n// in empty DOMRanges, use comment nodes instead.  Using\n// empty text nodes in modern browsers is great because\n// it doesn't clutter the web inspector.  In IE 8, however,\n// it seems to lead in some roundabout way to the OAuth\n// pop-up crashing the browser completely.  In the past,\n// we didn't use empty text nodes on IE 8 because they\n// don't accept JS properties, so just use the same logic\n// even though we don't need to set properties on the\n// placeholder anymore.\nDOMRange._USE_COMMENT_PLACEHOLDERS = (function () {\n  var result = false;\n  var textNode = document.createTextNode(\"\");\n  try {\n    textNode.someProp = true;\n  } catch (e) {\n    // IE 8\n    result = true;\n  }\n  return result;\n})();\n\n// static methods\nDOMRange._insert = function (rangeOrNode, parentElement, nextNode, _isMove) {\n  var m = rangeOrNode;\n  if (m instanceof DOMRange) {\n    m.attach(parentElement, nextNode, _isMove);\n  } else {\n    if (_isMove)\n      DOMRange._moveNodeWithHooks(m, parentElement, nextNode);\n    else\n      DOMRange._insertNodeWithHooks(m, parentElement, nextNode);\n  }\n};\n\nDOMRange._remove = function (rangeOrNode) {\n  var m = rangeOrNode;\n  if (m instanceof DOMRange) {\n    m.detach();\n  } else {\n    DOMRange._removeNodeWithHooks(m);\n  }\n};\n\nDOMRange._removeNodeWithHooks = function (n) {\n  if (! n.parentNode)\n    return;\n  if (n.nodeType === 1 &&\n      n.parentNode._uihooks && n.parentNode._uihooks.removeElement) {\n    n.parentNode._uihooks.removeElement(n);\n  } else {\n    n.parentNode.removeChild(n);\n  }\n};\n\nDOMRange._insertNodeWithHooks = function (n, parent, next) {\n  // `|| null` because IE throws an error if 'next' is undefined\n  next = next || null;\n  if (n.nodeType === 1 &&\n      parent._uihooks && parent._uihooks.insertElement) {\n    parent._uihooks.insertElement(n, next);\n  } else {\n    parent.insertBefore(n, next);\n  }\n};\n\nDOMRange._moveNodeWithHooks = function (n, parent, next) {\n  if (n.parentNode !== parent)\n    return;\n  // `|| null` because IE throws an error if 'next' is undefined\n  next = next || null;\n  if (n.nodeType === 1 &&\n      parent._uihooks && parent._uihooks.moveElement) {\n    parent._uihooks.moveElement(n, next);\n  } else {\n    parent.insertBefore(n, next);\n  }\n};\n\nDOMRange.forElement = function (elem) {\n  if (elem.nodeType !== 1)\n    throw new Error(\"Expected element, found: \" + elem);\n  var range = null;\n  while (elem && ! range) {\n    range = (elem.$blaze_range || null);\n    if (! range)\n      elem = elem.parentNode;\n  }\n  return range;\n};\n\nDOMRange.prototype.attach = function (parentElement, nextNode, _isMove, _isReplace) {\n  // This method is called to insert the DOMRange into the DOM for\n  // the first time, but it's also used internally when\n  // updating the DOM.\n  //\n  // If _isMove is true, move this attached range to a different\n  // location under the same parentElement.\n  if (_isMove || _isReplace) {\n    if (! (this.parentElement === parentElement &&\n           this.attached))\n      throw new Error(\"Can only move or replace an attached DOMRange, and only under the same parent element\");\n  }\n\n  var members = this.members;\n  if (members.length) {\n    this.emptyRangePlaceholder = null;\n    for (var i = 0; i < members.length; i++) {\n      DOMRange._insert(members[i], parentElement, nextNode, _isMove);\n    }\n  } else {\n    var placeholder = (\n      DOMRange._USE_COMMENT_PLACEHOLDERS ?\n        document.createComment(\"\") :\n        document.createTextNode(\"\"));\n    this.emptyRangePlaceholder = placeholder;\n    parentElement.insertBefore(placeholder, nextNode || null);\n  }\n  this.attached = true;\n  this.parentElement = parentElement;\n\n  if (! (_isMove || _isReplace)) {\n    for(var i = 0; i < this.attachedCallbacks.length; i++) {\n      var obj = this.attachedCallbacks[i];\n      obj.attached && obj.attached(this, parentElement);\n    }\n  }\n};\n\nDOMRange.prototype.setMembers = function (newNodeAndRangeArray) {\n  var newMembers = newNodeAndRangeArray;\n  if (! (newMembers && (typeof newMembers.length) === 'number'))\n    throw new Error(\"Expected array\");\n\n  var oldMembers = this.members;\n\n  for (var i = 0; i < oldMembers.length; i++)\n    this._memberOut(oldMembers[i]);\n  for (var i = 0; i < newMembers.length; i++)\n    this._memberIn(newMembers[i]);\n\n  if (! this.attached) {\n    this.members = newMembers;\n  } else {\n    // don't do anything if we're going from empty to empty\n    if (newMembers.length || oldMembers.length) {\n      // detach the old members and insert the new members\n      var nextNode = this.lastNode().nextSibling;\n      var parentElement = this.parentElement;\n      // Use detach/attach, but don't fire attached/detached hooks\n      this.detach(true /*_isReplace*/);\n      this.members = newMembers;\n      this.attach(parentElement, nextNode, false, true /*_isReplace*/);\n    }\n  }\n};\n\nDOMRange.prototype.firstNode = function () {\n  if (! this.attached)\n    throw new Error(\"Must be attached\");\n\n  if (! this.members.length)\n    return this.emptyRangePlaceholder;\n\n  var m = this.members[0];\n  return (m instanceof DOMRange) ? m.firstNode() : m;\n};\n\nDOMRange.prototype.lastNode = function () {\n  if (! this.attached)\n    throw new Error(\"Must be attached\");\n\n  if (! this.members.length)\n    return this.emptyRangePlaceholder;\n\n  var m = this.members[this.members.length - 1];\n  return (m instanceof DOMRange) ? m.lastNode() : m;\n};\n\nDOMRange.prototype.detach = function (_isReplace) {\n  if (! this.attached)\n    throw new Error(\"Must be attached\");\n\n  var oldParentElement = this.parentElement;\n  var members = this.members;\n  if (members.length) {\n    for (var i = 0; i < members.length; i++) {\n      DOMRange._remove(members[i]);\n    }\n  } else {\n    var placeholder = this.emptyRangePlaceholder;\n    this.parentElement.removeChild(placeholder);\n    this.emptyRangePlaceholder = null;\n  }\n\n  if (! _isReplace) {\n    this.attached = false;\n    this.parentElement = null;\n\n    for(var i = 0; i < this.attachedCallbacks.length; i++) {\n      var obj = this.attachedCallbacks[i];\n      obj.detached && obj.detached(this, oldParentElement);\n    }\n  }\n};\n\nDOMRange.prototype.addMember = function (newMember, atIndex, _isMove) {\n  var members = this.members;\n  if (! (atIndex >= 0 && atIndex <= members.length))\n    throw new Error(\"Bad index in range.addMember: \" + atIndex);\n\n  if (! _isMove)\n    this._memberIn(newMember);\n\n  if (! this.attached) {\n    // currently detached; just updated members\n    members.splice(atIndex, 0, newMember);\n  } else if (members.length === 0) {\n    // empty; use the empty-to-nonempty handling of setMembers\n    this.setMembers([newMember]);\n  } else {\n    var nextNode;\n    if (atIndex === members.length) {\n      // insert at end\n      nextNode = this.lastNode().nextSibling;\n    } else {\n      var m = members[atIndex];\n      nextNode = (m instanceof DOMRange) ? m.firstNode() : m;\n    }\n    members.splice(atIndex, 0, newMember);\n    DOMRange._insert(newMember, this.parentElement, nextNode, _isMove);\n  }\n};\n\nDOMRange.prototype.removeMember = function (atIndex, _isMove) {\n  var members = this.members;\n  if (! (atIndex >= 0 && atIndex < members.length))\n    throw new Error(\"Bad index in range.removeMember: \" + atIndex);\n\n  if (_isMove) {\n    members.splice(atIndex, 1);\n  } else {\n    var oldMember = members[atIndex];\n    this._memberOut(oldMember);\n\n    if (members.length === 1) {\n      // becoming empty; use the logic in setMembers\n      this.setMembers(_emptyArray);\n    } else {\n      members.splice(atIndex, 1);\n      if (this.attached)\n        DOMRange._remove(oldMember);\n    }\n  }\n};\n\nDOMRange.prototype.moveMember = function (oldIndex, newIndex) {\n  var member = this.members[oldIndex];\n  this.removeMember(oldIndex, true /*_isMove*/);\n  this.addMember(member, newIndex, true /*_isMove*/);\n};\n\nDOMRange.prototype.getMember = function (atIndex) {\n  var members = this.members;\n  if (! (atIndex >= 0 && atIndex < members.length))\n    throw new Error(\"Bad index in range.getMember: \" + atIndex);\n  return this.members[atIndex];\n};\n\nDOMRange.prototype._memberIn = function (m) {\n  if (m instanceof DOMRange)\n    m.parentRange = this;\n  else if (m.nodeType === 1) // DOM Element\n    m.$blaze_range = this;\n};\n\nDOMRange._destroy = function (m, _skipNodes) {\n  if (m instanceof DOMRange) {\n    if (m.view)\n      Blaze._destroyView(m.view, _skipNodes);\n  } else if ((! _skipNodes) && m.nodeType === 1) {\n    // DOM Element\n    if (m.$blaze_range) {\n      Blaze._destroyNode(m);\n      m.$blaze_range = null;\n    }\n  }\n};\n\nDOMRange.prototype._memberOut = DOMRange._destroy;\n\n// Tear down, but don't remove, the members.  Used when chunks\n// of DOM are being torn down or replaced.\nDOMRange.prototype.destroyMembers = function (_skipNodes) {\n  var members = this.members;\n  for (var i = 0; i < members.length; i++)\n    this._memberOut(members[i], _skipNodes);\n};\n\nDOMRange.prototype.destroy = function (_skipNodes) {\n  DOMRange._destroy(this, _skipNodes);\n};\n\nDOMRange.prototype.containsElement = function (elem) {\n  if (! this.attached)\n    throw new Error(\"Must be attached\");\n\n  // An element is contained in this DOMRange if it's possible to\n  // reach it by walking parent pointers, first through the DOM and\n  // then parentRange pointers.  In other words, the element or some\n  // ancestor of it is at our level of the DOM (a child of our\n  // parentElement), and this element is one of our members or\n  // is a member of a descendant Range.\n\n  // First check that elem is a descendant of this.parentElement,\n  // according to the DOM.\n  if (! Blaze._elementContains(this.parentElement, elem))\n    return false;\n\n  // If elem is not an immediate child of this.parentElement,\n  // walk up to its ancestor that is.\n  while (elem.parentNode !== this.parentElement)\n    elem = elem.parentNode;\n\n  var range = elem.$blaze_range;\n  while (range && range !== this)\n    range = range.parentRange;\n\n  return range === this;\n};\n\nDOMRange.prototype.containsRange = function (range) {\n  if (! this.attached)\n    throw new Error(\"Must be attached\");\n\n  if (! range.attached)\n    return false;\n\n  // A DOMRange is contained in this DOMRange if it's possible\n  // to reach this range by following parent pointers.  If the\n  // DOMRange has the same parentElement, then it should be\n  // a member, or a member of a member etc.  Otherwise, we must\n  // contain its parentElement.\n\n  if (range.parentElement !== this.parentElement)\n    return this.containsElement(range.parentElement);\n\n  if (range === this)\n    return false; // don't contain self\n\n  while (range && range !== this)\n    range = range.parentRange;\n\n  return range === this;\n};\n\nDOMRange.prototype.onAttached = function (attached) {\n  this.onAttachedDetached({ attached: attached });\n};\n\n// callbacks are `attached(range, element)` and\n// `detached(range, element)`, and they may\n// access the `callbacks` object in `this`.\n// The arguments to `detached` are the same\n// range and element that were passed to `attached`.\nDOMRange.prototype.onAttachedDetached = function (callbacks) {\n  if (this.attachedCallbacks === _emptyArray)\n    this.attachedCallbacks = [];\n  this.attachedCallbacks.push(callbacks);\n};\n\nDOMRange.prototype.$ = function (selector) {\n  var self = this;\n\n  var parentNode = this.parentElement;\n  if (! parentNode)\n    throw new Error(\"Can't select in removed DomRange\");\n\n  // Strategy: Find all selector matches under parentNode,\n  // then filter out the ones that aren't in this DomRange\n  // using `DOMRange#containsElement`.  This is\n  // asymptotically slow in the presence of O(N) sibling\n  // content that is under parentNode but not in our range,\n  // so if performance is an issue, the selector should be\n  // run on a child element.\n\n  // Since jQuery can't run selectors on a DocumentFragment,\n  // we don't expect findBySelector to work.\n  if (parentNode.nodeType === 11 /* DocumentFragment */)\n    throw new Error(\"Can't use $ on an offscreen range\");\n\n  var results = Blaze._DOMBackend.findBySelector(selector, parentNode);\n\n  // We don't assume `results` has jQuery API; a plain array\n  // should do just as well.  However, if we do have a jQuery\n  // array, we want to end up with one also, so we use\n  // `.filter`.\n\n  // Function that selects only elements that are actually\n  // in this DomRange, rather than simply descending from\n  // `parentNode`.\n  var filterFunc = function (elem) {\n    // handle jQuery's arguments to filter, where the node\n    // is in `this` and the index is the first argument.\n    if (typeof elem === 'number')\n      elem = this;\n\n    return self.containsElement(elem);\n  };\n\n  if (! results.filter) {\n    // not a jQuery array, and not a browser with\n    // Array.prototype.filter (e.g. IE <9)\n    var newResults = [];\n    for (var i = 0; i < results.length; i++) {\n      var x = results[i];\n      if (filterFunc(x))\n        newResults.push(x);\n    }\n    results = newResults;\n  } else {\n    // `results.filter` is either jQuery's or ECMAScript's `filter`\n    results = results.filter(filterFunc);\n  }\n\n  return results;\n};\n\n// Returns true if element a contains node b and is not node b.\n//\n// The restriction that `a` be an element (not a document fragment,\n// say) is based on what's easy to implement cross-browser.\nBlaze._elementContains = function (a, b) {\n  if (a.nodeType !== 1) // ELEMENT\n    return false;\n  if (a === b)\n    return false;\n\n  if (a.compareDocumentPosition) {\n    return a.compareDocumentPosition(b) & 0x10;\n  } else {\n    // Should be only old IE and maybe other old browsers here.\n    // Modern Safari has both functions but seems to get contains() wrong.\n    // IE can't handle b being a text node.  We work around this\n    // by doing a direct parent test now.\n    b = b.parentNode;\n    if (! (b && b.nodeType === 1)) // ELEMENT\n      return false;\n    if (a === b)\n      return true;\n\n    return a.contains(b);\n  }\n};\n"]},"sourceType":"module","hash":"9fad8d5bce1979281bf7c47d708d12c3f6fa8aad"}
