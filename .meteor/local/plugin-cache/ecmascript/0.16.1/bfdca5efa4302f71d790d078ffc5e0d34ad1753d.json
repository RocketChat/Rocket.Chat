{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/packages/check/match.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser.legacy"},"sourceFileName":"packages/check/match.js","filename":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/packages/check/match.js","targets":{"android":"95.0.0","chrome":"95.0.0","edge":"95.0.0","firefox":"78.0.0","ie":"10.0.0","ios":"15.0.0","opera":"81.0.0","safari":"15.1.0","samsung":"14.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat","root":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":true,"enforceStrictMode":false,"dynamicImport":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.16.5","helpers":true,"useESModules":false,"corejs":false}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"base$0$3","visitor":{"FunctionExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$4","visitor":{"ForInStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-arrow-functions","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-block-scoped-functions","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-block-scoping","visitor":{"VariableDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"_exploded":true,"BlockStatement":{"enter":[null]},"SwitchStatement":{"enter":[null]},"Program":{"enter":[null]},"_verified":true,"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-classes","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-computed-properties","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-destructuring","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-object-super","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-shorthand-properties","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-spread","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-sticky-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-typeof-symbol","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"StaticBlock":{"enter":[null]},"TSModuleBlock":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectPattern":{"enter":[null]}},"options":{}},{"key":"transform-unicode-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-property-literals","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"regenerator-transform","visitor":{"_exploded":true,"_verified":true,"ObjectMethod":{"enter":[null],"exit":[null]},"ClassMethod":{"enter":[null],"exit":[null]},"ClassPrivateMethod":{"enter":[null],"exit":[null]},"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]}},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/packages/check/match.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/check/match.js"}},"code":"var _toConsumableArray;\n\nmodule.link(\"@babel/runtime/helpers/toConsumableArray\", {\n  default: function (v) {\n    _toConsumableArray = v;\n  }\n}, 0);\n\nvar _typeof;\n\nmodule.link(\"@babel/runtime/helpers/typeof\", {\n  default: function (v) {\n    _typeof = v;\n  }\n}, 1);\nmodule.export({\n  check: function () {\n    return check;\n  },\n  Match: function () {\n    return Match;\n  }\n});\nvar isPlainObject;\nmodule.link(\"./isPlainObject\", {\n  isPlainObject: function (v) {\n    isPlainObject = v;\n  }\n}, 0);\n// Things we explicitly do NOT support:\n//    - heterogenous arrays\nvar currentArgumentChecker = new Meteor.EnvironmentVariable();\nvar hasOwn = Object.prototype.hasOwnProperty;\n/**\n * @summary Check that a value matches a [pattern](#matchpatterns).\n * If the value does not match the pattern, throw a `Match.Error`.\n *\n * Particularly useful to assert that arguments to a function have the right\n * types and structure.\n * @locus Anywhere\n * @param {Any} value The value to check\n * @param {MatchPattern} pattern The pattern to match `value` against\n */\n\nfunction check(value, pattern) {\n  // Record that check got called, if somebody cared.\n  //\n  // We use getOrNullIfOutsideFiber so that it's OK to call check()\n  // from non-Fiber server contexts; the downside is that if you forget to\n  // bindEnvironment on some random callback in your method/publisher,\n  // it might not find the argumentChecker and you'll get an error about\n  // not checking an argument that it looks like you're checking (instead\n  // of just getting a \"Node code must run in a Fiber\" error).\n  var argChecker = currentArgumentChecker.getOrNullIfOutsideFiber();\n\n  if (argChecker) {\n    argChecker.checking(value);\n  }\n\n  var result = testSubtree(value, pattern);\n\n  if (result) {\n    var err = new Match.Error(result.message);\n\n    if (result.path) {\n      err.message += \" in field \" + result.path;\n      err.path = result.path;\n    }\n\n    throw err;\n  }\n}\n\n;\n/**\n * @namespace Match\n * @summary The namespace for all Match types and methods.\n */\n\nvar Match = {\n  Optional: function (pattern) {\n    return new Optional(pattern);\n  },\n  Maybe: function (pattern) {\n    return new Maybe(pattern);\n  },\n  OneOf: function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return new OneOf(args);\n  },\n  Any: ['__any__'],\n  Where: function (condition) {\n    return new Where(condition);\n  },\n  ObjectIncluding: function (pattern) {\n    return new ObjectIncluding(pattern);\n  },\n  ObjectWithValues: function (pattern) {\n    return new ObjectWithValues(pattern);\n  },\n  // Matches only signed 32-bit integers\n  Integer: ['__integer__'],\n  // XXX matchers should know how to describe themselves for errors\n  Error: Meteor.makeErrorType('Match.Error', function (msg) {\n    this.message = \"Match error: \" + msg; // The path of the value that failed to match. Initially empty, this gets\n    // populated by catching and rethrowing the exception as it goes back up the\n    // stack.\n    // E.g.: \"vals[3].entity.created\"\n\n    this.path = ''; // If this gets sent over DDP, don't give full internal details but at least\n    // provide something better than 500 Internal server error.\n\n    this.sanitizedError = new Meteor.Error(400, 'Match failed');\n  }),\n  // Tests to see if value matches pattern. Unlike check, it merely returns true\n  // or false (unless an error other than Match.Error was thrown). It does not\n  // interact with _failIfArgumentsAreNotAllChecked.\n  // XXX maybe also implement a Match.match which returns more information about\n  //     failures but without using exception handling or doing what check()\n  //     does with _failIfArgumentsAreNotAllChecked and Meteor.Error conversion\n\n  /**\n   * @summary Returns true if the value matches the pattern.\n   * @locus Anywhere\n   * @param {Any} value The value to check\n   * @param {MatchPattern} pattern The pattern to match `value` against\n   */\n  test: function (value, pattern) {\n    return !testSubtree(value, pattern);\n  },\n  // Runs `f.apply(context, args)`. If check() is not called on every element of\n  // `args` (either directly or in the first level of an array), throws an error\n  // (using `description` in the message).\n  _failIfArgumentsAreNotAllChecked: function (f, context, args, description) {\n    var argChecker = new ArgumentChecker(args, description);\n    var result = currentArgumentChecker.withValue(argChecker, function () {\n      return f.apply(context, args);\n    }); // If f didn't itself throw, make sure it checked all of its arguments.\n\n    argChecker.throwUnlessAllArgumentsHaveBeenChecked();\n    return result;\n  }\n};\n\nvar Optional = function () {\n  function Optional(pattern) {\n    this.pattern = pattern;\n  }\n\n  return Optional;\n}();\n\nvar Maybe = function () {\n  function Maybe(pattern) {\n    this.pattern = pattern;\n  }\n\n  return Maybe;\n}();\n\nvar OneOf = function () {\n  function OneOf(choices) {\n    if (!choices || choices.length === 0) {\n      throw new Error('Must provide at least one choice to Match.OneOf');\n    }\n\n    this.choices = choices;\n  }\n\n  return OneOf;\n}();\n\nvar Where = function () {\n  function Where(condition) {\n    this.condition = condition;\n  }\n\n  return Where;\n}();\n\nvar ObjectIncluding = function () {\n  function ObjectIncluding(pattern) {\n    this.pattern = pattern;\n  }\n\n  return ObjectIncluding;\n}();\n\nvar ObjectWithValues = function () {\n  function ObjectWithValues(pattern) {\n    this.pattern = pattern;\n  }\n\n  return ObjectWithValues;\n}();\n\nvar stringForErrorMessage = function (value) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (value === null) {\n    return 'null';\n  }\n\n  if (options.onlyShowType) {\n    return _typeof(value);\n  } // Your average non-object things.  Saves from doing the try/catch below for.\n\n\n  if (_typeof(value) !== 'object') {\n    return EJSON.stringify(value);\n  }\n\n  try {\n    // Find objects with circular references since EJSON doesn't support them yet (Issue #4778 + Unaccepted PR)\n    // If the native stringify is going to choke, EJSON.stringify is going to choke too.\n    JSON.stringify(value);\n  } catch (stringifyError) {\n    if (stringifyError.name === 'TypeError') {\n      return _typeof(value);\n    }\n  }\n\n  return EJSON.stringify(value);\n};\n\nvar typeofChecks = [[String, 'string'], [Number, 'number'], [Boolean, 'boolean'], // While we don't allow undefined/function in EJSON, this is good for optional\n// arguments with OneOf.\n[Function, 'function'], [undefined, 'undefined']]; // Return `false` if it matches. Otherwise, return an object with a `message` and a `path` field.\n\nvar testSubtree = function (value, pattern) {\n  // Match anything!\n  if (pattern === Match.Any) {\n    return false;\n  } // Basic atomic types.\n  // Do not match boxed objects (e.g. String, Boolean)\n\n\n  for (var i = 0; i < typeofChecks.length; ++i) {\n    if (pattern === typeofChecks[i][0]) {\n      if (_typeof(value) === typeofChecks[i][1]) {\n        return false;\n      }\n\n      return {\n        message: \"Expected \" + typeofChecks[i][1] + \", got \" + stringForErrorMessage(value, {\n          onlyShowType: true\n        }),\n        path: ''\n      };\n    }\n  }\n\n  if (pattern === null) {\n    if (value === null) {\n      return false;\n    }\n\n    return {\n      message: \"Expected null, got \" + stringForErrorMessage(value),\n      path: ''\n    };\n  } // Strings, numbers, and booleans match literally. Goes well with Match.OneOf.\n\n\n  if (typeof pattern === 'string' || typeof pattern === 'number' || typeof pattern === 'boolean') {\n    if (value === pattern) {\n      return false;\n    }\n\n    return {\n      message: \"Expected \" + pattern + \", got \" + stringForErrorMessage(value),\n      path: ''\n    };\n  } // Match.Integer is special type encoded with array\n\n\n  if (pattern === Match.Integer) {\n    // There is no consistent and reliable way to check if variable is a 64-bit\n    // integer. One of the popular solutions is to get reminder of division by 1\n    // but this method fails on really large floats with big precision.\n    // E.g.: 1.348192308491824e+23 % 1 === 0 in V8\n    // Bitwise operators work consistantly but always cast variable to 32-bit\n    // signed integer according to JavaScript specs.\n    if (typeof value === 'number' && (value | 0) === value) {\n      return false;\n    }\n\n    return {\n      message: \"Expected Integer, got \" + stringForErrorMessage(value),\n      path: ''\n    };\n  } // 'Object' is shorthand for Match.ObjectIncluding({});\n\n\n  if (pattern === Object) {\n    pattern = Match.ObjectIncluding({});\n  } // Array (checked AFTER Any, which is implemented as an Array).\n\n\n  if (pattern instanceof Array) {\n    if (pattern.length !== 1) {\n      return {\n        message: \"Bad pattern: arrays must have one type element \" + stringForErrorMessage(pattern),\n        path: ''\n      };\n    }\n\n    if (!Array.isArray(value) && !isArguments(value)) {\n      return {\n        message: \"Expected array, got \" + stringForErrorMessage(value),\n        path: ''\n      };\n    }\n\n    for (var _i = 0, length = value.length; _i < length; _i++) {\n      var result = testSubtree(value[_i], pattern[0]);\n\n      if (result) {\n        result.path = _prependPath(_i, result.path);\n        return result;\n      }\n    }\n\n    return false;\n  } // Arbitrary validation checks. The condition can return false or throw a\n  // Match.Error (ie, it can internally use check()) to fail.\n\n\n  if (pattern instanceof Where) {\n    var _result;\n\n    try {\n      _result = pattern.condition(value);\n    } catch (err) {\n      if (!(err instanceof Match.Error)) {\n        throw err;\n      }\n\n      return {\n        message: err.message,\n        path: err.path\n      };\n    }\n\n    if (_result) {\n      return false;\n    } // XXX this error is terrible\n\n\n    return {\n      message: 'Failed Match.Where validation',\n      path: ''\n    };\n  }\n\n  if (pattern instanceof Maybe) {\n    pattern = Match.OneOf(undefined, null, pattern.pattern);\n  } else if (pattern instanceof Optional) {\n    pattern = Match.OneOf(undefined, pattern.pattern);\n  }\n\n  if (pattern instanceof OneOf) {\n    for (var _i2 = 0; _i2 < pattern.choices.length; ++_i2) {\n      var _result2 = testSubtree(value, pattern.choices[_i2]);\n\n      if (!_result2) {\n        // No error? Yay, return.\n        return false;\n      } // Match errors just mean try another choice.\n\n    } // XXX this error is terrible\n\n\n    return {\n      message: 'Failed Match.OneOf, Match.Maybe or Match.Optional validation',\n      path: ''\n    };\n  } // A function that isn't something we special-case is assumed to be a\n  // constructor.\n\n\n  if (pattern instanceof Function) {\n    if (value instanceof pattern) {\n      return false;\n    }\n\n    return {\n      message: \"Expected \" + (pattern.name || 'particular constructor'),\n      path: ''\n    };\n  }\n\n  var unknownKeysAllowed = false;\n  var unknownKeyPattern;\n\n  if (pattern instanceof ObjectIncluding) {\n    unknownKeysAllowed = true;\n    pattern = pattern.pattern;\n  }\n\n  if (pattern instanceof ObjectWithValues) {\n    unknownKeysAllowed = true;\n    unknownKeyPattern = [pattern.pattern];\n    pattern = {}; // no required keys\n  }\n\n  if (_typeof(pattern) !== 'object') {\n    return {\n      message: 'Bad pattern: unknown pattern type',\n      path: ''\n    };\n  } // An object, with required and optional keys. Note that this does NOT do\n  // structural matches against objects of special types that happen to match\n  // the pattern: this really needs to be a plain old {Object}!\n\n\n  if (_typeof(value) !== 'object') {\n    return {\n      message: \"Expected object, got \" + _typeof(value),\n      path: ''\n    };\n  }\n\n  if (value === null) {\n    return {\n      message: \"Expected object, got null\",\n      path: ''\n    };\n  }\n\n  if (!isPlainObject(value)) {\n    return {\n      message: \"Expected plain object\",\n      path: ''\n    };\n  }\n\n  var requiredPatterns = Object.create(null);\n  var optionalPatterns = Object.create(null);\n  Object.keys(pattern).forEach(function (key) {\n    var subPattern = pattern[key];\n\n    if (subPattern instanceof Optional || subPattern instanceof Maybe) {\n      optionalPatterns[key] = subPattern.pattern;\n    } else {\n      requiredPatterns[key] = subPattern;\n    }\n  });\n\n  for (var key in meteorBabelHelpers.sanitizeForInObject(Object(value))) {\n    var subValue = value[key];\n\n    if (hasOwn.call(requiredPatterns, key)) {\n      var _result3 = testSubtree(subValue, requiredPatterns[key]);\n\n      if (_result3) {\n        _result3.path = _prependPath(key, _result3.path);\n        return _result3;\n      }\n\n      delete requiredPatterns[key];\n    } else if (hasOwn.call(optionalPatterns, key)) {\n      var _result4 = testSubtree(subValue, optionalPatterns[key]);\n\n      if (_result4) {\n        _result4.path = _prependPath(key, _result4.path);\n        return _result4;\n      }\n    } else {\n      if (!unknownKeysAllowed) {\n        return {\n          message: 'Unknown key',\n          path: key\n        };\n      }\n\n      if (unknownKeyPattern) {\n        var _result5 = testSubtree(subValue, unknownKeyPattern[0]);\n\n        if (_result5) {\n          _result5.path = _prependPath(key, _result5.path);\n          return _result5;\n        }\n      }\n    }\n  }\n\n  var keys = Object.keys(requiredPatterns);\n\n  if (keys.length) {\n    return {\n      message: \"Missing key '\" + keys[0] + \"'\",\n      path: ''\n    };\n  }\n};\n\nvar ArgumentChecker = /*#__PURE__*/function () {\n  function ArgumentChecker(args, description) {\n    // Make a SHALLOW copy of the arguments. (We'll be doing identity checks\n    // against its contents.)\n    this.args = _toConsumableArray(args); // Since the common case will be to check arguments in order, and we splice\n    // out arguments when we check them, make it so we splice out from the end\n    // rather than the beginning.\n\n    this.args.reverse();\n    this.description = description;\n  }\n\n  var _proto = ArgumentChecker.prototype;\n\n  _proto.checking = function () {\n    function checking(value) {\n      if (this._checkingOneValue(value)) {\n        return;\n      } // Allow check(arguments, [String]) or check(arguments.slice(1), [String])\n      // or check([foo, bar], [String]) to count... but only if value wasn't\n      // itself an argument.\n\n\n      if (Array.isArray(value) || isArguments(value)) {\n        Array.prototype.forEach.call(value, this._checkingOneValue.bind(this));\n      }\n    }\n\n    return checking;\n  }();\n\n  _proto._checkingOneValue = function () {\n    function _checkingOneValue(value) {\n      for (var i = 0; i < this.args.length; ++i) {\n        // Is this value one of the arguments? (This can have a false positive if\n        // the argument is an interned primitive, but it's still a good enough\n        // check.)\n        // (NaN is not === to itself, so we have to check specially.)\n        if (value === this.args[i] || Number.isNaN(value) && Number.isNaN(this.args[i])) {\n          this.args.splice(i, 1);\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    return _checkingOneValue;\n  }();\n\n  _proto.throwUnlessAllArgumentsHaveBeenChecked = function () {\n    function throwUnlessAllArgumentsHaveBeenChecked() {\n      if (this.args.length > 0) throw new Error(\"Did not check() all arguments during \" + this.description);\n    }\n\n    return throwUnlessAllArgumentsHaveBeenChecked;\n  }();\n\n  return ArgumentChecker;\n}();\n\nvar _jsKeywords = ['do', 'if', 'in', 'for', 'let', 'new', 'try', 'var', 'case', 'else', 'enum', 'eval', 'false', 'null', 'this', 'true', 'void', 'with', 'break', 'catch', 'class', 'const', 'super', 'throw', 'while', 'yield', 'delete', 'export', 'import', 'public', 'return', 'static', 'switch', 'typeof', 'default', 'extends', 'finally', 'package', 'private', 'continue', 'debugger', 'function', 'arguments', 'interface', 'protected', 'implements', 'instanceof']; // Assumes the base of path is already escaped properly\n// returns key + base\n\nvar _prependPath = function (key, base) {\n  if (typeof key === 'number' || key.match(/^[0-9]+$/)) {\n    key = \"[\" + key + \"]\";\n  } else if (!key.match(/^[a-z_$][0-9a-z_$]*$/i) || _jsKeywords.indexOf(key) >= 0) {\n    key = JSON.stringify([key]);\n  }\n\n  if (base && base[0] !== '[') {\n    return key + \".\" + base;\n  }\n\n  return key + base;\n};\n\nvar isObject = function (value) {\n  return _typeof(value) === 'object' && value !== null;\n};\n\nvar baseIsArguments = function (item) {\n  return isObject(item) && Object.prototype.toString.call(item) === '[object Arguments]';\n};\n\nvar isArguments = baseIsArguments(function () {\n  return arguments;\n}()) ? baseIsArguments : function (value) {\n  return isObject(value) && typeof value.callee === 'function';\n};","map":{"version":3,"sources":["packages/check/match.js"],"names":["_toConsumableArray","module","link","default","v","_typeof","export","check","Match","isPlainObject","currentArgumentChecker","Meteor","EnvironmentVariable","hasOwn","Object","prototype","hasOwnProperty","value","pattern","argChecker","getOrNullIfOutsideFiber","checking","result","testSubtree","err","Error","message","path","Optional","Maybe","OneOf","args","Any","Where","condition","ObjectIncluding","ObjectWithValues","Integer","makeErrorType","msg","sanitizedError","test","_failIfArgumentsAreNotAllChecked","f","context","description","ArgumentChecker","withValue","apply","throwUnlessAllArgumentsHaveBeenChecked","choices","length","stringForErrorMessage","options","onlyShowType","EJSON","stringify","JSON","stringifyError","name","typeofChecks","String","Number","Boolean","Function","undefined","i","Array","isArray","isArguments","_prependPath","unknownKeysAllowed","unknownKeyPattern","requiredPatterns","create","optionalPatterns","keys","forEach","key","subPattern","subValue","call","reverse","_checkingOneValue","bind","isNaN","splice","_jsKeywords","base","match","indexOf","isObject","baseIsArguments","item","toString","arguments","callee"],"mappings":"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","sourcesContent":["// XXX docs\nimport { isPlainObject } from './isPlainObject';\n\n// Things we explicitly do NOT support:\n//    - heterogenous arrays\n\nconst currentArgumentChecker = new Meteor.EnvironmentVariable;\nconst hasOwn = Object.prototype.hasOwnProperty;\n\n/**\n * @summary Check that a value matches a [pattern](#matchpatterns).\n * If the value does not match the pattern, throw a `Match.Error`.\n *\n * Particularly useful to assert that arguments to a function have the right\n * types and structure.\n * @locus Anywhere\n * @param {Any} value The value to check\n * @param {MatchPattern} pattern The pattern to match `value` against\n */\nexport function check(value, pattern) {\n  // Record that check got called, if somebody cared.\n  //\n  // We use getOrNullIfOutsideFiber so that it's OK to call check()\n  // from non-Fiber server contexts; the downside is that if you forget to\n  // bindEnvironment on some random callback in your method/publisher,\n  // it might not find the argumentChecker and you'll get an error about\n  // not checking an argument that it looks like you're checking (instead\n  // of just getting a \"Node code must run in a Fiber\" error).\n  const argChecker = currentArgumentChecker.getOrNullIfOutsideFiber();\n  if (argChecker) {\n    argChecker.checking(value);\n  }\n\n  const result = testSubtree(value, pattern);\n  if (result) {\n    const err = new Match.Error(result.message);\n    if (result.path) {\n      err.message += ` in field ${result.path}`;\n      err.path = result.path;\n    }\n\n    throw err;\n  }\n};\n\n/**\n * @namespace Match\n * @summary The namespace for all Match types and methods.\n */\nexport const Match = {\n  Optional: function(pattern) {\n    return new Optional(pattern);\n  },\n\n  Maybe: function(pattern) {\n    return new Maybe(pattern);\n  },\n\n  OneOf: function(...args) {\n    return new OneOf(args);\n  },\n\n  Any: ['__any__'],\n  Where: function(condition) {\n    return new Where(condition);\n  },\n\n  ObjectIncluding: function(pattern) {\n    return new ObjectIncluding(pattern)\n  },\n\n  ObjectWithValues: function(pattern) {\n    return new ObjectWithValues(pattern);\n  },\n\n  // Matches only signed 32-bit integers\n  Integer: ['__integer__'],\n\n  // XXX matchers should know how to describe themselves for errors\n  Error: Meteor.makeErrorType('Match.Error', function (msg) {\n    this.message = `Match error: ${msg}`;\n\n    // The path of the value that failed to match. Initially empty, this gets\n    // populated by catching and rethrowing the exception as it goes back up the\n    // stack.\n    // E.g.: \"vals[3].entity.created\"\n    this.path = '';\n\n    // If this gets sent over DDP, don't give full internal details but at least\n    // provide something better than 500 Internal server error.\n    this.sanitizedError = new Meteor.Error(400, 'Match failed');\n  }),\n\n  // Tests to see if value matches pattern. Unlike check, it merely returns true\n  // or false (unless an error other than Match.Error was thrown). It does not\n  // interact with _failIfArgumentsAreNotAllChecked.\n  // XXX maybe also implement a Match.match which returns more information about\n  //     failures but without using exception handling or doing what check()\n  //     does with _failIfArgumentsAreNotAllChecked and Meteor.Error conversion\n\n  /**\n   * @summary Returns true if the value matches the pattern.\n   * @locus Anywhere\n   * @param {Any} value The value to check\n   * @param {MatchPattern} pattern The pattern to match `value` against\n   */\n  test(value, pattern) {\n    return !testSubtree(value, pattern);\n  },\n\n  // Runs `f.apply(context, args)`. If check() is not called on every element of\n  // `args` (either directly or in the first level of an array), throws an error\n  // (using `description` in the message).\n  _failIfArgumentsAreNotAllChecked(f, context, args, description) {\n    const argChecker = new ArgumentChecker(args, description);\n    const result = currentArgumentChecker.withValue(\n      argChecker, \n      () => f.apply(context, args)\n    );\n\n    // If f didn't itself throw, make sure it checked all of its arguments.\n    argChecker.throwUnlessAllArgumentsHaveBeenChecked();\n    return result;\n  }\n};\n\nclass Optional {\n  constructor(pattern) {\n    this.pattern = pattern;\n  }\n}\n\nclass Maybe {\n  constructor(pattern) {\n    this.pattern = pattern;\n  }\n}\n\nclass OneOf {\n  constructor(choices) {\n    if (!choices || choices.length === 0) {\n      throw new Error('Must provide at least one choice to Match.OneOf');\n    }\n\n    this.choices = choices;\n  }\n}\n\nclass Where {\n  constructor(condition) {\n    this.condition = condition;\n  }\n}\n\nclass ObjectIncluding {\n  constructor(pattern) {\n    this.pattern = pattern;\n  }\n}\n\nclass ObjectWithValues {\n  constructor(pattern) {\n    this.pattern = pattern;\n  }\n}\n\nconst stringForErrorMessage = (value, options = {}) => {\n  if ( value === null ) {\n    return 'null';\n  }\n\n  if ( options.onlyShowType ) {\n    return typeof value;\n  }\n\n  // Your average non-object things.  Saves from doing the try/catch below for.\n  if ( typeof value !== 'object' ) {\n    return EJSON.stringify(value)\n  }\n\n  try {\n\n    // Find objects with circular references since EJSON doesn't support them yet (Issue #4778 + Unaccepted PR)\n    // If the native stringify is going to choke, EJSON.stringify is going to choke too.\n    JSON.stringify(value);\n  } catch (stringifyError) {\n    if ( stringifyError.name === 'TypeError' ) {\n      return typeof value;\n    }\n  }\n\n  return EJSON.stringify(value);\n};\n\nconst typeofChecks = [\n  [String, 'string'],\n  [Number, 'number'],\n  [Boolean, 'boolean'],\n\n  // While we don't allow undefined/function in EJSON, this is good for optional\n  // arguments with OneOf.\n  [Function, 'function'],\n  [undefined, 'undefined'],\n];\n\n// Return `false` if it matches. Otherwise, return an object with a `message` and a `path` field.\nconst testSubtree = (value, pattern) => {\n\n  // Match anything!\n  if (pattern === Match.Any) {\n    return false;\n  }\n\n  // Basic atomic types.\n  // Do not match boxed objects (e.g. String, Boolean)\n  for (let i = 0; i < typeofChecks.length; ++i) {\n    if (pattern === typeofChecks[i][0]) {\n      if (typeof value === typeofChecks[i][1]) {\n        return false;\n      }\n\n      return {\n        message: `Expected ${typeofChecks[i][1]}, got ${stringForErrorMessage(value, { onlyShowType: true })}`,\n        path: '',\n      };\n    }\n  }\n\n  if (pattern === null) {\n    if (value === null) {\n      return false;\n    }\n\n    return {\n      message: `Expected null, got ${stringForErrorMessage(value)}`,\n      path: '',\n    };\n  }\n\n  // Strings, numbers, and booleans match literally. Goes well with Match.OneOf.\n  if (typeof pattern === 'string' || typeof pattern === 'number' || typeof pattern === 'boolean') {\n    if (value === pattern) {\n      return false;\n    }\n\n    return {\n      message: `Expected ${pattern}, got ${stringForErrorMessage(value)}`,\n      path: '',\n    };\n  }\n\n  // Match.Integer is special type encoded with array\n  if (pattern === Match.Integer) {\n\n    // There is no consistent and reliable way to check if variable is a 64-bit\n    // integer. One of the popular solutions is to get reminder of division by 1\n    // but this method fails on really large floats with big precision.\n    // E.g.: 1.348192308491824e+23 % 1 === 0 in V8\n    // Bitwise operators work consistantly but always cast variable to 32-bit\n    // signed integer according to JavaScript specs.\n    if (typeof value === 'number' && (value | 0) === value) {\n      return false;\n    }\n    \n    return {\n      message: `Expected Integer, got ${stringForErrorMessage(value)}`,\n      path: '',\n    };\n  }\n\n  // 'Object' is shorthand for Match.ObjectIncluding({});\n  if (pattern === Object) {\n    pattern = Match.ObjectIncluding({});\n  }\n\n  // Array (checked AFTER Any, which is implemented as an Array).\n  if (pattern instanceof Array) {\n    if (pattern.length !== 1) {\n      return {\n        message: `Bad pattern: arrays must have one type element ${stringForErrorMessage(pattern)}`,\n        path: '',\n      };\n    }\n\n    if (!Array.isArray(value) && !isArguments(value)) {\n      return {\n        message: `Expected array, got ${stringForErrorMessage(value)}`,\n        path: '',\n      };\n    }\n\n    for (let i = 0, length = value.length; i < length; i++) {\n      const result = testSubtree(value[i], pattern[0]);\n      if (result) {\n        result.path = _prependPath(i, result.path);\n        return result;\n      }\n    }\n    \n    return false;\n  }\n\n  // Arbitrary validation checks. The condition can return false or throw a\n  // Match.Error (ie, it can internally use check()) to fail.\n  if (pattern instanceof Where) {\n    let result;\n    try {\n      result = pattern.condition(value);\n    } catch (err) {\n      if (!(err instanceof Match.Error)) {\n        throw err;\n      }\n      \n      return {\n        message: err.message,\n        path: err.path\n      };\n    }\n\n    if (result) {\n      return false;\n    }\n\n    // XXX this error is terrible\n    return {\n      message: 'Failed Match.Where validation',\n      path: '',\n    };\n  }\n\n  if (pattern instanceof Maybe) {\n    pattern = Match.OneOf(undefined, null, pattern.pattern);\n  } else if (pattern instanceof Optional) {\n    pattern = Match.OneOf(undefined, pattern.pattern);\n  }\n\n  if (pattern instanceof OneOf) {\n    for (let i = 0; i < pattern.choices.length; ++i) {\n      const result = testSubtree(value, pattern.choices[i]);\n      if (!result) {\n\n        // No error? Yay, return.\n        return false;\n      }\n\n      // Match errors just mean try another choice.\n    }\n\n    // XXX this error is terrible\n    return {\n      message: 'Failed Match.OneOf, Match.Maybe or Match.Optional validation',\n      path: '',\n    };\n  }\n\n  // A function that isn't something we special-case is assumed to be a\n  // constructor.\n  if (pattern instanceof Function) {\n    if (value instanceof pattern) {\n      return false;\n    }\n\n    return {\n      message: `Expected ${pattern.name || 'particular constructor'}`,\n      path: '',\n    };\n  }\n\n  let unknownKeysAllowed = false;\n  let unknownKeyPattern;\n  if (pattern instanceof ObjectIncluding) {\n    unknownKeysAllowed = true;\n    pattern = pattern.pattern;\n  }\n\n  if (pattern instanceof ObjectWithValues) {\n    unknownKeysAllowed = true;\n    unknownKeyPattern = [pattern.pattern];\n    pattern = {};  // no required keys\n  }\n\n  if (typeof pattern !== 'object') {\n    return {\n      message: 'Bad pattern: unknown pattern type',\n      path: '',\n    };\n  }\n\n  // An object, with required and optional keys. Note that this does NOT do\n  // structural matches against objects of special types that happen to match\n  // the pattern: this really needs to be a plain old {Object}!\n  if (typeof value !== 'object') {\n    return {\n      message: `Expected object, got ${typeof value}`,\n      path: '',\n    };\n  }\n\n  if (value === null) {\n    return {\n      message: `Expected object, got null`,\n      path: '',\n    };\n  }\n\n  if (! isPlainObject(value)) {\n    return {\n      message: `Expected plain object`,\n      path: '',\n    };\n  }\n\n  const requiredPatterns = Object.create(null);\n  const optionalPatterns = Object.create(null);\n\n  Object.keys(pattern).forEach(key => {\n    const subPattern = pattern[key];\n    if (subPattern instanceof Optional ||\n        subPattern instanceof Maybe) {\n      optionalPatterns[key] = subPattern.pattern;\n    } else {\n      requiredPatterns[key] = subPattern;\n    }\n  });\n\n  for (let key in Object(value)) {\n    const subValue = value[key];\n    if (hasOwn.call(requiredPatterns, key)) {\n      const result = testSubtree(subValue, requiredPatterns[key]);\n      if (result) {\n        result.path = _prependPath(key, result.path);\n        return result;\n      }\n\n      delete requiredPatterns[key];\n    } else if (hasOwn.call(optionalPatterns, key)) {\n      const result = testSubtree(subValue, optionalPatterns[key]);\n      if (result) {\n        result.path = _prependPath(key, result.path);\n        return result;\n      }\n\n    } else {\n      if (!unknownKeysAllowed) {\n        return {\n          message: 'Unknown key',\n          path: key,\n        };\n      }\n\n      if (unknownKeyPattern) {\n        const result = testSubtree(subValue, unknownKeyPattern[0]);\n        if (result) {\n          result.path = _prependPath(key, result.path);\n          return result;\n        }\n      }\n    }\n  }\n\n  const keys = Object.keys(requiredPatterns);\n  if (keys.length) {\n    return {\n      message: `Missing key '${keys[0]}'`,\n      path: '',\n    };\n  }\n};\n\nclass ArgumentChecker {\n  constructor (args, description) {\n\n    // Make a SHALLOW copy of the arguments. (We'll be doing identity checks\n    // against its contents.)\n    this.args = [...args];\n\n    // Since the common case will be to check arguments in order, and we splice\n    // out arguments when we check them, make it so we splice out from the end\n    // rather than the beginning.\n    this.args.reverse();\n    this.description = description;\n  }\n\n  checking(value) {\n    if (this._checkingOneValue(value)) {\n      return;\n    }\n\n    // Allow check(arguments, [String]) or check(arguments.slice(1), [String])\n    // or check([foo, bar], [String]) to count... but only if value wasn't\n    // itself an argument.\n    if (Array.isArray(value) || isArguments(value)) {\n      Array.prototype.forEach.call(value, this._checkingOneValue.bind(this));\n    }\n  }\n\n  _checkingOneValue(value) {\n    for (let i = 0; i < this.args.length; ++i) {\n\n      // Is this value one of the arguments? (This can have a false positive if\n      // the argument is an interned primitive, but it's still a good enough\n      // check.)\n      // (NaN is not === to itself, so we have to check specially.)\n      if (value === this.args[i] ||\n          (Number.isNaN(value) && Number.isNaN(this.args[i]))) {\n        this.args.splice(i, 1);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  throwUnlessAllArgumentsHaveBeenChecked() {\n    if (this.args.length > 0)\n      throw new Error(`Did not check() all arguments during ${this.description}`);\n  }\n}\n\nconst _jsKeywords = ['do', 'if', 'in', 'for', 'let', 'new', 'try', 'var', 'case',\n  'else', 'enum', 'eval', 'false', 'null', 'this', 'true', 'void', 'with',\n  'break', 'catch', 'class', 'const', 'super', 'throw', 'while', 'yield',\n  'delete', 'export', 'import', 'public', 'return', 'static', 'switch',\n  'typeof', 'default', 'extends', 'finally', 'package', 'private', 'continue',\n  'debugger', 'function', 'arguments', 'interface', 'protected', 'implements',\n  'instanceof'];\n\n// Assumes the base of path is already escaped properly\n// returns key + base\nconst _prependPath = (key, base) => {\n  if ((typeof key) === 'number' || key.match(/^[0-9]+$/)) {\n    key = `[${key}]`;\n  } else if (!key.match(/^[a-z_$][0-9a-z_$]*$/i) ||\n             _jsKeywords.indexOf(key) >= 0) {\n    key = JSON.stringify([key]);\n  }\n\n  if (base && base[0] !== '[') {\n    return `${key}.${base}`;\n  }\n\n  return key + base;\n}\n\nconst isObject = value => typeof value === 'object' && value !== null;\n\nconst baseIsArguments = item =>\n  isObject(item) &&\n  Object.prototype.toString.call(item) === '[object Arguments]';\n\nconst isArguments = baseIsArguments(function() { return arguments; }()) ?\n  baseIsArguments :\n  value => isObject(value) && typeof value.callee === 'function';\n"]},"sourceType":"module","hash":"bfdca5efa4302f71d790d078ffc5e0d34ad1753d"}
