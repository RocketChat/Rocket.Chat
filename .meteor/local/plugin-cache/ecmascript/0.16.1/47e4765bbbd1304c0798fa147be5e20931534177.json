{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/packages/minimongo/sorter.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"packages/minimongo/sorter.js","filename":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/packages/minimongo/sorter.js","targets":{"android":"95.0.0","chrome":"95.0.0","edge":"95.0.0","firefox":"78.0.0","ie":"10.0.0","ios":"15.0.0","opera":"81.0.0","safari":"15.1.0","samsung":"14.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat","root":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.16.5","helpers":true,"useESModules":false,"corejs":false}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/packages/minimongo/sorter.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/minimongo/sorter.js"}},"code":"module.export({\n  default: () => Sorter\n});\nlet ELEMENT_OPERATORS, equalityElementMatcher, expandArraysInBranches, hasOwn, isOperatorObject, makeLookupFunction, regexpElementMatcher;\nmodule.link(\"./common.js\", {\n  ELEMENT_OPERATORS(v) {\n    ELEMENT_OPERATORS = v;\n  },\n\n  equalityElementMatcher(v) {\n    equalityElementMatcher = v;\n  },\n\n  expandArraysInBranches(v) {\n    expandArraysInBranches = v;\n  },\n\n  hasOwn(v) {\n    hasOwn = v;\n  },\n\n  isOperatorObject(v) {\n    isOperatorObject = v;\n  },\n\n  makeLookupFunction(v) {\n    makeLookupFunction = v;\n  },\n\n  regexpElementMatcher(v) {\n    regexpElementMatcher = v;\n  }\n\n}, 0);\n\nclass Sorter {\n  constructor(spec) {\n    this._sortSpecParts = [];\n    this._sortFunction = null;\n\n    const addSpecPart = (path, ascending) => {\n      if (!path) {\n        throw Error('sort keys must be non-empty');\n      }\n\n      if (path.charAt(0) === '$') {\n        throw Error(\"unsupported sort key: \".concat(path));\n      }\n\n      this._sortSpecParts.push({\n        ascending,\n        lookup: makeLookupFunction(path, {\n          forSort: true\n        }),\n        path\n      });\n    };\n\n    if (spec instanceof Array) {\n      spec.forEach(element => {\n        if (typeof element === 'string') {\n          addSpecPart(element, true);\n        } else {\n          addSpecPart(element[0], element[1] !== 'desc');\n        }\n      });\n    } else if (typeof spec === 'object') {\n      Object.keys(spec).forEach(key => {\n        addSpecPart(key, spec[key] >= 0);\n      });\n    } else if (typeof spec === 'function') {\n      this._sortFunction = spec;\n    } else {\n      throw Error(\"Bad sort specification: \".concat(JSON.stringify(spec)));\n    } // If a function is specified for sorting, we skip the rest.\n\n\n    if (this._sortFunction) {\n      return;\n    } // To implement affectedByModifier, we piggy-back on top of Matcher's\n    // affectedByModifier code; we create a selector that is affected by the\n    // same modifiers as this sort order. This is only implemented on the\n    // server.\n\n\n    if (this.affectedByModifier) {\n      const selector = {};\n\n      this._sortSpecParts.forEach(spec => {\n        selector[spec.path] = 1;\n      });\n\n      this._selectorForAffectedByModifier = new Minimongo.Matcher(selector);\n    }\n\n    this._keyComparator = composeComparators(this._sortSpecParts.map((spec, i) => this._keyFieldComparator(i)));\n  }\n\n  getComparator(options) {\n    // If sort is specified or have no distances, just use the comparator from\n    // the source specification (which defaults to \"everything is equal\".\n    // issue #3599\n    // https://docs.mongodb.com/manual/reference/operator/query/near/#sort-operation\n    // sort effectively overrides $near\n    if (this._sortSpecParts.length || !options || !options.distances) {\n      return this._getBaseComparator();\n    }\n\n    const distances = options.distances; // Return a comparator which compares using $near distances.\n\n    return (a, b) => {\n      if (!distances.has(a._id)) {\n        throw Error(\"Missing distance for \".concat(a._id));\n      }\n\n      if (!distances.has(b._id)) {\n        throw Error(\"Missing distance for \".concat(b._id));\n      }\n\n      return distances.get(a._id) - distances.get(b._id);\n    };\n  } // Takes in two keys: arrays whose lengths match the number of spec\n  // parts. Returns negative, 0, or positive based on using the sort spec to\n  // compare fields.\n\n\n  _compareKeys(key1, key2) {\n    if (key1.length !== this._sortSpecParts.length || key2.length !== this._sortSpecParts.length) {\n      throw Error('Key has wrong length');\n    }\n\n    return this._keyComparator(key1, key2);\n  } // Iterates over each possible \"key\" from doc (ie, over each branch), calling\n  // 'cb' with the key.\n\n\n  _generateKeysFromDoc(doc, cb) {\n    if (this._sortSpecParts.length === 0) {\n      throw new Error('can\\'t generate keys without a spec');\n    }\n\n    const pathFromIndices = indices => \"\".concat(indices.join(','), \",\");\n\n    let knownPaths = null; // maps index -> ({'' -> value} or {path -> value})\n\n    const valuesByIndexAndPath = this._sortSpecParts.map(spec => {\n      // Expand any leaf arrays that we find, and ignore those arrays\n      // themselves.  (We never sort based on an array itself.)\n      let branches = expandArraysInBranches(spec.lookup(doc), true); // If there are no values for a key (eg, key goes to an empty array),\n      // pretend we found one undefined value.\n\n      if (!branches.length) {\n        branches = [{\n          value: void 0\n        }];\n      }\n\n      const element = Object.create(null);\n      let usedPaths = false;\n      branches.forEach(branch => {\n        if (!branch.arrayIndices) {\n          // If there are no array indices for a branch, then it must be the\n          // only branch, because the only thing that produces multiple branches\n          // is the use of arrays.\n          if (branches.length > 1) {\n            throw Error('multiple branches but no array used?');\n          }\n\n          element[''] = branch.value;\n          return;\n        }\n\n        usedPaths = true;\n        const path = pathFromIndices(branch.arrayIndices);\n\n        if (hasOwn.call(element, path)) {\n          throw Error(\"duplicate path: \".concat(path));\n        }\n\n        element[path] = branch.value; // If two sort fields both go into arrays, they have to go into the\n        // exact same arrays and we have to find the same paths.  This is\n        // roughly the same condition that makes MongoDB throw this strange\n        // error message.  eg, the main thing is that if sort spec is {a: 1,\n        // b:1} then a and b cannot both be arrays.\n        //\n        // (In MongoDB it seems to be OK to have {a: 1, 'a.x.y': 1} where 'a'\n        // and 'a.x.y' are both arrays, but we don't allow this for now.\n        // #NestedArraySort\n        // XXX achieve full compatibility here\n\n        if (knownPaths && !hasOwn.call(knownPaths, path)) {\n          throw Error('cannot index parallel arrays');\n        }\n      });\n\n      if (knownPaths) {\n        // Similarly to above, paths must match everywhere, unless this is a\n        // non-array field.\n        if (!hasOwn.call(element, '') && Object.keys(knownPaths).length !== Object.keys(element).length) {\n          throw Error('cannot index parallel arrays!');\n        }\n      } else if (usedPaths) {\n        knownPaths = {};\n        Object.keys(element).forEach(path => {\n          knownPaths[path] = true;\n        });\n      }\n\n      return element;\n    });\n\n    if (!knownPaths) {\n      // Easy case: no use of arrays.\n      const soleKey = valuesByIndexAndPath.map(values => {\n        if (!hasOwn.call(values, '')) {\n          throw Error('no value in sole key case?');\n        }\n\n        return values[''];\n      });\n      cb(soleKey);\n      return;\n    }\n\n    Object.keys(knownPaths).forEach(path => {\n      const key = valuesByIndexAndPath.map(values => {\n        if (hasOwn.call(values, '')) {\n          return values[''];\n        }\n\n        if (!hasOwn.call(values, path)) {\n          throw Error('missing path?');\n        }\n\n        return values[path];\n      });\n      cb(key);\n    });\n  } // Returns a comparator that represents the sort specification (but not\n  // including a possible geoquery distance tie-breaker).\n\n\n  _getBaseComparator() {\n    if (this._sortFunction) {\n      return this._sortFunction;\n    } // If we're only sorting on geoquery distance and no specs, just say\n    // everything is equal.\n\n\n    if (!this._sortSpecParts.length) {\n      return (doc1, doc2) => 0;\n    }\n\n    return (doc1, doc2) => {\n      const key1 = this._getMinKeyFromDoc(doc1);\n\n      const key2 = this._getMinKeyFromDoc(doc2);\n\n      return this._compareKeys(key1, key2);\n    };\n  } // Finds the minimum key from the doc, according to the sort specs.  (We say\n  // \"minimum\" here but this is with respect to the sort spec, so \"descending\"\n  // sort fields mean we're finding the max for that field.)\n  //\n  // Note that this is NOT \"find the minimum value of the first field, the\n  // minimum value of the second field, etc\"... it's \"choose the\n  // lexicographically minimum value of the key vector, allowing only keys which\n  // you can find along the same paths\".  ie, for a doc {a: [{x: 0, y: 5}, {x:\n  // 1, y: 3}]} with sort spec {'a.x': 1, 'a.y': 1}, the only keys are [0,5] and\n  // [1,3], and the minimum key is [0,5]; notably, [0,3] is NOT a key.\n\n\n  _getMinKeyFromDoc(doc) {\n    let minKey = null;\n\n    this._generateKeysFromDoc(doc, key => {\n      if (minKey === null) {\n        minKey = key;\n        return;\n      }\n\n      if (this._compareKeys(key, minKey) < 0) {\n        minKey = key;\n      }\n    });\n\n    return minKey;\n  }\n\n  _getPaths() {\n    return this._sortSpecParts.map(part => part.path);\n  } // Given an index 'i', returns a comparator that compares two key arrays based\n  // on field 'i'.\n\n\n  _keyFieldComparator(i) {\n    const invert = !this._sortSpecParts[i].ascending;\n    return (key1, key2) => {\n      const compare = LocalCollection._f._cmp(key1[i], key2[i]);\n\n      return invert ? -compare : compare;\n    };\n  }\n\n}\n\n// Given an array of comparators\n// (functions (a,b)->(negative or positive or zero)), returns a single\n// comparator which uses each comparator in order and returns the first\n// non-zero value.\nfunction composeComparators(comparatorArray) {\n  return (a, b) => {\n    for (let i = 0; i < comparatorArray.length; ++i) {\n      const compare = comparatorArray[i](a, b);\n\n      if (compare !== 0) {\n        return compare;\n      }\n    }\n\n    return 0;\n  };\n}","map":{"version":3,"sources":["packages/minimongo/sorter.js"],"names":["module","export","default","Sorter","ELEMENT_OPERATORS","equalityElementMatcher","expandArraysInBranches","hasOwn","isOperatorObject","makeLookupFunction","regexpElementMatcher","link","v","constructor","spec","_sortSpecParts","_sortFunction","addSpecPart","path","ascending","Error","charAt","push","lookup","forSort","Array","forEach","element","Object","keys","key","JSON","stringify","affectedByModifier","selector","_selectorForAffectedByModifier","Minimongo","Matcher","_keyComparator","composeComparators","map","i","_keyFieldComparator","getComparator","options","length","distances","_getBaseComparator","a","b","has","_id","get","_compareKeys","key1","key2","_generateKeysFromDoc","doc","cb","pathFromIndices","indices","join","knownPaths","valuesByIndexAndPath","branches","value","create","usedPaths","branch","arrayIndices","call","soleKey","values","doc1","doc2","_getMinKeyFromDoc","minKey","_getPaths","part","invert","compare","LocalCollection","_f","_cmp","comparatorArray"],"mappings":"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","sourcesContent":["import {\n  ELEMENT_OPERATORS,\n  equalityElementMatcher,\n  expandArraysInBranches,\n  hasOwn,\n  isOperatorObject,\n  makeLookupFunction,\n  regexpElementMatcher,\n} from './common.js';\n\n// Give a sort spec, which can be in any of these forms:\n//   {\"key1\": 1, \"key2\": -1}\n//   [[\"key1\", \"asc\"], [\"key2\", \"desc\"]]\n//   [\"key1\", [\"key2\", \"desc\"]]\n//\n// (.. with the first form being dependent on the key enumeration\n// behavior of your javascript VM, which usually does what you mean in\n// this case if the key names don't look like integers ..)\n//\n// return a function that takes two objects, and returns -1 if the\n// first object comes first in order, 1 if the second object comes\n// first, or 0 if neither object comes before the other.\n\nexport default class Sorter {\n  constructor(spec) {\n    this._sortSpecParts = [];\n    this._sortFunction = null;\n\n    const addSpecPart = (path, ascending) => {\n      if (!path) {\n        throw Error('sort keys must be non-empty');\n      }\n\n      if (path.charAt(0) === '$') {\n        throw Error(`unsupported sort key: ${path}`);\n      }\n\n      this._sortSpecParts.push({\n        ascending,\n        lookup: makeLookupFunction(path, {forSort: true}),\n        path\n      });\n    };\n\n    if (spec instanceof Array) {\n      spec.forEach(element => {\n        if (typeof element === 'string') {\n          addSpecPart(element, true);\n        } else {\n          addSpecPart(element[0], element[1] !== 'desc');\n        }\n      });\n    } else if (typeof spec === 'object') {\n      Object.keys(spec).forEach(key => {\n        addSpecPart(key, spec[key] >= 0);\n      });\n    } else if (typeof spec === 'function') {\n      this._sortFunction = spec;\n    } else {\n      throw Error(`Bad sort specification: ${JSON.stringify(spec)}`);\n    }\n\n    // If a function is specified for sorting, we skip the rest.\n    if (this._sortFunction) {\n      return;\n    }\n\n    // To implement affectedByModifier, we piggy-back on top of Matcher's\n    // affectedByModifier code; we create a selector that is affected by the\n    // same modifiers as this sort order. This is only implemented on the\n    // server.\n    if (this.affectedByModifier) {\n      const selector = {};\n\n      this._sortSpecParts.forEach(spec => {\n        selector[spec.path] = 1;\n      });\n\n      this._selectorForAffectedByModifier = new Minimongo.Matcher(selector);\n    }\n\n    this._keyComparator = composeComparators(\n      this._sortSpecParts.map((spec, i) => this._keyFieldComparator(i))\n    );\n  }\n\n  getComparator(options) {\n    // If sort is specified or have no distances, just use the comparator from\n    // the source specification (which defaults to \"everything is equal\".\n    // issue #3599\n    // https://docs.mongodb.com/manual/reference/operator/query/near/#sort-operation\n    // sort effectively overrides $near\n    if (this._sortSpecParts.length || !options || !options.distances) {\n      return this._getBaseComparator();\n    }\n\n    const distances = options.distances;\n\n    // Return a comparator which compares using $near distances.\n    return (a, b) => {\n      if (!distances.has(a._id)) {\n        throw Error(`Missing distance for ${a._id}`);\n      }\n\n      if (!distances.has(b._id)) {\n        throw Error(`Missing distance for ${b._id}`);\n      }\n\n      return distances.get(a._id) - distances.get(b._id);\n    };\n  }\n\n  // Takes in two keys: arrays whose lengths match the number of spec\n  // parts. Returns negative, 0, or positive based on using the sort spec to\n  // compare fields.\n  _compareKeys(key1, key2) {\n    if (key1.length !== this._sortSpecParts.length ||\n        key2.length !== this._sortSpecParts.length) {\n      throw Error('Key has wrong length');\n    }\n\n    return this._keyComparator(key1, key2);\n  }\n\n  // Iterates over each possible \"key\" from doc (ie, over each branch), calling\n  // 'cb' with the key.\n  _generateKeysFromDoc(doc, cb) {\n    if (this._sortSpecParts.length === 0) {\n      throw new Error('can\\'t generate keys without a spec');\n    }\n\n    const pathFromIndices = indices => `${indices.join(',')},`;\n\n    let knownPaths = null;\n\n    // maps index -> ({'' -> value} or {path -> value})\n    const valuesByIndexAndPath = this._sortSpecParts.map(spec => {\n      // Expand any leaf arrays that we find, and ignore those arrays\n      // themselves.  (We never sort based on an array itself.)\n      let branches = expandArraysInBranches(spec.lookup(doc), true);\n\n      // If there are no values for a key (eg, key goes to an empty array),\n      // pretend we found one undefined value.\n      if (!branches.length) {\n        branches = [{ value: void 0 }];\n      }\n\n      const element = Object.create(null);\n      let usedPaths = false;\n\n      branches.forEach(branch => {\n        if (!branch.arrayIndices) {\n          // If there are no array indices for a branch, then it must be the\n          // only branch, because the only thing that produces multiple branches\n          // is the use of arrays.\n          if (branches.length > 1) {\n            throw Error('multiple branches but no array used?');\n          }\n\n          element[''] = branch.value;\n          return;\n        }\n\n        usedPaths = true;\n\n        const path = pathFromIndices(branch.arrayIndices);\n\n        if (hasOwn.call(element, path)) {\n          throw Error(`duplicate path: ${path}`);\n        }\n\n        element[path] = branch.value;\n\n        // If two sort fields both go into arrays, they have to go into the\n        // exact same arrays and we have to find the same paths.  This is\n        // roughly the same condition that makes MongoDB throw this strange\n        // error message.  eg, the main thing is that if sort spec is {a: 1,\n        // b:1} then a and b cannot both be arrays.\n        //\n        // (In MongoDB it seems to be OK to have {a: 1, 'a.x.y': 1} where 'a'\n        // and 'a.x.y' are both arrays, but we don't allow this for now.\n        // #NestedArraySort\n        // XXX achieve full compatibility here\n        if (knownPaths && !hasOwn.call(knownPaths, path)) {\n          throw Error('cannot index parallel arrays');\n        }\n      });\n\n      if (knownPaths) {\n        // Similarly to above, paths must match everywhere, unless this is a\n        // non-array field.\n        if (!hasOwn.call(element, '') &&\n            Object.keys(knownPaths).length !== Object.keys(element).length) {\n          throw Error('cannot index parallel arrays!');\n        }\n      } else if (usedPaths) {\n        knownPaths = {};\n\n        Object.keys(element).forEach(path => {\n          knownPaths[path] = true;\n        });\n      }\n\n      return element;\n    });\n\n    if (!knownPaths) {\n      // Easy case: no use of arrays.\n      const soleKey = valuesByIndexAndPath.map(values => {\n        if (!hasOwn.call(values, '')) {\n          throw Error('no value in sole key case?');\n        }\n\n        return values[''];\n      });\n\n      cb(soleKey);\n\n      return;\n    }\n\n    Object.keys(knownPaths).forEach(path => {\n      const key = valuesByIndexAndPath.map(values => {\n        if (hasOwn.call(values, '')) {\n          return values[''];\n        }\n\n        if (!hasOwn.call(values, path)) {\n          throw Error('missing path?');\n        }\n\n        return values[path];\n      });\n\n      cb(key);\n    });\n  }\n\n  // Returns a comparator that represents the sort specification (but not\n  // including a possible geoquery distance tie-breaker).\n  _getBaseComparator() {\n    if (this._sortFunction) {\n      return this._sortFunction;\n    }\n\n    // If we're only sorting on geoquery distance and no specs, just say\n    // everything is equal.\n    if (!this._sortSpecParts.length) {\n      return (doc1, doc2) => 0;\n    }\n\n    return (doc1, doc2) => {\n      const key1 = this._getMinKeyFromDoc(doc1);\n      const key2 = this._getMinKeyFromDoc(doc2);\n      return this._compareKeys(key1, key2);\n    };\n  }\n\n  // Finds the minimum key from the doc, according to the sort specs.  (We say\n  // \"minimum\" here but this is with respect to the sort spec, so \"descending\"\n  // sort fields mean we're finding the max for that field.)\n  //\n  // Note that this is NOT \"find the minimum value of the first field, the\n  // minimum value of the second field, etc\"... it's \"choose the\n  // lexicographically minimum value of the key vector, allowing only keys which\n  // you can find along the same paths\".  ie, for a doc {a: [{x: 0, y: 5}, {x:\n  // 1, y: 3}]} with sort spec {'a.x': 1, 'a.y': 1}, the only keys are [0,5] and\n  // [1,3], and the minimum key is [0,5]; notably, [0,3] is NOT a key.\n  _getMinKeyFromDoc(doc) {\n    let minKey = null;\n\n    this._generateKeysFromDoc(doc, key => {\n      if (minKey === null) {\n        minKey = key;\n        return;\n      }\n\n      if (this._compareKeys(key, minKey) < 0) {\n        minKey = key;\n      }\n    });\n\n    return minKey;\n  }\n\n  _getPaths() {\n    return this._sortSpecParts.map(part => part.path);\n  }\n\n  // Given an index 'i', returns a comparator that compares two key arrays based\n  // on field 'i'.\n  _keyFieldComparator(i) {\n    const invert = !this._sortSpecParts[i].ascending;\n\n    return (key1, key2) => {\n      const compare = LocalCollection._f._cmp(key1[i], key2[i]);\n      return invert ? -compare : compare;\n    };\n  }\n}\n\n// Given an array of comparators\n// (functions (a,b)->(negative or positive or zero)), returns a single\n// comparator which uses each comparator in order and returns the first\n// non-zero value.\nfunction composeComparators(comparatorArray) {\n  return (a, b) => {\n    for (let i = 0; i < comparatorArray.length; ++i) {\n      const compare = comparatorArray[i](a, b);\n      if (compare !== 0) {\n        return compare;\n      }\n    }\n\n    return 0;\n  };\n}\n"]},"sourceType":"module","hash":"47e4765bbbd1304c0798fa147be5e20931534177"}
