{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/weslley/Documents/projects/Rocket.Chat/app/settings/server/CachedSettings.ts","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"app/settings/server/CachedSettings.ts","filename":"/home/weslley/Documents/projects/Rocket.Chat/app/settings/server/CachedSettings.ts","inputSourceMap":{"version":3,"file":"app/settings/server/CachedSettings.ts","sourceRoot":"","sources":["app/settings/server/CachedSettings.ts"],"names":[],"mappings":"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","sourcesContent":["import { Emitter } from '@rocket.chat/emitter';\nimport _ from 'underscore';\n\nimport { ISetting, SettingValue } from '../../../definition/ISetting';\nimport { SystemLogger } from '../../../server/lib/logger/system';\n\nconst warn = process.env.NODE_ENV === 'development' || process.env.TEST_MODE;\n\ntype SettingsConfig = {\n\tdebounce: number;\n};\n\ntype OverCustomSettingsConfig = Partial<SettingsConfig>;\n\nexport interface ICachedSettings {\n\t/*\n\t * @description: The settings object as ready\n\t */\n\tinitilized(): void;\n\n\t/*\n\t * returns if the setting is defined\n\t * @param _id - The setting id\n\t * @returns {boolean}\n\t */\n\thas(_id: ISetting['_id']): boolean;\n\n\t/*\n\t * Gets the current Object of the setting\n\t * @param _id - The setting id\n\t * @returns {ISetting} - The current Object of the setting\n\t */\n\tgetSetting(_id: ISetting['_id']): ISetting | undefined;\n\n\t/*\n\t * Gets the current value of the setting\n\t * @remarks\n\t * \t\t- In development mode if you are trying to get the value of a setting that is not defined, it will give an warning, in theory it makes sense, there no reason to do that\n\t * @param _id - The setting id\n\t * @returns {SettingValue} - The current value of the setting\n\t */\n\tget<T extends SettingValue = SettingValue>(_id: ISetting['_id']): T;\n\n\t/*\n\t * Gets the current value of the setting\n\t * @remarks\n\t * \t\t- In development mode if you are trying to get the value of a setting that is not defined, it will give an warning, in theory it makes sense, there no reason to do that\n\t * @param _id - The setting id\n\t * @returns {SettingValue} - The current value of the setting\n\t *\n\t */\n\t/* @deprecated */\n\tgetByRegexp<T extends SettingValue = SettingValue>(_id: RegExp): [string, T][];\n\n\t/*\n\t * Get the current value of the settings, and keep track of changes\n\t * @remarks\n\t * \t\t- This callback is debounced\n\t *       - The callback is not fire until the settings got initialized\n\t * @param _ids - Array of setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\twatchMultiple<T extends SettingValue = SettingValue>(_id: ISetting['_id'][], callback: (settings: T[]) => void): () => void;\n\n\t/*\n\t * Get the current value of the setting, and keep track of changes\n\t * @remarks\n\t * \t\t- This callback is debounced\n\t *       - The callback is not fire until the settings got initialized\n\t * @param _id - The setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\twatch<T extends SettingValue = SettingValue>(_id: ISetting['_id'], cb: (args: T) => void, config?: OverCustomSettingsConfig): () => void;\n\n\t/*\n\t * Get the current value of the setting, or wait until the initialized\n\t * @remarks\n\t * \t\t- This is a one time run\n\t * \t\t- This callback is debounced\n\t *       - The callback is not fire until the settings got initialized\n\t * @param _id - The setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\twatchOnce<T extends SettingValue = SettingValue>(\n\t\t_id: ISetting['_id'],\n\t\tcb: (args: T) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void;\n\n\t/*\n\t * Observes the given setting by id and keep track of changes\n\t * @remarks\n\t * \t\t- This callback is debounced\n\t *       - The callback is not fire until the setting is changed\n\t *       - The callback is not fire until all the settings get initialized\n\t * @param _id - The setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\tchange<T extends SettingValue = SettingValue>(\n\t\t_id: ISetting['_id'],\n\t\tcallback: (args: T) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void;\n\n\t/*\n\t * Observes multiple settings and keep track of changes\n\t * @remarks\n\t * \t\t- This callback is debounced\n\t *       - The callback is not fire until the setting is changed\n\t *       - The callback is not fire until all the settings get initialized\n\t * @param _ids - Array of setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\tchangeMultiple<T extends SettingValue = SettingValue>(\n\t\t_ids: ISetting['_id'][],\n\t\tcallback: (settings: T[]) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void;\n\n\t/*\n\t * Observes the setting and fires only if there is a change. Runs only once\n\t * @remarks\n\t * \t\t- This is a one time run\n\t * \t\t- This callback is debounced\n\t *       - The callback is not fire until the setting is changed\n\t *       - The callback is not fire until all the settings get initialized\n\t * @param _id - The setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\tchangeOnce<T extends SettingValue = SettingValue>(\n\t\t_id: ISetting['_id'],\n\t\tcallback: (args: T) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void;\n\n\t/*\n\t * Sets the value of the setting\n\t * @remarks\n\t * \t\t- if the value set is the same as the current value, the change will not be fired\n\t *       - if the value is set before the initialization, the emit will be queued and will be fired after initialization\n\t * @param _id - The setting id\n\t * @param value - The value to set\n\t * @returns {void}\n\t */\n\tset(record: ISetting): void;\n\n\tgetConfig(config?: OverCustomSettingsConfig): SettingsConfig;\n\n\t/* @deprecated */\n\twatchByRegex(regex: RegExp, cb: (...args: [string, SettingValue]) => void, config?: OverCustomSettingsConfig): () => void;\n\n\t/* @deprecated */\n\tchangeByRegex(regex: RegExp, callback: (...args: [string, SettingValue]) => void, config?: OverCustomSettingsConfig): () => void;\n\n\t/*\n\t * @description: Wait until the settings get ready then run the callback\n\t */\n\tonReady(cb: () => void): void;\n}\n\n/**\n * Class responsible for setting up the settings, cache and propagation changes\n * Should be agnostic to the actual settings implementation, running on meteor or standalone\n *\n * You should not instantiate this class directly, only for testing purposes\n *\n * @extends Emitter\n * @alpha\n */\nexport class CachedSettings\n\textends Emitter<\n\t\t{\n\t\t\t'*': [string, SettingValue];\n\t\t} & {\n\t\t\tready: undefined;\n\t\t\t[k: string]: SettingValue;\n\t\t}\n\t>\n\timplements ICachedSettings\n{\n\tready = false;\n\n\tstore = new Map<string, ISetting>();\n\n\tinitilized(): void {\n\t\tif (this.ready) {\n\t\t\treturn;\n\t\t}\n\t\tthis.ready = true;\n\t\tthis.emit('ready');\n\t\tSystemLogger.debug('Settings initalized');\n\t}\n\n\t/*\n\t * returns if the setting is defined\n\t * @param _id - The setting id\n\t * @returns {boolean}\n\t */\n\tpublic has(_id: ISetting['_id']): boolean {\n\t\tif (!this.ready && warn) {\n\t\t\tSystemLogger.warn(`Settings not initialized yet. getting: ${_id}`);\n\t\t}\n\t\treturn this.store.has(_id);\n\t}\n\n\tpublic getSetting(_id: ISetting['_id']): ISetting | undefined {\n\t\tif (!this.ready && warn) {\n\t\t\tSystemLogger.warn(`Settings not initialized yet. getting: ${_id}`);\n\t\t}\n\t\treturn this.store.get(_id);\n\t}\n\n\t/*\n\t * Gets the current value of the setting\n\t * @remarks\n\t * \t\t- In development mode if you are trying to get the value of a setting that is not defined, it will give an warning, in theory it makes sense, there no reason to do that\n\t * \t\t- The setting's value will be cached in memory so it won't call the DB every time you fetch a particular setting\n\t * @param _id - The setting id\n\t * @returns {SettingValue} - The current value of the setting\n\t */\n\tpublic get<T extends SettingValue = SettingValue>(_id: ISetting['_id']): T {\n\t\tif (!this.ready && warn) {\n\t\t\tSystemLogger.warn(`Settings not initialized yet. getting: ${_id}`);\n\t\t}\n\t\treturn this.store.get(_id)?.value as T;\n\t}\n\n\t/*\n\t * Gets the current value of the setting\n\t * @remarks\n\t * \t\t- In development mode if you are trying to get the value of a setting that is not defined, it will give an warning, in theory it makes sense, there no reason to do that\n\t * @param _id - The setting id\n\t * @returns {SettingValue} - The current value of the setting\n\t *\n\t */\n\t/* @deprecated */\n\tpublic getByRegexp<T extends SettingValue = SettingValue>(_id: RegExp): [string, T][] {\n\t\tif (!this.ready && warn) {\n\t\t\tSystemLogger.warn(`Settings not initialized yet. getting: ${_id}`);\n\t\t}\n\n\t\treturn [...this.store.entries()].filter(([key]) => _id.test(key)).map(([key, setting]) => [key, setting.value]) as [string, T][];\n\t}\n\n\t/*\n\t * Get the current value of the settings, and keep track of changes\n\t * @remarks\n\t * \t\t- This callback is debounced\n\t *       - The callback is not fire until the settings got initialized\n\t * @param _ids - Array of setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\tpublic watchMultiple<T extends SettingValue = SettingValue>(_id: ISetting['_id'][], callback: (settings: T[]) => void): () => void {\n\t\tif (!this.ready) {\n\t\t\tconst cancel = new Set<() => void>();\n\n\t\t\tcancel.add(\n\t\t\t\tthis.once('ready', (): void => {\n\t\t\t\t\tcancel.clear();\n\t\t\t\t\tcancel.add(this.watchMultiple(_id, callback));\n\t\t\t\t}),\n\t\t\t);\n\t\t\treturn (): void => {\n\t\t\t\tcancel.forEach((fn) => fn());\n\t\t\t};\n\t\t}\n\n\t\tif (_id.every((id) => this.store.has(id))) {\n\t\t\tconst settings = _id.map((id) => this.store.get(id)?.value);\n\t\t\tcallback(settings as T[]);\n\t\t}\n\t\tconst mergeFunction = _.debounce((): void => {\n\t\t\tcallback(_id.map((id) => this.store.get(id)?.value) as T[]);\n\t\t}, 100);\n\n\t\tconst fns = _id.map((id) => this.on(id, mergeFunction));\n\t\treturn (): void => {\n\t\t\tfns.forEach((fn) => fn());\n\t\t};\n\t}\n\n\t/*\n\t * Get the current value of the setting, and keep track of changes\n\t * @remarks\n\t * \t\t- This callback is debounced\n\t *       - The callback is not fire until the settings got initialized\n\t * @param _id - The setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\tpublic watch<T extends SettingValue = SettingValue>(\n\t\t_id: ISetting['_id'],\n\t\tcb: (args: T) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void {\n\t\tif (!this.ready) {\n\t\t\tconst cancel = new Set<() => void>();\n\t\t\tcancel.add(\n\t\t\t\tthis.once('ready', (): void => {\n\t\t\t\t\tcancel.clear();\n\t\t\t\t\tcancel.add(this.watch(_id, cb, config));\n\t\t\t\t}),\n\t\t\t);\n\t\t\treturn (): void => {\n\t\t\t\tcancel.forEach((fn) => fn());\n\t\t\t};\n\t\t}\n\n\t\tthis.store.has(_id) && cb(this.store.get(_id)?.value as T);\n\t\treturn this.change(_id, cb, config);\n\t}\n\n\t/*\n\t * Get the current value of the setting, or wait until the initialized\n\t * @remarks\n\t * \t\t- This is a one time run\n\t * \t\t- This callback is debounced\n\t *       - The callback is not fire until the settings got initialized\n\t * @param _id - The setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\tpublic watchOnce<T extends SettingValue = SettingValue>(\n\t\t_id: ISetting['_id'],\n\t\tcb: (args: T) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void {\n\t\tif (this.store.has(_id)) {\n\t\t\tcb(this.store.get(_id)?.value as T);\n\t\t\treturn (): void => undefined;\n\t\t}\n\t\treturn this.changeOnce(_id, cb, config);\n\t}\n\n\t/*\n\t * Observes the given setting by id and keep track of changes\n\t * @remarks\n\t * \t\t- This callback is debounced\n\t *       - The callback is not fire until the setting is changed\n\t *       - The callback is not fire until all the settings get initialized\n\t * @param _id - The setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\tpublic change<T extends SettingValue = SettingValue>(\n\t\t_id: ISetting['_id'],\n\t\tcallback: (args: T) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void {\n\t\tconst { debounce } = this.getConfig(config);\n\t\treturn this.on(_id, _.debounce(callback, debounce) as any);\n\t}\n\n\t/*\n\t * Observes multiple settings and keep track of changes\n\t * @remarks\n\t * \t\t- This callback is debounced\n\t *       - The callback is not fire until the setting is changed\n\t *       - The callback is not fire until all the settings get initialized\n\t * @param _ids - Array of setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\tpublic changeMultiple<T extends SettingValue = SettingValue>(\n\t\t_ids: ISetting['_id'][],\n\t\tcallback: (settings: T[]) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void {\n\t\tconst fns = _ids.map((id) =>\n\t\t\tthis.change(\n\t\t\t\tid,\n\t\t\t\t(): void => {\n\t\t\t\t\tcallback(_ids.map((id) => this.store.get(id)?.value) as T[]);\n\t\t\t\t},\n\t\t\t\tconfig,\n\t\t\t),\n\t\t);\n\t\treturn (): void => {\n\t\t\tfns.forEach((fn) => fn());\n\t\t};\n\t}\n\n\t/*\n\t * Observes the setting and fires only if there is a change. Runs only once\n\t * @remarks\n\t * \t\t- This is a one time run\n\t * \t\t- This callback is debounced\n\t *       - The callback is not fire until the setting is changed\n\t *       - The callback is not fire until all the settings get initialized\n\t * @param _id - The setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\tpublic changeOnce<T extends SettingValue = SettingValue>(\n\t\t_id: ISetting['_id'],\n\t\tcallback: (args: T) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void {\n\t\tconst { debounce } = this.getConfig(config);\n\t\treturn this.once(_id, _.debounce(callback, debounce) as any);\n\t}\n\n\t/*\n\t * Sets the value of the setting\n\t * @remarks\n\t * \t\t- if the value set is the same as the current value, the change will not be fired\n\t *       - if the value is set before the initialization, the emit will be queued and will be fired after initialization\n\t * @param _id - The setting id\n\t * @param value - The value to set\n\t * @returns {void}\n\t */\n\tpublic set(record: ISetting): void {\n\t\tif (this.store.has(record._id) && this.store.get(record._id)?.value === record.value) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.store.set(record._id, record);\n\t\tif (!this.ready) {\n\t\t\tthis.once('ready', () => {\n\t\t\t\tthis.emit(record._id, this.store.get(record._id)?.value);\n\t\t\t\tthis.emit('*', [record._id, this.store.get(record._id)?.value]);\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\tthis.emit(record._id, this.store.get(record._id)?.value);\n\t\tthis.emit('*', [record._id, this.store.get(record._id)?.value]);\n\t}\n\n\tpublic getConfig = (config?: OverCustomSettingsConfig): SettingsConfig => ({\n\t\tdebounce: 500,\n\t\t...config,\n\t});\n\n\t/* @deprecated */\n\tpublic watchByRegex(regex: RegExp, cb: (...args: [string, SettingValue]) => void, config?: OverCustomSettingsConfig): () => void {\n\t\tif (!this.ready) {\n\t\t\tconst cancel = new Set<() => void>();\n\t\t\tcancel.add(\n\t\t\t\tthis.once('ready', (): void => {\n\t\t\t\t\tcancel.clear();\n\t\t\t\t\tcancel.add(this.watchByRegex(regex, cb, config));\n\t\t\t\t}),\n\t\t\t);\n\t\t\treturn (): void => {\n\t\t\t\tcancel.forEach((fn) => fn());\n\t\t\t};\n\t\t}\n\t\t[...this.store.entries()].forEach(([key, setting]) => {\n\t\t\tif (regex.test(key)) {\n\t\t\t\tcb(key, setting.value);\n\t\t\t}\n\t\t});\n\n\t\treturn this.changeByRegex(regex, cb, config);\n\t}\n\n\t/* @deprecated */\n\tpublic changeByRegex(regex: RegExp, callback: (...args: [string, SettingValue]) => void, config?: OverCustomSettingsConfig): () => void {\n\t\tconst store: Map<string, (...args: [string, SettingValue]) => void> = new Map();\n\t\treturn this.on('*', ([_id, value]) => {\n\t\t\tif (regex.test(_id)) {\n\t\t\t\tconst { debounce } = this.getConfig(config);\n\t\t\t\tconst cb = store.get(_id) || _.debounce(callback, debounce);\n\t\t\t\tcb(_id, value);\n\t\t\t\tstore.set(_id, cb);\n\t\t\t}\n\t\t\tregex.lastIndex = 0;\n\t\t});\n\t}\n\n\tpublic onReady(cb: () => void): void {\n\t\tif (this.ready) {\n\t\t\treturn cb();\n\t\t}\n\t\tthis.once('ready', cb);\n\t}\n}\n"]},"targets":{"android":"95.0.0","chrome":"95.0.0","edge":"95.0.0","firefox":"78.0.0","ie":"10.0.0","ios":"15.0.0","opera":"81.0.0","safari":"15.1.0","samsung":"14.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/home/weslley/Documents/projects/Rocket.Chat","root":"/home/weslley/Documents/projects/Rocket.Chat","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.16.5","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/home/weslley/Documents/projects/Rocket.Chat/app/settings/server/CachedSettings.ts","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"app/settings/server/CachedSettings.ts"}},"code":"let _objectSpread;\n\nmodule.link(\"@babel/runtime/helpers/objectSpread2\", {\n  default(v) {\n    _objectSpread = v;\n  }\n\n}, 0);\nmodule.export({\n  CachedSettings: () => CachedSettings\n});\nlet Emitter;\nmodule.link(\"@rocket.chat/emitter\", {\n  Emitter(v) {\n    Emitter = v;\n  }\n\n}, 0);\n\nlet _;\n\nmodule.link(\"underscore\", {\n  default(v) {\n    _ = v;\n  }\n\n}, 1);\nlet SystemLogger;\nmodule.link(\"../../../server/lib/logger/system\", {\n  SystemLogger(v) {\n    SystemLogger = v;\n  }\n\n}, 2);\nconst warn = process.env.NODE_ENV === 'development' || process.env.TEST_MODE;\n/**\n * Class responsible for setting up the settings, cache and propagation changes\n * Should be agnostic to the actual settings implementation, running on meteor or standalone\n *\n * You should not instantiate this class directly, only for testing purposes\n *\n * @extends Emitter\n * @alpha\n */\n\nclass CachedSettings extends Emitter {\n  constructor() {\n    super(...arguments);\n    this.ready = false;\n    this.store = new Map();\n\n    this.getConfig = config => _objectSpread({\n      debounce: 500\n    }, config);\n  }\n\n  initilized() {\n    if (this.ready) {\n      return;\n    }\n\n    this.ready = true;\n    this.emit('ready');\n    SystemLogger.debug('Settings initalized');\n  }\n  /*\n   * returns if the setting is defined\n   * @param _id - The setting id\n   * @returns {boolean}\n   */\n\n\n  has(_id) {\n    if (!this.ready && warn) {\n      SystemLogger.warn(\"Settings not initialized yet. getting: \".concat(_id));\n    }\n\n    return this.store.has(_id);\n  }\n\n  getSetting(_id) {\n    if (!this.ready && warn) {\n      SystemLogger.warn(\"Settings not initialized yet. getting: \".concat(_id));\n    }\n\n    return this.store.get(_id);\n  }\n  /*\n   * Gets the current value of the setting\n   * @remarks\n   * \t\t- In development mode if you are trying to get the value of a setting that is not defined, it will give an warning, in theory it makes sense, there no reason to do that\n   * \t\t- The setting's value will be cached in memory so it won't call the DB every time you fetch a particular setting\n   * @param _id - The setting id\n   * @returns {SettingValue} - The current value of the setting\n   */\n\n\n  get(_id) {\n    var _this$store$get;\n\n    if (!this.ready && warn) {\n      SystemLogger.warn(\"Settings not initialized yet. getting: \".concat(_id));\n    }\n\n    return (_this$store$get = this.store.get(_id)) === null || _this$store$get === void 0 ? void 0 : _this$store$get.value;\n  }\n  /*\n   * Gets the current value of the setting\n   * @remarks\n   * \t\t- In development mode if you are trying to get the value of a setting that is not defined, it will give an warning, in theory it makes sense, there no reason to do that\n   * @param _id - The setting id\n   * @returns {SettingValue} - The current value of the setting\n   *\n   */\n\n  /* @deprecated */\n\n\n  getByRegexp(_id) {\n    if (!this.ready && warn) {\n      SystemLogger.warn(\"Settings not initialized yet. getting: \".concat(_id));\n    }\n\n    return [...this.store.entries()].filter(_ref => {\n      let [key] = _ref;\n      return _id.test(key);\n    }).map(_ref2 => {\n      let [key, setting] = _ref2;\n      return [key, setting.value];\n    });\n  }\n  /*\n   * Get the current value of the settings, and keep track of changes\n   * @remarks\n   * \t\t- This callback is debounced\n   *       - The callback is not fire until the settings got initialized\n   * @param _ids - Array of setting id\n   * @param callback - The callback to run\n   * @returns {() => void} - A function that can be used to cancel the observe\n   */\n\n\n  watchMultiple(_id, callback) {\n    if (!this.ready) {\n      const cancel = new Set();\n      cancel.add(this.once('ready', () => {\n        cancel.clear();\n        cancel.add(this.watchMultiple(_id, callback));\n      }));\n      return () => {\n        cancel.forEach(fn => fn());\n      };\n    }\n\n    if (_id.every(id => this.store.has(id))) {\n      const settings = _id.map(id => {\n        var _this$store$get2;\n\n        return (_this$store$get2 = this.store.get(id)) === null || _this$store$get2 === void 0 ? void 0 : _this$store$get2.value;\n      });\n\n      callback(settings);\n    }\n\n    const mergeFunction = _.debounce(() => {\n      callback(_id.map(id => {\n        var _this$store$get3;\n\n        return (_this$store$get3 = this.store.get(id)) === null || _this$store$get3 === void 0 ? void 0 : _this$store$get3.value;\n      }));\n    }, 100);\n\n    const fns = _id.map(id => this.on(id, mergeFunction));\n\n    return () => {\n      fns.forEach(fn => fn());\n    };\n  }\n  /*\n   * Get the current value of the setting, and keep track of changes\n   * @remarks\n   * \t\t- This callback is debounced\n   *       - The callback is not fire until the settings got initialized\n   * @param _id - The setting id\n   * @param callback - The callback to run\n   * @returns {() => void} - A function that can be used to cancel the observe\n   */\n\n\n  watch(_id, cb, config) {\n    var _this$store$get4;\n\n    if (!this.ready) {\n      const cancel = new Set();\n      cancel.add(this.once('ready', () => {\n        cancel.clear();\n        cancel.add(this.watch(_id, cb, config));\n      }));\n      return () => {\n        cancel.forEach(fn => fn());\n      };\n    }\n\n    this.store.has(_id) && cb((_this$store$get4 = this.store.get(_id)) === null || _this$store$get4 === void 0 ? void 0 : _this$store$get4.value);\n    return this.change(_id, cb, config);\n  }\n  /*\n   * Get the current value of the setting, or wait until the initialized\n   * @remarks\n   * \t\t- This is a one time run\n   * \t\t- This callback is debounced\n   *       - The callback is not fire until the settings got initialized\n   * @param _id - The setting id\n   * @param callback - The callback to run\n   * @returns {() => void} - A function that can be used to cancel the observe\n   */\n\n\n  watchOnce(_id, cb, config) {\n    if (this.store.has(_id)) {\n      var _this$store$get5;\n\n      cb((_this$store$get5 = this.store.get(_id)) === null || _this$store$get5 === void 0 ? void 0 : _this$store$get5.value);\n      return () => undefined;\n    }\n\n    return this.changeOnce(_id, cb, config);\n  }\n  /*\n   * Observes the given setting by id and keep track of changes\n   * @remarks\n   * \t\t- This callback is debounced\n   *       - The callback is not fire until the setting is changed\n   *       - The callback is not fire until all the settings get initialized\n   * @param _id - The setting id\n   * @param callback - The callback to run\n   * @returns {() => void} - A function that can be used to cancel the observe\n   */\n\n\n  change(_id, callback, config) {\n    const {\n      debounce\n    } = this.getConfig(config);\n    return this.on(_id, _.debounce(callback, debounce));\n  }\n  /*\n   * Observes multiple settings and keep track of changes\n   * @remarks\n   * \t\t- This callback is debounced\n   *       - The callback is not fire until the setting is changed\n   *       - The callback is not fire until all the settings get initialized\n   * @param _ids - Array of setting id\n   * @param callback - The callback to run\n   * @returns {() => void} - A function that can be used to cancel the observe\n   */\n\n\n  changeMultiple(_ids, callback, config) {\n    const fns = _ids.map(id => this.change(id, () => {\n      callback(_ids.map(id => {\n        var _this$store$get6;\n\n        return (_this$store$get6 = this.store.get(id)) === null || _this$store$get6 === void 0 ? void 0 : _this$store$get6.value;\n      }));\n    }, config));\n\n    return () => {\n      fns.forEach(fn => fn());\n    };\n  }\n  /*\n   * Observes the setting and fires only if there is a change. Runs only once\n   * @remarks\n   * \t\t- This is a one time run\n   * \t\t- This callback is debounced\n   *       - The callback is not fire until the setting is changed\n   *       - The callback is not fire until all the settings get initialized\n   * @param _id - The setting id\n   * @param callback - The callback to run\n   * @returns {() => void} - A function that can be used to cancel the observe\n   */\n\n\n  changeOnce(_id, callback, config) {\n    const {\n      debounce\n    } = this.getConfig(config);\n    return this.once(_id, _.debounce(callback, debounce));\n  }\n  /*\n   * Sets the value of the setting\n   * @remarks\n   * \t\t- if the value set is the same as the current value, the change will not be fired\n   *       - if the value is set before the initialization, the emit will be queued and will be fired after initialization\n   * @param _id - The setting id\n   * @param value - The value to set\n   * @returns {void}\n   */\n\n\n  set(record) {\n    var _this$store$get7, _this$store$get10, _this$store$get11;\n\n    if (this.store.has(record._id) && ((_this$store$get7 = this.store.get(record._id)) === null || _this$store$get7 === void 0 ? void 0 : _this$store$get7.value) === record.value) {\n      return;\n    }\n\n    this.store.set(record._id, record);\n\n    if (!this.ready) {\n      this.once('ready', () => {\n        var _this$store$get8, _this$store$get9;\n\n        this.emit(record._id, (_this$store$get8 = this.store.get(record._id)) === null || _this$store$get8 === void 0 ? void 0 : _this$store$get8.value);\n        this.emit('*', [record._id, (_this$store$get9 = this.store.get(record._id)) === null || _this$store$get9 === void 0 ? void 0 : _this$store$get9.value]);\n      });\n      return;\n    }\n\n    this.emit(record._id, (_this$store$get10 = this.store.get(record._id)) === null || _this$store$get10 === void 0 ? void 0 : _this$store$get10.value);\n    this.emit('*', [record._id, (_this$store$get11 = this.store.get(record._id)) === null || _this$store$get11 === void 0 ? void 0 : _this$store$get11.value]);\n  }\n\n  /* @deprecated */\n  watchByRegex(regex, cb, config) {\n    if (!this.ready) {\n      const cancel = new Set();\n      cancel.add(this.once('ready', () => {\n        cancel.clear();\n        cancel.add(this.watchByRegex(regex, cb, config));\n      }));\n      return () => {\n        cancel.forEach(fn => fn());\n      };\n    }\n\n    [...this.store.entries()].forEach(_ref3 => {\n      let [key, setting] = _ref3;\n\n      if (regex.test(key)) {\n        cb(key, setting.value);\n      }\n    });\n    return this.changeByRegex(regex, cb, config);\n  }\n  /* @deprecated */\n\n\n  changeByRegex(regex, callback, config) {\n    const store = new Map();\n    return this.on('*', _ref4 => {\n      let [_id, value] = _ref4;\n\n      if (regex.test(_id)) {\n        const {\n          debounce\n        } = this.getConfig(config);\n\n        const cb = store.get(_id) || _.debounce(callback, debounce);\n\n        cb(_id, value);\n        store.set(_id, cb);\n      }\n\n      regex.lastIndex = 0;\n    });\n  }\n\n  onReady(cb) {\n    if (this.ready) {\n      return cb();\n    }\n\n    this.once('ready', cb);\n  }\n\n}","map":{"version":3,"sources":["app/settings/server/CachedSettings.ts"],"names":[],"mappings":"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","sourcesContent":["import { Emitter } from '@rocket.chat/emitter';\nimport _ from 'underscore';\n\nimport { ISetting, SettingValue } from '../../../definition/ISetting';\nimport { SystemLogger } from '../../../server/lib/logger/system';\n\nconst warn = process.env.NODE_ENV === 'development' || process.env.TEST_MODE;\n\ntype SettingsConfig = {\n\tdebounce: number;\n};\n\ntype OverCustomSettingsConfig = Partial<SettingsConfig>;\n\nexport interface ICachedSettings {\n\t/*\n\t * @description: The settings object as ready\n\t */\n\tinitilized(): void;\n\n\t/*\n\t * returns if the setting is defined\n\t * @param _id - The setting id\n\t * @returns {boolean}\n\t */\n\thas(_id: ISetting['_id']): boolean;\n\n\t/*\n\t * Gets the current Object of the setting\n\t * @param _id - The setting id\n\t * @returns {ISetting} - The current Object of the setting\n\t */\n\tgetSetting(_id: ISetting['_id']): ISetting | undefined;\n\n\t/*\n\t * Gets the current value of the setting\n\t * @remarks\n\t * \t\t- In development mode if you are trying to get the value of a setting that is not defined, it will give an warning, in theory it makes sense, there no reason to do that\n\t * @param _id - The setting id\n\t * @returns {SettingValue} - The current value of the setting\n\t */\n\tget<T extends SettingValue = SettingValue>(_id: ISetting['_id']): T;\n\n\t/*\n\t * Gets the current value of the setting\n\t * @remarks\n\t * \t\t- In development mode if you are trying to get the value of a setting that is not defined, it will give an warning, in theory it makes sense, there no reason to do that\n\t * @param _id - The setting id\n\t * @returns {SettingValue} - The current value of the setting\n\t *\n\t */\n\t/* @deprecated */\n\tgetByRegexp<T extends SettingValue = SettingValue>(_id: RegExp): [string, T][];\n\n\t/*\n\t * Get the current value of the settings, and keep track of changes\n\t * @remarks\n\t * \t\t- This callback is debounced\n\t *       - The callback is not fire until the settings got initialized\n\t * @param _ids - Array of setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\twatchMultiple<T extends SettingValue = SettingValue>(_id: ISetting['_id'][], callback: (settings: T[]) => void): () => void;\n\n\t/*\n\t * Get the current value of the setting, and keep track of changes\n\t * @remarks\n\t * \t\t- This callback is debounced\n\t *       - The callback is not fire until the settings got initialized\n\t * @param _id - The setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\twatch<T extends SettingValue = SettingValue>(_id: ISetting['_id'], cb: (args: T) => void, config?: OverCustomSettingsConfig): () => void;\n\n\t/*\n\t * Get the current value of the setting, or wait until the initialized\n\t * @remarks\n\t * \t\t- This is a one time run\n\t * \t\t- This callback is debounced\n\t *       - The callback is not fire until the settings got initialized\n\t * @param _id - The setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\twatchOnce<T extends SettingValue = SettingValue>(\n\t\t_id: ISetting['_id'],\n\t\tcb: (args: T) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void;\n\n\t/*\n\t * Observes the given setting by id and keep track of changes\n\t * @remarks\n\t * \t\t- This callback is debounced\n\t *       - The callback is not fire until the setting is changed\n\t *       - The callback is not fire until all the settings get initialized\n\t * @param _id - The setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\tchange<T extends SettingValue = SettingValue>(\n\t\t_id: ISetting['_id'],\n\t\tcallback: (args: T) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void;\n\n\t/*\n\t * Observes multiple settings and keep track of changes\n\t * @remarks\n\t * \t\t- This callback is debounced\n\t *       - The callback is not fire until the setting is changed\n\t *       - The callback is not fire until all the settings get initialized\n\t * @param _ids - Array of setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\tchangeMultiple<T extends SettingValue = SettingValue>(\n\t\t_ids: ISetting['_id'][],\n\t\tcallback: (settings: T[]) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void;\n\n\t/*\n\t * Observes the setting and fires only if there is a change. Runs only once\n\t * @remarks\n\t * \t\t- This is a one time run\n\t * \t\t- This callback is debounced\n\t *       - The callback is not fire until the setting is changed\n\t *       - The callback is not fire until all the settings get initialized\n\t * @param _id - The setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\tchangeOnce<T extends SettingValue = SettingValue>(\n\t\t_id: ISetting['_id'],\n\t\tcallback: (args: T) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void;\n\n\t/*\n\t * Sets the value of the setting\n\t * @remarks\n\t * \t\t- if the value set is the same as the current value, the change will not be fired\n\t *       - if the value is set before the initialization, the emit will be queued and will be fired after initialization\n\t * @param _id - The setting id\n\t * @param value - The value to set\n\t * @returns {void}\n\t */\n\tset(record: ISetting): void;\n\n\tgetConfig(config?: OverCustomSettingsConfig): SettingsConfig;\n\n\t/* @deprecated */\n\twatchByRegex(regex: RegExp, cb: (...args: [string, SettingValue]) => void, config?: OverCustomSettingsConfig): () => void;\n\n\t/* @deprecated */\n\tchangeByRegex(regex: RegExp, callback: (...args: [string, SettingValue]) => void, config?: OverCustomSettingsConfig): () => void;\n\n\t/*\n\t * @description: Wait until the settings get ready then run the callback\n\t */\n\tonReady(cb: () => void): void;\n}\n\n/**\n * Class responsible for setting up the settings, cache and propagation changes\n * Should be agnostic to the actual settings implementation, running on meteor or standalone\n *\n * You should not instantiate this class directly, only for testing purposes\n *\n * @extends Emitter\n * @alpha\n */\nexport class CachedSettings\n\textends Emitter<\n\t\t{\n\t\t\t'*': [string, SettingValue];\n\t\t} & {\n\t\t\tready: undefined;\n\t\t\t[k: string]: SettingValue;\n\t\t}\n\t>\n\timplements ICachedSettings\n{\n\tready = false;\n\n\tstore = new Map<string, ISetting>();\n\n\tinitilized(): void {\n\t\tif (this.ready) {\n\t\t\treturn;\n\t\t}\n\t\tthis.ready = true;\n\t\tthis.emit('ready');\n\t\tSystemLogger.debug('Settings initalized');\n\t}\n\n\t/*\n\t * returns if the setting is defined\n\t * @param _id - The setting id\n\t * @returns {boolean}\n\t */\n\tpublic has(_id: ISetting['_id']): boolean {\n\t\tif (!this.ready && warn) {\n\t\t\tSystemLogger.warn(`Settings not initialized yet. getting: ${_id}`);\n\t\t}\n\t\treturn this.store.has(_id);\n\t}\n\n\tpublic getSetting(_id: ISetting['_id']): ISetting | undefined {\n\t\tif (!this.ready && warn) {\n\t\t\tSystemLogger.warn(`Settings not initialized yet. getting: ${_id}`);\n\t\t}\n\t\treturn this.store.get(_id);\n\t}\n\n\t/*\n\t * Gets the current value of the setting\n\t * @remarks\n\t * \t\t- In development mode if you are trying to get the value of a setting that is not defined, it will give an warning, in theory it makes sense, there no reason to do that\n\t * \t\t- The setting's value will be cached in memory so it won't call the DB every time you fetch a particular setting\n\t * @param _id - The setting id\n\t * @returns {SettingValue} - The current value of the setting\n\t */\n\tpublic get<T extends SettingValue = SettingValue>(_id: ISetting['_id']): T {\n\t\tif (!this.ready && warn) {\n\t\t\tSystemLogger.warn(`Settings not initialized yet. getting: ${_id}`);\n\t\t}\n\t\treturn this.store.get(_id)?.value as T;\n\t}\n\n\t/*\n\t * Gets the current value of the setting\n\t * @remarks\n\t * \t\t- In development mode if you are trying to get the value of a setting that is not defined, it will give an warning, in theory it makes sense, there no reason to do that\n\t * @param _id - The setting id\n\t * @returns {SettingValue} - The current value of the setting\n\t *\n\t */\n\t/* @deprecated */\n\tpublic getByRegexp<T extends SettingValue = SettingValue>(_id: RegExp): [string, T][] {\n\t\tif (!this.ready && warn) {\n\t\t\tSystemLogger.warn(`Settings not initialized yet. getting: ${_id}`);\n\t\t}\n\n\t\treturn [...this.store.entries()].filter(([key]) => _id.test(key)).map(([key, setting]) => [key, setting.value]) as [string, T][];\n\t}\n\n\t/*\n\t * Get the current value of the settings, and keep track of changes\n\t * @remarks\n\t * \t\t- This callback is debounced\n\t *       - The callback is not fire until the settings got initialized\n\t * @param _ids - Array of setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\tpublic watchMultiple<T extends SettingValue = SettingValue>(_id: ISetting['_id'][], callback: (settings: T[]) => void): () => void {\n\t\tif (!this.ready) {\n\t\t\tconst cancel = new Set<() => void>();\n\n\t\t\tcancel.add(\n\t\t\t\tthis.once('ready', (): void => {\n\t\t\t\t\tcancel.clear();\n\t\t\t\t\tcancel.add(this.watchMultiple(_id, callback));\n\t\t\t\t}),\n\t\t\t);\n\t\t\treturn (): void => {\n\t\t\t\tcancel.forEach((fn) => fn());\n\t\t\t};\n\t\t}\n\n\t\tif (_id.every((id) => this.store.has(id))) {\n\t\t\tconst settings = _id.map((id) => this.store.get(id)?.value);\n\t\t\tcallback(settings as T[]);\n\t\t}\n\t\tconst mergeFunction = _.debounce((): void => {\n\t\t\tcallback(_id.map((id) => this.store.get(id)?.value) as T[]);\n\t\t}, 100);\n\n\t\tconst fns = _id.map((id) => this.on(id, mergeFunction));\n\t\treturn (): void => {\n\t\t\tfns.forEach((fn) => fn());\n\t\t};\n\t}\n\n\t/*\n\t * Get the current value of the setting, and keep track of changes\n\t * @remarks\n\t * \t\t- This callback is debounced\n\t *       - The callback is not fire until the settings got initialized\n\t * @param _id - The setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\tpublic watch<T extends SettingValue = SettingValue>(\n\t\t_id: ISetting['_id'],\n\t\tcb: (args: T) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void {\n\t\tif (!this.ready) {\n\t\t\tconst cancel = new Set<() => void>();\n\t\t\tcancel.add(\n\t\t\t\tthis.once('ready', (): void => {\n\t\t\t\t\tcancel.clear();\n\t\t\t\t\tcancel.add(this.watch(_id, cb, config));\n\t\t\t\t}),\n\t\t\t);\n\t\t\treturn (): void => {\n\t\t\t\tcancel.forEach((fn) => fn());\n\t\t\t};\n\t\t}\n\n\t\tthis.store.has(_id) && cb(this.store.get(_id)?.value as T);\n\t\treturn this.change(_id, cb, config);\n\t}\n\n\t/*\n\t * Get the current value of the setting, or wait until the initialized\n\t * @remarks\n\t * \t\t- This is a one time run\n\t * \t\t- This callback is debounced\n\t *       - The callback is not fire until the settings got initialized\n\t * @param _id - The setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\tpublic watchOnce<T extends SettingValue = SettingValue>(\n\t\t_id: ISetting['_id'],\n\t\tcb: (args: T) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void {\n\t\tif (this.store.has(_id)) {\n\t\t\tcb(this.store.get(_id)?.value as T);\n\t\t\treturn (): void => undefined;\n\t\t}\n\t\treturn this.changeOnce(_id, cb, config);\n\t}\n\n\t/*\n\t * Observes the given setting by id and keep track of changes\n\t * @remarks\n\t * \t\t- This callback is debounced\n\t *       - The callback is not fire until the setting is changed\n\t *       - The callback is not fire until all the settings get initialized\n\t * @param _id - The setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\tpublic change<T extends SettingValue = SettingValue>(\n\t\t_id: ISetting['_id'],\n\t\tcallback: (args: T) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void {\n\t\tconst { debounce } = this.getConfig(config);\n\t\treturn this.on(_id, _.debounce(callback, debounce) as any);\n\t}\n\n\t/*\n\t * Observes multiple settings and keep track of changes\n\t * @remarks\n\t * \t\t- This callback is debounced\n\t *       - The callback is not fire until the setting is changed\n\t *       - The callback is not fire until all the settings get initialized\n\t * @param _ids - Array of setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\tpublic changeMultiple<T extends SettingValue = SettingValue>(\n\t\t_ids: ISetting['_id'][],\n\t\tcallback: (settings: T[]) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void {\n\t\tconst fns = _ids.map((id) =>\n\t\t\tthis.change(\n\t\t\t\tid,\n\t\t\t\t(): void => {\n\t\t\t\t\tcallback(_ids.map((id) => this.store.get(id)?.value) as T[]);\n\t\t\t\t},\n\t\t\t\tconfig,\n\t\t\t),\n\t\t);\n\t\treturn (): void => {\n\t\t\tfns.forEach((fn) => fn());\n\t\t};\n\t}\n\n\t/*\n\t * Observes the setting and fires only if there is a change. Runs only once\n\t * @remarks\n\t * \t\t- This is a one time run\n\t * \t\t- This callback is debounced\n\t *       - The callback is not fire until the setting is changed\n\t *       - The callback is not fire until all the settings get initialized\n\t * @param _id - The setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\tpublic changeOnce<T extends SettingValue = SettingValue>(\n\t\t_id: ISetting['_id'],\n\t\tcallback: (args: T) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void {\n\t\tconst { debounce } = this.getConfig(config);\n\t\treturn this.once(_id, _.debounce(callback, debounce) as any);\n\t}\n\n\t/*\n\t * Sets the value of the setting\n\t * @remarks\n\t * \t\t- if the value set is the same as the current value, the change will not be fired\n\t *       - if the value is set before the initialization, the emit will be queued and will be fired after initialization\n\t * @param _id - The setting id\n\t * @param value - The value to set\n\t * @returns {void}\n\t */\n\tpublic set(record: ISetting): void {\n\t\tif (this.store.has(record._id) && this.store.get(record._id)?.value === record.value) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.store.set(record._id, record);\n\t\tif (!this.ready) {\n\t\t\tthis.once('ready', () => {\n\t\t\t\tthis.emit(record._id, this.store.get(record._id)?.value);\n\t\t\t\tthis.emit('*', [record._id, this.store.get(record._id)?.value]);\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\tthis.emit(record._id, this.store.get(record._id)?.value);\n\t\tthis.emit('*', [record._id, this.store.get(record._id)?.value]);\n\t}\n\n\tpublic getConfig = (config?: OverCustomSettingsConfig): SettingsConfig => ({\n\t\tdebounce: 500,\n\t\t...config,\n\t});\n\n\t/* @deprecated */\n\tpublic watchByRegex(regex: RegExp, cb: (...args: [string, SettingValue]) => void, config?: OverCustomSettingsConfig): () => void {\n\t\tif (!this.ready) {\n\t\t\tconst cancel = new Set<() => void>();\n\t\t\tcancel.add(\n\t\t\t\tthis.once('ready', (): void => {\n\t\t\t\t\tcancel.clear();\n\t\t\t\t\tcancel.add(this.watchByRegex(regex, cb, config));\n\t\t\t\t}),\n\t\t\t);\n\t\t\treturn (): void => {\n\t\t\t\tcancel.forEach((fn) => fn());\n\t\t\t};\n\t\t}\n\t\t[...this.store.entries()].forEach(([key, setting]) => {\n\t\t\tif (regex.test(key)) {\n\t\t\t\tcb(key, setting.value);\n\t\t\t}\n\t\t});\n\n\t\treturn this.changeByRegex(regex, cb, config);\n\t}\n\n\t/* @deprecated */\n\tpublic changeByRegex(regex: RegExp, callback: (...args: [string, SettingValue]) => void, config?: OverCustomSettingsConfig): () => void {\n\t\tconst store: Map<string, (...args: [string, SettingValue]) => void> = new Map();\n\t\treturn this.on('*', ([_id, value]) => {\n\t\t\tif (regex.test(_id)) {\n\t\t\t\tconst { debounce } = this.getConfig(config);\n\t\t\t\tconst cb = store.get(_id) || _.debounce(callback, debounce);\n\t\t\t\tcb(_id, value);\n\t\t\t\tstore.set(_id, cb);\n\t\t\t}\n\t\t\tregex.lastIndex = 0;\n\t\t});\n\t}\n\n\tpublic onReady(cb: () => void): void {\n\t\tif (this.ready) {\n\t\t\treturn cb();\n\t\t}\n\t\tthis.once('ready', cb);\n\t}\n}\n"],"sourceRoot":""},"sourceType":"module","hash":"d09a81bd7e12fe85c28c87a1e039435fdbc24435"}
