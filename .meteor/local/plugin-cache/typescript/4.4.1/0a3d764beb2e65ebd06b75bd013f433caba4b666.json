{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/weslley/Documents/projects/Rocket.Chat/app/apps/server/bridges/scheduler.ts","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"app/apps/server/bridges/scheduler.ts","filename":"/home/weslley/Documents/projects/Rocket.Chat/app/apps/server/bridges/scheduler.ts","inputSourceMap":{"version":3,"file":"app/apps/server/bridges/scheduler.ts","sourceRoot":"","sources":["app/apps/server/bridges/scheduler.ts"],"names":[],"mappings":"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","sourcesContent":["import Agenda from 'agenda';\nimport { ObjectID } from 'bson';\nimport { MongoInternals } from 'meteor/mongo';\nimport { StartupType, IProcessor, IOnetimeSchedule, IRecurringSchedule } from '@rocket.chat/apps-engine/definition/scheduler';\nimport { SchedulerBridge } from '@rocket.chat/apps-engine/server/bridges/SchedulerBridge';\n\nimport { AppServerOrchestrator } from '../orchestrator';\n\nfunction _callProcessor(processor: Function): (job: Agenda.Job) => void {\n\treturn (job): void => {\n\t\tconst data = job?.attrs?.data || {};\n\n\t\t// This field is for internal use, no need to leak to app processor\n\t\tdelete (data as any).appId;\n\n\t\tdata.jobId = job.attrs._id.toString();\n\n\t\treturn processor(data);\n\t};\n}\n\n/**\n * Provides the Apps Engine with task scheduling capabilities.\n * It uses {@link agenda:github.com/agenda/agenda} as backend\n */\nexport class AppSchedulerBridge extends SchedulerBridge {\n\tprivate isConnected: boolean;\n\n\tprivate scheduler: Agenda;\n\n\t// eslint-disable-next-line no-empty-function\n\tconstructor(private readonly orch: AppServerOrchestrator) {\n\t\tsuper();\n\t\tthis.scheduler = new Agenda({\n\t\t\tmongo: (MongoInternals.defaultRemoteCollectionDriver().mongo as any).client.db(),\n\t\t\tdb: { collection: 'rocketchat_apps_scheduler' },\n\t\t\t// this ensures the same job doesn't get executed multiple times in a cluster\n\t\t\tdefaultConcurrency: 1,\n\t\t});\n\t\tthis.isConnected = false;\n\t}\n\n\t/**\n\t * Entity that will be run in a job.\n\t * @typedef {Object} Processor\n\t * @property {string} id The processor's identifier\n\t * @property {function} processor The function that will be run on a given schedule\n\t * @property {IOnetimeStartup|IRecurrentStartup} [startupSetting] If provided, the processor will be configured with the setting as soon as it gets registered\n\n\t * Processor setting for running once after being registered\n\t * @typedef {Object} IOnetimeStartup\n\t * @property {string} type=onetime\n\t * @property {string} when When the processor will be executed\n\t * @property {Object} [data] An optional object that is passed to the processor\n\t *\n\t * Processor setting for running recurringly after being registered\n\t * @typedef {Object} IRecurrentStartup\n\t * @property {string} type=recurring\n\t * @property {string} interval When the processor will be re executed\n\t * @property {Object} [data] An optional object that is passed to the processor\n\t */\n\n\t/**\n\t * Register processors that can be scheduled to run\n\t *\n\t * @param {Array.<Processor>} processors An array of processors\n\t * @param {string} appId\n\t *\n\t * @returns {string[]} List of task ids run at startup, or void no startup run is set\n\t */\n\tprotected async registerProcessors(processors: Array<IProcessor> = [], appId: string): Promise<void | Array<string>> {\n\t\tconst runAfterRegister: Promise<string>[] = [];\n\t\tthis.orch.debugLog(`The App ${appId} is registering job processors`, processors);\n\t\tprocessors.forEach(({ id, processor, startupSetting }: IProcessor) => {\n\t\t\tthis.scheduler.define(id, _callProcessor(processor));\n\n\t\t\tif (!startupSetting) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tswitch (startupSetting.type) {\n\t\t\t\tcase StartupType.ONETIME:\n\t\t\t\t\trunAfterRegister.push(\n\t\t\t\t\t\tthis.scheduleOnceAfterRegister({ id, when: startupSetting.when, data: startupSetting.data }, appId) as Promise<string>,\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase StartupType.RECURRING:\n\t\t\t\t\trunAfterRegister.push(\n\t\t\t\t\t\tthis.scheduleRecurring(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\t\tinterval: startupSetting.interval,\n\t\t\t\t\t\t\t\tskipImmediate: startupSetting.skipImmediate,\n\t\t\t\t\t\t\t\tdata: startupSetting.data,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tappId,\n\t\t\t\t\t\t) as Promise<string>,\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.orch\n\t\t\t\t\t\t.getRocketChatLogger()\n\t\t\t\t\t\t.error(`Invalid startup setting type (${String((startupSetting as any).type)}) for the processor ${id}`);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\n\t\tif (runAfterRegister.length) {\n\t\t\treturn Promise.all(runAfterRegister) as Promise<Array<string>>;\n\t\t}\n\t}\n\n\t/**\n\t * Schedules a registered processor to run _once_.\n\t *\n\t * @param {Object} job\n\t * @param {string} job.id The processor's id\n\t * @param {string} job.when When the processor will be executed\n\t * @param {Object} [job.data] An optional object that is passed to the processor\n\t * @param {string} appId\n\t *\n\t * @returns {string} taskid\n\t */\n\tprotected async scheduleOnce({ id, when, data }: IOnetimeSchedule, appId: string): Promise<void | string> {\n\t\tthis.orch.debugLog(`The App ${appId} is scheduling an onetime job (processor ${id})`);\n\t\ttry {\n\t\t\tawait this.startScheduler();\n\t\t\tconst job = await this.scheduler.schedule(when, id, this.decorateJobData(data, appId));\n\t\t\treturn job.attrs._id.toString();\n\t\t} catch (e) {\n\t\t\tthis.orch.getRocketChatLogger().error(e);\n\t\t}\n\t}\n\n\tprivate async scheduleOnceAfterRegister(job: IOnetimeSchedule, appId: string): Promise<void | string> {\n\t\tconst scheduledJobs = await this.scheduler.jobs({ name: job.id, type: 'normal' });\n\t\tif (!scheduledJobs.length) {\n\t\t\treturn this.scheduleOnce(job, appId);\n\t\t}\n\t}\n\n\t/**\n\t * Schedules a registered processor to run recurrently according to a given interval.\n\t *\n\t * @param {Object} job\n\t * @param {string} job.id The processor's id\n\t * @param {string} job.interval When the processor will be re executed\n\t * @param {boolean} job.skipImmediate=false Whether to let the first iteration to execute as soon as the task is registered\n\t * @param {Object} [job.data] An optional object that is passed to the processor\n\t * @param {string} appId\n\t *\n\t * @returns {string} taskid\n\t */\n\tprotected async scheduleRecurring(\n\t\t{ id, interval, skipImmediate = false, data }: IRecurringSchedule,\n\t\tappId: string,\n\t): Promise<void | string> {\n\t\tthis.orch.debugLog(`The App ${appId} is scheduling a recurring job (processor ${id})`);\n\t\ttry {\n\t\t\tawait this.startScheduler();\n\t\t\tconst job = await this.scheduler.every(interval, id, this.decorateJobData(data, appId), {\n\t\t\t\tskipImmediate,\n\t\t\t});\n\t\t\treturn job.attrs._id.toString();\n\t\t} catch (e) {\n\t\t\tthis.orch.getRocketChatLogger().error(e);\n\t\t}\n\t}\n\n\t/**\n\t * Cancels a running job given its jobId\n\t *\n\t * @param {string} jobId\n\t * @param {string} appId\n\t *\n\t * @returns Promise<void>\n\t */\n\tprotected async cancelJob(jobId: string, appId: string): Promise<void> {\n\t\tthis.orch.debugLog(`The App ${appId} is canceling a job`, jobId);\n\t\tawait this.startScheduler();\n\n\t\tlet cancelQuery;\n\t\ttry {\n\t\t\tcancelQuery = { _id: new ObjectID(jobId.split('_')[0]) };\n\t\t} catch (jobDocIdError) {\n\t\t\t// it is not a valid objectid, so it won't try to cancel by document id\n\t\t\tcancelQuery = { name: jobId };\n\t\t}\n\n\t\ttry {\n\t\t\tawait this.scheduler.cancel(cancelQuery);\n\t\t} catch (e) {\n\t\t\tthis.orch.getRocketChatLogger().error(e);\n\t\t}\n\t}\n\n\t/**\n\t * Cancels all the running jobs from the app\n\t *\n\t * @param {string} appId\n\t *\n\t * @returns Promise<void>\n\t */\n\tprotected async cancelAllJobs(appId: string): Promise<void> {\n\t\tthis.orch.debugLog(`Canceling all jobs of App ${appId}`);\n\t\tawait this.startScheduler();\n\t\tconst matcher = new RegExp(`_${appId}$`);\n\t\ttry {\n\t\t\tawait this.scheduler.cancel({ name: { $regex: matcher } });\n\t\t} catch (e) {\n\t\t\tthis.orch.getRocketChatLogger().error(e);\n\t\t}\n\t}\n\n\tpublic async startScheduler(): Promise<void> {\n\t\tif (!this.isConnected) {\n\t\t\tawait this.scheduler.start();\n\t\t\tthis.isConnected = true;\n\t\t}\n\t}\n\n\tprivate decorateJobData(jobData: object | undefined, appId: string): object {\n\t\treturn Object.assign({}, jobData, { appId });\n\t}\n}\n"]},"targets":{"android":"95.0.0","chrome":"95.0.0","edge":"95.0.0","firefox":"78.0.0","ie":"10.0.0","ios":"15.0.0","opera":"81.0.0","safari":"15.1.0","samsung":"14.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/home/weslley/Documents/projects/Rocket.Chat","root":"/home/weslley/Documents/projects/Rocket.Chat","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.16.5","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/home/weslley/Documents/projects/Rocket.Chat/app/apps/server/bridges/scheduler.ts","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"app/apps/server/bridges/scheduler.ts"}},"code":"module.export({\n  AppSchedulerBridge: () => AppSchedulerBridge\n});\nlet Agenda;\nmodule.link(\"agenda\", {\n  default(v) {\n    Agenda = v;\n  }\n\n}, 0);\nlet ObjectID;\nmodule.link(\"bson\", {\n  ObjectID(v) {\n    ObjectID = v;\n  }\n\n}, 1);\nlet MongoInternals;\nmodule.link(\"meteor/mongo\", {\n  MongoInternals(v) {\n    MongoInternals = v;\n  }\n\n}, 2);\nlet StartupType;\nmodule.link(\"@rocket.chat/apps-engine/definition/scheduler\", {\n  StartupType(v) {\n    StartupType = v;\n  }\n\n}, 3);\nlet SchedulerBridge;\nmodule.link(\"@rocket.chat/apps-engine/server/bridges/SchedulerBridge\", {\n  SchedulerBridge(v) {\n    SchedulerBridge = v;\n  }\n\n}, 4);\n\nfunction _callProcessor(processor) {\n  return job => {\n    var _job$attrs;\n\n    const data = (job === null || job === void 0 ? void 0 : (_job$attrs = job.attrs) === null || _job$attrs === void 0 ? void 0 : _job$attrs.data) || {}; // This field is for internal use, no need to leak to app processor\n\n    delete data.appId;\n    data.jobId = job.attrs._id.toString();\n    return processor(data);\n  };\n}\n/**\n * Provides the Apps Engine with task scheduling capabilities.\n * It uses {@link agenda:github.com/agenda/agenda} as backend\n */\n\n\nclass AppSchedulerBridge extends SchedulerBridge {\n  // eslint-disable-next-line no-empty-function\n  constructor(orch) {\n    super();\n    this.orch = void 0;\n    this.isConnected = void 0;\n    this.scheduler = void 0;\n    this.orch = orch;\n    this.scheduler = new Agenda({\n      mongo: MongoInternals.defaultRemoteCollectionDriver().mongo.client.db(),\n      db: {\n        collection: 'rocketchat_apps_scheduler'\n      },\n      // this ensures the same job doesn't get executed multiple times in a cluster\n      defaultConcurrency: 1\n    });\n    this.isConnected = false;\n  }\n  /**\n   * Entity that will be run in a job.\n   * @typedef {Object} Processor\n   * @property {string} id The processor's identifier\n   * @property {function} processor The function that will be run on a given schedule\n   * @property {IOnetimeStartup|IRecurrentStartup} [startupSetting] If provided, the processor will be configured with the setting as soon as it gets registered\n    * Processor setting for running once after being registered\n   * @typedef {Object} IOnetimeStartup\n   * @property {string} type=onetime\n   * @property {string} when When the processor will be executed\n   * @property {Object} [data] An optional object that is passed to the processor\n   *\n   * Processor setting for running recurringly after being registered\n   * @typedef {Object} IRecurrentStartup\n   * @property {string} type=recurring\n   * @property {string} interval When the processor will be re executed\n   * @property {Object} [data] An optional object that is passed to the processor\n   */\n\n  /**\n   * Register processors that can be scheduled to run\n   *\n   * @param {Array.<Processor>} processors An array of processors\n   * @param {string} appId\n   *\n   * @returns {string[]} List of task ids run at startup, or void no startup run is set\n   */\n\n\n  registerProcessors() {\n    return Promise.asyncApply(() => {\n      let processors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      let appId = arguments.length > 1 ? arguments[1] : undefined;\n      const runAfterRegister = [];\n      this.orch.debugLog(\"The App \".concat(appId, \" is registering job processors\"), processors);\n      processors.forEach(_ref => {\n        let {\n          id,\n          processor,\n          startupSetting\n        } = _ref;\n        this.scheduler.define(id, _callProcessor(processor));\n\n        if (!startupSetting) {\n          return;\n        }\n\n        switch (startupSetting.type) {\n          case StartupType.ONETIME:\n            runAfterRegister.push(this.scheduleOnceAfterRegister({\n              id,\n              when: startupSetting.when,\n              data: startupSetting.data\n            }, appId));\n            break;\n\n          case StartupType.RECURRING:\n            runAfterRegister.push(this.scheduleRecurring({\n              id,\n              interval: startupSetting.interval,\n              skipImmediate: startupSetting.skipImmediate,\n              data: startupSetting.data\n            }, appId));\n            break;\n\n          default:\n            this.orch.getRocketChatLogger().error(\"Invalid startup setting type (\".concat(String(startupSetting.type), \") for the processor \").concat(id));\n            break;\n        }\n      });\n\n      if (runAfterRegister.length) {\n        return Promise.all(runAfterRegister);\n      }\n    });\n  }\n  /**\n   * Schedules a registered processor to run _once_.\n   *\n   * @param {Object} job\n   * @param {string} job.id The processor's id\n   * @param {string} job.when When the processor will be executed\n   * @param {Object} [job.data] An optional object that is passed to the processor\n   * @param {string} appId\n   *\n   * @returns {string} taskid\n   */\n\n\n  scheduleOnce(_ref2, appId) {\n    return Promise.asyncApply(() => {\n      let {\n        id,\n        when,\n        data\n      } = _ref2;\n      this.orch.debugLog(\"The App \".concat(appId, \" is scheduling an onetime job (processor \").concat(id, \")\"));\n\n      try {\n        Promise.await(this.startScheduler());\n        const job = Promise.await(this.scheduler.schedule(when, id, this.decorateJobData(data, appId)));\n        return job.attrs._id.toString();\n      } catch (e) {\n        this.orch.getRocketChatLogger().error(e);\n      }\n    });\n  }\n\n  scheduleOnceAfterRegister(job, appId) {\n    return Promise.asyncApply(() => {\n      const scheduledJobs = Promise.await(this.scheduler.jobs({\n        name: job.id,\n        type: 'normal'\n      }));\n\n      if (!scheduledJobs.length) {\n        return this.scheduleOnce(job, appId);\n      }\n    });\n  }\n  /**\n   * Schedules a registered processor to run recurrently according to a given interval.\n   *\n   * @param {Object} job\n   * @param {string} job.id The processor's id\n   * @param {string} job.interval When the processor will be re executed\n   * @param {boolean} job.skipImmediate=false Whether to let the first iteration to execute as soon as the task is registered\n   * @param {Object} [job.data] An optional object that is passed to the processor\n   * @param {string} appId\n   *\n   * @returns {string} taskid\n   */\n\n\n  scheduleRecurring(_ref3, appId) {\n    return Promise.asyncApply(() => {\n      let {\n        id,\n        interval,\n        skipImmediate = false,\n        data\n      } = _ref3;\n      this.orch.debugLog(\"The App \".concat(appId, \" is scheduling a recurring job (processor \").concat(id, \")\"));\n\n      try {\n        Promise.await(this.startScheduler());\n        const job = Promise.await(this.scheduler.every(interval, id, this.decorateJobData(data, appId), {\n          skipImmediate\n        }));\n        return job.attrs._id.toString();\n      } catch (e) {\n        this.orch.getRocketChatLogger().error(e);\n      }\n    });\n  }\n  /**\n   * Cancels a running job given its jobId\n   *\n   * @param {string} jobId\n   * @param {string} appId\n   *\n   * @returns Promise<void>\n   */\n\n\n  cancelJob(jobId, appId) {\n    return Promise.asyncApply(() => {\n      this.orch.debugLog(\"The App \".concat(appId, \" is canceling a job\"), jobId);\n      Promise.await(this.startScheduler());\n      let cancelQuery;\n\n      try {\n        cancelQuery = {\n          _id: new ObjectID(jobId.split('_')[0])\n        };\n      } catch (jobDocIdError) {\n        // it is not a valid objectid, so it won't try to cancel by document id\n        cancelQuery = {\n          name: jobId\n        };\n      }\n\n      try {\n        Promise.await(this.scheduler.cancel(cancelQuery));\n      } catch (e) {\n        this.orch.getRocketChatLogger().error(e);\n      }\n    });\n  }\n  /**\n   * Cancels all the running jobs from the app\n   *\n   * @param {string} appId\n   *\n   * @returns Promise<void>\n   */\n\n\n  cancelAllJobs(appId) {\n    return Promise.asyncApply(() => {\n      this.orch.debugLog(\"Canceling all jobs of App \".concat(appId));\n      Promise.await(this.startScheduler());\n      const matcher = new RegExp(\"_\".concat(appId, \"$\"));\n\n      try {\n        Promise.await(this.scheduler.cancel({\n          name: {\n            $regex: matcher\n          }\n        }));\n      } catch (e) {\n        this.orch.getRocketChatLogger().error(e);\n      }\n    });\n  }\n\n  startScheduler() {\n    return Promise.asyncApply(() => {\n      if (!this.isConnected) {\n        Promise.await(this.scheduler.start());\n        this.isConnected = true;\n      }\n    });\n  }\n\n  decorateJobData(jobData, appId) {\n    return Object.assign({}, jobData, {\n      appId\n    });\n  }\n\n}","map":{"version":3,"sources":["app/apps/server/bridges/scheduler.ts"],"names":[],"mappings":"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","sourcesContent":["import Agenda from 'agenda';\nimport { ObjectID } from 'bson';\nimport { MongoInternals } from 'meteor/mongo';\nimport { StartupType, IProcessor, IOnetimeSchedule, IRecurringSchedule } from '@rocket.chat/apps-engine/definition/scheduler';\nimport { SchedulerBridge } from '@rocket.chat/apps-engine/server/bridges/SchedulerBridge';\n\nimport { AppServerOrchestrator } from '../orchestrator';\n\nfunction _callProcessor(processor: Function): (job: Agenda.Job) => void {\n\treturn (job): void => {\n\t\tconst data = job?.attrs?.data || {};\n\n\t\t// This field is for internal use, no need to leak to app processor\n\t\tdelete (data as any).appId;\n\n\t\tdata.jobId = job.attrs._id.toString();\n\n\t\treturn processor(data);\n\t};\n}\n\n/**\n * Provides the Apps Engine with task scheduling capabilities.\n * It uses {@link agenda:github.com/agenda/agenda} as backend\n */\nexport class AppSchedulerBridge extends SchedulerBridge {\n\tprivate isConnected: boolean;\n\n\tprivate scheduler: Agenda;\n\n\t// eslint-disable-next-line no-empty-function\n\tconstructor(private readonly orch: AppServerOrchestrator) {\n\t\tsuper();\n\t\tthis.scheduler = new Agenda({\n\t\t\tmongo: (MongoInternals.defaultRemoteCollectionDriver().mongo as any).client.db(),\n\t\t\tdb: { collection: 'rocketchat_apps_scheduler' },\n\t\t\t// this ensures the same job doesn't get executed multiple times in a cluster\n\t\t\tdefaultConcurrency: 1,\n\t\t});\n\t\tthis.isConnected = false;\n\t}\n\n\t/**\n\t * Entity that will be run in a job.\n\t * @typedef {Object} Processor\n\t * @property {string} id The processor's identifier\n\t * @property {function} processor The function that will be run on a given schedule\n\t * @property {IOnetimeStartup|IRecurrentStartup} [startupSetting] If provided, the processor will be configured with the setting as soon as it gets registered\n\n\t * Processor setting for running once after being registered\n\t * @typedef {Object} IOnetimeStartup\n\t * @property {string} type=onetime\n\t * @property {string} when When the processor will be executed\n\t * @property {Object} [data] An optional object that is passed to the processor\n\t *\n\t * Processor setting for running recurringly after being registered\n\t * @typedef {Object} IRecurrentStartup\n\t * @property {string} type=recurring\n\t * @property {string} interval When the processor will be re executed\n\t * @property {Object} [data] An optional object that is passed to the processor\n\t */\n\n\t/**\n\t * Register processors that can be scheduled to run\n\t *\n\t * @param {Array.<Processor>} processors An array of processors\n\t * @param {string} appId\n\t *\n\t * @returns {string[]} List of task ids run at startup, or void no startup run is set\n\t */\n\tprotected async registerProcessors(processors: Array<IProcessor> = [], appId: string): Promise<void | Array<string>> {\n\t\tconst runAfterRegister: Promise<string>[] = [];\n\t\tthis.orch.debugLog(`The App ${appId} is registering job processors`, processors);\n\t\tprocessors.forEach(({ id, processor, startupSetting }: IProcessor) => {\n\t\t\tthis.scheduler.define(id, _callProcessor(processor));\n\n\t\t\tif (!startupSetting) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tswitch (startupSetting.type) {\n\t\t\t\tcase StartupType.ONETIME:\n\t\t\t\t\trunAfterRegister.push(\n\t\t\t\t\t\tthis.scheduleOnceAfterRegister({ id, when: startupSetting.when, data: startupSetting.data }, appId) as Promise<string>,\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase StartupType.RECURRING:\n\t\t\t\t\trunAfterRegister.push(\n\t\t\t\t\t\tthis.scheduleRecurring(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\t\tinterval: startupSetting.interval,\n\t\t\t\t\t\t\t\tskipImmediate: startupSetting.skipImmediate,\n\t\t\t\t\t\t\t\tdata: startupSetting.data,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tappId,\n\t\t\t\t\t\t) as Promise<string>,\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.orch\n\t\t\t\t\t\t.getRocketChatLogger()\n\t\t\t\t\t\t.error(`Invalid startup setting type (${String((startupSetting as any).type)}) for the processor ${id}`);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\n\t\tif (runAfterRegister.length) {\n\t\t\treturn Promise.all(runAfterRegister) as Promise<Array<string>>;\n\t\t}\n\t}\n\n\t/**\n\t * Schedules a registered processor to run _once_.\n\t *\n\t * @param {Object} job\n\t * @param {string} job.id The processor's id\n\t * @param {string} job.when When the processor will be executed\n\t * @param {Object} [job.data] An optional object that is passed to the processor\n\t * @param {string} appId\n\t *\n\t * @returns {string} taskid\n\t */\n\tprotected async scheduleOnce({ id, when, data }: IOnetimeSchedule, appId: string): Promise<void | string> {\n\t\tthis.orch.debugLog(`The App ${appId} is scheduling an onetime job (processor ${id})`);\n\t\ttry {\n\t\t\tawait this.startScheduler();\n\t\t\tconst job = await this.scheduler.schedule(when, id, this.decorateJobData(data, appId));\n\t\t\treturn job.attrs._id.toString();\n\t\t} catch (e) {\n\t\t\tthis.orch.getRocketChatLogger().error(e);\n\t\t}\n\t}\n\n\tprivate async scheduleOnceAfterRegister(job: IOnetimeSchedule, appId: string): Promise<void | string> {\n\t\tconst scheduledJobs = await this.scheduler.jobs({ name: job.id, type: 'normal' });\n\t\tif (!scheduledJobs.length) {\n\t\t\treturn this.scheduleOnce(job, appId);\n\t\t}\n\t}\n\n\t/**\n\t * Schedules a registered processor to run recurrently according to a given interval.\n\t *\n\t * @param {Object} job\n\t * @param {string} job.id The processor's id\n\t * @param {string} job.interval When the processor will be re executed\n\t * @param {boolean} job.skipImmediate=false Whether to let the first iteration to execute as soon as the task is registered\n\t * @param {Object} [job.data] An optional object that is passed to the processor\n\t * @param {string} appId\n\t *\n\t * @returns {string} taskid\n\t */\n\tprotected async scheduleRecurring(\n\t\t{ id, interval, skipImmediate = false, data }: IRecurringSchedule,\n\t\tappId: string,\n\t): Promise<void | string> {\n\t\tthis.orch.debugLog(`The App ${appId} is scheduling a recurring job (processor ${id})`);\n\t\ttry {\n\t\t\tawait this.startScheduler();\n\t\t\tconst job = await this.scheduler.every(interval, id, this.decorateJobData(data, appId), {\n\t\t\t\tskipImmediate,\n\t\t\t});\n\t\t\treturn job.attrs._id.toString();\n\t\t} catch (e) {\n\t\t\tthis.orch.getRocketChatLogger().error(e);\n\t\t}\n\t}\n\n\t/**\n\t * Cancels a running job given its jobId\n\t *\n\t * @param {string} jobId\n\t * @param {string} appId\n\t *\n\t * @returns Promise<void>\n\t */\n\tprotected async cancelJob(jobId: string, appId: string): Promise<void> {\n\t\tthis.orch.debugLog(`The App ${appId} is canceling a job`, jobId);\n\t\tawait this.startScheduler();\n\n\t\tlet cancelQuery;\n\t\ttry {\n\t\t\tcancelQuery = { _id: new ObjectID(jobId.split('_')[0]) };\n\t\t} catch (jobDocIdError) {\n\t\t\t// it is not a valid objectid, so it won't try to cancel by document id\n\t\t\tcancelQuery = { name: jobId };\n\t\t}\n\n\t\ttry {\n\t\t\tawait this.scheduler.cancel(cancelQuery);\n\t\t} catch (e) {\n\t\t\tthis.orch.getRocketChatLogger().error(e);\n\t\t}\n\t}\n\n\t/**\n\t * Cancels all the running jobs from the app\n\t *\n\t * @param {string} appId\n\t *\n\t * @returns Promise<void>\n\t */\n\tprotected async cancelAllJobs(appId: string): Promise<void> {\n\t\tthis.orch.debugLog(`Canceling all jobs of App ${appId}`);\n\t\tawait this.startScheduler();\n\t\tconst matcher = new RegExp(`_${appId}$`);\n\t\ttry {\n\t\t\tawait this.scheduler.cancel({ name: { $regex: matcher } });\n\t\t} catch (e) {\n\t\t\tthis.orch.getRocketChatLogger().error(e);\n\t\t}\n\t}\n\n\tpublic async startScheduler(): Promise<void> {\n\t\tif (!this.isConnected) {\n\t\t\tawait this.scheduler.start();\n\t\t\tthis.isConnected = true;\n\t\t}\n\t}\n\n\tprivate decorateJobData(jobData: object | undefined, appId: string): object {\n\t\treturn Object.assign({}, jobData, { appId });\n\t}\n}\n"],"sourceRoot":""},"sourceType":"module","hash":"0a3d764beb2e65ebd06b75bd013f433caba4b666"}
