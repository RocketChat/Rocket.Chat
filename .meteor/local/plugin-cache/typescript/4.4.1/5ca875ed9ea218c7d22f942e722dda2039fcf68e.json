{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/weslley/Documents/projects/Rocket.Chat/ee/server/lib/ldap/Manager.ts","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"ee/server/lib/ldap/Manager.ts","filename":"/home/weslley/Documents/projects/Rocket.Chat/ee/server/lib/ldap/Manager.ts","inputSourceMap":{"version":3,"file":"ee/server/lib/ldap/Manager.ts","sourceRoot":"","sources":["ee/server/lib/ldap/Manager.ts"],"names":[],"mappings":"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","sourcesContent":["import _ from 'underscore';\nimport type ldapjs from 'ldapjs';\n\nimport { ILDAPEntry } from '../../../../definition/ldap/ILDAPEntry';\nimport type { IUser } from '../../../../definition/IUser';\nimport type { IRoom, ICreatedRoom } from '../../../../definition/IRoom';\nimport type { IRole } from '../../../../definition/IRole';\nimport { IImportUser } from '../../../../definition/IImportUser';\nimport { ImporterAfterImportCallback } from '../../../../app/importer/server/definitions/IConversionCallbacks';\nimport { settings } from '../../../../app/settings/server';\nimport { Rooms } from '../../../../app/models/server';\nimport { Users as UsersRaw, Roles, Subscriptions as SubscriptionsRaw } from '../../../../app/models/server/raw';\nimport { LDAPDataConverter } from '../../../../server/lib/ldap/DataConverter';\nimport { LDAPConnection } from '../../../../server/lib/ldap/Connection';\nimport { LDAPManager } from '../../../../server/lib/ldap/Manager';\nimport { logger, searchLogger, mapLogger } from '../../../../server/lib/ldap/Logger';\nimport { templateVarHandler } from '../../../../app/utils/lib/templateVarHandler';\nimport { addUserToRoom, removeUserFromRoom, createRoom } from '../../../../app/lib/server/functions';\nimport { syncUserRoles } from '../syncUserRoles';\nimport { Team } from '../../../../server/sdk';\n\nexport class LDAPEEManager extends LDAPManager {\n\tpublic static async sync(): Promise<void> {\n\t\tif (settings.get('LDAP_Enable') !== true || settings.get('LDAP_Background_Sync') !== true) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst createNewUsers = settings.get<boolean>('LDAP_Background_Sync_Import_New_Users') ?? true;\n\t\tconst updateExistingUsers = settings.get<boolean>('LDAP_Background_Sync_Keep_Existant_Users_Updated') ?? true;\n\n\t\tconst options = this.getConverterOptions();\n\t\toptions.skipExistingUsers = !updateExistingUsers;\n\n\t\tconst ldap = new LDAPConnection();\n\t\tconst converter = new LDAPDataConverter(true, options);\n\n\t\ttry {\n\t\t\tawait ldap.connect();\n\n\t\t\tif (createNewUsers) {\n\t\t\t\tawait this.importNewUsers(ldap, converter);\n\t\t\t} else if (updateExistingUsers) {\n\t\t\t\tawait this.updateExistingUsers(ldap, converter);\n\t\t\t}\n\n\t\t\tconverter.convertUsers({\n\t\t\t\tafterImportFn: ((data: IImportUser, _type: string, isNewRecord: boolean): void =>\n\t\t\t\t\tPromise.await(this.advancedSync(ldap, data, converter, isNewRecord))) as ImporterAfterImportCallback,\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error(error);\n\t\t}\n\n\t\tldap.disconnect();\n\t}\n\n\tpublic static async syncAvatars(): Promise<void> {\n\t\tif (settings.get('LDAP_Enable') !== true || settings.get('LDAP_Background_Sync_Avatars') !== true) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tconst ldap = new LDAPConnection();\n\t\t\tawait ldap.connect();\n\n\t\t\ttry {\n\t\t\t\tawait this.updateUserAvatars(ldap);\n\t\t\t} finally {\n\t\t\t\tldap.disconnect();\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.error(error);\n\t\t}\n\t}\n\n\tpublic static validateLDAPTeamsMappingChanges(json: string): void {\n\t\tif (!json) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst mustBeAnArrayOfStrings = (array: Array<string>): boolean =>\n\t\t\tBoolean(Array.isArray(array) && array.length && array.every((item) => typeof item === 'string'));\n\t\tconst mappedTeams = this.parseJson(json);\n\t\tif (!mappedTeams) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst mappedRocketChatTeams = Object.values(mappedTeams);\n\t\tconst validStructureMapping = mappedRocketChatTeams.every(mustBeAnArrayOfStrings);\n\t\tif (!validStructureMapping) {\n\t\t\tthrow new Error(\n\t\t\t\t'Please verify your mapping for LDAP X RocketChat Teams. The structure is invalid, the structure should be an object like: {key: LdapTeam, value: [An array of rocket.chat teams]}',\n\t\t\t);\n\t\t}\n\t}\n\n\tpublic static async syncLogout(): Promise<void> {\n\t\tif (settings.get('LDAP_Enable') !== true || settings.get('LDAP_Sync_AutoLogout_Enabled') !== true) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tconst ldap = new LDAPConnection();\n\t\t\tawait ldap.connect();\n\n\t\t\ttry {\n\t\t\t\tawait this.logoutDeactivatedUsers(ldap);\n\t\t\t} finally {\n\t\t\t\tldap.disconnect();\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.error(error);\n\t\t}\n\t}\n\n\tpublic static async advancedSyncForUser(ldap: LDAPConnection, user: IUser, isNewRecord: boolean, dn: string): Promise<void> {\n\t\ttry {\n\t\t\tawait this.syncUserRoles(ldap, user, dn);\n\t\t\tawait this.syncUserChannels(ldap, user, dn);\n\t\t\tawait this.syncUserTeams(ldap, user, dn, isNewRecord);\n\t\t} catch (e) {\n\t\t\tlogger.debug(`Advanced Sync failed for user: ${dn}`);\n\t\t\tlogger.error(e);\n\t\t}\n\t}\n\n\tprivate static async advancedSync(\n\t\tldap: LDAPConnection,\n\t\timportUser: IImportUser,\n\t\tconverter: LDAPDataConverter,\n\t\tisNewRecord: boolean,\n\t): Promise<void> {\n\t\tconst user = converter.findExistingUser(importUser);\n\t\tif (!user?.username) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst dn = importUser.importIds[0];\n\t\treturn this.advancedSyncForUser(ldap, user, isNewRecord, dn);\n\t}\n\n\tprivate static async isUserInGroup(\n\t\tldap: LDAPConnection,\n\t\tbaseDN: string,\n\t\tfilter: string,\n\t\t{ dn, username }: { dn: string; username: string },\n\t\tgroupName: string,\n\t): Promise<boolean> {\n\t\tif (!filter || !baseDN) {\n\t\t\tlogger.error('Please setup LDAP Group Filter and LDAP Group BaseDN in LDAP Settings.');\n\t\t\treturn false;\n\t\t}\n\t\tconst searchOptions: ldapjs.SearchOptions = {\n\t\t\tfilter: filter\n\t\t\t\t.replace(/#{username}/g, username)\n\t\t\t\t.replace(/#{groupName}/g, groupName)\n\t\t\t\t.replace(/#{userdn}/g, dn),\n\t\t\tscope: 'sub',\n\t\t};\n\n\t\tconst result = await ldap.searchRaw(baseDN, searchOptions);\n\n\t\tif (!Array.isArray(result) || result.length === 0) {\n\t\t\tlogger.debug(`${username} is not in ${groupName} group!!!`);\n\t\t} else {\n\t\t\tlogger.debug(`${username} is in ${groupName} group.`);\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate static parseJson(json: string): Record<string, any> | undefined {\n\t\ttry {\n\t\t\treturn JSON.parse(json);\n\t\t} catch (err) {\n\t\t\tlogger.error(`Unexpected error : ${err.message}`);\n\t\t}\n\t}\n\n\tprivate static async syncUserRoles(ldap: LDAPConnection, user: IUser, dn: string): Promise<void> {\n\t\tconst { username } = user;\n\t\tif (!username) {\n\t\t\tlogger.debug('User has no username');\n\t\t\treturn;\n\t\t}\n\n\t\tconst shouldSyncUserRoles = settings.get<boolean>('LDAP_Sync_User_Data_Roles') ?? false;\n\t\tconst syncUserRolesAutoRemove = settings.get<boolean>('LDAP_Sync_User_Data_Roles_AutoRemove') ?? false;\n\t\tconst syncUserRolesFieldMap = (settings.get<string>('LDAP_Sync_User_Data_RolesMap') ?? '').trim();\n\t\tconst syncUserRolesFilter = (settings.get<string>('LDAP_Sync_User_Data_Roles_Filter') ?? '').trim();\n\t\tconst syncUserRolesBaseDN = (settings.get<string>('LDAP_Sync_User_Data_Roles_BaseDN') ?? '').trim();\n\n\t\tif (!shouldSyncUserRoles || !syncUserRolesFieldMap) {\n\t\t\tlogger.debug('not syncing user roles');\n\t\t\treturn;\n\t\t}\n\n\t\tconst roles = (await Roles.find(\n\t\t\t{},\n\t\t\t{\n\t\t\t\tprojection: {\n\t\t\t\t\t_updatedAt: 0,\n\t\t\t\t},\n\t\t\t},\n\t\t).toArray()) as Array<IRole>;\n\n\t\tif (!roles) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst fieldMap = this.parseJson(syncUserRolesFieldMap);\n\t\tif (!fieldMap) {\n\t\t\tlogger.debug('missing group role mapping');\n\t\t\treturn;\n\t\t}\n\n\t\tconst ldapFields = Object.keys(fieldMap);\n\t\tconst roleList: Array<IRole['_id']> = [];\n\t\tconst allowedRoles: Array<IRole['_id']> = [];\n\n\t\tfor await (const ldapField of ldapFields) {\n\t\t\tif (!fieldMap[ldapField]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst userField = fieldMap[ldapField];\n\t\t\tconst [roleId] = userField.split(/\\.(.+)/);\n\t\t\tallowedRoles.push(roleId);\n\n\t\t\tif (await this.isUserInGroup(ldap, syncUserRolesBaseDN, syncUserRolesFilter, { dn, username }, ldapField)) {\n\t\t\t\troleList.push(roleId);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tawait syncUserRoles(user._id, roleList, {\n\t\t\tallowedRoles,\n\t\t\tskipRemovingRoles: !syncUserRolesAutoRemove,\n\t\t});\n\t}\n\n\tprivate static createRoomForSync(channel: string): IRoom | undefined {\n\t\tlogger.debug(`Channel '${channel}' doesn't exist, creating it.`);\n\n\t\tconst roomOwner = settings.get<string>('LDAP_Sync_User_Data_Channels_Admin') || '';\n\t\t// #ToDo: Remove typecastings when createRoom is converted to ts.\n\t\tconst room = createRoom('c', channel, roomOwner, [], false, {\n\t\t\tcustomFields: { ldap: true },\n\t\t} as any) as unknown as ICreatedRoom | undefined;\n\t\tif (!room?.rid) {\n\t\t\tlogger.error(`Unable to auto-create channel '${channel}' during ldap sync.`);\n\t\t\treturn;\n\t\t}\n\n\t\troom._id = room.rid;\n\t\treturn room;\n\t}\n\n\tprivate static async syncUserChannels(ldap: LDAPConnection, user: IUser, dn: string): Promise<void> {\n\t\tconst syncUserChannels = settings.get<boolean>('LDAP_Sync_User_Data_Channels') ?? false;\n\t\tconst syncUserChannelsRemove = settings.get<boolean>('LDAP_Sync_User_Data_Channels_Enforce_AutoChannels') ?? false;\n\t\tconst syncUserChannelsFieldMap = (settings.get<string>('LDAP_Sync_User_Data_ChannelsMap') ?? '').trim();\n\t\tconst syncUserChannelsFilter = (settings.get<string>('LDAP_Sync_User_Data_Channels_Filter') ?? '').trim();\n\t\tconst syncUserChannelsBaseDN = (settings.get<string>('LDAP_Sync_User_Data_Channels_BaseDN') ?? '').trim();\n\n\t\tif (!syncUserChannels || !syncUserChannelsFieldMap) {\n\t\t\tlogger.debug('not syncing groups to channels');\n\t\t\treturn;\n\t\t}\n\n\t\tconst fieldMap = this.parseJson(syncUserChannelsFieldMap);\n\t\tif (!fieldMap) {\n\t\t\tlogger.debug('missing group channel mapping');\n\t\t\treturn;\n\t\t}\n\n\t\tconst { username } = user;\n\t\tif (!username) {\n\t\t\treturn;\n\t\t}\n\n\t\tlogger.debug('syncing user channels');\n\t\tconst ldapFields = Object.keys(fieldMap);\n\n\t\tfor await (const ldapField of ldapFields) {\n\t\t\tif (!fieldMap[ldapField]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst isUserInGroup = await this.isUserInGroup(ldap, syncUserChannelsBaseDN, syncUserChannelsFilter, { dn, username }, ldapField);\n\n\t\t\tconst channels: Array<string> = [].concat(fieldMap[ldapField]);\n\t\t\tfor await (const channel of channels) {\n\t\t\t\ttry {\n\t\t\t\t\tconst room: IRoom | undefined = Rooms.findOneByNonValidatedName(channel) || this.createRoomForSync(channel);\n\t\t\t\t\tif (!room) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isUserInGroup) {\n\t\t\t\t\t\tif (room.teamMain) {\n\t\t\t\t\t\t\tlogger.error(`Can't add user to channel ${channel} because it is a team.`);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taddUserToRoom(room._id, user);\n\t\t\t\t\t\t\tlogger.debug(`Synced user channel ${room._id} from LDAP for ${username}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (syncUserChannelsRemove && !room.teamMain) {\n\t\t\t\t\t\tconst subscription = await SubscriptionsRaw.findOneByRoomIdAndUserId(room._id, user._id);\n\t\t\t\t\t\tif (subscription) {\n\t\t\t\t\t\t\tawait removeUserFromRoom(room._id, user);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tlogger.debug(`Failed to sync user room, user = ${username}, channel = ${channel}`);\n\t\t\t\t\tlogger.error(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static async syncUserTeams(ldap: LDAPConnection, user: IUser, dn: string, isNewRecord: boolean): Promise<void> {\n\t\tif (!user.username) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst mapTeams =\n\t\t\tsettings.get<boolean>('LDAP_Enable_LDAP_Groups_To_RC_Teams') &&\n\t\t\t(isNewRecord || settings.get<boolean>('LDAP_Validate_Teams_For_Each_Login'));\n\t\tif (!mapTeams) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst ldapUserTeams = await this.getLdapTeamsByUsername(ldap, user.username, dn);\n\t\tconst mapJson = settings.get<string>('LDAP_Groups_To_Rocket_Chat_Teams');\n\t\tif (!mapJson) {\n\t\t\treturn;\n\t\t}\n\t\tconst map = this.parseJson(mapJson) as Record<string, string>;\n\t\tif (!map) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst teamNames = this.getRocketChatTeamsByLdapTeams(map, ldapUserTeams);\n\n\t\tconst allTeamNames = [...new Set(Object.values(map).flat())];\n\t\tconst allTeams = await Team.listByNames(allTeamNames, { projection: { _id: 1, name: 1 } });\n\n\t\tconst inTeamIds = allTeams.filter(({ name }) => teamNames.includes(name)).map(({ _id }) => _id);\n\t\tconst notInTeamIds = allTeams.filter(({ name }) => !teamNames.includes(name)).map(({ _id }) => _id);\n\n\t\tconst currentTeams = await Team.listTeamsBySubscriberUserId(user._id, {\n\t\t\tprojection: { teamId: 1 },\n\t\t});\n\t\tconst currentTeamIds = currentTeams?.map(({ teamId }) => teamId);\n\t\tconst teamsToRemove = currentTeamIds?.filter((teamId) => notInTeamIds.includes(teamId));\n\t\tconst teamsToAdd = inTeamIds.filter((teamId) => !currentTeamIds?.includes(teamId));\n\n\t\tawait Team.insertMemberOnTeams(user._id, teamsToAdd);\n\t\tif (teamsToRemove) {\n\t\t\tawait Team.removeMemberFromTeams(user._id, teamsToRemove);\n\t\t}\n\t}\n\n\tprivate static getRocketChatTeamsByLdapTeams(mappedTeams: Record<string, string>, ldapUserTeams: Array<string>): Array<string> {\n\t\tconst mappedLdapTeams = Object.keys(mappedTeams);\n\t\tconst filteredTeams = ldapUserTeams.filter((ldapTeam) => mappedLdapTeams.includes(ldapTeam));\n\n\t\tif (filteredTeams.length < ldapUserTeams.length) {\n\t\t\tconst unmappedLdapTeams = ldapUserTeams.filter((ldapTeam) => !mappedLdapTeams.includes(ldapTeam));\n\t\t\tlogger.error(`The following LDAP teams are not mapped in Rocket.Chat: \"${unmappedLdapTeams.join(', ')}\".`);\n\t\t}\n\n\t\tif (!filteredTeams.length) {\n\t\t\treturn [];\n\t\t}\n\n\t\treturn [...new Set(filteredTeams.map((ldapTeam) => mappedTeams[ldapTeam]).flat())];\n\t}\n\n\tprivate static async getLdapTeamsByUsername(ldap: LDAPConnection, username: string, dn: string): Promise<Array<string>> {\n\t\tconst baseDN = (settings.get<string>('LDAP_Teams_BaseDN') ?? '').trim() || ldap.options.baseDN;\n\t\tconst query = settings.get<string>('LDAP_Query_To_Get_User_Teams');\n\t\tif (!query) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst searchOptions = {\n\t\t\tfilter: query.replace(/#{username}/g, username).replace(/#{userdn}/g, dn),\n\t\t\tscope: ldap.options.userSearchScope || 'sub',\n\t\t\tsizeLimit: ldap.options.searchSizeLimit,\n\t\t};\n\n\t\tconst attributeNames = (settings.get<string>('LDAP_Teams_Name_Field') ?? '').split(',').map((attributeName) => attributeName.trim());\n\t\tif (!attributeNames.length) {\n\t\t\tattributeNames.push('ou');\n\t\t}\n\n\t\tconst ldapUserGroups = await ldap.searchRaw(baseDN, searchOptions);\n\t\tif (!Array.isArray(ldapUserGroups)) {\n\t\t\treturn [];\n\t\t}\n\n\t\treturn ldapUserGroups\n\t\t\t.map((entry) => {\n\t\t\t\tif (!entry?.raw) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\tfor (const attributeName of attributeNames) {\n\t\t\t\t\tif (entry.raw[attributeName]) {\n\t\t\t\t\t\treturn ldap.extractLdapAttribute(entry.raw[attributeName]) as string;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn undefined;\n\t\t\t})\n\t\t\t.filter((entry): entry is string => Boolean(entry))\n\t\t\t.flat();\n\t}\n\n\tprivate static isUserDeactivated(ldapUser: ILDAPEntry): boolean {\n\t\t// Account locked by \"Draft-behera-ldap-password-policy\"\n\t\tif (ldapUser.pwdAccountLockedTime) {\n\t\t\tmapLogger.debug('User account is locked by password policy (attribute pwdAccountLockedTime)');\n\t\t\treturn true;\n\t\t}\n\n\t\t// EDirectory: Account manually disabled by an admin\n\t\tif (ldapUser.loginDisabled) {\n\t\t\tmapLogger.debug('User account was manually disabled by an admin (attribute loginDisabled)');\n\t\t\treturn true;\n\t\t}\n\n\t\t// Oracle: Account must not be allowed to authenticate\n\t\tif (ldapUser.orclIsEnabled && ldapUser.orclIsEnabled !== 'ENABLED') {\n\t\t\tmapLogger.debug('User must not be allowed to authenticate (attribute orclIsEnabled)');\n\t\t\treturn true;\n\t\t}\n\n\t\t// Active Directory - Account locked automatically by security policies\n\t\tif (ldapUser.lockoutTime && ldapUser.lockoutTime !== '0') {\n\t\t\tconst lockoutTimeValue = Number(ldapUser.lockoutTime);\n\t\t\tif (lockoutTimeValue && !isNaN(lockoutTimeValue)) {\n\t\t\t\t// Automatic unlock is disabled\n\t\t\t\tif (!ldapUser.lockoutDuration) {\n\t\t\t\t\tmapLogger.debug('User account locked indefinitely by security policy (attribute lockoutTime)');\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tconst lockoutTime = new Date(lockoutTimeValue);\n\t\t\t\tlockoutTime.setMinutes(lockoutTime.getMinutes() + Number(ldapUser.lockoutDuration));\n\t\t\t\t// Account has not unlocked itself yet\n\t\t\t\tif (lockoutTime.valueOf() > Date.now()) {\n\t\t\t\t\tmapLogger.debug('User account locked temporarily by security policy (attribute lockoutTime)');\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Active Directory - Account disabled by an Admin\n\t\tif (ldapUser.userAccountControl && (ldapUser.userAccountControl & 2) === 2) {\n\t\t\tmapLogger.debug('User account disabled by an admin (attribute userAccountControl)');\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic static copyActiveState(ldapUser: ILDAPEntry, userData: IImportUser): void {\n\t\tif (!ldapUser) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst syncUserState = settings.get('LDAP_Sync_User_Active_State');\n\t\tif (syncUserState === 'none') {\n\t\t\treturn;\n\t\t}\n\n\t\tconst deleted = this.isUserDeactivated(ldapUser);\n\t\tif (deleted === userData.deleted) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (syncUserState === 'disable' && !deleted) {\n\t\t\treturn;\n\t\t}\n\n\t\tuserData.deleted = deleted;\n\t\tlogger.info(`${deleted ? 'Deactivating' : 'Activating'} user ${userData.name} (${userData.username})`);\n\t}\n\n\tpublic static copyCustomFields(ldapUser: ILDAPEntry, userData: IImportUser): void {\n\t\tif (!settings.get<boolean>('LDAP_Sync_Custom_Fields')) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst customFieldsSettings = settings.get<string>('Accounts_CustomFields');\n\t\tconst customFieldsMap = settings.get<string>('LDAP_CustomFieldMap');\n\n\t\tif (!customFieldsMap || !customFieldsSettings) {\n\t\t\tif (customFieldsMap) {\n\t\t\t\tlogger.debug('Skipping LDAP custom fields because there are no custom fields configured.');\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tlet map: Record<string, string>;\n\t\ttry {\n\t\t\tmap = JSON.parse(customFieldsMap) as Record<string, string>;\n\t\t} catch (error) {\n\t\t\tlogger.error('Failed to parse LDAP Custom Fields mapping');\n\t\t\tlogger.error(error);\n\t\t\treturn;\n\t\t}\n\n\t\tlet customFields: Record<string, any>;\n\t\ttry {\n\t\t\tcustomFields = JSON.parse(customFieldsSettings) as Record<string, any>;\n\t\t} catch (error) {\n\t\t\tlogger.error('Failed to parse Custom Fields');\n\t\t\tlogger.error(error);\n\t\t\treturn;\n\t\t}\n\n\t\t_.map(map, (userField, ldapField) => {\n\t\t\tif (!this.getCustomField(customFields, userField)) {\n\t\t\t\tlogger.debug(`User attribute does not exist: ${userField}`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!userData.customFields) {\n\t\t\t\tuserData.customFields = {};\n\t\t\t}\n\n\t\t\tconst value = templateVarHandler(ldapField, ldapUser);\n\n\t\t\tif (value) {\n\t\t\t\tlet ref: Record<string, any> = userData.customFields;\n\t\t\t\tconst attributeNames = userField.split('.');\n\t\t\t\tlet previousKey: string | undefined;\n\n\t\t\t\tfor (const key of attributeNames) {\n\t\t\t\t\tif (previousKey) {\n\t\t\t\t\t\tif (ref[previousKey] === undefined) {\n\t\t\t\t\t\t\tref[previousKey] = {};\n\t\t\t\t\t\t} else if (typeof ref[previousKey] !== 'object') {\n\t\t\t\t\t\t\tlogger.error(`Failed to assign custom field: ${userField}`);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tref = ref[previousKey];\n\t\t\t\t\t}\n\n\t\t\t\t\tpreviousKey = key;\n\t\t\t\t}\n\n\t\t\t\tif (previousKey) {\n\t\t\t\t\tref[previousKey] = value;\n\t\t\t\t\tlogger.debug(`user.customFields.${userField} changed to: ${value}`);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate static async importNewUsers(ldap: LDAPConnection, converter: LDAPDataConverter): Promise<void> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tlet count = 0;\n\n\t\t\tldap.searchAllUsers<IImportUser>({\n\t\t\t\tentryCallback: (entry: ldapjs.SearchEntry): IImportUser | undefined => {\n\t\t\t\t\tconst data = ldap.extractLdapEntryData(entry);\n\t\t\t\t\tcount++;\n\n\t\t\t\t\tconst userData = this.mapUserData(data);\n\t\t\t\t\tconverter.addUser(userData);\n\t\t\t\t\treturn userData;\n\t\t\t\t},\n\t\t\t\tendCallback: (error: any): void => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tlogger.error(error);\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tlogger.info('LDAP finished loading users. Users added to importer: ', count);\n\t\t\t\t\tresolve();\n\t\t\t\t},\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate static async updateExistingUsers(ldap: LDAPConnection, converter: LDAPDataConverter): Promise<void> {\n\t\tconst users = await UsersRaw.findLDAPUsers().toArray();\n\t\tfor await (const user of users) {\n\t\t\tconst ldapUser = await this.findLDAPUser(ldap, user);\n\n\t\t\tif (ldapUser) {\n\t\t\t\tconst userData = this.mapUserData(ldapUser, user.username);\n\t\t\t\tconverter.addUser(userData);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static async updateUserAvatars(ldap: LDAPConnection): Promise<void> {\n\t\tconst users = await UsersRaw.findLDAPUsers().toArray();\n\t\tfor await (const user of users) {\n\t\t\tconst ldapUser = await this.findLDAPUser(ldap, user);\n\t\t\tif (!ldapUser) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tLDAPManager.syncUserAvatar(user, ldapUser);\n\t\t}\n\t}\n\n\tprivate static async findLDAPUser(ldap: LDAPConnection, user: IUser): Promise<ILDAPEntry | undefined> {\n\t\tif (user.services?.ldap?.id) {\n\t\t\treturn ldap.findOneById(user.services.ldap.id, user.services.ldap.idAttribute);\n\t\t}\n\n\t\tif (user.username) {\n\t\t\treturn ldap.findOneByUsername(user.username);\n\t\t}\n\n\t\tsearchLogger.debug({\n\t\t\tmsg: 'existing LDAP user not found during Sync',\n\t\t\tldapId: user.services?.ldap?.id,\n\t\t\tldapAttribute: user.services?.ldap?.idAttribute,\n\t\t\tusername: user.username,\n\t\t});\n\t}\n\n\tprivate static async logoutDeactivatedUsers(ldap: LDAPConnection): Promise<void> {\n\t\tconst users = await UsersRaw.findConnectedLDAPUsers().toArray();\n\n\t\tfor await (const user of users) {\n\t\t\tconst ldapUser = await this.findLDAPUser(ldap, user);\n\t\t\tif (!ldapUser) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (this.isUserDeactivated(ldapUser)) {\n\t\t\t\tUsersRaw.unsetLoginTokens(user._id);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static getCustomField(customFields: Record<string, any>, property: string): any {\n\t\ttry {\n\t\t\treturn _.reduce(property.split('.'), (acc, el) => acc[el], customFields);\n\t\t} catch {\n\t\t\t// ignore errors\n\t\t}\n\t}\n}\n"]},"targets":{"android":"95.0.0","chrome":"95.0.0","edge":"95.0.0","firefox":"78.0.0","ie":"10.0.0","ios":"15.0.0","opera":"81.0.0","safari":"15.1.0","samsung":"14.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/home/weslley/Documents/projects/Rocket.Chat","root":"/home/weslley/Documents/projects/Rocket.Chat","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.16.5","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/home/weslley/Documents/projects/Rocket.Chat/ee/server/lib/ldap/Manager.ts","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"ee/server/lib/ldap/Manager.ts"}},"code":"let _asyncIterator;\n\nmodule.link(\"@babel/runtime/helpers/asyncIterator\", {\n  default(v) {\n    _asyncIterator = v;\n  }\n\n}, 0);\nmodule.export({\n  LDAPEEManager: () => LDAPEEManager\n});\n\nlet _;\n\nmodule.link(\"underscore\", {\n  default(v) {\n    _ = v;\n  }\n\n}, 0);\nlet settings;\nmodule.link(\"../../../../app/settings/server\", {\n  settings(v) {\n    settings = v;\n  }\n\n}, 1);\nlet Rooms;\nmodule.link(\"../../../../app/models/server\", {\n  Rooms(v) {\n    Rooms = v;\n  }\n\n}, 2);\nlet UsersRaw, Roles, SubscriptionsRaw;\nmodule.link(\"../../../../app/models/server/raw\", {\n  Users(v) {\n    UsersRaw = v;\n  },\n\n  Roles(v) {\n    Roles = v;\n  },\n\n  Subscriptions(v) {\n    SubscriptionsRaw = v;\n  }\n\n}, 3);\nlet LDAPDataConverter;\nmodule.link(\"../../../../server/lib/ldap/DataConverter\", {\n  LDAPDataConverter(v) {\n    LDAPDataConverter = v;\n  }\n\n}, 4);\nlet LDAPConnection;\nmodule.link(\"../../../../server/lib/ldap/Connection\", {\n  LDAPConnection(v) {\n    LDAPConnection = v;\n  }\n\n}, 5);\nlet LDAPManager;\nmodule.link(\"../../../../server/lib/ldap/Manager\", {\n  LDAPManager(v) {\n    LDAPManager = v;\n  }\n\n}, 6);\nlet logger, searchLogger, mapLogger;\nmodule.link(\"../../../../server/lib/ldap/Logger\", {\n  logger(v) {\n    logger = v;\n  },\n\n  searchLogger(v) {\n    searchLogger = v;\n  },\n\n  mapLogger(v) {\n    mapLogger = v;\n  }\n\n}, 7);\nlet templateVarHandler;\nmodule.link(\"../../../../app/utils/lib/templateVarHandler\", {\n  templateVarHandler(v) {\n    templateVarHandler = v;\n  }\n\n}, 8);\nlet addUserToRoom, removeUserFromRoom, createRoom;\nmodule.link(\"../../../../app/lib/server/functions\", {\n  addUserToRoom(v) {\n    addUserToRoom = v;\n  },\n\n  removeUserFromRoom(v) {\n    removeUserFromRoom = v;\n  },\n\n  createRoom(v) {\n    createRoom = v;\n  }\n\n}, 9);\nlet syncUserRoles;\nmodule.link(\"../syncUserRoles\", {\n  syncUserRoles(v) {\n    syncUserRoles = v;\n  }\n\n}, 10);\nlet Team;\nmodule.link(\"../../../../server/sdk\", {\n  Team(v) {\n    Team = v;\n  }\n\n}, 11);\n\nclass LDAPEEManager extends LDAPManager {\n  static sync() {\n    return Promise.asyncApply(() => {\n      var _settings$get, _settings$get2;\n\n      if (settings.get('LDAP_Enable') !== true || settings.get('LDAP_Background_Sync') !== true) {\n        return;\n      }\n\n      const createNewUsers = (_settings$get = settings.get('LDAP_Background_Sync_Import_New_Users')) !== null && _settings$get !== void 0 ? _settings$get : true;\n      const updateExistingUsers = (_settings$get2 = settings.get('LDAP_Background_Sync_Keep_Existant_Users_Updated')) !== null && _settings$get2 !== void 0 ? _settings$get2 : true;\n      const options = this.getConverterOptions();\n      options.skipExistingUsers = !updateExistingUsers;\n      const ldap = new LDAPConnection();\n      const converter = new LDAPDataConverter(true, options);\n\n      try {\n        Promise.await(ldap.connect());\n\n        if (createNewUsers) {\n          Promise.await(this.importNewUsers(ldap, converter));\n        } else if (updateExistingUsers) {\n          Promise.await(this.updateExistingUsers(ldap, converter));\n        }\n\n        converter.convertUsers({\n          afterImportFn: (data, _type, isNewRecord) => Promise.await(this.advancedSync(ldap, data, converter, isNewRecord))\n        });\n      } catch (error) {\n        logger.error(error);\n      }\n\n      ldap.disconnect();\n    });\n  }\n\n  static syncAvatars() {\n    return Promise.asyncApply(() => {\n      if (settings.get('LDAP_Enable') !== true || settings.get('LDAP_Background_Sync_Avatars') !== true) {\n        return;\n      }\n\n      try {\n        const ldap = new LDAPConnection();\n        Promise.await(ldap.connect());\n\n        try {\n          Promise.await(this.updateUserAvatars(ldap));\n        } finally {\n          ldap.disconnect();\n        }\n      } catch (error) {\n        logger.error(error);\n      }\n    });\n  }\n\n  static validateLDAPTeamsMappingChanges(json) {\n    if (!json) {\n      return;\n    }\n\n    const mustBeAnArrayOfStrings = array => Boolean(Array.isArray(array) && array.length && array.every(item => typeof item === 'string'));\n\n    const mappedTeams = this.parseJson(json);\n\n    if (!mappedTeams) {\n      return;\n    }\n\n    const mappedRocketChatTeams = Object.values(mappedTeams);\n    const validStructureMapping = mappedRocketChatTeams.every(mustBeAnArrayOfStrings);\n\n    if (!validStructureMapping) {\n      throw new Error('Please verify your mapping for LDAP X RocketChat Teams. The structure is invalid, the structure should be an object like: {key: LdapTeam, value: [An array of rocket.chat teams]}');\n    }\n  }\n\n  static syncLogout() {\n    return Promise.asyncApply(() => {\n      if (settings.get('LDAP_Enable') !== true || settings.get('LDAP_Sync_AutoLogout_Enabled') !== true) {\n        return;\n      }\n\n      try {\n        const ldap = new LDAPConnection();\n        Promise.await(ldap.connect());\n\n        try {\n          Promise.await(this.logoutDeactivatedUsers(ldap));\n        } finally {\n          ldap.disconnect();\n        }\n      } catch (error) {\n        logger.error(error);\n      }\n    });\n  }\n\n  static advancedSyncForUser(ldap, user, isNewRecord, dn) {\n    return Promise.asyncApply(() => {\n      try {\n        Promise.await(this.syncUserRoles(ldap, user, dn));\n        Promise.await(this.syncUserChannels(ldap, user, dn));\n        Promise.await(this.syncUserTeams(ldap, user, dn, isNewRecord));\n      } catch (e) {\n        logger.debug(\"Advanced Sync failed for user: \".concat(dn));\n        logger.error(e);\n      }\n    });\n  }\n\n  static advancedSync(ldap, importUser, converter, isNewRecord) {\n    return Promise.asyncApply(() => {\n      const user = converter.findExistingUser(importUser);\n\n      if (!(user !== null && user !== void 0 && user.username)) {\n        return;\n      }\n\n      const dn = importUser.importIds[0];\n      return this.advancedSyncForUser(ldap, user, isNewRecord, dn);\n    });\n  }\n\n  static isUserInGroup(ldap, baseDN, filter, _ref, groupName) {\n    return Promise.asyncApply(() => {\n      let {\n        dn,\n        username\n      } = _ref;\n\n      if (!filter || !baseDN) {\n        logger.error('Please setup LDAP Group Filter and LDAP Group BaseDN in LDAP Settings.');\n        return false;\n      }\n\n      const searchOptions = {\n        filter: filter.replace(/#{username}/g, username).replace(/#{groupName}/g, groupName).replace(/#{userdn}/g, dn),\n        scope: 'sub'\n      };\n      const result = Promise.await(ldap.searchRaw(baseDN, searchOptions));\n\n      if (!Array.isArray(result) || result.length === 0) {\n        logger.debug(\"\".concat(username, \" is not in \").concat(groupName, \" group!!!\"));\n      } else {\n        logger.debug(\"\".concat(username, \" is in \").concat(groupName, \" group.\"));\n        return true;\n      }\n\n      return false;\n    });\n  }\n\n  static parseJson(json) {\n    try {\n      return JSON.parse(json);\n    } catch (err) {\n      logger.error(\"Unexpected error : \".concat(err.message));\n    }\n  }\n\n  static syncUserRoles(ldap, user, dn) {\n    return Promise.asyncApply(() => {\n      var _settings$get3, _settings$get4, _settings$get5, _settings$get6, _settings$get7;\n\n      const {\n        username\n      } = user;\n\n      if (!username) {\n        logger.debug('User has no username');\n        return;\n      }\n\n      const shouldSyncUserRoles = (_settings$get3 = settings.get('LDAP_Sync_User_Data_Roles')) !== null && _settings$get3 !== void 0 ? _settings$get3 : false;\n      const syncUserRolesAutoRemove = (_settings$get4 = settings.get('LDAP_Sync_User_Data_Roles_AutoRemove')) !== null && _settings$get4 !== void 0 ? _settings$get4 : false;\n      const syncUserRolesFieldMap = ((_settings$get5 = settings.get('LDAP_Sync_User_Data_RolesMap')) !== null && _settings$get5 !== void 0 ? _settings$get5 : '').trim();\n      const syncUserRolesFilter = ((_settings$get6 = settings.get('LDAP_Sync_User_Data_Roles_Filter')) !== null && _settings$get6 !== void 0 ? _settings$get6 : '').trim();\n      const syncUserRolesBaseDN = ((_settings$get7 = settings.get('LDAP_Sync_User_Data_Roles_BaseDN')) !== null && _settings$get7 !== void 0 ? _settings$get7 : '').trim();\n\n      if (!shouldSyncUserRoles || !syncUserRolesFieldMap) {\n        logger.debug('not syncing user roles');\n        return;\n      }\n\n      const roles = Promise.await(Roles.find({}, {\n        projection: {\n          _updatedAt: 0\n        }\n      }).toArray());\n\n      if (!roles) {\n        return;\n      }\n\n      const fieldMap = this.parseJson(syncUserRolesFieldMap);\n\n      if (!fieldMap) {\n        logger.debug('missing group role mapping');\n        return;\n      }\n\n      const ldapFields = Object.keys(fieldMap);\n      const roleList = [];\n      const allowedRoles = [];\n      var _iteratorAbruptCompletion = false;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(ldapFields), _step; _iteratorAbruptCompletion = !(_step = Promise.await(_iterator.next())).done; _iteratorAbruptCompletion = false) {\n          const ldapField = _step.value;\n\n          if (!fieldMap[ldapField]) {\n            continue;\n          }\n\n          const userField = fieldMap[ldapField];\n          const [roleId] = userField.split(/\\.(.+)/);\n          allowedRoles.push(roleId);\n\n          if (Promise.await(this.isUserInGroup(ldap, syncUserRolesBaseDN, syncUserRolesFilter, {\n            dn,\n            username\n          }, ldapField))) {\n            roleList.push(roleId);\n            continue;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion && _iterator.return != null) {\n            Promise.await(_iterator.return());\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      Promise.await(syncUserRoles(user._id, roleList, {\n        allowedRoles,\n        skipRemovingRoles: !syncUserRolesAutoRemove\n      }));\n    });\n  }\n\n  static createRoomForSync(channel) {\n    logger.debug(\"Channel '\".concat(channel, \"' doesn't exist, creating it.\"));\n    const roomOwner = settings.get('LDAP_Sync_User_Data_Channels_Admin') || ''; // #ToDo: Remove typecastings when createRoom is converted to ts.\n\n    const room = createRoom('c', channel, roomOwner, [], false, {\n      customFields: {\n        ldap: true\n      }\n    });\n\n    if (!(room !== null && room !== void 0 && room.rid)) {\n      logger.error(\"Unable to auto-create channel '\".concat(channel, \"' during ldap sync.\"));\n      return;\n    }\n\n    room._id = room.rid;\n    return room;\n  }\n\n  static syncUserChannels(ldap, user, dn) {\n    return Promise.asyncApply(() => {\n      var _settings$get8, _settings$get9, _settings$get10, _settings$get11, _settings$get12;\n\n      const syncUserChannels = (_settings$get8 = settings.get('LDAP_Sync_User_Data_Channels')) !== null && _settings$get8 !== void 0 ? _settings$get8 : false;\n      const syncUserChannelsRemove = (_settings$get9 = settings.get('LDAP_Sync_User_Data_Channels_Enforce_AutoChannels')) !== null && _settings$get9 !== void 0 ? _settings$get9 : false;\n      const syncUserChannelsFieldMap = ((_settings$get10 = settings.get('LDAP_Sync_User_Data_ChannelsMap')) !== null && _settings$get10 !== void 0 ? _settings$get10 : '').trim();\n      const syncUserChannelsFilter = ((_settings$get11 = settings.get('LDAP_Sync_User_Data_Channels_Filter')) !== null && _settings$get11 !== void 0 ? _settings$get11 : '').trim();\n      const syncUserChannelsBaseDN = ((_settings$get12 = settings.get('LDAP_Sync_User_Data_Channels_BaseDN')) !== null && _settings$get12 !== void 0 ? _settings$get12 : '').trim();\n\n      if (!syncUserChannels || !syncUserChannelsFieldMap) {\n        logger.debug('not syncing groups to channels');\n        return;\n      }\n\n      const fieldMap = this.parseJson(syncUserChannelsFieldMap);\n\n      if (!fieldMap) {\n        logger.debug('missing group channel mapping');\n        return;\n      }\n\n      const {\n        username\n      } = user;\n\n      if (!username) {\n        return;\n      }\n\n      logger.debug('syncing user channels');\n      const ldapFields = Object.keys(fieldMap);\n      var _iteratorAbruptCompletion2 = false;\n      var _didIteratorError2 = false;\n\n      var _iteratorError2;\n\n      try {\n        for (var _iterator2 = _asyncIterator(ldapFields), _step2; _iteratorAbruptCompletion2 = !(_step2 = Promise.await(_iterator2.next())).done; _iteratorAbruptCompletion2 = false) {\n          const ldapField = _step2.value;\n\n          if (!fieldMap[ldapField]) {\n            continue;\n          }\n\n          const isUserInGroup = Promise.await(this.isUserInGroup(ldap, syncUserChannelsBaseDN, syncUserChannelsFilter, {\n            dn,\n            username\n          }, ldapField));\n          const channels = [].concat(fieldMap[ldapField]);\n          var _iteratorAbruptCompletion3 = false;\n          var _didIteratorError3 = false;\n\n          var _iteratorError3;\n\n          try {\n            for (var _iterator3 = _asyncIterator(channels), _step3; _iteratorAbruptCompletion3 = !(_step3 = Promise.await(_iterator3.next())).done; _iteratorAbruptCompletion3 = false) {\n              const channel = _step3.value;\n\n              try {\n                const room = Rooms.findOneByNonValidatedName(channel) || this.createRoomForSync(channel);\n\n                if (!room) {\n                  return;\n                }\n\n                if (isUserInGroup) {\n                  if (room.teamMain) {\n                    logger.error(\"Can't add user to channel \".concat(channel, \" because it is a team.\"));\n                  } else {\n                    addUserToRoom(room._id, user);\n                    logger.debug(\"Synced user channel \".concat(room._id, \" from LDAP for \").concat(username));\n                  }\n                } else if (syncUserChannelsRemove && !room.teamMain) {\n                  const subscription = Promise.await(SubscriptionsRaw.findOneByRoomIdAndUserId(room._id, user._id));\n\n                  if (subscription) {\n                    Promise.await(removeUserFromRoom(room._id, user));\n                  }\n                }\n              } catch (e) {\n                logger.debug(\"Failed to sync user room, user = \".concat(username, \", channel = \").concat(channel));\n                logger.error(e);\n              }\n            }\n          } catch (err) {\n            _didIteratorError3 = true;\n            _iteratorError3 = err;\n          } finally {\n            try {\n              if (_iteratorAbruptCompletion3 && _iterator3.return != null) {\n                Promise.await(_iterator3.return());\n              }\n            } finally {\n              if (_didIteratorError3) {\n                throw _iteratorError3;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion2 && _iterator2.return != null) {\n            Promise.await(_iterator2.return());\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    });\n  }\n\n  static syncUserTeams(ldap, user, dn, isNewRecord) {\n    return Promise.asyncApply(() => {\n      if (!user.username) {\n        return;\n      }\n\n      const mapTeams = settings.get('LDAP_Enable_LDAP_Groups_To_RC_Teams') && (isNewRecord || settings.get('LDAP_Validate_Teams_For_Each_Login'));\n\n      if (!mapTeams) {\n        return;\n      }\n\n      const ldapUserTeams = Promise.await(this.getLdapTeamsByUsername(ldap, user.username, dn));\n      const mapJson = settings.get('LDAP_Groups_To_Rocket_Chat_Teams');\n\n      if (!mapJson) {\n        return;\n      }\n\n      const map = this.parseJson(mapJson);\n\n      if (!map) {\n        return;\n      }\n\n      const teamNames = this.getRocketChatTeamsByLdapTeams(map, ldapUserTeams);\n      const allTeamNames = [...new Set(Object.values(map).flat())];\n      const allTeams = Promise.await(Team.listByNames(allTeamNames, {\n        projection: {\n          _id: 1,\n          name: 1\n        }\n      }));\n      const inTeamIds = allTeams.filter(_ref2 => {\n        let {\n          name\n        } = _ref2;\n        return teamNames.includes(name);\n      }).map(_ref3 => {\n        let {\n          _id\n        } = _ref3;\n        return _id;\n      });\n      const notInTeamIds = allTeams.filter(_ref4 => {\n        let {\n          name\n        } = _ref4;\n        return !teamNames.includes(name);\n      }).map(_ref5 => {\n        let {\n          _id\n        } = _ref5;\n        return _id;\n      });\n      const currentTeams = Promise.await(Team.listTeamsBySubscriberUserId(user._id, {\n        projection: {\n          teamId: 1\n        }\n      }));\n      const currentTeamIds = currentTeams === null || currentTeams === void 0 ? void 0 : currentTeams.map(_ref6 => {\n        let {\n          teamId\n        } = _ref6;\n        return teamId;\n      });\n      const teamsToRemove = currentTeamIds === null || currentTeamIds === void 0 ? void 0 : currentTeamIds.filter(teamId => notInTeamIds.includes(teamId));\n      const teamsToAdd = inTeamIds.filter(teamId => !(currentTeamIds !== null && currentTeamIds !== void 0 && currentTeamIds.includes(teamId)));\n      Promise.await(Team.insertMemberOnTeams(user._id, teamsToAdd));\n\n      if (teamsToRemove) {\n        Promise.await(Team.removeMemberFromTeams(user._id, teamsToRemove));\n      }\n    });\n  }\n\n  static getRocketChatTeamsByLdapTeams(mappedTeams, ldapUserTeams) {\n    const mappedLdapTeams = Object.keys(mappedTeams);\n    const filteredTeams = ldapUserTeams.filter(ldapTeam => mappedLdapTeams.includes(ldapTeam));\n\n    if (filteredTeams.length < ldapUserTeams.length) {\n      const unmappedLdapTeams = ldapUserTeams.filter(ldapTeam => !mappedLdapTeams.includes(ldapTeam));\n      logger.error(\"The following LDAP teams are not mapped in Rocket.Chat: \\\"\".concat(unmappedLdapTeams.join(', '), \"\\\".\"));\n    }\n\n    if (!filteredTeams.length) {\n      return [];\n    }\n\n    return [...new Set(filteredTeams.map(ldapTeam => mappedTeams[ldapTeam]).flat())];\n  }\n\n  static getLdapTeamsByUsername(ldap, username, dn) {\n    return Promise.asyncApply(() => {\n      var _settings$get13, _settings$get14;\n\n      const baseDN = ((_settings$get13 = settings.get('LDAP_Teams_BaseDN')) !== null && _settings$get13 !== void 0 ? _settings$get13 : '').trim() || ldap.options.baseDN;\n      const query = settings.get('LDAP_Query_To_Get_User_Teams');\n\n      if (!query) {\n        return [];\n      }\n\n      const searchOptions = {\n        filter: query.replace(/#{username}/g, username).replace(/#{userdn}/g, dn),\n        scope: ldap.options.userSearchScope || 'sub',\n        sizeLimit: ldap.options.searchSizeLimit\n      };\n      const attributeNames = ((_settings$get14 = settings.get('LDAP_Teams_Name_Field')) !== null && _settings$get14 !== void 0 ? _settings$get14 : '').split(',').map(attributeName => attributeName.trim());\n\n      if (!attributeNames.length) {\n        attributeNames.push('ou');\n      }\n\n      const ldapUserGroups = Promise.await(ldap.searchRaw(baseDN, searchOptions));\n\n      if (!Array.isArray(ldapUserGroups)) {\n        return [];\n      }\n\n      return ldapUserGroups.map(entry => {\n        if (!(entry !== null && entry !== void 0 && entry.raw)) {\n          return undefined;\n        }\n\n        for (const attributeName of attributeNames) {\n          if (entry.raw[attributeName]) {\n            return ldap.extractLdapAttribute(entry.raw[attributeName]);\n          }\n        }\n\n        return undefined;\n      }).filter(entry => Boolean(entry)).flat();\n    });\n  }\n\n  static isUserDeactivated(ldapUser) {\n    // Account locked by \"Draft-behera-ldap-password-policy\"\n    if (ldapUser.pwdAccountLockedTime) {\n      mapLogger.debug('User account is locked by password policy (attribute pwdAccountLockedTime)');\n      return true;\n    } // EDirectory: Account manually disabled by an admin\n\n\n    if (ldapUser.loginDisabled) {\n      mapLogger.debug('User account was manually disabled by an admin (attribute loginDisabled)');\n      return true;\n    } // Oracle: Account must not be allowed to authenticate\n\n\n    if (ldapUser.orclIsEnabled && ldapUser.orclIsEnabled !== 'ENABLED') {\n      mapLogger.debug('User must not be allowed to authenticate (attribute orclIsEnabled)');\n      return true;\n    } // Active Directory - Account locked automatically by security policies\n\n\n    if (ldapUser.lockoutTime && ldapUser.lockoutTime !== '0') {\n      const lockoutTimeValue = Number(ldapUser.lockoutTime);\n\n      if (lockoutTimeValue && !isNaN(lockoutTimeValue)) {\n        // Automatic unlock is disabled\n        if (!ldapUser.lockoutDuration) {\n          mapLogger.debug('User account locked indefinitely by security policy (attribute lockoutTime)');\n          return true;\n        }\n\n        const lockoutTime = new Date(lockoutTimeValue);\n        lockoutTime.setMinutes(lockoutTime.getMinutes() + Number(ldapUser.lockoutDuration)); // Account has not unlocked itself yet\n\n        if (lockoutTime.valueOf() > Date.now()) {\n          mapLogger.debug('User account locked temporarily by security policy (attribute lockoutTime)');\n          return true;\n        }\n      }\n    } // Active Directory - Account disabled by an Admin\n\n\n    if (ldapUser.userAccountControl && (ldapUser.userAccountControl & 2) === 2) {\n      mapLogger.debug('User account disabled by an admin (attribute userAccountControl)');\n      return true;\n    }\n\n    return false;\n  }\n\n  static copyActiveState(ldapUser, userData) {\n    if (!ldapUser) {\n      return;\n    }\n\n    const syncUserState = settings.get('LDAP_Sync_User_Active_State');\n\n    if (syncUserState === 'none') {\n      return;\n    }\n\n    const deleted = this.isUserDeactivated(ldapUser);\n\n    if (deleted === userData.deleted) {\n      return;\n    }\n\n    if (syncUserState === 'disable' && !deleted) {\n      return;\n    }\n\n    userData.deleted = deleted;\n    logger.info(\"\".concat(deleted ? 'Deactivating' : 'Activating', \" user \").concat(userData.name, \" (\").concat(userData.username, \")\"));\n  }\n\n  static copyCustomFields(ldapUser, userData) {\n    if (!settings.get('LDAP_Sync_Custom_Fields')) {\n      return;\n    }\n\n    const customFieldsSettings = settings.get('Accounts_CustomFields');\n    const customFieldsMap = settings.get('LDAP_CustomFieldMap');\n\n    if (!customFieldsMap || !customFieldsSettings) {\n      if (customFieldsMap) {\n        logger.debug('Skipping LDAP custom fields because there are no custom fields configured.');\n      }\n\n      return;\n    }\n\n    let map;\n\n    try {\n      map = JSON.parse(customFieldsMap);\n    } catch (error) {\n      logger.error('Failed to parse LDAP Custom Fields mapping');\n      logger.error(error);\n      return;\n    }\n\n    let customFields;\n\n    try {\n      customFields = JSON.parse(customFieldsSettings);\n    } catch (error) {\n      logger.error('Failed to parse Custom Fields');\n      logger.error(error);\n      return;\n    }\n\n    _.map(map, (userField, ldapField) => {\n      if (!this.getCustomField(customFields, userField)) {\n        logger.debug(\"User attribute does not exist: \".concat(userField));\n        return;\n      }\n\n      if (!userData.customFields) {\n        userData.customFields = {};\n      }\n\n      const value = templateVarHandler(ldapField, ldapUser);\n\n      if (value) {\n        let ref = userData.customFields;\n        const attributeNames = userField.split('.');\n        let previousKey;\n\n        for (const key of attributeNames) {\n          if (previousKey) {\n            if (ref[previousKey] === undefined) {\n              ref[previousKey] = {};\n            } else if (typeof ref[previousKey] !== 'object') {\n              logger.error(\"Failed to assign custom field: \".concat(userField));\n              return;\n            }\n\n            ref = ref[previousKey];\n          }\n\n          previousKey = key;\n        }\n\n        if (previousKey) {\n          ref[previousKey] = value;\n          logger.debug(\"user.customFields.\".concat(userField, \" changed to: \").concat(value));\n        }\n      }\n    });\n  }\n\n  static importNewUsers(ldap, converter) {\n    return Promise.asyncApply(() => {\n      return new Promise((resolve, reject) => {\n        let count = 0;\n        ldap.searchAllUsers({\n          entryCallback: entry => {\n            const data = ldap.extractLdapEntryData(entry);\n            count++;\n            const userData = this.mapUserData(data);\n            converter.addUser(userData);\n            return userData;\n          },\n          endCallback: error => {\n            if (error) {\n              logger.error(error);\n              reject(error);\n              return;\n            }\n\n            logger.info('LDAP finished loading users. Users added to importer: ', count);\n            resolve();\n          }\n        });\n      });\n    });\n  }\n\n  static updateExistingUsers(ldap, converter) {\n    return Promise.asyncApply(() => {\n      const users = Promise.await(UsersRaw.findLDAPUsers().toArray());\n      var _iteratorAbruptCompletion4 = false;\n      var _didIteratorError4 = false;\n\n      var _iteratorError4;\n\n      try {\n        for (var _iterator4 = _asyncIterator(users), _step4; _iteratorAbruptCompletion4 = !(_step4 = Promise.await(_iterator4.next())).done; _iteratorAbruptCompletion4 = false) {\n          const user = _step4.value;\n          const ldapUser = Promise.await(this.findLDAPUser(ldap, user));\n\n          if (ldapUser) {\n            const userData = this.mapUserData(ldapUser, user.username);\n            converter.addUser(userData);\n          }\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion4 && _iterator4.return != null) {\n            Promise.await(_iterator4.return());\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n    });\n  }\n\n  static updateUserAvatars(ldap) {\n    return Promise.asyncApply(() => {\n      const users = Promise.await(UsersRaw.findLDAPUsers().toArray());\n      var _iteratorAbruptCompletion5 = false;\n      var _didIteratorError5 = false;\n\n      var _iteratorError5;\n\n      try {\n        for (var _iterator5 = _asyncIterator(users), _step5; _iteratorAbruptCompletion5 = !(_step5 = Promise.await(_iterator5.next())).done; _iteratorAbruptCompletion5 = false) {\n          const user = _step5.value;\n          const ldapUser = Promise.await(this.findLDAPUser(ldap, user));\n\n          if (!ldapUser) {\n            continue;\n          }\n\n          LDAPManager.syncUserAvatar(user, ldapUser);\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion5 && _iterator5.return != null) {\n            Promise.await(_iterator5.return());\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n    });\n  }\n\n  static findLDAPUser(ldap, user) {\n    return Promise.asyncApply(() => {\n      var _user$services, _user$services$ldap, _user$services2, _user$services2$ldap, _user$services3, _user$services3$ldap;\n\n      if ((_user$services = user.services) !== null && _user$services !== void 0 && (_user$services$ldap = _user$services.ldap) !== null && _user$services$ldap !== void 0 && _user$services$ldap.id) {\n        return ldap.findOneById(user.services.ldap.id, user.services.ldap.idAttribute);\n      }\n\n      if (user.username) {\n        return ldap.findOneByUsername(user.username);\n      }\n\n      searchLogger.debug({\n        msg: 'existing LDAP user not found during Sync',\n        ldapId: (_user$services2 = user.services) === null || _user$services2 === void 0 ? void 0 : (_user$services2$ldap = _user$services2.ldap) === null || _user$services2$ldap === void 0 ? void 0 : _user$services2$ldap.id,\n        ldapAttribute: (_user$services3 = user.services) === null || _user$services3 === void 0 ? void 0 : (_user$services3$ldap = _user$services3.ldap) === null || _user$services3$ldap === void 0 ? void 0 : _user$services3$ldap.idAttribute,\n        username: user.username\n      });\n    });\n  }\n\n  static logoutDeactivatedUsers(ldap) {\n    return Promise.asyncApply(() => {\n      const users = Promise.await(UsersRaw.findConnectedLDAPUsers().toArray());\n      var _iteratorAbruptCompletion6 = false;\n      var _didIteratorError6 = false;\n\n      var _iteratorError6;\n\n      try {\n        for (var _iterator6 = _asyncIterator(users), _step6; _iteratorAbruptCompletion6 = !(_step6 = Promise.await(_iterator6.next())).done; _iteratorAbruptCompletion6 = false) {\n          const user = _step6.value;\n          const ldapUser = Promise.await(this.findLDAPUser(ldap, user));\n\n          if (!ldapUser) {\n            continue;\n          }\n\n          if (this.isUserDeactivated(ldapUser)) {\n            UsersRaw.unsetLoginTokens(user._id);\n          }\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion6 && _iterator6.return != null) {\n            Promise.await(_iterator6.return());\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n    });\n  }\n\n  static getCustomField(customFields, property) {\n    try {\n      return _.reduce(property.split('.'), (acc, el) => acc[el], customFields);\n    } catch (_unused) {// ignore errors\n    }\n  }\n\n}","map":{"version":3,"sources":["ee/server/lib/ldap/Manager.ts"],"names":[],"mappings":"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","sourcesContent":["import _ from 'underscore';\nimport type ldapjs from 'ldapjs';\n\nimport { ILDAPEntry } from '../../../../definition/ldap/ILDAPEntry';\nimport type { IUser } from '../../../../definition/IUser';\nimport type { IRoom, ICreatedRoom } from '../../../../definition/IRoom';\nimport type { IRole } from '../../../../definition/IRole';\nimport { IImportUser } from '../../../../definition/IImportUser';\nimport { ImporterAfterImportCallback } from '../../../../app/importer/server/definitions/IConversionCallbacks';\nimport { settings } from '../../../../app/settings/server';\nimport { Rooms } from '../../../../app/models/server';\nimport { Users as UsersRaw, Roles, Subscriptions as SubscriptionsRaw } from '../../../../app/models/server/raw';\nimport { LDAPDataConverter } from '../../../../server/lib/ldap/DataConverter';\nimport { LDAPConnection } from '../../../../server/lib/ldap/Connection';\nimport { LDAPManager } from '../../../../server/lib/ldap/Manager';\nimport { logger, searchLogger, mapLogger } from '../../../../server/lib/ldap/Logger';\nimport { templateVarHandler } from '../../../../app/utils/lib/templateVarHandler';\nimport { addUserToRoom, removeUserFromRoom, createRoom } from '../../../../app/lib/server/functions';\nimport { syncUserRoles } from '../syncUserRoles';\nimport { Team } from '../../../../server/sdk';\n\nexport class LDAPEEManager extends LDAPManager {\n\tpublic static async sync(): Promise<void> {\n\t\tif (settings.get('LDAP_Enable') !== true || settings.get('LDAP_Background_Sync') !== true) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst createNewUsers = settings.get<boolean>('LDAP_Background_Sync_Import_New_Users') ?? true;\n\t\tconst updateExistingUsers = settings.get<boolean>('LDAP_Background_Sync_Keep_Existant_Users_Updated') ?? true;\n\n\t\tconst options = this.getConverterOptions();\n\t\toptions.skipExistingUsers = !updateExistingUsers;\n\n\t\tconst ldap = new LDAPConnection();\n\t\tconst converter = new LDAPDataConverter(true, options);\n\n\t\ttry {\n\t\t\tawait ldap.connect();\n\n\t\t\tif (createNewUsers) {\n\t\t\t\tawait this.importNewUsers(ldap, converter);\n\t\t\t} else if (updateExistingUsers) {\n\t\t\t\tawait this.updateExistingUsers(ldap, converter);\n\t\t\t}\n\n\t\t\tconverter.convertUsers({\n\t\t\t\tafterImportFn: ((data: IImportUser, _type: string, isNewRecord: boolean): void =>\n\t\t\t\t\tPromise.await(this.advancedSync(ldap, data, converter, isNewRecord))) as ImporterAfterImportCallback,\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error(error);\n\t\t}\n\n\t\tldap.disconnect();\n\t}\n\n\tpublic static async syncAvatars(): Promise<void> {\n\t\tif (settings.get('LDAP_Enable') !== true || settings.get('LDAP_Background_Sync_Avatars') !== true) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tconst ldap = new LDAPConnection();\n\t\t\tawait ldap.connect();\n\n\t\t\ttry {\n\t\t\t\tawait this.updateUserAvatars(ldap);\n\t\t\t} finally {\n\t\t\t\tldap.disconnect();\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.error(error);\n\t\t}\n\t}\n\n\tpublic static validateLDAPTeamsMappingChanges(json: string): void {\n\t\tif (!json) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst mustBeAnArrayOfStrings = (array: Array<string>): boolean =>\n\t\t\tBoolean(Array.isArray(array) && array.length && array.every((item) => typeof item === 'string'));\n\t\tconst mappedTeams = this.parseJson(json);\n\t\tif (!mappedTeams) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst mappedRocketChatTeams = Object.values(mappedTeams);\n\t\tconst validStructureMapping = mappedRocketChatTeams.every(mustBeAnArrayOfStrings);\n\t\tif (!validStructureMapping) {\n\t\t\tthrow new Error(\n\t\t\t\t'Please verify your mapping for LDAP X RocketChat Teams. The structure is invalid, the structure should be an object like: {key: LdapTeam, value: [An array of rocket.chat teams]}',\n\t\t\t);\n\t\t}\n\t}\n\n\tpublic static async syncLogout(): Promise<void> {\n\t\tif (settings.get('LDAP_Enable') !== true || settings.get('LDAP_Sync_AutoLogout_Enabled') !== true) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tconst ldap = new LDAPConnection();\n\t\t\tawait ldap.connect();\n\n\t\t\ttry {\n\t\t\t\tawait this.logoutDeactivatedUsers(ldap);\n\t\t\t} finally {\n\t\t\t\tldap.disconnect();\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.error(error);\n\t\t}\n\t}\n\n\tpublic static async advancedSyncForUser(ldap: LDAPConnection, user: IUser, isNewRecord: boolean, dn: string): Promise<void> {\n\t\ttry {\n\t\t\tawait this.syncUserRoles(ldap, user, dn);\n\t\t\tawait this.syncUserChannels(ldap, user, dn);\n\t\t\tawait this.syncUserTeams(ldap, user, dn, isNewRecord);\n\t\t} catch (e) {\n\t\t\tlogger.debug(`Advanced Sync failed for user: ${dn}`);\n\t\t\tlogger.error(e);\n\t\t}\n\t}\n\n\tprivate static async advancedSync(\n\t\tldap: LDAPConnection,\n\t\timportUser: IImportUser,\n\t\tconverter: LDAPDataConverter,\n\t\tisNewRecord: boolean,\n\t): Promise<void> {\n\t\tconst user = converter.findExistingUser(importUser);\n\t\tif (!user?.username) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst dn = importUser.importIds[0];\n\t\treturn this.advancedSyncForUser(ldap, user, isNewRecord, dn);\n\t}\n\n\tprivate static async isUserInGroup(\n\t\tldap: LDAPConnection,\n\t\tbaseDN: string,\n\t\tfilter: string,\n\t\t{ dn, username }: { dn: string; username: string },\n\t\tgroupName: string,\n\t): Promise<boolean> {\n\t\tif (!filter || !baseDN) {\n\t\t\tlogger.error('Please setup LDAP Group Filter and LDAP Group BaseDN in LDAP Settings.');\n\t\t\treturn false;\n\t\t}\n\t\tconst searchOptions: ldapjs.SearchOptions = {\n\t\t\tfilter: filter\n\t\t\t\t.replace(/#{username}/g, username)\n\t\t\t\t.replace(/#{groupName}/g, groupName)\n\t\t\t\t.replace(/#{userdn}/g, dn),\n\t\t\tscope: 'sub',\n\t\t};\n\n\t\tconst result = await ldap.searchRaw(baseDN, searchOptions);\n\n\t\tif (!Array.isArray(result) || result.length === 0) {\n\t\t\tlogger.debug(`${username} is not in ${groupName} group!!!`);\n\t\t} else {\n\t\t\tlogger.debug(`${username} is in ${groupName} group.`);\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate static parseJson(json: string): Record<string, any> | undefined {\n\t\ttry {\n\t\t\treturn JSON.parse(json);\n\t\t} catch (err) {\n\t\t\tlogger.error(`Unexpected error : ${err.message}`);\n\t\t}\n\t}\n\n\tprivate static async syncUserRoles(ldap: LDAPConnection, user: IUser, dn: string): Promise<void> {\n\t\tconst { username } = user;\n\t\tif (!username) {\n\t\t\tlogger.debug('User has no username');\n\t\t\treturn;\n\t\t}\n\n\t\tconst shouldSyncUserRoles = settings.get<boolean>('LDAP_Sync_User_Data_Roles') ?? false;\n\t\tconst syncUserRolesAutoRemove = settings.get<boolean>('LDAP_Sync_User_Data_Roles_AutoRemove') ?? false;\n\t\tconst syncUserRolesFieldMap = (settings.get<string>('LDAP_Sync_User_Data_RolesMap') ?? '').trim();\n\t\tconst syncUserRolesFilter = (settings.get<string>('LDAP_Sync_User_Data_Roles_Filter') ?? '').trim();\n\t\tconst syncUserRolesBaseDN = (settings.get<string>('LDAP_Sync_User_Data_Roles_BaseDN') ?? '').trim();\n\n\t\tif (!shouldSyncUserRoles || !syncUserRolesFieldMap) {\n\t\t\tlogger.debug('not syncing user roles');\n\t\t\treturn;\n\t\t}\n\n\t\tconst roles = (await Roles.find(\n\t\t\t{},\n\t\t\t{\n\t\t\t\tprojection: {\n\t\t\t\t\t_updatedAt: 0,\n\t\t\t\t},\n\t\t\t},\n\t\t).toArray()) as Array<IRole>;\n\n\t\tif (!roles) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst fieldMap = this.parseJson(syncUserRolesFieldMap);\n\t\tif (!fieldMap) {\n\t\t\tlogger.debug('missing group role mapping');\n\t\t\treturn;\n\t\t}\n\n\t\tconst ldapFields = Object.keys(fieldMap);\n\t\tconst roleList: Array<IRole['_id']> = [];\n\t\tconst allowedRoles: Array<IRole['_id']> = [];\n\n\t\tfor await (const ldapField of ldapFields) {\n\t\t\tif (!fieldMap[ldapField]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst userField = fieldMap[ldapField];\n\t\t\tconst [roleId] = userField.split(/\\.(.+)/);\n\t\t\tallowedRoles.push(roleId);\n\n\t\t\tif (await this.isUserInGroup(ldap, syncUserRolesBaseDN, syncUserRolesFilter, { dn, username }, ldapField)) {\n\t\t\t\troleList.push(roleId);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tawait syncUserRoles(user._id, roleList, {\n\t\t\tallowedRoles,\n\t\t\tskipRemovingRoles: !syncUserRolesAutoRemove,\n\t\t});\n\t}\n\n\tprivate static createRoomForSync(channel: string): IRoom | undefined {\n\t\tlogger.debug(`Channel '${channel}' doesn't exist, creating it.`);\n\n\t\tconst roomOwner = settings.get<string>('LDAP_Sync_User_Data_Channels_Admin') || '';\n\t\t// #ToDo: Remove typecastings when createRoom is converted to ts.\n\t\tconst room = createRoom('c', channel, roomOwner, [], false, {\n\t\t\tcustomFields: { ldap: true },\n\t\t} as any) as unknown as ICreatedRoom | undefined;\n\t\tif (!room?.rid) {\n\t\t\tlogger.error(`Unable to auto-create channel '${channel}' during ldap sync.`);\n\t\t\treturn;\n\t\t}\n\n\t\troom._id = room.rid;\n\t\treturn room;\n\t}\n\n\tprivate static async syncUserChannels(ldap: LDAPConnection, user: IUser, dn: string): Promise<void> {\n\t\tconst syncUserChannels = settings.get<boolean>('LDAP_Sync_User_Data_Channels') ?? false;\n\t\tconst syncUserChannelsRemove = settings.get<boolean>('LDAP_Sync_User_Data_Channels_Enforce_AutoChannels') ?? false;\n\t\tconst syncUserChannelsFieldMap = (settings.get<string>('LDAP_Sync_User_Data_ChannelsMap') ?? '').trim();\n\t\tconst syncUserChannelsFilter = (settings.get<string>('LDAP_Sync_User_Data_Channels_Filter') ?? '').trim();\n\t\tconst syncUserChannelsBaseDN = (settings.get<string>('LDAP_Sync_User_Data_Channels_BaseDN') ?? '').trim();\n\n\t\tif (!syncUserChannels || !syncUserChannelsFieldMap) {\n\t\t\tlogger.debug('not syncing groups to channels');\n\t\t\treturn;\n\t\t}\n\n\t\tconst fieldMap = this.parseJson(syncUserChannelsFieldMap);\n\t\tif (!fieldMap) {\n\t\t\tlogger.debug('missing group channel mapping');\n\t\t\treturn;\n\t\t}\n\n\t\tconst { username } = user;\n\t\tif (!username) {\n\t\t\treturn;\n\t\t}\n\n\t\tlogger.debug('syncing user channels');\n\t\tconst ldapFields = Object.keys(fieldMap);\n\n\t\tfor await (const ldapField of ldapFields) {\n\t\t\tif (!fieldMap[ldapField]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst isUserInGroup = await this.isUserInGroup(ldap, syncUserChannelsBaseDN, syncUserChannelsFilter, { dn, username }, ldapField);\n\n\t\t\tconst channels: Array<string> = [].concat(fieldMap[ldapField]);\n\t\t\tfor await (const channel of channels) {\n\t\t\t\ttry {\n\t\t\t\t\tconst room: IRoom | undefined = Rooms.findOneByNonValidatedName(channel) || this.createRoomForSync(channel);\n\t\t\t\t\tif (!room) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isUserInGroup) {\n\t\t\t\t\t\tif (room.teamMain) {\n\t\t\t\t\t\t\tlogger.error(`Can't add user to channel ${channel} because it is a team.`);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taddUserToRoom(room._id, user);\n\t\t\t\t\t\t\tlogger.debug(`Synced user channel ${room._id} from LDAP for ${username}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (syncUserChannelsRemove && !room.teamMain) {\n\t\t\t\t\t\tconst subscription = await SubscriptionsRaw.findOneByRoomIdAndUserId(room._id, user._id);\n\t\t\t\t\t\tif (subscription) {\n\t\t\t\t\t\t\tawait removeUserFromRoom(room._id, user);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tlogger.debug(`Failed to sync user room, user = ${username}, channel = ${channel}`);\n\t\t\t\t\tlogger.error(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static async syncUserTeams(ldap: LDAPConnection, user: IUser, dn: string, isNewRecord: boolean): Promise<void> {\n\t\tif (!user.username) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst mapTeams =\n\t\t\tsettings.get<boolean>('LDAP_Enable_LDAP_Groups_To_RC_Teams') &&\n\t\t\t(isNewRecord || settings.get<boolean>('LDAP_Validate_Teams_For_Each_Login'));\n\t\tif (!mapTeams) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst ldapUserTeams = await this.getLdapTeamsByUsername(ldap, user.username, dn);\n\t\tconst mapJson = settings.get<string>('LDAP_Groups_To_Rocket_Chat_Teams');\n\t\tif (!mapJson) {\n\t\t\treturn;\n\t\t}\n\t\tconst map = this.parseJson(mapJson) as Record<string, string>;\n\t\tif (!map) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst teamNames = this.getRocketChatTeamsByLdapTeams(map, ldapUserTeams);\n\n\t\tconst allTeamNames = [...new Set(Object.values(map).flat())];\n\t\tconst allTeams = await Team.listByNames(allTeamNames, { projection: { _id: 1, name: 1 } });\n\n\t\tconst inTeamIds = allTeams.filter(({ name }) => teamNames.includes(name)).map(({ _id }) => _id);\n\t\tconst notInTeamIds = allTeams.filter(({ name }) => !teamNames.includes(name)).map(({ _id }) => _id);\n\n\t\tconst currentTeams = await Team.listTeamsBySubscriberUserId(user._id, {\n\t\t\tprojection: { teamId: 1 },\n\t\t});\n\t\tconst currentTeamIds = currentTeams?.map(({ teamId }) => teamId);\n\t\tconst teamsToRemove = currentTeamIds?.filter((teamId) => notInTeamIds.includes(teamId));\n\t\tconst teamsToAdd = inTeamIds.filter((teamId) => !currentTeamIds?.includes(teamId));\n\n\t\tawait Team.insertMemberOnTeams(user._id, teamsToAdd);\n\t\tif (teamsToRemove) {\n\t\t\tawait Team.removeMemberFromTeams(user._id, teamsToRemove);\n\t\t}\n\t}\n\n\tprivate static getRocketChatTeamsByLdapTeams(mappedTeams: Record<string, string>, ldapUserTeams: Array<string>): Array<string> {\n\t\tconst mappedLdapTeams = Object.keys(mappedTeams);\n\t\tconst filteredTeams = ldapUserTeams.filter((ldapTeam) => mappedLdapTeams.includes(ldapTeam));\n\n\t\tif (filteredTeams.length < ldapUserTeams.length) {\n\t\t\tconst unmappedLdapTeams = ldapUserTeams.filter((ldapTeam) => !mappedLdapTeams.includes(ldapTeam));\n\t\t\tlogger.error(`The following LDAP teams are not mapped in Rocket.Chat: \"${unmappedLdapTeams.join(', ')}\".`);\n\t\t}\n\n\t\tif (!filteredTeams.length) {\n\t\t\treturn [];\n\t\t}\n\n\t\treturn [...new Set(filteredTeams.map((ldapTeam) => mappedTeams[ldapTeam]).flat())];\n\t}\n\n\tprivate static async getLdapTeamsByUsername(ldap: LDAPConnection, username: string, dn: string): Promise<Array<string>> {\n\t\tconst baseDN = (settings.get<string>('LDAP_Teams_BaseDN') ?? '').trim() || ldap.options.baseDN;\n\t\tconst query = settings.get<string>('LDAP_Query_To_Get_User_Teams');\n\t\tif (!query) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst searchOptions = {\n\t\t\tfilter: query.replace(/#{username}/g, username).replace(/#{userdn}/g, dn),\n\t\t\tscope: ldap.options.userSearchScope || 'sub',\n\t\t\tsizeLimit: ldap.options.searchSizeLimit,\n\t\t};\n\n\t\tconst attributeNames = (settings.get<string>('LDAP_Teams_Name_Field') ?? '').split(',').map((attributeName) => attributeName.trim());\n\t\tif (!attributeNames.length) {\n\t\t\tattributeNames.push('ou');\n\t\t}\n\n\t\tconst ldapUserGroups = await ldap.searchRaw(baseDN, searchOptions);\n\t\tif (!Array.isArray(ldapUserGroups)) {\n\t\t\treturn [];\n\t\t}\n\n\t\treturn ldapUserGroups\n\t\t\t.map((entry) => {\n\t\t\t\tif (!entry?.raw) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\tfor (const attributeName of attributeNames) {\n\t\t\t\t\tif (entry.raw[attributeName]) {\n\t\t\t\t\t\treturn ldap.extractLdapAttribute(entry.raw[attributeName]) as string;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn undefined;\n\t\t\t})\n\t\t\t.filter((entry): entry is string => Boolean(entry))\n\t\t\t.flat();\n\t}\n\n\tprivate static isUserDeactivated(ldapUser: ILDAPEntry): boolean {\n\t\t// Account locked by \"Draft-behera-ldap-password-policy\"\n\t\tif (ldapUser.pwdAccountLockedTime) {\n\t\t\tmapLogger.debug('User account is locked by password policy (attribute pwdAccountLockedTime)');\n\t\t\treturn true;\n\t\t}\n\n\t\t// EDirectory: Account manually disabled by an admin\n\t\tif (ldapUser.loginDisabled) {\n\t\t\tmapLogger.debug('User account was manually disabled by an admin (attribute loginDisabled)');\n\t\t\treturn true;\n\t\t}\n\n\t\t// Oracle: Account must not be allowed to authenticate\n\t\tif (ldapUser.orclIsEnabled && ldapUser.orclIsEnabled !== 'ENABLED') {\n\t\t\tmapLogger.debug('User must not be allowed to authenticate (attribute orclIsEnabled)');\n\t\t\treturn true;\n\t\t}\n\n\t\t// Active Directory - Account locked automatically by security policies\n\t\tif (ldapUser.lockoutTime && ldapUser.lockoutTime !== '0') {\n\t\t\tconst lockoutTimeValue = Number(ldapUser.lockoutTime);\n\t\t\tif (lockoutTimeValue && !isNaN(lockoutTimeValue)) {\n\t\t\t\t// Automatic unlock is disabled\n\t\t\t\tif (!ldapUser.lockoutDuration) {\n\t\t\t\t\tmapLogger.debug('User account locked indefinitely by security policy (attribute lockoutTime)');\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tconst lockoutTime = new Date(lockoutTimeValue);\n\t\t\t\tlockoutTime.setMinutes(lockoutTime.getMinutes() + Number(ldapUser.lockoutDuration));\n\t\t\t\t// Account has not unlocked itself yet\n\t\t\t\tif (lockoutTime.valueOf() > Date.now()) {\n\t\t\t\t\tmapLogger.debug('User account locked temporarily by security policy (attribute lockoutTime)');\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Active Directory - Account disabled by an Admin\n\t\tif (ldapUser.userAccountControl && (ldapUser.userAccountControl & 2) === 2) {\n\t\t\tmapLogger.debug('User account disabled by an admin (attribute userAccountControl)');\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic static copyActiveState(ldapUser: ILDAPEntry, userData: IImportUser): void {\n\t\tif (!ldapUser) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst syncUserState = settings.get('LDAP_Sync_User_Active_State');\n\t\tif (syncUserState === 'none') {\n\t\t\treturn;\n\t\t}\n\n\t\tconst deleted = this.isUserDeactivated(ldapUser);\n\t\tif (deleted === userData.deleted) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (syncUserState === 'disable' && !deleted) {\n\t\t\treturn;\n\t\t}\n\n\t\tuserData.deleted = deleted;\n\t\tlogger.info(`${deleted ? 'Deactivating' : 'Activating'} user ${userData.name} (${userData.username})`);\n\t}\n\n\tpublic static copyCustomFields(ldapUser: ILDAPEntry, userData: IImportUser): void {\n\t\tif (!settings.get<boolean>('LDAP_Sync_Custom_Fields')) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst customFieldsSettings = settings.get<string>('Accounts_CustomFields');\n\t\tconst customFieldsMap = settings.get<string>('LDAP_CustomFieldMap');\n\n\t\tif (!customFieldsMap || !customFieldsSettings) {\n\t\t\tif (customFieldsMap) {\n\t\t\t\tlogger.debug('Skipping LDAP custom fields because there are no custom fields configured.');\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tlet map: Record<string, string>;\n\t\ttry {\n\t\t\tmap = JSON.parse(customFieldsMap) as Record<string, string>;\n\t\t} catch (error) {\n\t\t\tlogger.error('Failed to parse LDAP Custom Fields mapping');\n\t\t\tlogger.error(error);\n\t\t\treturn;\n\t\t}\n\n\t\tlet customFields: Record<string, any>;\n\t\ttry {\n\t\t\tcustomFields = JSON.parse(customFieldsSettings) as Record<string, any>;\n\t\t} catch (error) {\n\t\t\tlogger.error('Failed to parse Custom Fields');\n\t\t\tlogger.error(error);\n\t\t\treturn;\n\t\t}\n\n\t\t_.map(map, (userField, ldapField) => {\n\t\t\tif (!this.getCustomField(customFields, userField)) {\n\t\t\t\tlogger.debug(`User attribute does not exist: ${userField}`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!userData.customFields) {\n\t\t\t\tuserData.customFields = {};\n\t\t\t}\n\n\t\t\tconst value = templateVarHandler(ldapField, ldapUser);\n\n\t\t\tif (value) {\n\t\t\t\tlet ref: Record<string, any> = userData.customFields;\n\t\t\t\tconst attributeNames = userField.split('.');\n\t\t\t\tlet previousKey: string | undefined;\n\n\t\t\t\tfor (const key of attributeNames) {\n\t\t\t\t\tif (previousKey) {\n\t\t\t\t\t\tif (ref[previousKey] === undefined) {\n\t\t\t\t\t\t\tref[previousKey] = {};\n\t\t\t\t\t\t} else if (typeof ref[previousKey] !== 'object') {\n\t\t\t\t\t\t\tlogger.error(`Failed to assign custom field: ${userField}`);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tref = ref[previousKey];\n\t\t\t\t\t}\n\n\t\t\t\t\tpreviousKey = key;\n\t\t\t\t}\n\n\t\t\t\tif (previousKey) {\n\t\t\t\t\tref[previousKey] = value;\n\t\t\t\t\tlogger.debug(`user.customFields.${userField} changed to: ${value}`);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate static async importNewUsers(ldap: LDAPConnection, converter: LDAPDataConverter): Promise<void> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tlet count = 0;\n\n\t\t\tldap.searchAllUsers<IImportUser>({\n\t\t\t\tentryCallback: (entry: ldapjs.SearchEntry): IImportUser | undefined => {\n\t\t\t\t\tconst data = ldap.extractLdapEntryData(entry);\n\t\t\t\t\tcount++;\n\n\t\t\t\t\tconst userData = this.mapUserData(data);\n\t\t\t\t\tconverter.addUser(userData);\n\t\t\t\t\treturn userData;\n\t\t\t\t},\n\t\t\t\tendCallback: (error: any): void => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tlogger.error(error);\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tlogger.info('LDAP finished loading users. Users added to importer: ', count);\n\t\t\t\t\tresolve();\n\t\t\t\t},\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate static async updateExistingUsers(ldap: LDAPConnection, converter: LDAPDataConverter): Promise<void> {\n\t\tconst users = await UsersRaw.findLDAPUsers().toArray();\n\t\tfor await (const user of users) {\n\t\t\tconst ldapUser = await this.findLDAPUser(ldap, user);\n\n\t\t\tif (ldapUser) {\n\t\t\t\tconst userData = this.mapUserData(ldapUser, user.username);\n\t\t\t\tconverter.addUser(userData);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static async updateUserAvatars(ldap: LDAPConnection): Promise<void> {\n\t\tconst users = await UsersRaw.findLDAPUsers().toArray();\n\t\tfor await (const user of users) {\n\t\t\tconst ldapUser = await this.findLDAPUser(ldap, user);\n\t\t\tif (!ldapUser) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tLDAPManager.syncUserAvatar(user, ldapUser);\n\t\t}\n\t}\n\n\tprivate static async findLDAPUser(ldap: LDAPConnection, user: IUser): Promise<ILDAPEntry | undefined> {\n\t\tif (user.services?.ldap?.id) {\n\t\t\treturn ldap.findOneById(user.services.ldap.id, user.services.ldap.idAttribute);\n\t\t}\n\n\t\tif (user.username) {\n\t\t\treturn ldap.findOneByUsername(user.username);\n\t\t}\n\n\t\tsearchLogger.debug({\n\t\t\tmsg: 'existing LDAP user not found during Sync',\n\t\t\tldapId: user.services?.ldap?.id,\n\t\t\tldapAttribute: user.services?.ldap?.idAttribute,\n\t\t\tusername: user.username,\n\t\t});\n\t}\n\n\tprivate static async logoutDeactivatedUsers(ldap: LDAPConnection): Promise<void> {\n\t\tconst users = await UsersRaw.findConnectedLDAPUsers().toArray();\n\n\t\tfor await (const user of users) {\n\t\t\tconst ldapUser = await this.findLDAPUser(ldap, user);\n\t\t\tif (!ldapUser) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (this.isUserDeactivated(ldapUser)) {\n\t\t\t\tUsersRaw.unsetLoginTokens(user._id);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static getCustomField(customFields: Record<string, any>, property: string): any {\n\t\ttry {\n\t\t\treturn _.reduce(property.split('.'), (acc, el) => acc[el], customFields);\n\t\t} catch {\n\t\t\t// ignore errors\n\t\t}\n\t}\n}\n"],"sourceRoot":""},"sourceType":"module","hash":"5ca875ed9ea218c7d22f942e722dda2039fcf68e"}
