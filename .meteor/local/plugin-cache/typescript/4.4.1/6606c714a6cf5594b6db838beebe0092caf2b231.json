{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/weslley/Documents/projects/Rocket.Chat/server/lib/ldap/Manager.ts","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"server/lib/ldap/Manager.ts","filename":"/home/weslley/Documents/projects/Rocket.Chat/server/lib/ldap/Manager.ts","inputSourceMap":{"version":3,"file":"server/lib/ldap/Manager.ts","sourceRoot":"","sources":["server/lib/ldap/Manager.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,MAAM,OAAO,CAAC;AAC1B,2CAA2C;AAC3C,OAAO,EAAE,MAAM,EAAE,MAAM,YAAY,CAAC;AACpC,OAAO,EAAE,MAAM,EAAE,MAAM,eAAe,CAAC;AACvC,OAAO,EAAE,QAAQ,EAAE,MAAM,sBAAsB,CAAC;AAChD,OAAO,UAAU,MAAM,aAAa,CAAC;AACrC,OAAO,CAAC,MAAM,YAAY,CAAC;AAO3B,OAAO,EAAE,QAAQ,EAAE,MAAM,8BAA8B,CAAC;AACxD,OAAO,EAAE,KAAK,IAAI,QAAQ,EAAE,MAAM,gCAAgC,CAAC;AACnE,OAAO,EAAE,cAAc,EAAE,MAAM,cAAc,CAAC;AAC9C,OAAO,EAAE,iBAAiB,EAAE,MAAM,iBAAiB,CAAC;AACpD,OAAO,EAAE,yBAAyB,EAAE,MAAM,6BAA6B,CAAC;AACxE,OAAO,EAAE,MAAM,EAAE,UAAU,EAAE,UAAU,EAAE,MAAM,UAAU,CAAC;AAE1D,OAAO,EAAE,SAAS,EAAE,MAAM,wBAAwB,CAAC;AACnD,OAAO,EAAE,aAAa,EAAE,MAAM,mCAAmC,CAAC;AAElE,MAAM,OAAO,WAAW;IAChB,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,QAAgB,EAAE,QAAgB;QAC3D,MAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,iBAAiB,EAAE,QAAQ,EAAE,CAAC,CAAC;QAEnD,IAAI,QAAQ,CAAC,GAAG,CAAC,aAAa,CAAC,KAAK,IAAI,EAAE;YACzC,OAAO,IAAI,CAAC,sBAAsB,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;SACvD;QAED,IAAI,QAAgC,CAAC;QAErC,MAAM,IAAI,GAAG,IAAI,cAAc,EAAE,CAAC;QAClC,IAAI;YACH,IAAI;gBACH,MAAM,IAAI,CAAC,OAAO,EAAE,CAAC;gBACrB,QAAQ,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC;aACzD;YAAC,OAAO,KAAK,EAAE;gBACf,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;aACpB;YAED,IAAI,QAAQ,KAAK,SAAS,EAAE;gBAC3B,OAAO,IAAI,CAAC,sBAAsB,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;aACvD;YAED,MAAM,iBAAiB,GAAG,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;YACnE,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC,QAAQ,EAAE,iBAAiB,CAAC,CAAC;YAEtE,IAAI,IAAI,EAAE;gBACT,OAAO,MAAM,IAAI,CAAC,iBAAiB,CAAC,IAAI,EAAE,IAAI,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC;aACpE;YAED,OAAO,MAAM,IAAI,CAAC,oBAAoB,CAAC,iBAAiB,EAAE,QAAQ,EAAE,QAAQ,EAAE,IAAI,CAAC,CAAC;SACpF;gBAAS;YACT,IAAI,CAAC,UAAU,EAAE,CAAC;SAClB;IACF,CAAC;IAEM,MAAM,CAAC,KAAK,CAAC,cAAc;QACjC,IAAI;YACH,MAAM,IAAI,GAAG,IAAI,cAAc,EAAE,CAAC;YAClC,MAAM,IAAI,CAAC,cAAc,EAAE,CAAC;SAC5B;QAAC,OAAO,KAAK,EAAE;YACf,UAAU,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;YACxB,MAAM,KAAK,CAAC;SACZ;IACF,CAAC;IAEM,MAAM,CAAC,KAAK,CAAC,UAAU,CAAC,QAAgB;QAC9C,MAAM,eAAe,GAAG,UAAU,CAAC,MAAM,CAAA,GAAG,QAAQ,EAAE,CAAC;QACvD,MAAM,IAAI,GAAG,IAAI,cAAc,EAAE,CAAC;QAElC,IAAI;YACH,MAAM,IAAI,CAAC,OAAO,EAAE,CAAC;YAErB,MAAM,KAAK,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC,eAAe,CAAC,CAAC;YAC3D,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;gBACvB,MAAM,CAAC,KAAK,CAAC,mBAAmB,KAAK,CAAC,MAAM,gBAAgB,eAAe,EAAE,CAAC,CAAC;gBAC/E,MAAM,IAAI,KAAK,CAAC,gBAAgB,CAAC,CAAC;aAClC;SACD;QAAC,OAAO,KAAK,EAAE;YACf,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;YACpB,MAAM,KAAK,CAAC;SACZ;IACF,CAAC;IAEM,MAAM,CAAC,cAAc,CAAC,IAAW,EAAE,QAAoB;QAC7D,IAAI,CAAC,IAAI,EAAE,GAAG,IAAI,QAAQ,CAAC,GAAG,CAAC,uBAAuB,CAAC,KAAK,IAAI,EAAE;YACjE,OAAO;SACP;QAED,MAAM,MAAM,GAAG,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAC;QAChD,IAAI,CAAC,MAAM,EAAE;YACZ,OAAO;SACP;QAED,MAAM,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC,CAAC;QACvC,IAAI,IAAI,CAAC,UAAU,KAAK,IAAI,EAAE;YAC7B,OAAO;SACP;QAED,MAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,qBAAqB,EAAE,QAAQ,EAAE,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;QACtE,uCAAuC;QACvC,4FAA4F;QAC5F,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC,aAAa,CAAC,IAAI,EAAE,MAAM,EAAE,YAAY,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC,CAAC;IAC3F,CAAC;IAED,4EAA4E;IAClE,MAAM,CAAC,KAAK,CAAC,oBAAoB,CAAC,QAAoB;QAC/D,MAAM,qBAAqB,GAAG,IAAI,CAAC,mBAAmB,CAAC,QAAQ,CAAC,CAAC;QAEjE,IAAI,qBAAqB,EAAE;YAC1B,MAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,eAAe,EAAE,QAAQ,EAAE,qBAAqB,CAAC,KAAK,EAAE,CAAC,CAAC;YAC9E,OAAO,QAAQ,CAAC,eAAe,CAAC,qBAAqB,CAAC,KAAK,EAAE,qBAAqB,CAAC,SAAS,CAAC,CAAC;SAC9F;IACF,CAAC;IAES,MAAM,CAAC,mBAAmB;QACnC,OAAO;YACN,oBAAoB,EAAE,QAAQ,CAAC,GAAG,CAAU,6CAA6C,CAAC,IAAI,KAAK;YACnG,iBAAiB,EAAE,KAAK;SACxB,CAAC;IACH,CAAC;IAES,MAAM,CAAC,WAAW,CAAC,QAAoB,EAAE,YAAiC;QACnF,MAAM,QAAQ,GAAG,IAAI,CAAC,mBAAmB,CAAC,QAAQ,CAAC,CAAC;QACpD,IAAI,CAAC,QAAQ,EAAE;YACd,MAAM,IAAI,KAAK,CAAC,qDAAqD,CAAC,CAAC;SACvE;QAED,MAAM,EAAE,SAAS,EAAE,WAAW,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,QAAQ,CAAC;QACvD,MAAM,QAAQ,GAAG,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,IAAI,YAAY,IAAI,EAAE,IAAI,SAAS,CAAC;QACnF,MAAM,MAAM,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;QACtD,MAAM,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,IAAI,SAAS,CAAC;QAErD,MAAM,QAAQ,GAAgB;YAC7B,IAAI,EAAE,MAAM;YACZ,MAAM;YACN,SAAS,EAAE,CAAC,QAAQ,CAAC,EAAE,CAAC;YACxB,QAAQ;YACR,IAAI;YACJ,QAAQ,EAAE;gBACT,IAAI,EAAE;oBACL,WAAW;oBACX,EAAE;iBACF;aACD;SACD,CAAC;QAEF,IAAI,CAAC,aAAa,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;QACvC,OAAO,QAAQ,CAAC;IACjB,CAAC;IAEO,MAAM,CAAC,aAAa,CAAC,QAAoB,EAAE,QAAqB;QACvE,SAAS,CAAC,GAAG,CAAC,iBAAiB,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC;IACtD,CAAC;IAEO,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAoB,EAAE,QAAgB,EAAE,QAAgB;QACrF,MAAM,eAAe,GAAG,UAAU,CAAC,MAAM,CAAA,GAAG,QAAQ,EAAE,CAAC;QAEvD,IAAI;YACH,MAAM,KAAK,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC,eAAe,CAAC,CAAC;YAE3D,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;gBACvB,MAAM,CAAC,KAAK,CAAC,mBAAmB,KAAK,CAAC,MAAM,gBAAgB,eAAe,EAAE,CAAC,CAAC;gBAC/E,MAAM,IAAI,KAAK,CAAC,gBAAgB,CAAC,CAAC;aAClC;YAED,MAAM,CAAC,QAAQ,CAAC,GAAG,KAAK,CAAC;YACzB,IAAI,CAAC,CAAC,MAAM,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,EAAE,EAAE,QAAQ,CAAC,CAAC,EAAE;gBACtD,MAAM,CAAC,KAAK,CAAC,sBAAsB,eAAe,EAAE,CAAC,CAAC;gBACtD,MAAM,IAAI,KAAK,CAAC,gCAAgC,CAAC,CAAC;aAClD;YAED,IAAI,QAAQ,CAAC,GAAG,CAAU,4BAA4B,CAAC,EAAE;gBACxD,4DAA4D;gBAC5D,UAAU,CAAC,KAAK,CAAC,gEAAgE,CAAC,CAAC;gBACnF,IAAI,CAAC,MAAM,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC,KAAK,CAAC,EAAE;oBACvD,UAAU,CAAC,KAAK,CAAC,4BAA4B,QAAQ,CAAC,EAAE,2BAA2B,CAAC,CAAC;iBACrF;aACD;YAED,IAAI,CAAC,CAAC,MAAM,IAAI,CAAC,2BAA2B,CAAC,eAAe,EAAE,QAAQ,CAAC,EAAE,CAAC,CAAC,EAAE;gBAC5E,MAAM,IAAI,KAAK,CAAC,2BAA2B,CAAC,CAAC;aAC7C;YAED,OAAO,QAAQ,CAAC;SAChB;QAAC,OAAO,KAAK,EAAE;YACf,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;SACpB;IACF,CAAC;IAEO,MAAM,CAAC,KAAK,CAAC,oBAAoB,CACxC,iBAAyB,EACzB,QAAgB,EAChB,QAAoB,EACpB,IAAoB;QAEpB,MAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,+BAA+B,EAAE,QAAQ,EAAE,iBAAiB,EAAE,CAAC,CAAC;QAEpF,IAAI,QAA4B,CAAC;QAEjC,IAAI,yBAAyB,CAAC,qBAAqB,CAAC,KAAK,EAAE,EAAE;YAC5D,QAAQ,GAAG,iBAAiB,CAAC;SAC7B;QAED,kBAAkB;QAClB,OAAO,IAAI,CAAC,WAAW,CAAC,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAAE,IAAI,CAAC,CAAC;IAC7D,CAAC;IAEO,MAAM,CAAC,KAAK,CAAC,WAAW,CAC/B,QAAoB,EACpB,QAA4B,EAC5B,QAA4B,EAC5B,IAAoB;QAEpB,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC,QAAQ,EAAE,SAAS,EAAE,QAAQ,CAAC,CAAC;QAExE,IAAI,CAAC,IAAI,EAAE;YACV,OAAO;SACP;QAED,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,IAAI,EAAE,QAAQ,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;QAEnD,OAAO;YACN,MAAM,EAAE,IAAI,CAAC,GAAG;SAChB,CAAC;IACH,CAAC;IAEO,MAAM,CAAC,OAAO,CAAC,QAAoB,EAAE,IAAW,EAAE,QAA4B,EAAE,IAAoB,EAAE,SAAkB;QAC/H,MAAM,CAAC,KAAK,CAAC,qBAAqB,CAAC,CAAC;QACpC,IAAI,QAAQ,CAAC,GAAG,CAAU,qBAAqB,CAAC,IAAI,OAAO,QAAQ,KAAK,QAAQ,IAAI,QAAQ,CAAC,IAAI,EAAE,KAAK,EAAE,EAAE;YAC3G,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,GAAG,EAAE,QAAQ,EAAE,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,CAAC;SAC5D;QAED,IAAI,CAAC,cAAc,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;QACpC,SAAS,CAAC,GAAG,CAAC,aAAa,EAAE,EAAE,IAAI,EAAE,QAAQ,EAAE,SAAS,EAAE,EAAE,IAAI,CAAC,CAAC;IACnE,CAAC;IAEO,MAAM,CAAC,KAAK,CAAC,iBAAiB,CACrC,IAAoB,EACpB,IAAW,EACX,QAAoB,EACpB,QAAgB;QAEhB,IAAI,IAAI,CAAC,IAAI,KAAK,IAAI,IAAI,QAAQ,CAAC,GAAG,CAAC,2BAA2B,CAAC,KAAK,IAAI,EAAE;YAC7E,MAAM,CAAC,KAAK,CAAC,kCAAkC,CAAC,CAAC;YACjD,MAAM,IAAI,MAAM,CAAC,KAAK,CACrB,kBAAkB,EAClB,+FAA+F,IAAI,CAAC,QAAQ,aAAa,CACzH,CAAC;SACF;QAED,wHAAwH;QACxH,MAAM,aAAa,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC;QAEjC,MAAM,QAAQ,GAAG,aAAa,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAU,2BAA2B,CAAC,IAAI,IAAI,CAAC,CAAC;QAC/F,MAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,iBAAiB,EAAE,QAAQ,EAAE,CAAC,CAAC;QACnD,MAAM,WAAW,GAAG,CAAC,QAAQ,IAAI,CAAC,MAAM,IAAI,CAAC,gBAAgB,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC;QAExF,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,WAAW,EAAE,QAAQ,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;QAC3D,OAAO;YACN,MAAM,EAAE,IAAI,CAAC,GAAG;SAChB,CAAC;IACH,CAAC;IAEO,MAAM,CAAC,KAAK,CAAC,gBAAgB,CACpC,QAAoB,EACpB,YAAoB,EACpB,YAAiC;QAEjC,MAAM,CAAC,KAAK,CAAC;YACZ,GAAG,EAAE,mBAAmB;YACxB,QAAQ,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,EAAE,MAAM,CAAC;YAClC,IAAI,EAAE,EAAE,GAAG,CAAC,YAAY,IAAI,EAAE,KAAK,EAAE,YAAY,CAAC,MAAM,EAAE,GAAG,EAAE,YAAY,CAAC,GAAG,EAAE,CAAC,EAAE;SACpF,CAAC,CAAC;QAEH,MAAM,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,EAAE,YAAY,CAAC,CAAC;QAE1D,uEAAuE;QACvE,+KAA+K;QAC/K,IAAI,YAAY,EAAE;YACjB,IAAI,CAAC,QAAQ,CAAC,KAAK,IAAI,YAAY,CAAC,KAAK,EAAE;gBAC1C,QAAQ,CAAC,KAAK,GAAG,YAAY,CAAC,KAAK,CAAC;aACpC;YACD,IAAI,CAAC,QAAQ,CAAC,IAAI,IAAI,YAAY,CAAC,IAAI,EAAE;gBACxC,QAAQ,CAAC,IAAI,GAAG,YAAY,CAAC,IAA2B,CAAC;aACzD;SACD;QAED,MAAM,OAAO,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAC;QAC3C,iBAAiB,CAAC,iBAAiB,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;QAEvD,OAAO,YAAY,IAAI,IAAI,CAAC,oBAAoB,CAAC,QAAQ,CAAC,CAAC;IAC5D,CAAC;IAEO,MAAM,CAAC,mBAAmB,CAAC,QAAoB;QACtD,IAAI,qBAAqB,GAAkC,QAAQ,CAAC,GAAG,CAAS,8BAA8B,CAAC,CAAC;QAEhH,IAAI,qBAAqB,EAAE;YAC1B,qBAAqB,GAAG,qBAAqB,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;SAC5E;aAAM;YACN,qBAAqB,GAAG,EAAE,CAAC;SAC3B;QAED,IAAI,eAAe,GAAkC,yBAAyB,CAAS,wBAAwB,CAAC,CAAC;QAEjH,IAAI,eAAe,EAAE;YACpB,eAAe,GAAG,eAAe,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;SAChE;aAAM;YACN,eAAe,GAAG,EAAE,CAAC;SACrB;QAED,qBAAqB,GAAG,qBAAqB,CAAC,MAAM,CAAC,eAAe,CAAC,CAAC;QACtE,IAAI,CAAC,qBAAqB,CAAC,MAAM,EAAE;YAClC,qBAAqB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SACjC;QAED,MAAM,GAAG,GAAG,qBAAqB,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QACpF,IAAI,GAAG,EAAE;YACR,OAAO;gBACN,SAAS,EAAE,GAAG;gBACd,KAAK,EAAE,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC;aACzC,CAAC;SACF;QAED,UAAU,CAAC,IAAI,CAAC,qDAAqD,CAAC,CAAC;QACvE,UAAU,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;IAC5B,CAAC;IAEO,MAAM,CAAC,aAAa,CAAC,QAAoB,EAAE,GAAW;QAC7D,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;IACzC,CAAC;IAEO,MAAM,CAAC,aAAa,CAAC,QAAoB,EAAE,GAAW;QAC7D,OAAO,QAAQ,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC;IAC7B,CAAC;IAEO,MAAM,CAAC,mBAAmB,CAAC,QAAoB,EAAE,gBAAoC;QAC5F,IAAI,CAAC,gBAAgB,EAAE;YACtB,OAAO;SACP;QAED,2EAA2E;QAC3E,IAAI,gBAAgB,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;YACpC,OAAO,gBAAgB,CAAC,OAAO,CAAC,WAAW,EAAE,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE;gBAC9D,MAAM,GAAG,GAAG,KAAK,CAAC,IAAI,EAAE,CAAC;gBAEzB,IAAI,IAAI,CAAC,aAAa,CAAC,QAAQ,EAAE,GAAG,CAAC,EAAE;oBACtC,OAAO,IAAI,CAAC,aAAa,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;iBACzC;gBAED,OAAO,EAAE,CAAC;YACX,CAAC,CAAC,CAAC;SACH;QAED,2HAA2H;QAC3H,MAAM,aAAa,GAAa,gBAAgB,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAC/E,MAAM,GAAG,GAAG,aAAa,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,IAAI,CAAC,aAAa,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC,CAAC;QAC/E,IAAI,GAAG,EAAE;YACR,OAAO,IAAI,CAAC,aAAa,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;SACzC;IACF,CAAC;IAEO,MAAM,CAAC,WAAW,CAAC,QAAoB;QAC9C,MAAM,cAAc,GAAG,yBAAyB,CAAqB,iBAAiB,CAAC,CAAC;QACxF,OAAO,IAAI,CAAC,mBAAmB,CAAC,QAAQ,EAAE,cAAc,CAAC,CAAC;IAC3D,CAAC;IAEO,MAAM,CAAC,aAAa,CAAC,QAAoB,EAAE,QAAiB;QACnE,MAAM,eAAe,GAAG,yBAAyB,CAAS,kBAAkB,CAAC,CAAC;QAC9E,IAAI,eAAe,EAAE;YACpB,MAAM,aAAa,GAAa,eAAe,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;YAC9E,MAAM,GAAG,GAAG,aAAa,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,IAAI,CAAC,aAAa,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC,CAAC;YAE/E,MAAM,MAAM,GAAa,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;YACpE,MAAM,cAAc,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC;YAErE,IAAI,cAAc,CAAC,MAAM,EAAE;gBAC1B,OAAO,cAAc,CAAC;aACtB;SACD;QAED,IAAI,QAAQ,CAAC,GAAG,CAAC,qBAAqB,CAAC,KAAK,EAAE,IAAI,QAAQ,EAAE;YAC3D,OAAO,CAAC,GAAG,QAAQ,IAAI,QAAQ,CAAC,GAAG,CAAC,qBAAqB,CAAC,EAAE,CAAC,CAAC;SAC9D;QAED,IAAI,QAAQ,CAAC,IAAI,IAAI,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;YACjD,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;SACvB;QAED,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;QACvB,MAAM,IAAI,KAAK,CAAC,4CAA4C,CAAC,CAAC;IAC/D,CAAC;IAEO,MAAM,CAAC,OAAO,CAAC,IAAY;QAClC,IAAI,QAAQ,CAAC,GAAG,CAAC,oBAAoB,CAAC,KAAK,IAAI,EAAE;YAChD,OAAO,IAAI,CAAC;SACZ;QAED,IAAI,GAAG,KAAK,CAAC,IAAI,EAAE,EAAE,WAAW,EAAE,GAAG,EAAE,CAAC,CAAC;QACzC,OAAO,IAAI,CAAC,OAAO,CAAC,eAAe,EAAE,EAAE,CAAC,CAAC;IAC1C,CAAC;IAEO,MAAM,CAAC,eAAe,CAAC,QAAoB,EAAE,eAAuB;QAC3E,IAAI,yBAAyB,CAAC,qBAAqB,CAAC,KAAK,EAAE,EAAE;YAC5D,MAAM,QAAQ,GAAG,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC;YAChD,IAAI,QAAQ,EAAE;gBACb,OAAO,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;aAC9B;SACD;QAED,OAAO,IAAI,CAAC,OAAO,CAAC,eAAe,CAAC,CAAC;IACtC,CAAC;IAEO,MAAM,CAAC,eAAe,CAAC,QAAoB;QAClD,MAAM,aAAa,GAAG,yBAAyB,CAAC,qBAAqB,CAAW,CAAC;QACjF,OAAO,IAAI,CAAC,mBAAmB,CAAC,QAAQ,EAAE,aAAa,CAAC,CAAC;IAC1D,CAAC;IAED,kEAAkE;IAC1D,MAAM,CAAC,KAAK,CAAC,gBAAgB,CAAC,QAAoB,EAAE,iBAAyB;QACpF,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,oBAAoB,CAAC,QAAQ,CAAC,CAAC;QACvD,IAAI,IAAI,EAAE;YACT,OAAO,IAAI,CAAC;SACZ;QAED,OAAO,QAAQ,CAAC,iBAAiB,CAAC,iBAAiB,CAAC,CAAC;IACtD,CAAC;IAEO,MAAM,CAAC,sBAAsB,CAAC,QAAuB,EAAE,QAAgB;QAC9E,IAAI,OAAO,QAAQ,KAAK,QAAQ,EAAE;YACjC,IAAI,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE;gBACjC,QAAQ,GAAG,EAAE,QAAQ,EAAE,CAAC;aACxB;iBAAM;gBACN,QAAQ,GAAG,EAAE,KAAK,EAAE,QAAQ,EAAE,CAAC;aAC/B;SACD;QAED,MAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,oCAAoC,EAAE,QAAQ,EAAE,CAAC,CAAC;QAEtE,MAAM,YAAY,GAAG;YACpB,IAAI,EAAE,QAAQ;YACd,QAAQ,EAAE;gBACT,MAAM,EAAE,MAAM,CAAC,QAAQ,CAAC;gBACxB,SAAS,EAAE,SAAS;aACpB;SACD,CAAC;QAEF,OAAO,QAAQ,CAAC,iBAAiB,CAAC,IAAI,EAAE,YAAY,CAAC,CAAC;IACvD,CAAC;IAEO,MAAM,CAAC,iBAAiB,CAAC,QAAoB;QACpD,MAAM,WAAW,GAAG,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,mBAAmB,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC;QAC3E,IAAI,WAAW,IAAI,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE;YAC9C,OAAO,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;SAClC;QAED,IAAI,QAAQ,CAAC,IAAI,CAAC,cAAc,EAAE;YACjC,OAAO,QAAQ,CAAC,IAAI,CAAC,cAAc,CAAC;SACpC;QAED,IAAI,QAAQ,CAAC,IAAI,CAAC,SAAS,EAAE;YAC5B,OAAO,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC;SAC/B;IACF,CAAC;CACD","sourcesContent":["import limax from 'limax';\n// #ToDo: #TODO: Remove Meteor dependencies\nimport { SHA256 } from 'meteor/sha';\nimport { Meteor } from 'meteor/meteor';\nimport { Accounts } from 'meteor/accounts-base';\nimport ldapEscape from 'ldap-escape';\nimport _ from 'underscore';\n\nimport { ILDAPEntry } from '../../../definition/ldap/ILDAPEntry';\nimport { LDAPLoginResult } from '../../../definition/ldap/ILDAPLoginResult';\nimport { ILDAPUniqueIdentifierField } from '../../../definition/ldap/ILDAPUniqueIdentifierField';\nimport { IUser, LoginUsername } from '../../../definition/IUser';\nimport { IImportUser } from '../../../definition/IImportUser';\nimport { settings } from '../../../app/settings/server';\nimport { Users as UsersRaw } from '../../../app/models/server/raw';\nimport { LDAPConnection } from './Connection';\nimport { LDAPDataConverter } from './DataConverter';\nimport { getLDAPConditionalSetting } from './getLDAPConditionalSetting';\nimport { logger, authLogger, connLogger } from './Logger';\nimport type { IConverterOptions } from '../../../app/importer/server/classes/ImportDataConverter';\nimport { callbacks } from '../../../lib/callbacks';\nimport { setUserAvatar } from '../../../app/lib/server/functions';\n\nexport class LDAPManager {\n\tpublic static async login(username: string, password: string): Promise<LDAPLoginResult> {\n\t\tlogger.debug({ msg: 'Init LDAP login', username });\n\n\t\tif (settings.get('LDAP_Enable') !== true) {\n\t\t\treturn this.fallbackToDefaultLogin(username, password);\n\t\t}\n\n\t\tlet ldapUser: ILDAPEntry | undefined;\n\n\t\tconst ldap = new LDAPConnection();\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tawait ldap.connect();\n\t\t\t\tldapUser = await this.findUser(ldap, username, password);\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(error);\n\t\t\t}\n\n\t\t\tif (ldapUser === undefined) {\n\t\t\t\treturn this.fallbackToDefaultLogin(username, password);\n\t\t\t}\n\n\t\t\tconst slugifiedUsername = this.slugifyUsername(ldapUser, username);\n\t\t\tconst user = await this.findExistingUser(ldapUser, slugifiedUsername);\n\n\t\t\tif (user) {\n\t\t\t\treturn await this.loginExistingUser(ldap, user, ldapUser, password);\n\t\t\t}\n\n\t\t\treturn await this.loginNewUserFromLDAP(slugifiedUsername, password, ldapUser, ldap);\n\t\t} finally {\n\t\t\tldap.disconnect();\n\t\t}\n\t}\n\n\tpublic static async testConnection(): Promise<void> {\n\t\ttry {\n\t\t\tconst ldap = new LDAPConnection();\n\t\t\tawait ldap.testConnection();\n\t\t} catch (error) {\n\t\t\tconnLogger.error(error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tpublic static async testSearch(username: string): Promise<void> {\n\t\tconst escapedUsername = ldapEscape.filter`${username}`;\n\t\tconst ldap = new LDAPConnection();\n\n\t\ttry {\n\t\t\tawait ldap.connect();\n\n\t\t\tconst users = await ldap.searchByUsername(escapedUsername);\n\t\t\tif (users.length !== 1) {\n\t\t\t\tlogger.debug(`Search returned ${users.length} records for ${escapedUsername}`);\n\t\t\t\tthrow new Error('User not found');\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.error(error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tpublic static syncUserAvatar(user: IUser, ldapUser: ILDAPEntry): void {\n\t\tif (!user?._id || settings.get('LDAP_Sync_User_Avatar') !== true) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst avatar = this.getAvatarFromUser(ldapUser);\n\t\tif (!avatar) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst hash = SHA256(avatar.toString());\n\t\tif (user.avatarETag === hash) {\n\t\t\treturn;\n\t\t}\n\n\t\tlogger.debug({ msg: 'Syncing user avatar', username: user.username });\n\t\t// #ToDo: Remove Meteor references here\n\t\t// runAsUser is needed for now because the UploadFS class rejects files if there's no userId\n\t\tMeteor.runAsUser(user._id, () => setUserAvatar(user, avatar, 'image/jpeg', 'rest', hash));\n\t}\n\n\t// This method will only find existing users that are already linked to LDAP\n\tprotected static async findExistingLDAPUser(ldapUser: ILDAPEntry): Promise<IUser | undefined> {\n\t\tconst uniqueIdentifierField = this.getLdapUserUniqueID(ldapUser);\n\n\t\tif (uniqueIdentifierField) {\n\t\t\tlogger.debug({ msg: 'Querying user', uniqueId: uniqueIdentifierField.value });\n\t\t\treturn UsersRaw.findOneByLDAPId(uniqueIdentifierField.value, uniqueIdentifierField.attribute);\n\t\t}\n\t}\n\n\tprotected static getConverterOptions(): IConverterOptions {\n\t\treturn {\n\t\t\tflagEmailsAsVerified: settings.get<boolean>('Accounts_Verify_Email_For_External_Accounts') ?? false,\n\t\t\tskipExistingUsers: false,\n\t\t};\n\t}\n\n\tprotected static mapUserData(ldapUser: ILDAPEntry, usedUsername?: string | undefined): IImportUser {\n\t\tconst uniqueId = this.getLdapUserUniqueID(ldapUser);\n\t\tif (!uniqueId) {\n\t\t\tthrow new Error('Failed to generate unique identifier for ldap entry');\n\t\t}\n\n\t\tconst { attribute: idAttribute, value: id } = uniqueId;\n\t\tconst username = this.getLdapUsername(ldapUser) || usedUsername || id || undefined;\n\t\tconst emails = this.getLdapEmails(ldapUser, username);\n\t\tconst name = this.getLdapName(ldapUser) || undefined;\n\n\t\tconst userData: IImportUser = {\n\t\t\ttype: 'user',\n\t\t\temails,\n\t\t\timportIds: [ldapUser.dn],\n\t\t\tusername,\n\t\t\tname,\n\t\t\tservices: {\n\t\t\t\tldap: {\n\t\t\t\t\tidAttribute,\n\t\t\t\t\tid,\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\tthis.onMapUserData(ldapUser, userData);\n\t\treturn userData;\n\t}\n\n\tprivate static onMapUserData(ldapUser: ILDAPEntry, userData: IImportUser): void {\n\t\tcallbacks.run('mapLDAPUserData', userData, ldapUser);\n\t}\n\n\tprivate static async findUser(ldap: LDAPConnection, username: string, password: string): Promise<ILDAPEntry | undefined> {\n\t\tconst escapedUsername = ldapEscape.filter`${username}`;\n\n\t\ttry {\n\t\t\tconst users = await ldap.searchByUsername(escapedUsername);\n\n\t\t\tif (users.length !== 1) {\n\t\t\t\tlogger.debug(`Search returned ${users.length} records for ${escapedUsername}`);\n\t\t\t\tthrow new Error('User not found');\n\t\t\t}\n\n\t\t\tconst [ldapUser] = users;\n\t\t\tif (!(await ldap.authenticate(ldapUser.dn, password))) {\n\t\t\t\tlogger.debug(`Wrong password for ${escapedUsername}`);\n\t\t\t\tthrow new Error('Invalid user or wrong password');\n\t\t\t}\n\n\t\t\tif (settings.get<boolean>('LDAP_Find_User_After_Login')) {\n\t\t\t\t// Do a search as the user and check if they have any result\n\t\t\t\tauthLogger.debug('User authenticated successfully, performing additional search.');\n\t\t\t\tif ((await ldap.searchAndCount(ldapUser.dn, {})) === 0) {\n\t\t\t\t\tauthLogger.debug(`Bind successful but user ${ldapUser.dn} was not found via search`);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!(await ldap.isUserAcceptedByGroupFilter(escapedUsername, ldapUser.dn))) {\n\t\t\t\tthrow new Error('User not in a valid group');\n\t\t\t}\n\n\t\t\treturn ldapUser;\n\t\t} catch (error) {\n\t\t\tlogger.error(error);\n\t\t}\n\t}\n\n\tprivate static async loginNewUserFromLDAP(\n\t\tslugifiedUsername: string,\n\t\tldapPass: string,\n\t\tldapUser: ILDAPEntry,\n\t\tldap: LDAPConnection,\n\t): Promise<LDAPLoginResult> {\n\t\tlogger.debug({ msg: 'User does not exist, creating', username: slugifiedUsername });\n\n\t\tlet username: string | undefined;\n\n\t\tif (getLDAPConditionalSetting('LDAP_Username_Field') !== '') {\n\t\t\tusername = slugifiedUsername;\n\t\t}\n\n\t\t// Create new user\n\t\treturn this.addLdapUser(ldapUser, username, ldapPass, ldap);\n\t}\n\n\tprivate static async addLdapUser(\n\t\tldapUser: ILDAPEntry,\n\t\tusername: string | undefined,\n\t\tpassword: string | undefined,\n\t\tldap: LDAPConnection,\n\t): Promise<LDAPLoginResult> {\n\t\tconst user = await this.syncUserForLogin(ldapUser, undefined, username);\n\n\t\tif (!user) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.onLogin(ldapUser, user, password, ldap, true);\n\n\t\treturn {\n\t\t\tuserId: user._id,\n\t\t};\n\t}\n\n\tprivate static onLogin(ldapUser: ILDAPEntry, user: IUser, password: string | undefined, ldap: LDAPConnection, isNewUser: boolean): void {\n\t\tlogger.debug('running onLDAPLogin');\n\t\tif (settings.get<boolean>('LDAP_Login_Fallback') && typeof password === 'string' && password.trim() !== '') {\n\t\t\tAccounts.setPassword(user._id, password, { logout: false });\n\t\t}\n\n\t\tthis.syncUserAvatar(user, ldapUser);\n\t\tcallbacks.run('onLDAPLogin', { user, ldapUser, isNewUser }, ldap);\n\t}\n\n\tprivate static async loginExistingUser(\n\t\tldap: LDAPConnection,\n\t\tuser: IUser,\n\t\tldapUser: ILDAPEntry,\n\t\tpassword: string,\n\t): Promise<LDAPLoginResult> {\n\t\tif (user.ldap !== true && settings.get('LDAP_Merge_Existing_Users') !== true) {\n\t\t\tlogger.debug('User exists without \"ldap: true\"');\n\t\t\tthrow new Meteor.Error(\n\t\t\t\t'LDAP-login-error',\n\t\t\t\t`LDAP Authentication succeeded, but there's already an existing user with provided username [${user.username}] in Mongo.`,\n\t\t\t);\n\t\t}\n\n\t\t// If we're merging an ldap user with a local user, then we need to sync the data even if 'update data on login' is off.\n\t\tconst forceUserSync = !user.ldap;\n\n\t\tconst syncData = forceUserSync || (settings.get<boolean>('LDAP_Update_Data_On_Login') ?? true);\n\t\tlogger.debug({ msg: 'Logging user in', syncData });\n\t\tconst updatedUser = (syncData && (await this.syncUserForLogin(ldapUser, user))) || user;\n\n\t\tthis.onLogin(ldapUser, updatedUser, password, ldap, false);\n\t\treturn {\n\t\t\tuserId: user._id,\n\t\t};\n\t}\n\n\tprivate static async syncUserForLogin(\n\t\tldapUser: ILDAPEntry,\n\t\texistingUser?: IUser,\n\t\tusedUsername?: string | undefined,\n\t): Promise<IUser | undefined> {\n\t\tlogger.debug({\n\t\t\tmsg: 'Syncing user data',\n\t\t\tldapUser: _.omit(ldapUser, '_raw'),\n\t\t\tuser: { ...(existingUser && { email: existingUser.emails, _id: existingUser._id }) },\n\t\t});\n\n\t\tconst userData = this.mapUserData(ldapUser, usedUsername);\n\n\t\t// make sure to persist existing user data when passing to sync/convert\n\t\t// TODO this is only needed because ImporterDataConverter assigns a default role and type if nothing is set. we might need to figure out a better way and stop doing that there\n\t\tif (existingUser) {\n\t\t\tif (!userData.roles && existingUser.roles) {\n\t\t\t\tuserData.roles = existingUser.roles;\n\t\t\t}\n\t\t\tif (!userData.type && existingUser.type) {\n\t\t\t\tuserData.type = existingUser.type as IImportUser['type'];\n\t\t\t}\n\t\t}\n\n\t\tconst options = this.getConverterOptions();\n\t\tLDAPDataConverter.convertSingleUser(userData, options);\n\n\t\treturn existingUser || this.findExistingLDAPUser(ldapUser);\n\t}\n\n\tprivate static getLdapUserUniqueID(ldapUser: ILDAPEntry): ILDAPUniqueIdentifierField | undefined {\n\t\tlet uniqueIdentifierField: string | string[] | undefined = settings.get<string>('LDAP_Unique_Identifier_Field');\n\n\t\tif (uniqueIdentifierField) {\n\t\t\tuniqueIdentifierField = uniqueIdentifierField.replace(/\\s/g, '').split(',');\n\t\t} else {\n\t\t\tuniqueIdentifierField = [];\n\t\t}\n\n\t\tlet userSearchField: string | string[] | undefined = getLDAPConditionalSetting<string>('LDAP_User_Search_Field');\n\n\t\tif (userSearchField) {\n\t\t\tuserSearchField = userSearchField.replace(/\\s/g, '').split(',');\n\t\t} else {\n\t\t\tuserSearchField = [];\n\t\t}\n\n\t\tuniqueIdentifierField = uniqueIdentifierField.concat(userSearchField);\n\t\tif (!uniqueIdentifierField.length) {\n\t\t\tuniqueIdentifierField.push('dn');\n\t\t}\n\n\t\tconst key = uniqueIdentifierField.find((field) => !_.isEmpty(ldapUser._raw[field]));\n\t\tif (key) {\n\t\t\treturn {\n\t\t\t\tattribute: key,\n\t\t\t\tvalue: ldapUser._raw[key].toString('hex'),\n\t\t\t};\n\t\t}\n\n\t\tconnLogger.warn('Failed to generate unique identifier for ldap entry');\n\t\tconnLogger.debug(ldapUser);\n\t}\n\n\tprivate static ldapKeyExists(ldapUser: ILDAPEntry, key: string): boolean {\n\t\treturn !_.isEmpty(ldapUser[key.trim()]);\n\t}\n\n\tprivate static getLdapString(ldapUser: ILDAPEntry, key: string): string {\n\t\treturn ldapUser[key.trim()];\n\t}\n\n\tprivate static getLdapDynamicValue(ldapUser: ILDAPEntry, attributeSetting: string | undefined): string | undefined {\n\t\tif (!attributeSetting) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If the attribute setting is a template, then convert the variables in it\n\t\tif (attributeSetting.includes('#{')) {\n\t\t\treturn attributeSetting.replace(/#{(.+?)}/g, (_match, field) => {\n\t\t\t\tconst key = field.trim();\n\n\t\t\t\tif (this.ldapKeyExists(ldapUser, key)) {\n\t\t\t\t\treturn this.getLdapString(ldapUser, key);\n\t\t\t\t}\n\n\t\t\t\treturn '';\n\t\t\t});\n\t\t}\n\n\t\t// If it's not a template, then treat the setting as a CSV list of possible attribute names and return the first valid one.\n\t\tconst attributeList: string[] = attributeSetting.replace(/\\s/g, '').split(',');\n\t\tconst key = attributeList.find((field) => this.ldapKeyExists(ldapUser, field));\n\t\tif (key) {\n\t\t\treturn this.getLdapString(ldapUser, key);\n\t\t}\n\t}\n\n\tprivate static getLdapName(ldapUser: ILDAPEntry): string | undefined {\n\t\tconst nameAttributes = getLDAPConditionalSetting<string | undefined>('LDAP_Name_Field');\n\t\treturn this.getLdapDynamicValue(ldapUser, nameAttributes);\n\t}\n\n\tprivate static getLdapEmails(ldapUser: ILDAPEntry, username?: string): string[] {\n\t\tconst emailAttributes = getLDAPConditionalSetting<string>('LDAP_Email_Field');\n\t\tif (emailAttributes) {\n\t\t\tconst attributeList: string[] = emailAttributes.replace(/\\s/g, '').split(',');\n\t\t\tconst key = attributeList.find((field) => this.ldapKeyExists(ldapUser, field));\n\n\t\t\tconst emails: string[] = [].concat(key ? ldapUser[key.trim()] : []);\n\t\t\tconst filteredEmails = emails.filter((email) => email.includes('@'));\n\n\t\t\tif (filteredEmails.length) {\n\t\t\t\treturn filteredEmails;\n\t\t\t}\n\t\t}\n\n\t\tif (settings.get('LDAP_Default_Domain') !== '' && username) {\n\t\t\treturn [`${username}@${settings.get('LDAP_Default_Domain')}`];\n\t\t}\n\n\t\tif (ldapUser.mail && ldapUser.mail.includes('@')) {\n\t\t\treturn [ldapUser.mail];\n\t\t}\n\n\t\tlogger.debug(ldapUser);\n\t\tthrow new Error('Failed to get email address from LDAP user');\n\t}\n\n\tprivate static slugify(text: string): string {\n\t\tif (settings.get('UTF8_Names_Slugify') !== true) {\n\t\t\treturn text;\n\t\t}\n\n\t\ttext = limax(text, { replacement: '.' });\n\t\treturn text.replace(/[^0-9a-z-_.]/g, '');\n\t}\n\n\tprivate static slugifyUsername(ldapUser: ILDAPEntry, requestUsername: string): string {\n\t\tif (getLDAPConditionalSetting('LDAP_Username_Field') !== '') {\n\t\t\tconst username = this.getLdapUsername(ldapUser);\n\t\t\tif (username) {\n\t\t\t\treturn this.slugify(username);\n\t\t\t}\n\t\t}\n\n\t\treturn this.slugify(requestUsername);\n\t}\n\n\tprivate static getLdapUsername(ldapUser: ILDAPEntry): string | undefined {\n\t\tconst usernameField = getLDAPConditionalSetting('LDAP_Username_Field') as string;\n\t\treturn this.getLdapDynamicValue(ldapUser, usernameField);\n\t}\n\n\t// This method will find existing users by LDAP id or by username.\n\tprivate static async findExistingUser(ldapUser: ILDAPEntry, slugifiedUsername: string): Promise<IUser | undefined> {\n\t\tconst user = await this.findExistingLDAPUser(ldapUser);\n\t\tif (user) {\n\t\t\treturn user;\n\t\t}\n\n\t\treturn UsersRaw.findOneByUsername(slugifiedUsername);\n\t}\n\n\tprivate static fallbackToDefaultLogin(username: LoginUsername, password: string): LDAPLoginResult {\n\t\tif (typeof username === 'string') {\n\t\t\tif (username.indexOf('@') === -1) {\n\t\t\t\tusername = { username };\n\t\t\t} else {\n\t\t\t\tusername = { email: username };\n\t\t\t}\n\t\t}\n\n\t\tlogger.debug({ msg: 'Fallback to default account system', username });\n\n\t\tconst loginRequest = {\n\t\t\tuser: username,\n\t\t\tpassword: {\n\t\t\t\tdigest: SHA256(password),\n\t\t\t\talgorithm: 'sha-256',\n\t\t\t},\n\t\t};\n\n\t\treturn Accounts._runLoginHandlers(this, loginRequest);\n\t}\n\n\tprivate static getAvatarFromUser(ldapUser: ILDAPEntry): any | undefined {\n\t\tconst avatarField = String(settings.get('LDAP_Avatar_Field') || '').trim();\n\t\tif (avatarField && ldapUser._raw[avatarField]) {\n\t\t\treturn ldapUser._raw[avatarField];\n\t\t}\n\n\t\tif (ldapUser._raw.thumbnailPhoto) {\n\t\t\treturn ldapUser._raw.thumbnailPhoto;\n\t\t}\n\n\t\tif (ldapUser._raw.jpegPhoto) {\n\t\t\treturn ldapUser._raw.jpegPhoto;\n\t\t}\n\t}\n}\n"]},"targets":{"android":"95.0.0","chrome":"95.0.0","edge":"95.0.0","firefox":"78.0.0","ie":"10.0.0","ios":"15.0.0","opera":"81.0.0","safari":"15.1.0","samsung":"14.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/home/weslley/Documents/projects/Rocket.Chat","root":"/home/weslley/Documents/projects/Rocket.Chat","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.16.5","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/home/weslley/Documents/projects/Rocket.Chat/server/lib/ldap/Manager.ts","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"server/lib/ldap/Manager.ts"}},"code":"var _templateObject, _templateObject2;\n\nlet _objectSpread;\n\nmodule.link(\"@babel/runtime/helpers/objectSpread2\", {\n  default(v) {\n    _objectSpread = v;\n  }\n\n}, 0);\n\nlet _taggedTemplateLiteral;\n\nmodule.link(\"@babel/runtime/helpers/taggedTemplateLiteral\", {\n  default(v) {\n    _taggedTemplateLiteral = v;\n  }\n\n}, 1);\nmodule.export({\n  LDAPManager: () => LDAPManager\n});\nlet limax;\nmodule.link(\"limax\", {\n  default(v) {\n    limax = v;\n  }\n\n}, 0);\nlet SHA256;\nmodule.link(\"meteor/sha\", {\n  SHA256(v) {\n    SHA256 = v;\n  }\n\n}, 1);\nlet Meteor;\nmodule.link(\"meteor/meteor\", {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 2);\nlet Accounts;\nmodule.link(\"meteor/accounts-base\", {\n  Accounts(v) {\n    Accounts = v;\n  }\n\n}, 3);\nlet ldapEscape;\nmodule.link(\"ldap-escape\", {\n  default(v) {\n    ldapEscape = v;\n  }\n\n}, 4);\n\nlet _;\n\nmodule.link(\"underscore\", {\n  default(v) {\n    _ = v;\n  }\n\n}, 5);\nlet settings;\nmodule.link(\"../../../app/settings/server\", {\n  settings(v) {\n    settings = v;\n  }\n\n}, 6);\nlet UsersRaw;\nmodule.link(\"../../../app/models/server/raw\", {\n  Users(v) {\n    UsersRaw = v;\n  }\n\n}, 7);\nlet LDAPConnection;\nmodule.link(\"./Connection\", {\n  LDAPConnection(v) {\n    LDAPConnection = v;\n  }\n\n}, 8);\nlet LDAPDataConverter;\nmodule.link(\"./DataConverter\", {\n  LDAPDataConverter(v) {\n    LDAPDataConverter = v;\n  }\n\n}, 9);\nlet getLDAPConditionalSetting;\nmodule.link(\"./getLDAPConditionalSetting\", {\n  getLDAPConditionalSetting(v) {\n    getLDAPConditionalSetting = v;\n  }\n\n}, 10);\nlet logger, authLogger, connLogger;\nmodule.link(\"./Logger\", {\n  logger(v) {\n    logger = v;\n  },\n\n  authLogger(v) {\n    authLogger = v;\n  },\n\n  connLogger(v) {\n    connLogger = v;\n  }\n\n}, 11);\nlet callbacks;\nmodule.link(\"../../../lib/callbacks\", {\n  callbacks(v) {\n    callbacks = v;\n  }\n\n}, 12);\nlet setUserAvatar;\nmodule.link(\"../../../app/lib/server/functions\", {\n  setUserAvatar(v) {\n    setUserAvatar = v;\n  }\n\n}, 13);\n\nclass LDAPManager {\n  static login(username, password) {\n    return Promise.asyncApply(() => {\n      logger.debug({\n        msg: 'Init LDAP login',\n        username\n      });\n\n      if (settings.get('LDAP_Enable') !== true) {\n        return this.fallbackToDefaultLogin(username, password);\n      }\n\n      let ldapUser;\n      const ldap = new LDAPConnection();\n\n      try {\n        try {\n          Promise.await(ldap.connect());\n          ldapUser = Promise.await(this.findUser(ldap, username, password));\n        } catch (error) {\n          logger.error(error);\n        }\n\n        if (ldapUser === undefined) {\n          return this.fallbackToDefaultLogin(username, password);\n        }\n\n        const slugifiedUsername = this.slugifyUsername(ldapUser, username);\n        const user = Promise.await(this.findExistingUser(ldapUser, slugifiedUsername));\n\n        if (user) {\n          return Promise.await(this.loginExistingUser(ldap, user, ldapUser, password));\n        }\n\n        return Promise.await(this.loginNewUserFromLDAP(slugifiedUsername, password, ldapUser, ldap));\n      } finally {\n        ldap.disconnect();\n      }\n    });\n  }\n\n  static testConnection() {\n    return Promise.asyncApply(() => {\n      try {\n        const ldap = new LDAPConnection();\n        Promise.await(ldap.testConnection());\n      } catch (error) {\n        connLogger.error(error);\n        throw error;\n      }\n    });\n  }\n\n  static testSearch(username) {\n    return Promise.asyncApply(() => {\n      const escapedUsername = ldapEscape.filter(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\", \"\"])), username);\n      const ldap = new LDAPConnection();\n\n      try {\n        Promise.await(ldap.connect());\n        const users = Promise.await(ldap.searchByUsername(escapedUsername));\n\n        if (users.length !== 1) {\n          logger.debug(\"Search returned \".concat(users.length, \" records for \").concat(escapedUsername));\n          throw new Error('User not found');\n        }\n      } catch (error) {\n        logger.error(error);\n        throw error;\n      }\n    });\n  }\n\n  static syncUserAvatar(user, ldapUser) {\n    if (!(user !== null && user !== void 0 && user._id) || settings.get('LDAP_Sync_User_Avatar') !== true) {\n      return;\n    }\n\n    const avatar = this.getAvatarFromUser(ldapUser);\n\n    if (!avatar) {\n      return;\n    }\n\n    const hash = SHA256(avatar.toString());\n\n    if (user.avatarETag === hash) {\n      return;\n    }\n\n    logger.debug({\n      msg: 'Syncing user avatar',\n      username: user.username\n    }); // #ToDo: Remove Meteor references here\n    // runAsUser is needed for now because the UploadFS class rejects files if there's no userId\n\n    Meteor.runAsUser(user._id, () => setUserAvatar(user, avatar, 'image/jpeg', 'rest', hash));\n  } // This method will only find existing users that are already linked to LDAP\n\n\n  static findExistingLDAPUser(ldapUser) {\n    return Promise.asyncApply(() => {\n      const uniqueIdentifierField = this.getLdapUserUniqueID(ldapUser);\n\n      if (uniqueIdentifierField) {\n        logger.debug({\n          msg: 'Querying user',\n          uniqueId: uniqueIdentifierField.value\n        });\n        return UsersRaw.findOneByLDAPId(uniqueIdentifierField.value, uniqueIdentifierField.attribute);\n      }\n    });\n  }\n\n  static getConverterOptions() {\n    var _settings$get;\n\n    return {\n      flagEmailsAsVerified: (_settings$get = settings.get('Accounts_Verify_Email_For_External_Accounts')) !== null && _settings$get !== void 0 ? _settings$get : false,\n      skipExistingUsers: false\n    };\n  }\n\n  static mapUserData(ldapUser, usedUsername) {\n    const uniqueId = this.getLdapUserUniqueID(ldapUser);\n\n    if (!uniqueId) {\n      throw new Error('Failed to generate unique identifier for ldap entry');\n    }\n\n    const {\n      attribute: idAttribute,\n      value: id\n    } = uniqueId;\n    const username = this.getLdapUsername(ldapUser) || usedUsername || id || undefined;\n    const emails = this.getLdapEmails(ldapUser, username);\n    const name = this.getLdapName(ldapUser) || undefined;\n    const userData = {\n      type: 'user',\n      emails,\n      importIds: [ldapUser.dn],\n      username,\n      name,\n      services: {\n        ldap: {\n          idAttribute,\n          id\n        }\n      }\n    };\n    this.onMapUserData(ldapUser, userData);\n    return userData;\n  }\n\n  static onMapUserData(ldapUser, userData) {\n    callbacks.run('mapLDAPUserData', userData, ldapUser);\n  }\n\n  static findUser(ldap, username, password) {\n    return Promise.asyncApply(() => {\n      const escapedUsername = ldapEscape.filter(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\", \"\"])), username);\n\n      try {\n        const users = Promise.await(ldap.searchByUsername(escapedUsername));\n\n        if (users.length !== 1) {\n          logger.debug(\"Search returned \".concat(users.length, \" records for \").concat(escapedUsername));\n          throw new Error('User not found');\n        }\n\n        const [ldapUser] = users;\n\n        if (!Promise.await(ldap.authenticate(ldapUser.dn, password))) {\n          logger.debug(\"Wrong password for \".concat(escapedUsername));\n          throw new Error('Invalid user or wrong password');\n        }\n\n        if (settings.get('LDAP_Find_User_After_Login')) {\n          // Do a search as the user and check if they have any result\n          authLogger.debug('User authenticated successfully, performing additional search.');\n\n          if (Promise.await(ldap.searchAndCount(ldapUser.dn, {})) === 0) {\n            authLogger.debug(\"Bind successful but user \".concat(ldapUser.dn, \" was not found via search\"));\n          }\n        }\n\n        if (!Promise.await(ldap.isUserAcceptedByGroupFilter(escapedUsername, ldapUser.dn))) {\n          throw new Error('User not in a valid group');\n        }\n\n        return ldapUser;\n      } catch (error) {\n        logger.error(error);\n      }\n    });\n  }\n\n  static loginNewUserFromLDAP(slugifiedUsername, ldapPass, ldapUser, ldap) {\n    return Promise.asyncApply(() => {\n      logger.debug({\n        msg: 'User does not exist, creating',\n        username: slugifiedUsername\n      });\n      let username;\n\n      if (getLDAPConditionalSetting('LDAP_Username_Field') !== '') {\n        username = slugifiedUsername;\n      } // Create new user\n\n\n      return this.addLdapUser(ldapUser, username, ldapPass, ldap);\n    });\n  }\n\n  static addLdapUser(ldapUser, username, password, ldap) {\n    return Promise.asyncApply(() => {\n      const user = Promise.await(this.syncUserForLogin(ldapUser, undefined, username));\n\n      if (!user) {\n        return;\n      }\n\n      this.onLogin(ldapUser, user, password, ldap, true);\n      return {\n        userId: user._id\n      };\n    });\n  }\n\n  static onLogin(ldapUser, user, password, ldap, isNewUser) {\n    logger.debug('running onLDAPLogin');\n\n    if (settings.get('LDAP_Login_Fallback') && typeof password === 'string' && password.trim() !== '') {\n      Accounts.setPassword(user._id, password, {\n        logout: false\n      });\n    }\n\n    this.syncUserAvatar(user, ldapUser);\n    callbacks.run('onLDAPLogin', {\n      user,\n      ldapUser,\n      isNewUser\n    }, ldap);\n  }\n\n  static loginExistingUser(ldap, user, ldapUser, password) {\n    return Promise.asyncApply(() => {\n      var _settings$get2;\n\n      if (user.ldap !== true && settings.get('LDAP_Merge_Existing_Users') !== true) {\n        logger.debug('User exists without \"ldap: true\"');\n        throw new Meteor.Error('LDAP-login-error', \"LDAP Authentication succeeded, but there's already an existing user with provided username [\".concat(user.username, \"] in Mongo.\"));\n      } // If we're merging an ldap user with a local user, then we need to sync the data even if 'update data on login' is off.\n\n\n      const forceUserSync = !user.ldap;\n      const syncData = forceUserSync || ((_settings$get2 = settings.get('LDAP_Update_Data_On_Login')) !== null && _settings$get2 !== void 0 ? _settings$get2 : true);\n      logger.debug({\n        msg: 'Logging user in',\n        syncData\n      });\n      const updatedUser = syncData && Promise.await(this.syncUserForLogin(ldapUser, user)) || user;\n      this.onLogin(ldapUser, updatedUser, password, ldap, false);\n      return {\n        userId: user._id\n      };\n    });\n  }\n\n  static syncUserForLogin(ldapUser, existingUser, usedUsername) {\n    return Promise.asyncApply(() => {\n      logger.debug({\n        msg: 'Syncing user data',\n        ldapUser: _.omit(ldapUser, '_raw'),\n        user: _objectSpread({}, existingUser && {\n          email: existingUser.emails,\n          _id: existingUser._id\n        })\n      });\n      const userData = this.mapUserData(ldapUser, usedUsername); // make sure to persist existing user data when passing to sync/convert\n      // TODO this is only needed because ImporterDataConverter assigns a default role and type if nothing is set. we might need to figure out a better way and stop doing that there\n\n      if (existingUser) {\n        if (!userData.roles && existingUser.roles) {\n          userData.roles = existingUser.roles;\n        }\n\n        if (!userData.type && existingUser.type) {\n          userData.type = existingUser.type;\n        }\n      }\n\n      const options = this.getConverterOptions();\n      LDAPDataConverter.convertSingleUser(userData, options);\n      return existingUser || this.findExistingLDAPUser(ldapUser);\n    });\n  }\n\n  static getLdapUserUniqueID(ldapUser) {\n    let uniqueIdentifierField = settings.get('LDAP_Unique_Identifier_Field');\n\n    if (uniqueIdentifierField) {\n      uniqueIdentifierField = uniqueIdentifierField.replace(/\\s/g, '').split(',');\n    } else {\n      uniqueIdentifierField = [];\n    }\n\n    let userSearchField = getLDAPConditionalSetting('LDAP_User_Search_Field');\n\n    if (userSearchField) {\n      userSearchField = userSearchField.replace(/\\s/g, '').split(',');\n    } else {\n      userSearchField = [];\n    }\n\n    uniqueIdentifierField = uniqueIdentifierField.concat(userSearchField);\n\n    if (!uniqueIdentifierField.length) {\n      uniqueIdentifierField.push('dn');\n    }\n\n    const key = uniqueIdentifierField.find(field => !_.isEmpty(ldapUser._raw[field]));\n\n    if (key) {\n      return {\n        attribute: key,\n        value: ldapUser._raw[key].toString('hex')\n      };\n    }\n\n    connLogger.warn('Failed to generate unique identifier for ldap entry');\n    connLogger.debug(ldapUser);\n  }\n\n  static ldapKeyExists(ldapUser, key) {\n    return !_.isEmpty(ldapUser[key.trim()]);\n  }\n\n  static getLdapString(ldapUser, key) {\n    return ldapUser[key.trim()];\n  }\n\n  static getLdapDynamicValue(ldapUser, attributeSetting) {\n    if (!attributeSetting) {\n      return;\n    } // If the attribute setting is a template, then convert the variables in it\n\n\n    if (attributeSetting.includes('#{')) {\n      return attributeSetting.replace(/#{(.+?)}/g, (_match, field) => {\n        const key = field.trim();\n\n        if (this.ldapKeyExists(ldapUser, key)) {\n          return this.getLdapString(ldapUser, key);\n        }\n\n        return '';\n      });\n    } // If it's not a template, then treat the setting as a CSV list of possible attribute names and return the first valid one.\n\n\n    const attributeList = attributeSetting.replace(/\\s/g, '').split(',');\n    const key = attributeList.find(field => this.ldapKeyExists(ldapUser, field));\n\n    if (key) {\n      return this.getLdapString(ldapUser, key);\n    }\n  }\n\n  static getLdapName(ldapUser) {\n    const nameAttributes = getLDAPConditionalSetting('LDAP_Name_Field');\n    return this.getLdapDynamicValue(ldapUser, nameAttributes);\n  }\n\n  static getLdapEmails(ldapUser, username) {\n    const emailAttributes = getLDAPConditionalSetting('LDAP_Email_Field');\n\n    if (emailAttributes) {\n      const attributeList = emailAttributes.replace(/\\s/g, '').split(',');\n      const key = attributeList.find(field => this.ldapKeyExists(ldapUser, field));\n      const emails = [].concat(key ? ldapUser[key.trim()] : []);\n      const filteredEmails = emails.filter(email => email.includes('@'));\n\n      if (filteredEmails.length) {\n        return filteredEmails;\n      }\n    }\n\n    if (settings.get('LDAP_Default_Domain') !== '' && username) {\n      return [\"\".concat(username, \"@\").concat(settings.get('LDAP_Default_Domain'))];\n    }\n\n    if (ldapUser.mail && ldapUser.mail.includes('@')) {\n      return [ldapUser.mail];\n    }\n\n    logger.debug(ldapUser);\n    throw new Error('Failed to get email address from LDAP user');\n  }\n\n  static slugify(text) {\n    if (settings.get('UTF8_Names_Slugify') !== true) {\n      return text;\n    }\n\n    text = limax(text, {\n      replacement: '.'\n    });\n    return text.replace(/[^0-9a-z-_.]/g, '');\n  }\n\n  static slugifyUsername(ldapUser, requestUsername) {\n    if (getLDAPConditionalSetting('LDAP_Username_Field') !== '') {\n      const username = this.getLdapUsername(ldapUser);\n\n      if (username) {\n        return this.slugify(username);\n      }\n    }\n\n    return this.slugify(requestUsername);\n  }\n\n  static getLdapUsername(ldapUser) {\n    const usernameField = getLDAPConditionalSetting('LDAP_Username_Field');\n    return this.getLdapDynamicValue(ldapUser, usernameField);\n  } // This method will find existing users by LDAP id or by username.\n\n\n  static findExistingUser(ldapUser, slugifiedUsername) {\n    return Promise.asyncApply(() => {\n      const user = Promise.await(this.findExistingLDAPUser(ldapUser));\n\n      if (user) {\n        return user;\n      }\n\n      return UsersRaw.findOneByUsername(slugifiedUsername);\n    });\n  }\n\n  static fallbackToDefaultLogin(username, password) {\n    if (typeof username === 'string') {\n      if (username.indexOf('@') === -1) {\n        username = {\n          username\n        };\n      } else {\n        username = {\n          email: username\n        };\n      }\n    }\n\n    logger.debug({\n      msg: 'Fallback to default account system',\n      username\n    });\n    const loginRequest = {\n      user: username,\n      password: {\n        digest: SHA256(password),\n        algorithm: 'sha-256'\n      }\n    };\n    return Accounts._runLoginHandlers(this, loginRequest);\n  }\n\n  static getAvatarFromUser(ldapUser) {\n    const avatarField = String(settings.get('LDAP_Avatar_Field') || '').trim();\n\n    if (avatarField && ldapUser._raw[avatarField]) {\n      return ldapUser._raw[avatarField];\n    }\n\n    if (ldapUser._raw.thumbnailPhoto) {\n      return ldapUser._raw.thumbnailPhoto;\n    }\n\n    if (ldapUser._raw.jpegPhoto) {\n      return ldapUser._raw.jpegPhoto;\n    }\n  }\n\n}","map":{"version":3,"sources":["server/lib/ldap/Manager.ts"],"names":[],"mappings":"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","sourcesContent":["import limax from 'limax';\n// #ToDo: #TODO: Remove Meteor dependencies\nimport { SHA256 } from 'meteor/sha';\nimport { Meteor } from 'meteor/meteor';\nimport { Accounts } from 'meteor/accounts-base';\nimport ldapEscape from 'ldap-escape';\nimport _ from 'underscore';\n\nimport { ILDAPEntry } from '../../../definition/ldap/ILDAPEntry';\nimport { LDAPLoginResult } from '../../../definition/ldap/ILDAPLoginResult';\nimport { ILDAPUniqueIdentifierField } from '../../../definition/ldap/ILDAPUniqueIdentifierField';\nimport { IUser, LoginUsername } from '../../../definition/IUser';\nimport { IImportUser } from '../../../definition/IImportUser';\nimport { settings } from '../../../app/settings/server';\nimport { Users as UsersRaw } from '../../../app/models/server/raw';\nimport { LDAPConnection } from './Connection';\nimport { LDAPDataConverter } from './DataConverter';\nimport { getLDAPConditionalSetting } from './getLDAPConditionalSetting';\nimport { logger, authLogger, connLogger } from './Logger';\nimport type { IConverterOptions } from '../../../app/importer/server/classes/ImportDataConverter';\nimport { callbacks } from '../../../lib/callbacks';\nimport { setUserAvatar } from '../../../app/lib/server/functions';\n\nexport class LDAPManager {\n\tpublic static async login(username: string, password: string): Promise<LDAPLoginResult> {\n\t\tlogger.debug({ msg: 'Init LDAP login', username });\n\n\t\tif (settings.get('LDAP_Enable') !== true) {\n\t\t\treturn this.fallbackToDefaultLogin(username, password);\n\t\t}\n\n\t\tlet ldapUser: ILDAPEntry | undefined;\n\n\t\tconst ldap = new LDAPConnection();\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tawait ldap.connect();\n\t\t\t\tldapUser = await this.findUser(ldap, username, password);\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(error);\n\t\t\t}\n\n\t\t\tif (ldapUser === undefined) {\n\t\t\t\treturn this.fallbackToDefaultLogin(username, password);\n\t\t\t}\n\n\t\t\tconst slugifiedUsername = this.slugifyUsername(ldapUser, username);\n\t\t\tconst user = await this.findExistingUser(ldapUser, slugifiedUsername);\n\n\t\t\tif (user) {\n\t\t\t\treturn await this.loginExistingUser(ldap, user, ldapUser, password);\n\t\t\t}\n\n\t\t\treturn await this.loginNewUserFromLDAP(slugifiedUsername, password, ldapUser, ldap);\n\t\t} finally {\n\t\t\tldap.disconnect();\n\t\t}\n\t}\n\n\tpublic static async testConnection(): Promise<void> {\n\t\ttry {\n\t\t\tconst ldap = new LDAPConnection();\n\t\t\tawait ldap.testConnection();\n\t\t} catch (error) {\n\t\t\tconnLogger.error(error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tpublic static async testSearch(username: string): Promise<void> {\n\t\tconst escapedUsername = ldapEscape.filter`${username}`;\n\t\tconst ldap = new LDAPConnection();\n\n\t\ttry {\n\t\t\tawait ldap.connect();\n\n\t\t\tconst users = await ldap.searchByUsername(escapedUsername);\n\t\t\tif (users.length !== 1) {\n\t\t\t\tlogger.debug(`Search returned ${users.length} records for ${escapedUsername}`);\n\t\t\t\tthrow new Error('User not found');\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.error(error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tpublic static syncUserAvatar(user: IUser, ldapUser: ILDAPEntry): void {\n\t\tif (!user?._id || settings.get('LDAP_Sync_User_Avatar') !== true) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst avatar = this.getAvatarFromUser(ldapUser);\n\t\tif (!avatar) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst hash = SHA256(avatar.toString());\n\t\tif (user.avatarETag === hash) {\n\t\t\treturn;\n\t\t}\n\n\t\tlogger.debug({ msg: 'Syncing user avatar', username: user.username });\n\t\t// #ToDo: Remove Meteor references here\n\t\t// runAsUser is needed for now because the UploadFS class rejects files if there's no userId\n\t\tMeteor.runAsUser(user._id, () => setUserAvatar(user, avatar, 'image/jpeg', 'rest', hash));\n\t}\n\n\t// This method will only find existing users that are already linked to LDAP\n\tprotected static async findExistingLDAPUser(ldapUser: ILDAPEntry): Promise<IUser | undefined> {\n\t\tconst uniqueIdentifierField = this.getLdapUserUniqueID(ldapUser);\n\n\t\tif (uniqueIdentifierField) {\n\t\t\tlogger.debug({ msg: 'Querying user', uniqueId: uniqueIdentifierField.value });\n\t\t\treturn UsersRaw.findOneByLDAPId(uniqueIdentifierField.value, uniqueIdentifierField.attribute);\n\t\t}\n\t}\n\n\tprotected static getConverterOptions(): IConverterOptions {\n\t\treturn {\n\t\t\tflagEmailsAsVerified: settings.get<boolean>('Accounts_Verify_Email_For_External_Accounts') ?? false,\n\t\t\tskipExistingUsers: false,\n\t\t};\n\t}\n\n\tprotected static mapUserData(ldapUser: ILDAPEntry, usedUsername?: string | undefined): IImportUser {\n\t\tconst uniqueId = this.getLdapUserUniqueID(ldapUser);\n\t\tif (!uniqueId) {\n\t\t\tthrow new Error('Failed to generate unique identifier for ldap entry');\n\t\t}\n\n\t\tconst { attribute: idAttribute, value: id } = uniqueId;\n\t\tconst username = this.getLdapUsername(ldapUser) || usedUsername || id || undefined;\n\t\tconst emails = this.getLdapEmails(ldapUser, username);\n\t\tconst name = this.getLdapName(ldapUser) || undefined;\n\n\t\tconst userData: IImportUser = {\n\t\t\ttype: 'user',\n\t\t\temails,\n\t\t\timportIds: [ldapUser.dn],\n\t\t\tusername,\n\t\t\tname,\n\t\t\tservices: {\n\t\t\t\tldap: {\n\t\t\t\t\tidAttribute,\n\t\t\t\t\tid,\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\tthis.onMapUserData(ldapUser, userData);\n\t\treturn userData;\n\t}\n\n\tprivate static onMapUserData(ldapUser: ILDAPEntry, userData: IImportUser): void {\n\t\tcallbacks.run('mapLDAPUserData', userData, ldapUser);\n\t}\n\n\tprivate static async findUser(ldap: LDAPConnection, username: string, password: string): Promise<ILDAPEntry | undefined> {\n\t\tconst escapedUsername = ldapEscape.filter`${username}`;\n\n\t\ttry {\n\t\t\tconst users = await ldap.searchByUsername(escapedUsername);\n\n\t\t\tif (users.length !== 1) {\n\t\t\t\tlogger.debug(`Search returned ${users.length} records for ${escapedUsername}`);\n\t\t\t\tthrow new Error('User not found');\n\t\t\t}\n\n\t\t\tconst [ldapUser] = users;\n\t\t\tif (!(await ldap.authenticate(ldapUser.dn, password))) {\n\t\t\t\tlogger.debug(`Wrong password for ${escapedUsername}`);\n\t\t\t\tthrow new Error('Invalid user or wrong password');\n\t\t\t}\n\n\t\t\tif (settings.get<boolean>('LDAP_Find_User_After_Login')) {\n\t\t\t\t// Do a search as the user and check if they have any result\n\t\t\t\tauthLogger.debug('User authenticated successfully, performing additional search.');\n\t\t\t\tif ((await ldap.searchAndCount(ldapUser.dn, {})) === 0) {\n\t\t\t\t\tauthLogger.debug(`Bind successful but user ${ldapUser.dn} was not found via search`);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!(await ldap.isUserAcceptedByGroupFilter(escapedUsername, ldapUser.dn))) {\n\t\t\t\tthrow new Error('User not in a valid group');\n\t\t\t}\n\n\t\t\treturn ldapUser;\n\t\t} catch (error) {\n\t\t\tlogger.error(error);\n\t\t}\n\t}\n\n\tprivate static async loginNewUserFromLDAP(\n\t\tslugifiedUsername: string,\n\t\tldapPass: string,\n\t\tldapUser: ILDAPEntry,\n\t\tldap: LDAPConnection,\n\t): Promise<LDAPLoginResult> {\n\t\tlogger.debug({ msg: 'User does not exist, creating', username: slugifiedUsername });\n\n\t\tlet username: string | undefined;\n\n\t\tif (getLDAPConditionalSetting('LDAP_Username_Field') !== '') {\n\t\t\tusername = slugifiedUsername;\n\t\t}\n\n\t\t// Create new user\n\t\treturn this.addLdapUser(ldapUser, username, ldapPass, ldap);\n\t}\n\n\tprivate static async addLdapUser(\n\t\tldapUser: ILDAPEntry,\n\t\tusername: string | undefined,\n\t\tpassword: string | undefined,\n\t\tldap: LDAPConnection,\n\t): Promise<LDAPLoginResult> {\n\t\tconst user = await this.syncUserForLogin(ldapUser, undefined, username);\n\n\t\tif (!user) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.onLogin(ldapUser, user, password, ldap, true);\n\n\t\treturn {\n\t\t\tuserId: user._id,\n\t\t};\n\t}\n\n\tprivate static onLogin(ldapUser: ILDAPEntry, user: IUser, password: string | undefined, ldap: LDAPConnection, isNewUser: boolean): void {\n\t\tlogger.debug('running onLDAPLogin');\n\t\tif (settings.get<boolean>('LDAP_Login_Fallback') && typeof password === 'string' && password.trim() !== '') {\n\t\t\tAccounts.setPassword(user._id, password, { logout: false });\n\t\t}\n\n\t\tthis.syncUserAvatar(user, ldapUser);\n\t\tcallbacks.run('onLDAPLogin', { user, ldapUser, isNewUser }, ldap);\n\t}\n\n\tprivate static async loginExistingUser(\n\t\tldap: LDAPConnection,\n\t\tuser: IUser,\n\t\tldapUser: ILDAPEntry,\n\t\tpassword: string,\n\t): Promise<LDAPLoginResult> {\n\t\tif (user.ldap !== true && settings.get('LDAP_Merge_Existing_Users') !== true) {\n\t\t\tlogger.debug('User exists without \"ldap: true\"');\n\t\t\tthrow new Meteor.Error(\n\t\t\t\t'LDAP-login-error',\n\t\t\t\t`LDAP Authentication succeeded, but there's already an existing user with provided username [${user.username}] in Mongo.`,\n\t\t\t);\n\t\t}\n\n\t\t// If we're merging an ldap user with a local user, then we need to sync the data even if 'update data on login' is off.\n\t\tconst forceUserSync = !user.ldap;\n\n\t\tconst syncData = forceUserSync || (settings.get<boolean>('LDAP_Update_Data_On_Login') ?? true);\n\t\tlogger.debug({ msg: 'Logging user in', syncData });\n\t\tconst updatedUser = (syncData && (await this.syncUserForLogin(ldapUser, user))) || user;\n\n\t\tthis.onLogin(ldapUser, updatedUser, password, ldap, false);\n\t\treturn {\n\t\t\tuserId: user._id,\n\t\t};\n\t}\n\n\tprivate static async syncUserForLogin(\n\t\tldapUser: ILDAPEntry,\n\t\texistingUser?: IUser,\n\t\tusedUsername?: string | undefined,\n\t): Promise<IUser | undefined> {\n\t\tlogger.debug({\n\t\t\tmsg: 'Syncing user data',\n\t\t\tldapUser: _.omit(ldapUser, '_raw'),\n\t\t\tuser: { ...(existingUser && { email: existingUser.emails, _id: existingUser._id }) },\n\t\t});\n\n\t\tconst userData = this.mapUserData(ldapUser, usedUsername);\n\n\t\t// make sure to persist existing user data when passing to sync/convert\n\t\t// TODO this is only needed because ImporterDataConverter assigns a default role and type if nothing is set. we might need to figure out a better way and stop doing that there\n\t\tif (existingUser) {\n\t\t\tif (!userData.roles && existingUser.roles) {\n\t\t\t\tuserData.roles = existingUser.roles;\n\t\t\t}\n\t\t\tif (!userData.type && existingUser.type) {\n\t\t\t\tuserData.type = existingUser.type as IImportUser['type'];\n\t\t\t}\n\t\t}\n\n\t\tconst options = this.getConverterOptions();\n\t\tLDAPDataConverter.convertSingleUser(userData, options);\n\n\t\treturn existingUser || this.findExistingLDAPUser(ldapUser);\n\t}\n\n\tprivate static getLdapUserUniqueID(ldapUser: ILDAPEntry): ILDAPUniqueIdentifierField | undefined {\n\t\tlet uniqueIdentifierField: string | string[] | undefined = settings.get<string>('LDAP_Unique_Identifier_Field');\n\n\t\tif (uniqueIdentifierField) {\n\t\t\tuniqueIdentifierField = uniqueIdentifierField.replace(/\\s/g, '').split(',');\n\t\t} else {\n\t\t\tuniqueIdentifierField = [];\n\t\t}\n\n\t\tlet userSearchField: string | string[] | undefined = getLDAPConditionalSetting<string>('LDAP_User_Search_Field');\n\n\t\tif (userSearchField) {\n\t\t\tuserSearchField = userSearchField.replace(/\\s/g, '').split(',');\n\t\t} else {\n\t\t\tuserSearchField = [];\n\t\t}\n\n\t\tuniqueIdentifierField = uniqueIdentifierField.concat(userSearchField);\n\t\tif (!uniqueIdentifierField.length) {\n\t\t\tuniqueIdentifierField.push('dn');\n\t\t}\n\n\t\tconst key = uniqueIdentifierField.find((field) => !_.isEmpty(ldapUser._raw[field]));\n\t\tif (key) {\n\t\t\treturn {\n\t\t\t\tattribute: key,\n\t\t\t\tvalue: ldapUser._raw[key].toString('hex'),\n\t\t\t};\n\t\t}\n\n\t\tconnLogger.warn('Failed to generate unique identifier for ldap entry');\n\t\tconnLogger.debug(ldapUser);\n\t}\n\n\tprivate static ldapKeyExists(ldapUser: ILDAPEntry, key: string): boolean {\n\t\treturn !_.isEmpty(ldapUser[key.trim()]);\n\t}\n\n\tprivate static getLdapString(ldapUser: ILDAPEntry, key: string): string {\n\t\treturn ldapUser[key.trim()];\n\t}\n\n\tprivate static getLdapDynamicValue(ldapUser: ILDAPEntry, attributeSetting: string | undefined): string | undefined {\n\t\tif (!attributeSetting) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If the attribute setting is a template, then convert the variables in it\n\t\tif (attributeSetting.includes('#{')) {\n\t\t\treturn attributeSetting.replace(/#{(.+?)}/g, (_match, field) => {\n\t\t\t\tconst key = field.trim();\n\n\t\t\t\tif (this.ldapKeyExists(ldapUser, key)) {\n\t\t\t\t\treturn this.getLdapString(ldapUser, key);\n\t\t\t\t}\n\n\t\t\t\treturn '';\n\t\t\t});\n\t\t}\n\n\t\t// If it's not a template, then treat the setting as a CSV list of possible attribute names and return the first valid one.\n\t\tconst attributeList: string[] = attributeSetting.replace(/\\s/g, '').split(',');\n\t\tconst key = attributeList.find((field) => this.ldapKeyExists(ldapUser, field));\n\t\tif (key) {\n\t\t\treturn this.getLdapString(ldapUser, key);\n\t\t}\n\t}\n\n\tprivate static getLdapName(ldapUser: ILDAPEntry): string | undefined {\n\t\tconst nameAttributes = getLDAPConditionalSetting<string | undefined>('LDAP_Name_Field');\n\t\treturn this.getLdapDynamicValue(ldapUser, nameAttributes);\n\t}\n\n\tprivate static getLdapEmails(ldapUser: ILDAPEntry, username?: string): string[] {\n\t\tconst emailAttributes = getLDAPConditionalSetting<string>('LDAP_Email_Field');\n\t\tif (emailAttributes) {\n\t\t\tconst attributeList: string[] = emailAttributes.replace(/\\s/g, '').split(',');\n\t\t\tconst key = attributeList.find((field) => this.ldapKeyExists(ldapUser, field));\n\n\t\t\tconst emails: string[] = [].concat(key ? ldapUser[key.trim()] : []);\n\t\t\tconst filteredEmails = emails.filter((email) => email.includes('@'));\n\n\t\t\tif (filteredEmails.length) {\n\t\t\t\treturn filteredEmails;\n\t\t\t}\n\t\t}\n\n\t\tif (settings.get('LDAP_Default_Domain') !== '' && username) {\n\t\t\treturn [`${username}@${settings.get('LDAP_Default_Domain')}`];\n\t\t}\n\n\t\tif (ldapUser.mail && ldapUser.mail.includes('@')) {\n\t\t\treturn [ldapUser.mail];\n\t\t}\n\n\t\tlogger.debug(ldapUser);\n\t\tthrow new Error('Failed to get email address from LDAP user');\n\t}\n\n\tprivate static slugify(text: string): string {\n\t\tif (settings.get('UTF8_Names_Slugify') !== true) {\n\t\t\treturn text;\n\t\t}\n\n\t\ttext = limax(text, { replacement: '.' });\n\t\treturn text.replace(/[^0-9a-z-_.]/g, '');\n\t}\n\n\tprivate static slugifyUsername(ldapUser: ILDAPEntry, requestUsername: string): string {\n\t\tif (getLDAPConditionalSetting('LDAP_Username_Field') !== '') {\n\t\t\tconst username = this.getLdapUsername(ldapUser);\n\t\t\tif (username) {\n\t\t\t\treturn this.slugify(username);\n\t\t\t}\n\t\t}\n\n\t\treturn this.slugify(requestUsername);\n\t}\n\n\tprivate static getLdapUsername(ldapUser: ILDAPEntry): string | undefined {\n\t\tconst usernameField = getLDAPConditionalSetting('LDAP_Username_Field') as string;\n\t\treturn this.getLdapDynamicValue(ldapUser, usernameField);\n\t}\n\n\t// This method will find existing users by LDAP id or by username.\n\tprivate static async findExistingUser(ldapUser: ILDAPEntry, slugifiedUsername: string): Promise<IUser | undefined> {\n\t\tconst user = await this.findExistingLDAPUser(ldapUser);\n\t\tif (user) {\n\t\t\treturn user;\n\t\t}\n\n\t\treturn UsersRaw.findOneByUsername(slugifiedUsername);\n\t}\n\n\tprivate static fallbackToDefaultLogin(username: LoginUsername, password: string): LDAPLoginResult {\n\t\tif (typeof username === 'string') {\n\t\t\tif (username.indexOf('@') === -1) {\n\t\t\t\tusername = { username };\n\t\t\t} else {\n\t\t\t\tusername = { email: username };\n\t\t\t}\n\t\t}\n\n\t\tlogger.debug({ msg: 'Fallback to default account system', username });\n\n\t\tconst loginRequest = {\n\t\t\tuser: username,\n\t\t\tpassword: {\n\t\t\t\tdigest: SHA256(password),\n\t\t\t\talgorithm: 'sha-256',\n\t\t\t},\n\t\t};\n\n\t\treturn Accounts._runLoginHandlers(this, loginRequest);\n\t}\n\n\tprivate static getAvatarFromUser(ldapUser: ILDAPEntry): any | undefined {\n\t\tconst avatarField = String(settings.get('LDAP_Avatar_Field') || '').trim();\n\t\tif (avatarField && ldapUser._raw[avatarField]) {\n\t\t\treturn ldapUser._raw[avatarField];\n\t\t}\n\n\t\tif (ldapUser._raw.thumbnailPhoto) {\n\t\t\treturn ldapUser._raw.thumbnailPhoto;\n\t\t}\n\n\t\tif (ldapUser._raw.jpegPhoto) {\n\t\t\treturn ldapUser._raw.jpegPhoto;\n\t\t}\n\t}\n}\n"],"sourceRoot":""},"sourceType":"module","hash":"6606c714a6cf5594b6db838beebe0092caf2b231"}
