[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar IdMap = Package['id-map'].IdMap;\nvar ECMAScript = Package.ecmascript.ECMAScript;\nvar meteorInstall = Package.modules.meteorInstall;\nvar Promise = Package.promise.Promise;\n\n/* Package-scope variables */\nvar idx, MaxHeap, MinHeap, MinMaxHeap;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"binary-heap\":{\"binary-heap.js\":function module(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                  //\n// packages/binary-heap/binary-heap.js                                                                              //\n//                                                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                    //\nmodule.link(\"./max-heap.js\", {\n  MaxHeap: \"MaxHeap\"\n}, 0);\nmodule.link(\"./min-heap.js\", {\n  MinHeap: \"MinHeap\"\n}, 1);\nmodule.link(\"./min-max-heap.js\", {\n  MinMaxHeap: \"MinMaxHeap\"\n}, 2);\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"max-heap.js\":function module(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                  //\n// packages/binary-heap/max-heap.js                                                                                 //\n//                                                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                    //\nmodule.export({\n  MaxHeap: () => MaxHeap\n});\n\nclass MaxHeap {\n  constructor(comparator) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (typeof comparator !== 'function') {\n      throw new Error('Passed comparator is invalid, should be a comparison function');\n    } // a C-style comparator that is given two values and returns a number,\n    // negative if the first value is less than the second, positive if the second\n    // value is greater than the first and zero if they are equal.\n\n\n    this._comparator = comparator;\n\n    if (!options.IdMap) {\n      options.IdMap = IdMap;\n    } // _heapIdx maps an id to an index in the Heap array the corresponding value\n    // is located on.\n\n\n    this._heapIdx = new options.IdMap(); // The Heap data-structure implemented as a 0-based contiguous array where\n    // every item on index idx is a node in a complete binary tree. Every node can\n    // have children on indexes idx*2+1 and idx*2+2, except for the leaves. Every\n    // node has a parent on index (idx-1)/2;\n\n    this._heap = []; // If the initial array is passed, we can build the heap in linear time\n    // complexity (O(N)) compared to linearithmic time complexity (O(nlogn)) if\n    // we push elements one by one.\n\n    if (Array.isArray(options.initData)) {\n      this._initFromData(options.initData);\n    }\n  } // Builds a new heap in-place in linear time based on passed data\n\n\n  _initFromData(data) {\n    this._heap = data.map(_ref => {\n      let {\n        id,\n        value\n      } = _ref;\n      return {\n        id,\n        value\n      };\n    });\n    data.forEach((_ref2, i) => {\n      let {\n        id\n      } = _ref2;\n      return this._heapIdx.set(id, i);\n    });\n\n    if (!data.length) {\n      return;\n    } // start from the first non-leaf - the parent of the last leaf\n\n\n    for (let i = parentIdx(data.length - 1); i >= 0; i--) {\n      this._downHeap(i);\n    }\n  }\n\n  _downHeap(idx) {\n    while (leftChildIdx(idx) < this.size()) {\n      const left = leftChildIdx(idx);\n      const right = rightChildIdx(idx);\n      let largest = idx;\n\n      if (left < this.size()) {\n        largest = this._maxIndex(largest, left);\n      }\n\n      if (right < this.size()) {\n        largest = this._maxIndex(largest, right);\n      }\n\n      if (largest === idx) {\n        break;\n      }\n\n      this._swap(largest, idx);\n\n      idx = largest;\n    }\n  }\n\n  _upHeap(idx) {\n    while (idx > 0) {\n      const parent = parentIdx(idx);\n\n      if (this._maxIndex(parent, idx) === idx) {\n        this._swap(parent, idx);\n\n        idx = parent;\n      } else {\n        break;\n      }\n    }\n  }\n\n  _maxIndex(idxA, idxB) {\n    const valueA = this._get(idxA);\n\n    const valueB = this._get(idxB);\n\n    return this._comparator(valueA, valueB) >= 0 ? idxA : idxB;\n  } // Internal: gets raw data object placed on idxth place in heap\n\n\n  _get(idx) {\n    return this._heap[idx].value;\n  }\n\n  _swap(idxA, idxB) {\n    const recA = this._heap[idxA];\n    const recB = this._heap[idxB];\n\n    this._heapIdx.set(recA.id, idxB);\n\n    this._heapIdx.set(recB.id, idxA);\n\n    this._heap[idxA] = recB;\n    this._heap[idxB] = recA;\n  }\n\n  get(id) {\n    return this.has(id) ? this._get(this._heapIdx.get(id)) : null;\n  }\n\n  set(id, value) {\n    if (this.has(id)) {\n      if (this.get(id) === value) {\n        return;\n      }\n\n      const idx = this._heapIdx.get(id);\n\n      this._heap[idx].value = value; // Fix the new value's position\n      // Either bubble new value up if it is greater than its parent\n\n      this._upHeap(idx); // or bubble it down if it is smaller than one of its children\n\n\n      this._downHeap(idx);\n    } else {\n      this._heapIdx.set(id, this._heap.length);\n\n      this._heap.push({\n        id,\n        value\n      });\n\n      this._upHeap(this._heap.length - 1);\n    }\n  }\n\n  remove(id) {\n    if (this.has(id)) {\n      const last = this._heap.length - 1;\n\n      const idx = this._heapIdx.get(id);\n\n      if (idx !== last) {\n        this._swap(idx, last);\n\n        this._heap.pop();\n\n        this._heapIdx.remove(id); // Fix the swapped value's position\n\n\n        this._upHeap(idx);\n\n        this._downHeap(idx);\n      } else {\n        this._heap.pop();\n\n        this._heapIdx.remove(id);\n      }\n    }\n  }\n\n  has(id) {\n    return this._heapIdx.has(id);\n  }\n\n  empty() {\n    return !this.size();\n  }\n\n  clear() {\n    this._heap = [];\n\n    this._heapIdx.clear();\n  } // iterate over values in no particular order\n\n\n  forEach(iterator) {\n    this._heap.forEach(obj => iterator(obj.value, obj.id));\n  }\n\n  size() {\n    return this._heap.length;\n  }\n\n  setDefault(id, def) {\n    if (this.has(id)) {\n      return this.get(id);\n    }\n\n    this.set(id, def);\n    return def;\n  }\n\n  clone() {\n    const clone = new MaxHeap(this._comparator, this._heap);\n    return clone;\n  }\n\n  maxElementId() {\n    return this.size() ? this._heap[0].id : null;\n  }\n\n  _selfCheck() {\n    for (let i = 1; i < this._heap.length; i++) {\n      if (this._maxIndex(parentIdx(i), i) !== parentIdx(i)) {\n        throw new Error(\"An item with id \".concat(this._heap[i].id) + \" has a parent younger than it: \" + this._heap[parentIdx(i)].id);\n      }\n    }\n  }\n\n}\n\nconst leftChildIdx = i => i * 2 + 1;\n\nconst rightChildIdx = i => i * 2 + 2;\n\nconst parentIdx = i => i - 1 >> 1;\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"min-heap.js\":function module(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                  //\n// packages/binary-heap/min-heap.js                                                                                 //\n//                                                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                    //\nmodule.export({\n  MinHeap: () => MinHeap\n});\nlet MaxHeap;\nmodule.link(\"./max-heap.js\", {\n  MaxHeap(v) {\n    MaxHeap = v;\n  }\n\n}, 0);\n\nclass MinHeap extends MaxHeap {\n  constructor(comparator, options) {\n    super((a, b) => -comparator(a, b), options);\n  }\n\n  maxElementId() {\n    throw new Error(\"Cannot call maxElementId on MinHeap\");\n  }\n\n  minElementId() {\n    return super.maxElementId();\n  }\n\n}\n\n;\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"min-max-heap.js\":function module(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                  //\n// packages/binary-heap/min-max-heap.js                                                                             //\n//                                                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                    //\nmodule.export({\n  MinMaxHeap: () => MinMaxHeap\n});\nlet MaxHeap;\nmodule.link(\"./max-heap.js\", {\n  MaxHeap(v) {\n    MaxHeap = v;\n  }\n\n}, 0);\nlet MinHeap;\nmodule.link(\"./min-heap.js\", {\n  MinHeap(v) {\n    MinHeap = v;\n  }\n\n}, 1);\n\nclass MinMaxHeap extends MaxHeap {\n  constructor(comparator, options) {\n    super(comparator, options);\n    this._minHeap = new MinHeap(comparator, options);\n  }\n\n  set() {\n    super.set(...arguments);\n\n    this._minHeap.set(...arguments);\n  }\n\n  remove() {\n    super.remove(...arguments);\n\n    this._minHeap.remove(...arguments);\n  }\n\n  clear() {\n    super.clear(...arguments);\n\n    this._minHeap.clear(...arguments);\n  }\n\n  setDefault() {\n    super.setDefault(...arguments);\n    return this._minHeap.setDefault(...arguments);\n  }\n\n  clone() {\n    const clone = new MinMaxHeap(this._comparator, this._heap);\n    return clone;\n  }\n\n  minElementId() {\n    return this._minHeap.minElementId();\n  }\n\n}\n\n;\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\n\nvar exports = require(\"/node_modules/meteor/binary-heap/binary-heap.js\");\n\n/* Exports */\nPackage._define(\"binary-heap\", exports, {\n  MaxHeap: MaxHeap,\n  MinHeap: MinHeap,\n  MinMaxHeap: MinMaxHeap\n});\n\n})();\n","servePath":"/packages/binary-heap.js","sourceMap":{"version":3,"sources":["packages/binary-heap/binary-heap.js","packages/binary-heap/max-heap.js","packages/binary-heap/min-heap.js","packages/binary-heap/min-max-heap.js"],"names":["module","link","MaxHeap","MinHeap","MinMaxHeap","export","constructor","comparator","options","Error","_comparator","IdMap","_heapIdx","_heap","Array","isArray","initData","_initFromData","data","map","id","value","forEach","i","set","length","parentIdx","_downHeap","idx","leftChildIdx","size","left","right","rightChildIdx","largest","_maxIndex","_swap","_upHeap","parent","idxA","idxB","valueA","_get","valueB","recA","recB","get","has","push","remove","last","pop","empty","clear","iterator","obj","setDefault","def","clone","maxElementId","_selfCheck","v","a","b","minElementId","_minHeap"],"mappings":"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","file":"/packages/binary-heap.js","sourcesContent":["export { MaxHeap } from './max-heap.js';\nexport { MinHeap } from './min-heap.js';\nexport { MinMaxHeap } from './min-max-heap.js';\n","// Constructor of Heap\n// - comparator - Function - given two items returns a number\n// - options:\n//   - initData - Array - Optional - the initial data in a format:\n//        Object:\n//          - id - String - unique id of the item\n//          - value - Any - the data value\n//      each value is retained\n//   - IdMap - Constructor - Optional - custom IdMap class to store id->index\n//       mappings internally. Standard IdMap is used by default.\nexport class MaxHeap { \n  constructor(comparator, options = {}) {\n    if (typeof comparator !== 'function') {\n      throw new Error('Passed comparator is invalid, should be a comparison function');\n    }\n\n    // a C-style comparator that is given two values and returns a number,\n    // negative if the first value is less than the second, positive if the second\n    // value is greater than the first and zero if they are equal.\n    this._comparator = comparator;\n\n    if (! options.IdMap) {\n      options.IdMap = IdMap;\n    }\n\n    // _heapIdx maps an id to an index in the Heap array the corresponding value\n    // is located on.\n    this._heapIdx = new options.IdMap;\n\n    // The Heap data-structure implemented as a 0-based contiguous array where\n    // every item on index idx is a node in a complete binary tree. Every node can\n    // have children on indexes idx*2+1 and idx*2+2, except for the leaves. Every\n    // node has a parent on index (idx-1)/2;\n    this._heap = [];\n\n    // If the initial array is passed, we can build the heap in linear time\n    // complexity (O(N)) compared to linearithmic time complexity (O(nlogn)) if\n    // we push elements one by one.\n    if (Array.isArray(options.initData)) {\n      this._initFromData(options.initData);\n    }\n  }\n\n  // Builds a new heap in-place in linear time based on passed data\n  _initFromData(data) {\n    this._heap = data.map(({ id, value }) => ({ id, value }));\n\n    data.forEach(({ id }, i) => this._heapIdx.set(id, i));\n\n    if (! data.length) {\n      return;\n    }\n\n    // start from the first non-leaf - the parent of the last leaf\n    for (let i = parentIdx(data.length - 1); i >= 0; i--) {\n      this._downHeap(i);\n    }\n  }\n\n  _downHeap(idx) {\n    while (leftChildIdx(idx) < this.size()) {\n      const left = leftChildIdx(idx);\n      const right = rightChildIdx(idx);\n      let largest = idx;\n\n      if (left < this.size()) {\n        largest = this._maxIndex(largest, left);\n      }\n\n      if (right < this.size()) {\n        largest = this._maxIndex(largest, right);\n      }\n\n      if (largest === idx) {\n        break;\n      }\n\n      this._swap(largest, idx);\n      idx = largest;\n    }\n  }\n\n  _upHeap(idx) {\n    while (idx > 0) {\n      const parent = parentIdx(idx);\n      if (this._maxIndex(parent, idx) === idx) {\n        this._swap(parent, idx)\n        idx = parent;\n      } else {\n        break;\n      }\n    }\n  }\n\n  _maxIndex(idxA, idxB) {\n    const valueA = this._get(idxA);\n    const valueB = this._get(idxB);\n    return this._comparator(valueA, valueB) >= 0 ? idxA : idxB;\n  }\n\n  // Internal: gets raw data object placed on idxth place in heap\n  _get(idx) {\n    return this._heap[idx].value;\n  }\n\n  _swap(idxA, idxB) {\n    const recA = this._heap[idxA];\n    const recB = this._heap[idxB];\n\n    this._heapIdx.set(recA.id, idxB);\n    this._heapIdx.set(recB.id, idxA);\n\n    this._heap[idxA] = recB;\n    this._heap[idxB] = recA;\n  }\n\n  get(id) {\n    return this.has(id) ?\n      this._get(this._heapIdx.get(id)) :\n      null;\n  }\n\n  set(id, value) {\n    if (this.has(id)) {\n      if (this.get(id) === value) {\n        return;\n      }\n\n      const idx = this._heapIdx.get(id);\n      this._heap[idx].value = value;\n\n      // Fix the new value's position\n      // Either bubble new value up if it is greater than its parent\n      this._upHeap(idx);\n      // or bubble it down if it is smaller than one of its children\n      this._downHeap(idx);\n    } else {\n      this._heapIdx.set(id, this._heap.length);\n      this._heap.push({ id, value });\n      this._upHeap(this._heap.length - 1);\n    }\n  }\n\n  remove(id) {\n    if (this.has(id)) {\n      const last = this._heap.length - 1;\n      const idx = this._heapIdx.get(id);\n\n      if (idx !== last) {\n        this._swap(idx, last);\n        this._heap.pop();\n        this._heapIdx.remove(id);\n\n        // Fix the swapped value's position\n        this._upHeap(idx);\n        this._downHeap(idx);\n      } else {\n        this._heap.pop();\n        this._heapIdx.remove(id);\n      }\n    }\n  }\n\n  has(id) {\n    return this._heapIdx.has(id);\n  }\n\n  empty() {\n    return !this.size();\n  }\n\n  clear() {\n    this._heap = [];\n    this._heapIdx.clear();\n  }\n\n  // iterate over values in no particular order\n  forEach(iterator) {\n    this._heap.forEach(obj => iterator(obj.value, obj.id));\n  }\n\n  size() {\n    return this._heap.length;\n  }\n\n  setDefault(id, def) {\n    if (this.has(id)) {\n      return this.get(id);\n    }\n\n    this.set(id, def);\n    return def;\n  }\n\n  clone() {\n    const clone = new MaxHeap(this._comparator, this._heap);\n    return clone;\n  }\n\n  maxElementId() {\n    return this.size() ? this._heap[0].id : null;\n  }\n\n  _selfCheck() {\n    for (let i = 1; i < this._heap.length; i++) {\n      if (this._maxIndex(parentIdx(i), i) !== parentIdx(i)) {\n          throw new Error(`An item with id ${this._heap[i].id}` +\n                          \" has a parent younger than it: \" +\n                          this._heap[parentIdx(i)].id);\n      }\n    }\n  }\n}\n\nconst leftChildIdx = i => i * 2 + 1;\nconst rightChildIdx = i => i * 2 + 2;\nconst parentIdx = i => (i - 1) >> 1;\n","import { MaxHeap } from './max-heap.js';\n\nexport class MinHeap extends MaxHeap {\n  constructor(comparator, options) {\n    super((a, b) => -comparator(a, b), options);\n  }\n\n  maxElementId() {\n    throw new Error(\"Cannot call maxElementId on MinHeap\");\n  }\n\n  minElementId() {\n    return super.maxElementId();\n  }\n};\n","import { MaxHeap } from './max-heap.js';\nimport { MinHeap } from './min-heap.js';\n\n// This implementation of Min/Max-Heap is just a subclass of Max-Heap\n// with a Min-Heap as an encapsulated property.\n//\n// Most of the operations are just proxy methods to call the same method on both\n// heaps.\n//\n// This implementation takes 2*N memory but is fairly simple to write and\n// understand. And the constant factor of a simple Heap is usually smaller\n// compared to other two-way priority queues like Min/Max Heaps\n// (http://www.cs.otago.ac.nz/staffpriv/mike/Papers/MinMaxHeaps/MinMaxHeaps.pdf)\n// and Interval Heaps\n// (http://www.cise.ufl.edu/~sahni/dsaac/enrich/c13/double.htm)\nexport class MinMaxHeap extends MaxHeap {\n  constructor(comparator, options) {\n    super(comparator, options);\n    this._minHeap = new MinHeap(comparator, options);\n  }\n\n  set(...args) {\n    super.set(...args);\n    this._minHeap.set(...args);\n  }\n\n  remove(...args) {\n    super.remove(...args);\n    this._minHeap.remove(...args);\n  }\n\n  clear(...args) {\n    super.clear(...args);\n    this._minHeap.clear(...args);\n  }\n\n  setDefault(...args) {\n    super.setDefault(...args);\n    return this._minHeap.setDefault(...args);\n  }\n\n  clone() {\n    const clone = new MinMaxHeap(this._comparator, this._heap);\n    return clone;\n  }\n\n  minElementId() {\n    return this._minHeap.minElementId();\n  }\n\n};\n"]}}]