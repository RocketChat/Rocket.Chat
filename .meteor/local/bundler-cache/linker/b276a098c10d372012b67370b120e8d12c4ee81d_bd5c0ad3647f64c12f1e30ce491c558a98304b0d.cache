[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar ECMAScript = Package.ecmascript.ECMAScript;\nvar Base64 = Package.base64.Base64;\nvar meteorInstall = Package.modules.meteorInstall;\nvar Promise = Package.promise.Promise;\n\n/* Package-scope variables */\nvar EJSON;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"ejson\":{\"ejson.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                             //\n// packages/ejson/ejson.js                                                                                     //\n//                                                                                                             //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                               //\nmodule.export({\n  EJSON: () => EJSON\n});\nlet isFunction, isObject, keysOf, lengthOf, hasOwn, convertMapToObject, isArguments, isInfOrNaN, handleError;\nmodule.link(\"./utils\", {\n  isFunction(v) {\n    isFunction = v;\n  },\n\n  isObject(v) {\n    isObject = v;\n  },\n\n  keysOf(v) {\n    keysOf = v;\n  },\n\n  lengthOf(v) {\n    lengthOf = v;\n  },\n\n  hasOwn(v) {\n    hasOwn = v;\n  },\n\n  convertMapToObject(v) {\n    convertMapToObject = v;\n  },\n\n  isArguments(v) {\n    isArguments = v;\n  },\n\n  isInfOrNaN(v) {\n    isInfOrNaN = v;\n  },\n\n  handleError(v) {\n    handleError = v;\n  }\n\n}, 0);\n\n/**\n * @namespace\n * @summary Namespace for EJSON functions\n */\nconst EJSON = {}; // Custom type interface definition\n\n/**\n * @class CustomType\n * @instanceName customType\n * @memberOf EJSON\n * @summary The interface that a class must satisfy to be able to become an\n * EJSON custom type via EJSON.addType.\n */\n\n/**\n * @function typeName\n * @memberOf EJSON.CustomType\n * @summary Return the tag used to identify this type.  This must match the\n *          tag used to register this type with\n *          [`EJSON.addType`](#ejson_add_type).\n * @locus Anywhere\n * @instance\n */\n\n/**\n * @function toJSONValue\n * @memberOf EJSON.CustomType\n * @summary Serialize this instance into a JSON-compatible value.\n * @locus Anywhere\n * @instance\n */\n\n/**\n * @function clone\n * @memberOf EJSON.CustomType\n * @summary Return a value `r` such that `this.equals(r)` is true, and\n *          modifications to `r` do not affect `this` and vice versa.\n * @locus Anywhere\n * @instance\n */\n\n/**\n * @function equals\n * @memberOf EJSON.CustomType\n * @summary Return `true` if `other` has a value equal to `this`; `false`\n *          otherwise.\n * @locus Anywhere\n * @param {Object} other Another object to compare this to.\n * @instance\n */\n\nconst customTypes = new Map(); // Add a custom type, using a method of your choice to get to and\n// from a basic JSON-able representation.  The factory argument\n// is a function of JSON-able --> your object\n// The type you add must have:\n// - A toJSONValue() method, so that Meteor can serialize it\n// - a typeName() method, to show how to look it up in our type table.\n// It is okay if these methods are monkey-patched on.\n// EJSON.clone will use toJSONValue and the given factory to produce\n// a clone, but you may specify a method clone() that will be\n// used instead.\n// Similarly, EJSON.equals will use toJSONValue to make comparisons,\n// but you may provide a method equals() instead.\n\n/**\n * @summary Add a custom datatype to EJSON.\n * @locus Anywhere\n * @param {String} name A tag for your custom type; must be unique among\n *                      custom data types defined in your project, and must\n *                      match the result of your type's `typeName` method.\n * @param {Function} factory A function that deserializes a JSON-compatible\n *                           value into an instance of your type.  This should\n *                           match the serialization performed by your\n *                           type's `toJSONValue` method.\n */\n\nEJSON.addType = (name, factory) => {\n  if (customTypes.has(name)) {\n    throw new Error(\"Type \".concat(name, \" already present\"));\n  }\n\n  customTypes.set(name, factory);\n};\n\nconst builtinConverters = [{\n  // Date\n  matchJSONValue(obj) {\n    return hasOwn(obj, '$date') && lengthOf(obj) === 1;\n  },\n\n  matchObject(obj) {\n    return obj instanceof Date;\n  },\n\n  toJSONValue(obj) {\n    return {\n      $date: obj.getTime()\n    };\n  },\n\n  fromJSONValue(obj) {\n    return new Date(obj.$date);\n  }\n\n}, {\n  // RegExp\n  matchJSONValue(obj) {\n    return hasOwn(obj, '$regexp') && hasOwn(obj, '$flags') && lengthOf(obj) === 2;\n  },\n\n  matchObject(obj) {\n    return obj instanceof RegExp;\n  },\n\n  toJSONValue(regexp) {\n    return {\n      $regexp: regexp.source,\n      $flags: regexp.flags\n    };\n  },\n\n  fromJSONValue(obj) {\n    // Replaces duplicate / invalid flags.\n    return new RegExp(obj.$regexp, obj.$flags // Cut off flags at 50 chars to avoid abusing RegExp for DOS.\n    .slice(0, 50).replace(/[^gimuy]/g, '').replace(/(.)(?=.*\\1)/g, ''));\n  }\n\n}, {\n  // NaN, Inf, -Inf. (These are the only objects with typeof !== 'object'\n  // which we match.)\n  matchJSONValue(obj) {\n    return hasOwn(obj, '$InfNaN') && lengthOf(obj) === 1;\n  },\n\n  matchObject: isInfOrNaN,\n\n  toJSONValue(obj) {\n    let sign;\n\n    if (Number.isNaN(obj)) {\n      sign = 0;\n    } else if (obj === Infinity) {\n      sign = 1;\n    } else {\n      sign = -1;\n    }\n\n    return {\n      $InfNaN: sign\n    };\n  },\n\n  fromJSONValue(obj) {\n    return obj.$InfNaN / 0;\n  }\n\n}, {\n  // Binary\n  matchJSONValue(obj) {\n    return hasOwn(obj, '$binary') && lengthOf(obj) === 1;\n  },\n\n  matchObject(obj) {\n    return typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array || obj && hasOwn(obj, '$Uint8ArrayPolyfill');\n  },\n\n  toJSONValue(obj) {\n    return {\n      $binary: Base64.encode(obj)\n    };\n  },\n\n  fromJSONValue(obj) {\n    return Base64.decode(obj.$binary);\n  }\n\n}, {\n  // Escaping one level\n  matchJSONValue(obj) {\n    return hasOwn(obj, '$escape') && lengthOf(obj) === 1;\n  },\n\n  matchObject(obj) {\n    let match = false;\n\n    if (obj) {\n      const keyCount = lengthOf(obj);\n\n      if (keyCount === 1 || keyCount === 2) {\n        match = builtinConverters.some(converter => converter.matchJSONValue(obj));\n      }\n    }\n\n    return match;\n  },\n\n  toJSONValue(obj) {\n    const newObj = {};\n    keysOf(obj).forEach(key => {\n      newObj[key] = EJSON.toJSONValue(obj[key]);\n    });\n    return {\n      $escape: newObj\n    };\n  },\n\n  fromJSONValue(obj) {\n    const newObj = {};\n    keysOf(obj.$escape).forEach(key => {\n      newObj[key] = EJSON.fromJSONValue(obj.$escape[key]);\n    });\n    return newObj;\n  }\n\n}, {\n  // Custom\n  matchJSONValue(obj) {\n    return hasOwn(obj, '$type') && hasOwn(obj, '$value') && lengthOf(obj) === 2;\n  },\n\n  matchObject(obj) {\n    return EJSON._isCustomType(obj);\n  },\n\n  toJSONValue(obj) {\n    const jsonValue = Meteor._noYieldsAllowed(() => obj.toJSONValue());\n\n    return {\n      $type: obj.typeName(),\n      $value: jsonValue\n    };\n  },\n\n  fromJSONValue(obj) {\n    const typeName = obj.$type;\n\n    if (!customTypes.has(typeName)) {\n      throw new Error(\"Custom EJSON type \".concat(typeName, \" is not defined\"));\n    }\n\n    const converter = customTypes.get(typeName);\n    return Meteor._noYieldsAllowed(() => converter(obj.$value));\n  }\n\n}];\n\nEJSON._isCustomType = obj => obj && isFunction(obj.toJSONValue) && isFunction(obj.typeName) && customTypes.has(obj.typeName());\n\nEJSON._getTypes = function () {\n  let isOriginal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  return isOriginal ? customTypes : convertMapToObject(customTypes);\n};\n\nEJSON._getConverters = () => builtinConverters; // Either return the JSON-compatible version of the argument, or undefined (if\n// the item isn't itself replaceable, but maybe some fields in it are)\n\n\nconst toJSONValueHelper = item => {\n  for (let i = 0; i < builtinConverters.length; i++) {\n    const converter = builtinConverters[i];\n\n    if (converter.matchObject(item)) {\n      return converter.toJSONValue(item);\n    }\n  }\n\n  return undefined;\n}; // for both arrays and objects, in-place modification.\n\n\nconst adjustTypesToJSONValue = obj => {\n  // Is it an atom that we need to adjust?\n  if (obj === null) {\n    return null;\n  }\n\n  const maybeChanged = toJSONValueHelper(obj);\n\n  if (maybeChanged !== undefined) {\n    return maybeChanged;\n  } // Other atoms are unchanged.\n\n\n  if (!isObject(obj)) {\n    return obj;\n  } // Iterate over array or object structure.\n\n\n  keysOf(obj).forEach(key => {\n    const value = obj[key];\n\n    if (!isObject(value) && value !== undefined && !isInfOrNaN(value)) {\n      return; // continue\n    }\n\n    const changed = toJSONValueHelper(value);\n\n    if (changed) {\n      obj[key] = changed;\n      return; // on to the next key\n    } // if we get here, value is an object but not adjustable\n    // at this level.  recurse.\n\n\n    adjustTypesToJSONValue(value);\n  });\n  return obj;\n};\n\nEJSON._adjustTypesToJSONValue = adjustTypesToJSONValue;\n/**\n * @summary Serialize an EJSON-compatible value into its plain JSON\n *          representation.\n * @locus Anywhere\n * @param {EJSON} val A value to serialize to plain JSON.\n */\n\nEJSON.toJSONValue = item => {\n  const changed = toJSONValueHelper(item);\n\n  if (changed !== undefined) {\n    return changed;\n  }\n\n  let newItem = item;\n\n  if (isObject(item)) {\n    newItem = EJSON.clone(item);\n    adjustTypesToJSONValue(newItem);\n  }\n\n  return newItem;\n}; // Either return the argument changed to have the non-json\n// rep of itself (the Object version) or the argument itself.\n// DOES NOT RECURSE.  For actually getting the fully-changed value, use\n// EJSON.fromJSONValue\n\n\nconst fromJSONValueHelper = value => {\n  if (isObject(value) && value !== null) {\n    const keys = keysOf(value);\n\n    if (keys.length <= 2 && keys.every(k => typeof k === 'string' && k.substr(0, 1) === '$')) {\n      for (let i = 0; i < builtinConverters.length; i++) {\n        const converter = builtinConverters[i];\n\n        if (converter.matchJSONValue(value)) {\n          return converter.fromJSONValue(value);\n        }\n      }\n    }\n  }\n\n  return value;\n}; // for both arrays and objects. Tries its best to just\n// use the object you hand it, but may return something\n// different if the object you hand it itself needs changing.\n\n\nconst adjustTypesFromJSONValue = obj => {\n  if (obj === null) {\n    return null;\n  }\n\n  const maybeChanged = fromJSONValueHelper(obj);\n\n  if (maybeChanged !== obj) {\n    return maybeChanged;\n  } // Other atoms are unchanged.\n\n\n  if (!isObject(obj)) {\n    return obj;\n  }\n\n  keysOf(obj).forEach(key => {\n    const value = obj[key];\n\n    if (isObject(value)) {\n      const changed = fromJSONValueHelper(value);\n\n      if (value !== changed) {\n        obj[key] = changed;\n        return;\n      } // if we get here, value is an object but not adjustable\n      // at this level.  recurse.\n\n\n      adjustTypesFromJSONValue(value);\n    }\n  });\n  return obj;\n};\n\nEJSON._adjustTypesFromJSONValue = adjustTypesFromJSONValue;\n/**\n * @summary Deserialize an EJSON value from its plain JSON representation.\n * @locus Anywhere\n * @param {JSONCompatible} val A value to deserialize into EJSON.\n */\n\nEJSON.fromJSONValue = item => {\n  let changed = fromJSONValueHelper(item);\n\n  if (changed === item && isObject(item)) {\n    changed = EJSON.clone(item);\n    adjustTypesFromJSONValue(changed);\n  }\n\n  return changed;\n};\n/**\n * @summary Serialize a value to a string. For EJSON values, the serialization\n *          fully represents the value. For non-EJSON values, serializes the\n *          same way as `JSON.stringify`.\n * @locus Anywhere\n * @param {EJSON} val A value to stringify.\n * @param {Object} [options]\n * @param {Boolean | Integer | String} options.indent Indents objects and\n * arrays for easy readability.  When `true`, indents by 2 spaces; when an\n * integer, indents by that number of spaces; and when a string, uses the\n * string as the indentation pattern.\n * @param {Boolean} options.canonical When `true`, stringifies keys in an\n *                                    object in sorted order.\n */\n\n\nEJSON.stringify = handleError((item, options) => {\n  let serialized;\n  const json = EJSON.toJSONValue(item);\n\n  if (options && (options.canonical || options.indent)) {\n    let canonicalStringify;\n    module.link(\"./stringify\", {\n      default(v) {\n        canonicalStringify = v;\n      }\n\n    }, 1);\n    serialized = canonicalStringify(json, options);\n  } else {\n    serialized = JSON.stringify(json);\n  }\n\n  return serialized;\n});\n/**\n * @summary Parse a string into an EJSON value. Throws an error if the string\n *          is not valid EJSON.\n * @locus Anywhere\n * @param {String} str A string to parse into an EJSON value.\n */\n\nEJSON.parse = item => {\n  if (typeof item !== 'string') {\n    throw new Error('EJSON.parse argument should be a string');\n  }\n\n  return EJSON.fromJSONValue(JSON.parse(item));\n};\n/**\n * @summary Returns true if `x` is a buffer of binary data, as returned from\n *          [`EJSON.newBinary`](#ejson_new_binary).\n * @param {Object} x The variable to check.\n * @locus Anywhere\n */\n\n\nEJSON.isBinary = obj => {\n  return !!(typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array || obj && obj.$Uint8ArrayPolyfill);\n};\n/**\n * @summary Return true if `a` and `b` are equal to each other.  Return false\n *          otherwise.  Uses the `equals` method on `a` if present, otherwise\n *          performs a deep comparison.\n * @locus Anywhere\n * @param {EJSON} a\n * @param {EJSON} b\n * @param {Object} [options]\n * @param {Boolean} options.keyOrderSensitive Compare in key sensitive order,\n * if supported by the JavaScript implementation.  For example, `{a: 1, b: 2}`\n * is equal to `{b: 2, a: 1}` only when `keyOrderSensitive` is `false`.  The\n * default is `false`.\n */\n\n\nEJSON.equals = (a, b, options) => {\n  let i;\n  const keyOrderSensitive = !!(options && options.keyOrderSensitive);\n\n  if (a === b) {\n    return true;\n  } // This differs from the IEEE spec for NaN equality, b/c we don't want\n  // anything ever with a NaN to be poisoned from becoming equal to anything.\n\n\n  if (Number.isNaN(a) && Number.isNaN(b)) {\n    return true;\n  } // if either one is falsy, they'd have to be === to be equal\n\n\n  if (!a || !b) {\n    return false;\n  }\n\n  if (!(isObject(a) && isObject(b))) {\n    return false;\n  }\n\n  if (a instanceof Date && b instanceof Date) {\n    return a.valueOf() === b.valueOf();\n  }\n\n  if (EJSON.isBinary(a) && EJSON.isBinary(b)) {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  if (isFunction(a.equals)) {\n    return a.equals(b, options);\n  }\n\n  if (isFunction(b.equals)) {\n    return b.equals(a, options);\n  }\n\n  if (a instanceof Array) {\n    if (!(b instanceof Array)) {\n      return false;\n    }\n\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    for (i = 0; i < a.length; i++) {\n      if (!EJSON.equals(a[i], b[i], options)) {\n        return false;\n      }\n    }\n\n    return true;\n  } // fallback for custom types that don't implement their own equals\n\n\n  switch (EJSON._isCustomType(a) + EJSON._isCustomType(b)) {\n    case 1:\n      return false;\n\n    case 2:\n      return EJSON.equals(EJSON.toJSONValue(a), EJSON.toJSONValue(b));\n\n    default: // Do nothing\n\n  } // fall back to structural equality of objects\n\n\n  let ret;\n  const aKeys = keysOf(a);\n  const bKeys = keysOf(b);\n\n  if (keyOrderSensitive) {\n    i = 0;\n    ret = aKeys.every(key => {\n      if (i >= bKeys.length) {\n        return false;\n      }\n\n      if (key !== bKeys[i]) {\n        return false;\n      }\n\n      if (!EJSON.equals(a[key], b[bKeys[i]], options)) {\n        return false;\n      }\n\n      i++;\n      return true;\n    });\n  } else {\n    i = 0;\n    ret = aKeys.every(key => {\n      if (!hasOwn(b, key)) {\n        return false;\n      }\n\n      if (!EJSON.equals(a[key], b[key], options)) {\n        return false;\n      }\n\n      i++;\n      return true;\n    });\n  }\n\n  return ret && i === bKeys.length;\n};\n/**\n * @summary Return a deep copy of `val`.\n * @locus Anywhere\n * @param {EJSON} val A value to copy.\n */\n\n\nEJSON.clone = v => {\n  let ret;\n\n  if (!isObject(v)) {\n    return v;\n  }\n\n  if (v === null) {\n    return null; // null has typeof \"object\"\n  }\n\n  if (v instanceof Date) {\n    return new Date(v.getTime());\n  } // RegExps are not really EJSON elements (eg we don't define a serialization\n  // for them), but they're immutable anyway, so we can support them in clone.\n\n\n  if (v instanceof RegExp) {\n    return v;\n  }\n\n  if (EJSON.isBinary(v)) {\n    ret = EJSON.newBinary(v.length);\n\n    for (let i = 0; i < v.length; i++) {\n      ret[i] = v[i];\n    }\n\n    return ret;\n  }\n\n  if (Array.isArray(v)) {\n    return v.map(EJSON.clone);\n  }\n\n  if (isArguments(v)) {\n    return Array.from(v).map(EJSON.clone);\n  } // handle general user-defined typed Objects if they have a clone method\n\n\n  if (isFunction(v.clone)) {\n    return v.clone();\n  } // handle other custom types\n\n\n  if (EJSON._isCustomType(v)) {\n    return EJSON.fromJSONValue(EJSON.clone(EJSON.toJSONValue(v)), true);\n  } // handle other objects\n\n\n  ret = {};\n  keysOf(v).forEach(key => {\n    ret[key] = EJSON.clone(v[key]);\n  });\n  return ret;\n};\n/**\n * @summary Allocate a new buffer of binary data that EJSON can serialize.\n * @locus Anywhere\n * @param {Number} size The number of bytes of binary data to allocate.\n */\n// EJSON.newBinary is the public documented API for this functionality,\n// but the implementation is in the 'base64' package to avoid\n// introducing a circular dependency. (If the implementation were here,\n// then 'base64' would have to use EJSON.newBinary, and 'ejson' would\n// also have to use 'base64'.)\n\n\nEJSON.newBinary = Base64.newBinary;\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"stringify.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                             //\n// packages/ejson/stringify.js                                                                                 //\n//                                                                                                             //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                               //\n// Based on json2.js from https://github.com/douglascrockford/JSON-js\n//\n//    json2.js\n//    2012-10-08\n//\n//    Public Domain.\n//\n//    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\nfunction quote(string) {\n  return JSON.stringify(string);\n}\n\nconst str = (key, holder, singleIndent, outerIndent, canonical) => {\n  const value = holder[key]; // What happens next depends on the value's type.\n\n  switch (typeof value) {\n    case 'string':\n      return quote(value);\n\n    case 'number':\n      // JSON numbers must be finite. Encode non-finite numbers as null.\n      return isFinite(value) ? String(value) : 'null';\n\n    case 'boolean':\n      return String(value);\n    // If the type is 'object', we might be dealing with an object or an array or\n    // null.\n\n    case 'object':\n      {\n        // Due to a specification blunder in ECMAScript, typeof null is 'object',\n        // so watch out for that case.\n        if (!value) {\n          return 'null';\n        } // Make an array to hold the partial results of stringifying this object\n        // value.\n\n\n        const innerIndent = outerIndent + singleIndent;\n        const partial = [];\n        let v; // Is the value an array?\n\n        if (Array.isArray(value) || {}.hasOwnProperty.call(value, 'callee')) {\n          // The value is an array. Stringify every element. Use null as a\n          // placeholder for non-JSON values.\n          const length = value.length;\n\n          for (let i = 0; i < length; i += 1) {\n            partial[i] = str(i, value, singleIndent, innerIndent, canonical) || 'null';\n          } // Join all of the elements together, separated with commas, and wrap\n          // them in brackets.\n\n\n          if (partial.length === 0) {\n            v = '[]';\n          } else if (innerIndent) {\n            v = '[\\n' + innerIndent + partial.join(',\\n' + innerIndent) + '\\n' + outerIndent + ']';\n          } else {\n            v = '[' + partial.join(',') + ']';\n          }\n\n          return v;\n        } // Iterate through all of the keys in the object.\n\n\n        let keys = Object.keys(value);\n\n        if (canonical) {\n          keys = keys.sort();\n        }\n\n        keys.forEach(k => {\n          v = str(k, value, singleIndent, innerIndent, canonical);\n\n          if (v) {\n            partial.push(quote(k) + (innerIndent ? ': ' : ':') + v);\n          }\n        }); // Join all of the member texts together, separated with commas,\n        // and wrap them in braces.\n\n        if (partial.length === 0) {\n          v = '{}';\n        } else if (innerIndent) {\n          v = '{\\n' + innerIndent + partial.join(',\\n' + innerIndent) + '\\n' + outerIndent + '}';\n        } else {\n          v = '{' + partial.join(',') + '}';\n        }\n\n        return v;\n      }\n\n    default: // Do nothing\n\n  }\n}; // If the JSON object does not yet have a stringify method, give it one.\n\n\nconst canonicalStringify = (value, options) => {\n  // Make a fake root object containing our value under the key of ''.\n  // Return the result of stringifying the value.\n  const allOptions = Object.assign({\n    indent: '',\n    canonical: false\n  }, options);\n\n  if (allOptions.indent === true) {\n    allOptions.indent = '  ';\n  } else if (typeof allOptions.indent === 'number') {\n    let newIndent = '';\n\n    for (let i = 0; i < allOptions.indent; i++) {\n      newIndent += ' ';\n    }\n\n    allOptions.indent = newIndent;\n  }\n\n  return str('', {\n    '': value\n  }, allOptions.indent, '', allOptions.canonical);\n};\n\nmodule.exportDefault(canonicalStringify);\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"utils.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                             //\n// packages/ejson/utils.js                                                                                     //\n//                                                                                                             //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                               //\nmodule.export({\n  isFunction: () => isFunction,\n  isObject: () => isObject,\n  keysOf: () => keysOf,\n  lengthOf: () => lengthOf,\n  hasOwn: () => hasOwn,\n  convertMapToObject: () => convertMapToObject,\n  isArguments: () => isArguments,\n  isInfOrNaN: () => isInfOrNaN,\n  checkError: () => checkError,\n  handleError: () => handleError\n});\n\nconst isFunction = fn => typeof fn === 'function';\n\nconst isObject = fn => typeof fn === 'object';\n\nconst keysOf = obj => Object.keys(obj);\n\nconst lengthOf = obj => Object.keys(obj).length;\n\nconst hasOwn = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n\nconst convertMapToObject = map => Array.from(map).reduce((acc, _ref) => {\n  let [key, value] = _ref;\n  // reassign to not create new object\n  acc[key] = value;\n  return acc;\n}, {});\n\nconst isArguments = obj => obj != null && hasOwn(obj, 'callee');\n\nconst isInfOrNaN = obj => Number.isNaN(obj) || obj === Infinity || obj === -Infinity;\n\nconst checkError = {\n  maxStack: msgError => new RegExp('Maximum call stack size exceeded', 'g').test(msgError)\n};\n\nconst handleError = fn => function () {\n  try {\n    return fn.apply(this, arguments);\n  } catch (error) {\n    const isMaxStack = checkError.maxStack(error.message);\n\n    if (isMaxStack) {\n      throw new Error('Converting circular structure to JSON');\n    }\n\n    throw error;\n  }\n};\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\n\nvar exports = require(\"/node_modules/meteor/ejson/ejson.js\");\n\n/* Exports */\nPackage._define(\"ejson\", exports, {\n  EJSON: EJSON\n});\n\n})();\n","servePath":"/packages/ejson.js","sourceMap":{"version":3,"sources":["packages/ejson/ejson.js","packages/ejson/stringify.js","packages/ejson/utils.js"],"names":["module","export","EJSON","isFunction","isObject","keysOf","lengthOf","hasOwn","convertMapToObject","isArguments","isInfOrNaN","handleError","link","v","customTypes","Map","addType","name","factory","has","Error","set","builtinConverters","matchJSONValue","obj","matchObject","Date","toJSONValue","$date","getTime","fromJSONValue","RegExp","regexp","$regexp","source","$flags","flags","slice","replace","sign","Number","isNaN","Infinity","$InfNaN","Uint8Array","$binary","Base64","encode","decode","match","keyCount","some","converter","newObj","forEach","key","$escape","_isCustomType","jsonValue","Meteor","_noYieldsAllowed","$type","typeName","$value","get","_getTypes","isOriginal","_getConverters","toJSONValueHelper","item","i","length","undefined","adjustTypesToJSONValue","maybeChanged","value","changed","_adjustTypesToJSONValue","newItem","clone","fromJSONValueHelper","keys","every","k","substr","adjustTypesFromJSONValue","_adjustTypesFromJSONValue","stringify","options","serialized","json","canonical","indent","canonicalStringify","default","JSON","parse","isBinary","$Uint8ArrayPolyfill","equals","a","b","keyOrderSensitive","valueOf","Array","ret","aKeys","bKeys","newBinary","isArray","map","from","quote","string","str","holder","singleIndent","outerIndent","isFinite","String","innerIndent","partial","hasOwnProperty","call","join","Object","sort","push","allOptions","assign","newIndent","exportDefault","checkError","fn","prop","prototype","reduce","acc","maxStack","msgError","test","apply","arguments","error","isMaxStack","message"],"mappings":"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","file":"/packages/ejson.js","sourcesContent":["import {\n  isFunction,\n  isObject,\n  keysOf,\n  lengthOf,\n  hasOwn,\n  convertMapToObject,\n  isArguments,\n  isInfOrNaN,\n  handleError,\n} from './utils';\n\n/**\n * @namespace\n * @summary Namespace for EJSON functions\n */\nconst EJSON = {};\n\n// Custom type interface definition\n/**\n * @class CustomType\n * @instanceName customType\n * @memberOf EJSON\n * @summary The interface that a class must satisfy to be able to become an\n * EJSON custom type via EJSON.addType.\n */\n\n/**\n * @function typeName\n * @memberOf EJSON.CustomType\n * @summary Return the tag used to identify this type.  This must match the\n *          tag used to register this type with\n *          [`EJSON.addType`](#ejson_add_type).\n * @locus Anywhere\n * @instance\n */\n\n/**\n * @function toJSONValue\n * @memberOf EJSON.CustomType\n * @summary Serialize this instance into a JSON-compatible value.\n * @locus Anywhere\n * @instance\n */\n\n/**\n * @function clone\n * @memberOf EJSON.CustomType\n * @summary Return a value `r` such that `this.equals(r)` is true, and\n *          modifications to `r` do not affect `this` and vice versa.\n * @locus Anywhere\n * @instance\n */\n\n/**\n * @function equals\n * @memberOf EJSON.CustomType\n * @summary Return `true` if `other` has a value equal to `this`; `false`\n *          otherwise.\n * @locus Anywhere\n * @param {Object} other Another object to compare this to.\n * @instance\n */\n\nconst customTypes = new Map();\n\n// Add a custom type, using a method of your choice to get to and\n// from a basic JSON-able representation.  The factory argument\n// is a function of JSON-able --> your object\n// The type you add must have:\n// - A toJSONValue() method, so that Meteor can serialize it\n// - a typeName() method, to show how to look it up in our type table.\n// It is okay if these methods are monkey-patched on.\n// EJSON.clone will use toJSONValue and the given factory to produce\n// a clone, but you may specify a method clone() that will be\n// used instead.\n// Similarly, EJSON.equals will use toJSONValue to make comparisons,\n// but you may provide a method equals() instead.\n/**\n * @summary Add a custom datatype to EJSON.\n * @locus Anywhere\n * @param {String} name A tag for your custom type; must be unique among\n *                      custom data types defined in your project, and must\n *                      match the result of your type's `typeName` method.\n * @param {Function} factory A function that deserializes a JSON-compatible\n *                           value into an instance of your type.  This should\n *                           match the serialization performed by your\n *                           type's `toJSONValue` method.\n */\nEJSON.addType = (name, factory) => {\n  if (customTypes.has(name)) {\n    throw new Error(`Type ${name} already present`);\n  }\n  customTypes.set(name, factory);\n};\n\nconst builtinConverters = [\n  { // Date\n    matchJSONValue(obj) {\n      return hasOwn(obj, '$date') && lengthOf(obj) === 1;\n    },\n    matchObject(obj) {\n      return obj instanceof Date;\n    },\n    toJSONValue(obj) {\n      return {$date: obj.getTime()};\n    },\n    fromJSONValue(obj) {\n      return new Date(obj.$date);\n    },\n  },\n  { // RegExp\n    matchJSONValue(obj) {\n      return hasOwn(obj, '$regexp')\n        && hasOwn(obj, '$flags')\n        && lengthOf(obj) === 2;\n    },\n    matchObject(obj) {\n      return obj instanceof RegExp;\n    },\n    toJSONValue(regexp) {\n      return {\n        $regexp: regexp.source,\n        $flags: regexp.flags\n      };\n    },\n    fromJSONValue(obj) {\n      // Replaces duplicate / invalid flags.\n      return new RegExp(\n        obj.$regexp,\n        obj.$flags\n          // Cut off flags at 50 chars to avoid abusing RegExp for DOS.\n          .slice(0, 50)\n          .replace(/[^gimuy]/g,'')\n          .replace(/(.)(?=.*\\1)/g, '')\n      );\n    },\n  },\n  { // NaN, Inf, -Inf. (These are the only objects with typeof !== 'object'\n    // which we match.)\n    matchJSONValue(obj) {\n      return hasOwn(obj, '$InfNaN') && lengthOf(obj) === 1;\n    },\n    matchObject: isInfOrNaN,\n    toJSONValue(obj) {\n      let sign;\n      if (Number.isNaN(obj)) {\n        sign = 0;\n      } else if (obj === Infinity) {\n        sign = 1;\n      } else {\n        sign = -1;\n      }\n      return {$InfNaN: sign};\n    },\n    fromJSONValue(obj) {\n      return obj.$InfNaN / 0;\n    },\n  },\n  { // Binary\n    matchJSONValue(obj) {\n      return hasOwn(obj, '$binary') && lengthOf(obj) === 1;\n    },\n    matchObject(obj) {\n      return typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array\n        || (obj && hasOwn(obj, '$Uint8ArrayPolyfill'));\n    },\n    toJSONValue(obj) {\n      return {$binary: Base64.encode(obj)};\n    },\n    fromJSONValue(obj) {\n      return Base64.decode(obj.$binary);\n    },\n  },\n  { // Escaping one level\n    matchJSONValue(obj) {\n      return hasOwn(obj, '$escape') && lengthOf(obj) === 1;\n    },\n    matchObject(obj) {\n      let match = false;\n      if (obj) {\n        const keyCount = lengthOf(obj);\n        if (keyCount === 1 || keyCount === 2) {\n          match =\n            builtinConverters.some(converter => converter.matchJSONValue(obj));\n        }\n      }\n      return match;\n    },\n    toJSONValue(obj) {\n      const newObj = {};\n      keysOf(obj).forEach(key => {\n        newObj[key] = EJSON.toJSONValue(obj[key]);\n      });\n      return {$escape: newObj};\n    },\n    fromJSONValue(obj) {\n      const newObj = {};\n      keysOf(obj.$escape).forEach(key => {\n        newObj[key] = EJSON.fromJSONValue(obj.$escape[key]);\n      });\n      return newObj;\n    },\n  },\n  { // Custom\n    matchJSONValue(obj) {\n      return hasOwn(obj, '$type')\n        && hasOwn(obj, '$value') && lengthOf(obj) === 2;\n    },\n    matchObject(obj) {\n      return EJSON._isCustomType(obj);\n    },\n    toJSONValue(obj) {\n      const jsonValue = Meteor._noYieldsAllowed(() => obj.toJSONValue());\n      return {$type: obj.typeName(), $value: jsonValue};\n    },\n    fromJSONValue(obj) {\n      const typeName = obj.$type;\n      if (!customTypes.has(typeName)) {\n        throw new Error(`Custom EJSON type ${typeName} is not defined`);\n      }\n      const converter = customTypes.get(typeName);\n      return Meteor._noYieldsAllowed(() => converter(obj.$value));\n    },\n  },\n];\n\nEJSON._isCustomType = (obj) => (\n  obj &&\n  isFunction(obj.toJSONValue) &&\n  isFunction(obj.typeName) &&\n  customTypes.has(obj.typeName())\n);\n\nEJSON._getTypes = (isOriginal = false) => (isOriginal ? customTypes : convertMapToObject(customTypes));\n\nEJSON._getConverters = () => builtinConverters;\n\n// Either return the JSON-compatible version of the argument, or undefined (if\n// the item isn't itself replaceable, but maybe some fields in it are)\nconst toJSONValueHelper = item => {\n  for (let i = 0; i < builtinConverters.length; i++) {\n    const converter = builtinConverters[i];\n    if (converter.matchObject(item)) {\n      return converter.toJSONValue(item);\n    }\n  }\n  return undefined;\n};\n\n// for both arrays and objects, in-place modification.\nconst adjustTypesToJSONValue = obj => {\n  // Is it an atom that we need to adjust?\n  if (obj === null) {\n    return null;\n  }\n\n  const maybeChanged = toJSONValueHelper(obj);\n  if (maybeChanged !== undefined) {\n    return maybeChanged;\n  }\n\n  // Other atoms are unchanged.\n  if (!isObject(obj)) {\n    return obj;\n  }\n\n  // Iterate over array or object structure.\n  keysOf(obj).forEach(key => {\n    const value = obj[key];\n    if (!isObject(value) && value !== undefined &&\n        !isInfOrNaN(value)) {\n      return; // continue\n    }\n\n    const changed = toJSONValueHelper(value);\n    if (changed) {\n      obj[key] = changed;\n      return; // on to the next key\n    }\n    // if we get here, value is an object but not adjustable\n    // at this level.  recurse.\n    adjustTypesToJSONValue(value);\n  });\n  return obj;\n};\n\nEJSON._adjustTypesToJSONValue = adjustTypesToJSONValue;\n\n/**\n * @summary Serialize an EJSON-compatible value into its plain JSON\n *          representation.\n * @locus Anywhere\n * @param {EJSON} val A value to serialize to plain JSON.\n */\nEJSON.toJSONValue = item => {\n  const changed = toJSONValueHelper(item);\n  if (changed !== undefined) {\n    return changed;\n  }\n\n  let newItem = item;\n  if (isObject(item)) {\n    newItem = EJSON.clone(item);\n    adjustTypesToJSONValue(newItem);\n  }\n  return newItem;\n};\n\n// Either return the argument changed to have the non-json\n// rep of itself (the Object version) or the argument itself.\n// DOES NOT RECURSE.  For actually getting the fully-changed value, use\n// EJSON.fromJSONValue\nconst fromJSONValueHelper = value => {\n  if (isObject(value) && value !== null) {\n    const keys = keysOf(value);\n    if (keys.length <= 2\n        && keys.every(k => typeof k === 'string' && k.substr(0, 1) === '$')) {\n      for (let i = 0; i < builtinConverters.length; i++) {\n        const converter = builtinConverters[i];\n        if (converter.matchJSONValue(value)) {\n          return converter.fromJSONValue(value);\n        }\n      }\n    }\n  }\n  return value;\n};\n\n// for both arrays and objects. Tries its best to just\n// use the object you hand it, but may return something\n// different if the object you hand it itself needs changing.\nconst adjustTypesFromJSONValue = obj => {\n  if (obj === null) {\n    return null;\n  }\n\n  const maybeChanged = fromJSONValueHelper(obj);\n  if (maybeChanged !== obj) {\n    return maybeChanged;\n  }\n\n  // Other atoms are unchanged.\n  if (!isObject(obj)) {\n    return obj;\n  }\n\n  keysOf(obj).forEach(key => {\n    const value = obj[key];\n    if (isObject(value)) {\n      const changed = fromJSONValueHelper(value);\n      if (value !== changed) {\n        obj[key] = changed;\n        return;\n      }\n      // if we get here, value is an object but not adjustable\n      // at this level.  recurse.\n      adjustTypesFromJSONValue(value);\n    }\n  });\n  return obj;\n};\n\nEJSON._adjustTypesFromJSONValue = adjustTypesFromJSONValue;\n\n/**\n * @summary Deserialize an EJSON value from its plain JSON representation.\n * @locus Anywhere\n * @param {JSONCompatible} val A value to deserialize into EJSON.\n */\nEJSON.fromJSONValue = item => {\n  let changed = fromJSONValueHelper(item);\n  if (changed === item && isObject(item)) {\n    changed = EJSON.clone(item);\n    adjustTypesFromJSONValue(changed);\n  }\n  return changed;\n};\n\n/**\n * @summary Serialize a value to a string. For EJSON values, the serialization\n *          fully represents the value. For non-EJSON values, serializes the\n *          same way as `JSON.stringify`.\n * @locus Anywhere\n * @param {EJSON} val A value to stringify.\n * @param {Object} [options]\n * @param {Boolean | Integer | String} options.indent Indents objects and\n * arrays for easy readability.  When `true`, indents by 2 spaces; when an\n * integer, indents by that number of spaces; and when a string, uses the\n * string as the indentation pattern.\n * @param {Boolean} options.canonical When `true`, stringifies keys in an\n *                                    object in sorted order.\n */\nEJSON.stringify = handleError((item, options) => {\n  let serialized;\n  const json = EJSON.toJSONValue(item);\n  if (options && (options.canonical || options.indent)) {\n    import canonicalStringify from './stringify';\n    serialized = canonicalStringify(json, options);\n  } else {\n    serialized = JSON.stringify(json);\n  }\n  return serialized;\n});\n\n/**\n * @summary Parse a string into an EJSON value. Throws an error if the string\n *          is not valid EJSON.\n * @locus Anywhere\n * @param {String} str A string to parse into an EJSON value.\n */\nEJSON.parse = item => {\n  if (typeof item !== 'string') {\n    throw new Error('EJSON.parse argument should be a string');\n  }\n  return EJSON.fromJSONValue(JSON.parse(item));\n};\n\n/**\n * @summary Returns true if `x` is a buffer of binary data, as returned from\n *          [`EJSON.newBinary`](#ejson_new_binary).\n * @param {Object} x The variable to check.\n * @locus Anywhere\n */\nEJSON.isBinary = obj => {\n  return !!((typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array) ||\n    (obj && obj.$Uint8ArrayPolyfill));\n};\n\n/**\n * @summary Return true if `a` and `b` are equal to each other.  Return false\n *          otherwise.  Uses the `equals` method on `a` if present, otherwise\n *          performs a deep comparison.\n * @locus Anywhere\n * @param {EJSON} a\n * @param {EJSON} b\n * @param {Object} [options]\n * @param {Boolean} options.keyOrderSensitive Compare in key sensitive order,\n * if supported by the JavaScript implementation.  For example, `{a: 1, b: 2}`\n * is equal to `{b: 2, a: 1}` only when `keyOrderSensitive` is `false`.  The\n * default is `false`.\n */\nEJSON.equals = (a, b, options) => {\n  let i;\n  const keyOrderSensitive = !!(options && options.keyOrderSensitive);\n  if (a === b) {\n    return true;\n  }\n\n  // This differs from the IEEE spec for NaN equality, b/c we don't want\n  // anything ever with a NaN to be poisoned from becoming equal to anything.\n  if (Number.isNaN(a) && Number.isNaN(b)) {\n    return true;\n  }\n\n  // if either one is falsy, they'd have to be === to be equal\n  if (!a || !b) {\n    return false;\n  }\n\n  if (!(isObject(a) && isObject(b))) {\n    return false;\n  }\n\n  if (a instanceof Date && b instanceof Date) {\n    return a.valueOf() === b.valueOf();\n  }\n\n  if (EJSON.isBinary(a) && EJSON.isBinary(b)) {\n    if (a.length !== b.length) {\n      return false;\n    }\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  if (isFunction(a.equals)) {\n    return a.equals(b, options);\n  }\n\n  if (isFunction(b.equals)) {\n    return b.equals(a, options);\n  }\n\n  if (a instanceof Array) {\n    if (!(b instanceof Array)) {\n      return false;\n    }\n    if (a.length !== b.length) {\n      return false;\n    }\n    for (i = 0; i < a.length; i++) {\n      if (!EJSON.equals(a[i], b[i], options)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // fallback for custom types that don't implement their own equals\n  switch (EJSON._isCustomType(a) + EJSON._isCustomType(b)) {\n    case 1: return false;\n    case 2: return EJSON.equals(EJSON.toJSONValue(a), EJSON.toJSONValue(b));\n    default: // Do nothing\n  }\n\n  // fall back to structural equality of objects\n  let ret;\n  const aKeys = keysOf(a);\n  const bKeys = keysOf(b);\n  if (keyOrderSensitive) {\n    i = 0;\n    ret = aKeys.every(key => {\n      if (i >= bKeys.length) {\n        return false;\n      }\n      if (key !== bKeys[i]) {\n        return false;\n      }\n      if (!EJSON.equals(a[key], b[bKeys[i]], options)) {\n        return false;\n      }\n      i++;\n      return true;\n    });\n  } else {\n    i = 0;\n    ret = aKeys.every(key => {\n      if (!hasOwn(b, key)) {\n        return false;\n      }\n      if (!EJSON.equals(a[key], b[key], options)) {\n        return false;\n      }\n      i++;\n      return true;\n    });\n  }\n  return ret && i === bKeys.length;\n};\n\n/**\n * @summary Return a deep copy of `val`.\n * @locus Anywhere\n * @param {EJSON} val A value to copy.\n */\nEJSON.clone = v => {\n  let ret;\n  if (!isObject(v)) {\n    return v;\n  }\n\n  if (v === null) {\n    return null; // null has typeof \"object\"\n  }\n\n  if (v instanceof Date) {\n    return new Date(v.getTime());\n  }\n\n  // RegExps are not really EJSON elements (eg we don't define a serialization\n  // for them), but they're immutable anyway, so we can support them in clone.\n  if (v instanceof RegExp) {\n    return v;\n  }\n\n  if (EJSON.isBinary(v)) {\n    ret = EJSON.newBinary(v.length);\n    for (let i = 0; i < v.length; i++) {\n      ret[i] = v[i];\n    }\n    return ret;\n  }\n\n  if (Array.isArray(v)) {\n    return v.map(EJSON.clone);\n  }\n\n  if (isArguments(v)) {\n    return Array.from(v).map(EJSON.clone);\n  }\n\n  // handle general user-defined typed Objects if they have a clone method\n  if (isFunction(v.clone)) {\n    return v.clone();\n  }\n\n  // handle other custom types\n  if (EJSON._isCustomType(v)) {\n    return EJSON.fromJSONValue(EJSON.clone(EJSON.toJSONValue(v)), true);\n  }\n\n  // handle other objects\n  ret = {};\n  keysOf(v).forEach((key) => {\n    ret[key] = EJSON.clone(v[key]);\n  });\n  return ret;\n};\n\n/**\n * @summary Allocate a new buffer of binary data that EJSON can serialize.\n * @locus Anywhere\n * @param {Number} size The number of bytes of binary data to allocate.\n */\n// EJSON.newBinary is the public documented API for this functionality,\n// but the implementation is in the 'base64' package to avoid\n// introducing a circular dependency. (If the implementation were here,\n// then 'base64' would have to use EJSON.newBinary, and 'ejson' would\n// also have to use 'base64'.)\nEJSON.newBinary = Base64.newBinary;\n\nexport { EJSON };\n","// Based on json2.js from https://github.com/douglascrockford/JSON-js\n//\n//    json2.js\n//    2012-10-08\n//\n//    Public Domain.\n//\n//    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n\nfunction quote(string) {\n  return JSON.stringify(string);\n}\n\nconst str = (key, holder, singleIndent, outerIndent, canonical) => {\n  const value = holder[key];\n\n  // What happens next depends on the value's type.\n  switch (typeof value) {\n  case 'string':\n    return quote(value);\n  case 'number':\n    // JSON numbers must be finite. Encode non-finite numbers as null.\n    return isFinite(value) ? String(value) : 'null';\n  case 'boolean':\n    return String(value);\n  // If the type is 'object', we might be dealing with an object or an array or\n  // null.\n  case 'object': {\n    // Due to a specification blunder in ECMAScript, typeof null is 'object',\n    // so watch out for that case.\n    if (!value) {\n      return 'null';\n    }\n    // Make an array to hold the partial results of stringifying this object\n    // value.\n    const innerIndent = outerIndent + singleIndent;\n    const partial = [];\n    let v;\n\n    // Is the value an array?\n    if (Array.isArray(value) || ({}).hasOwnProperty.call(value, 'callee')) {\n      // The value is an array. Stringify every element. Use null as a\n      // placeholder for non-JSON values.\n      const length = value.length;\n      for (let i = 0; i < length; i += 1) {\n        partial[i] =\n          str(i, value, singleIndent, innerIndent, canonical) || 'null';\n      }\n\n      // Join all of the elements together, separated with commas, and wrap\n      // them in brackets.\n      if (partial.length === 0) {\n        v = '[]';\n      } else if (innerIndent) {\n        v = '[\\n' +\n          innerIndent +\n          partial.join(',\\n' +\n          innerIndent) +\n          '\\n' +\n          outerIndent +\n          ']';\n      } else {\n        v = '[' + partial.join(',') + ']';\n      }\n      return v;\n    }\n\n    // Iterate through all of the keys in the object.\n    let keys = Object.keys(value);\n    if (canonical) {\n      keys = keys.sort();\n    }\n    keys.forEach(k => {\n      v = str(k, value, singleIndent, innerIndent, canonical);\n      if (v) {\n        partial.push(quote(k) + (innerIndent ? ': ' : ':') + v);\n      }\n    });\n\n    // Join all of the member texts together, separated with commas,\n    // and wrap them in braces.\n    if (partial.length === 0) {\n      v = '{}';\n    } else if (innerIndent) {\n      v = '{\\n' +\n        innerIndent +\n        partial.join(',\\n' +\n        innerIndent) +\n        '\\n' +\n        outerIndent +\n        '}';\n    } else {\n      v = '{' + partial.join(',') + '}';\n    }\n    return v;\n  }\n\n  default: // Do nothing\n  }\n};\n\n// If the JSON object does not yet have a stringify method, give it one.\nconst canonicalStringify = (value, options) => {\n  // Make a fake root object containing our value under the key of ''.\n  // Return the result of stringifying the value.\n  const allOptions = Object.assign({\n    indent: '',\n    canonical: false,\n  }, options);\n  if (allOptions.indent === true) {\n    allOptions.indent = '  ';\n  } else if (typeof allOptions.indent === 'number') {\n    let newIndent = '';\n    for (let i = 0; i < allOptions.indent; i++) {\n      newIndent += ' ';\n    }\n    allOptions.indent = newIndent;\n  }\n  return str('', {'': value}, allOptions.indent, '', allOptions.canonical);\n};\n\nexport default canonicalStringify;\n","export const isFunction = (fn) => typeof fn === 'function';\n\nexport const isObject = (fn) => typeof fn === 'object';\n\nexport const keysOf = (obj) => Object.keys(obj);\n\nexport const lengthOf = (obj) => Object.keys(obj).length;\n\nexport const hasOwn = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n\nexport const convertMapToObject = (map) => Array.from(map).reduce((acc, [key, value]) => {\n  // reassign to not create new object\n  acc[key] = value;\n  return acc;\n}, {});\n\nexport const isArguments = obj => obj != null && hasOwn(obj, 'callee');\n\nexport const isInfOrNaN =\n  obj => Number.isNaN(obj) || obj === Infinity || obj === -Infinity;\n\nexport const checkError = {\n  maxStack: (msgError) => new RegExp('Maximum call stack size exceeded', 'g').test(msgError),\n};\n\nexport const handleError = (fn) => function() {\n  try {\n    return fn.apply(this, arguments);\n  } catch (error) {\n    const isMaxStack = checkError.maxStack(error.message);\n    if (isMaxStack) {\n      throw new Error('Converting circular structure to JSON')\n    }\n    throw error;\n  }\n};\n"]}}]