[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar ObserveSequence = Package['observe-sequence'].ObserveSequence;\nvar Tracker = Package.tracker.Tracker;\nvar Deps = Package.tracker.Deps;\nvar HTML = Package.htmljs.HTML;\nvar Blaze = Package.blaze.Blaze;\nvar UI = Package.blaze.UI;\nvar Handlebars = Package.blaze.Handlebars;\n\n/* Package-scope variables */\nvar Spacebars;\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////\n//                                                                               //\n// packages/spacebars/spacebars-runtime.js                                       //\n//                                                                               //\n///////////////////////////////////////////////////////////////////////////////////\n                                                                                 //\nSpacebars = {};\n\nvar tripleEquals = function (a, b) { return a === b; };\n\nSpacebars.include = function (templateOrFunction, contentFunc, elseFunc) {\n  if (! templateOrFunction)\n    return null;\n\n  if (typeof templateOrFunction !== 'function') {\n    var template = templateOrFunction;\n    if (! Blaze.isTemplate(template))\n      throw new Error(\"Expected template or null, found: \" + template);\n    var view = templateOrFunction.constructView(contentFunc, elseFunc);\n    view.__startsNewLexicalScope = true;\n    return view;\n  }\n\n  var templateVar = Blaze.ReactiveVar(null, tripleEquals);\n  var view = Blaze.View('Spacebars.include', function () {\n    var template = templateVar.get();\n    if (template === null)\n      return null;\n\n    if (! Blaze.isTemplate(template))\n      throw new Error(\"Expected template or null, found: \" + template);\n\n    return template.constructView(contentFunc, elseFunc);\n  });\n  view.__templateVar = templateVar;\n  view.onViewCreated(function () {\n    this.autorun(function () {\n      templateVar.set(templateOrFunction());\n    });\n  });\n  view.__startsNewLexicalScope = true;\n\n  return view;\n};\n\n// Executes `{{foo bar baz}}` when called on `(foo, bar, baz)`.\n// If `bar` and `baz` are functions, they are called before\n// `foo` is called on them.\n//\n// This is the shared part of Spacebars.mustache and\n// Spacebars.attrMustache, which differ in how they post-process the\n// result.\nSpacebars.mustacheImpl = function (value/*, args*/) {\n  var args = arguments;\n  // if we have any arguments (pos or kw), add an options argument\n  // if there isn't one.\n  if (args.length > 1) {\n    var kw = args[args.length - 1];\n    if (! (kw instanceof Spacebars.kw)) {\n      kw = Spacebars.kw();\n      // clone arguments into an actual array, then push\n      // the empty kw object.\n      args = Array.prototype.slice.call(arguments);\n      args.push(kw);\n    } else {\n      // For each keyword arg, call it if it's a function\n      var newHash = {};\n      for (var k in kw.hash) {\n        var v = kw.hash[k];\n        newHash[k] = (typeof v === 'function' ? v() : v);\n      }\n      args[args.length - 1] = Spacebars.kw(newHash);\n    }\n  }\n\n  return Spacebars.call.apply(null, args);\n};\n\nSpacebars.mustache = function (value/*, args*/) {\n  var result = Spacebars.mustacheImpl.apply(null, arguments);\n\n  if (result instanceof Spacebars.SafeString)\n    return HTML.Raw(result.toString());\n  else\n    // map `null`, `undefined`, and `false` to null, which is important\n    // so that attributes with nully values are considered absent.\n    // stringify anything else (e.g. strings, booleans, numbers including 0).\n    return (result == null || result === false) ? null : String(result);\n};\n\nSpacebars.attrMustache = function (value/*, args*/) {\n  var result = Spacebars.mustacheImpl.apply(null, arguments);\n\n  if (result == null || result === '') {\n    return null;\n  } else if (typeof result === 'object') {\n    return result;\n  } else if (typeof result === 'string' && HTML.isValidAttributeName(result)) {\n    var obj = {};\n    obj[result] = '';\n    return obj;\n  } else {\n    throw new Error(\"Expected valid attribute name, '', null, or object\");\n  }\n};\n\nSpacebars.dataMustache = function (value/*, args*/) {\n  var result = Spacebars.mustacheImpl.apply(null, arguments);\n\n  return result;\n};\n\n// Idempotently wrap in `HTML.Raw`.\n//\n// Called on the return value from `Spacebars.mustache` in case the\n// template uses triple-stache (`{{{foo bar baz}}}`).\nSpacebars.makeRaw = function (value) {\n  if (value == null) // null or undefined\n    return null;\n  else if (value instanceof HTML.Raw)\n    return value;\n  else\n    return HTML.Raw(value);\n};\n\n// If `value` is a function, evaluate its `args` (by calling them, if they\n// are functions), and then call it on them. Otherwise, return `value`.\n//\n// If `value` is not a function and is not null, then this method will assert\n// that there are no args. We check for null before asserting because a user\n// may write a template like {{user.fullNameWithPrefix 'Mr.'}}, where the\n// function will be null until data is ready.\nSpacebars.call = function (value/*, args*/) {\n  if (typeof value === 'function') {\n    // Evaluate arguments by calling them if they are functions.\n    var newArgs = [];\n    for (var i = 1; i < arguments.length; i++) {\n      var arg = arguments[i];\n      newArgs[i-1] = (typeof arg === 'function' ? arg() : arg);\n    }\n\n    return value.apply(null, newArgs);\n  } else {\n    if (value != null && arguments.length > 1) {\n      throw new Error(\"Can't call non-function: \" + value);\n    }\n    return value;\n  }\n};\n\n// Call this as `Spacebars.kw({ ... })`.  The return value\n// is `instanceof Spacebars.kw`.\nSpacebars.kw = function (hash) {\n  if (! (this instanceof Spacebars.kw))\n    // called without new; call with new\n    return new Spacebars.kw(hash);\n\n  this.hash = hash || {};\n};\n\n// Call this as `Spacebars.SafeString(\"some HTML\")`.  The return value\n// is `instanceof Spacebars.SafeString` (and `instanceof Handlebars.SafeString).\nSpacebars.SafeString = function (html) {\n  if (! (this instanceof Spacebars.SafeString))\n    // called without new; call with new\n    return new Spacebars.SafeString(html);\n\n  return new Handlebars.SafeString(html);\n};\nSpacebars.SafeString.prototype = Handlebars.SafeString.prototype;\n\n// `Spacebars.dot(foo, \"bar\", \"baz\")` performs a special kind\n// of `foo.bar.baz` that allows safe indexing of `null` and\n// indexing of functions (which calls the function).  If the\n// result is a function, it is always a bound function (e.g.\n// a wrapped version of `baz` that always uses `foo.bar` as\n// `this`).\n//\n// In `Spacebars.dot(foo, \"bar\")`, `foo` is assumed to be either\n// a non-function value or a \"fully-bound\" function wrapping a value,\n// where fully-bound means it takes no arguments and ignores `this`.\n//\n// `Spacebars.dot(foo, \"bar\")` performs the following steps:\n//\n// * If `foo` is falsy, return `foo`.\n//\n// * If `foo` is a function, call it (set `foo` to `foo()`).\n//\n// * If `foo` is falsy now, return `foo`.\n//\n// * Return `foo.bar`, binding it to `foo` if it's a function.\nSpacebars.dot = function (value, id1/*, id2, ...*/) {\n  if (arguments.length > 2) {\n    // Note: doing this recursively is probably less efficient than\n    // doing it in an iterative loop.\n    var argsForRecurse = [];\n    argsForRecurse.push(Spacebars.dot(value, id1));\n    argsForRecurse.push.apply(argsForRecurse,\n                              Array.prototype.slice.call(arguments, 2));\n    return Spacebars.dot.apply(null, argsForRecurse);\n  }\n\n  if (typeof value === 'function')\n    value = value();\n\n  if (! value)\n    return value; // falsy, don't index, pass through\n\n  var result = value[id1];\n  if (typeof result !== 'function')\n    return result;\n  // `value[id1]` (or `value()[id1]`) is a function.\n  // Bind it so that when called, `value` will be placed in `this`.\n  return function (/*arguments*/) {\n    return result.apply(value, arguments);\n  };\n};\n\n// Spacebars.With implements the conditional logic of rendering\n// the `{{else}}` block if the argument is falsy.  It combines\n// a Blaze.If with a Blaze.With (the latter only in the truthy\n// case, since the else block is evaluated without entering\n// a new data context).\nSpacebars.With = function (argFunc, contentFunc, elseFunc) {\n  var argVar = new Blaze.ReactiveVar;\n  var view = Blaze.View('Spacebars_with', function () {\n    return Blaze.If(function () { return argVar.get(); },\n                    function () { return Blaze.With(function () {\n                      return argVar.get(); }, contentFunc); },\n                    elseFunc);\n  });\n  view.onViewCreated(function () {\n    this.autorun(function () {\n      argVar.set(argFunc());\n\n      // This is a hack so that autoruns inside the body\n      // of the #with get stopped sooner.  It reaches inside\n      // our ReactiveVar to access its dep.\n\n      Tracker.onInvalidate(function () {\n        argVar.dep.changed();\n      });\n\n      // Take the case of `{{#with A}}{{B}}{{/with}}`.  The goal\n      // is to not re-render `B` if `A` changes to become falsy\n      // and `B` is simultaneously invalidated.\n      //\n      // A series of autoruns are involved:\n      //\n      // 1. This autorun (argument to Spacebars.With)\n      // 2. Argument to Blaze.If\n      // 3. Blaze.If view re-render\n      // 4. Argument to Blaze.With\n      // 5. The template tag `{{B}}`\n      //\n      // When (3) is invalidated, it immediately stops (4) and (5)\n      // because of a Tracker.onInvalidate built into materializeView.\n      // (When a View's render method is invalidated, it immediately\n      // tears down all the subviews, via a Tracker.onInvalidate much\n      // like this one.\n      //\n      // Suppose `A` changes to become falsy, and `B` changes at the\n      // same time (i.e. without an intervening flush).\n      // Without the code above, this happens:\n      //\n      // - (1) and (5) are invalidated.\n      // - (1) runs, invalidating (2) and (4).\n      // - (5) runs.\n      // - (2) runs, invalidating (3), stopping (4) and (5).\n      //\n      // With the code above:\n      //\n      // - (1) and (5) are invalidated, invalidating (2) and (4).\n      // - (1) runs.\n      // - (2) runs, invalidating (3), stopping (4) and (5).\n      //\n      // If the re-run of (5) is originally enqueued before (1), all\n      // bets are off, but typically that doesn't seem to be the\n      // case.  Anyway, doing this is always better than not doing it,\n      // because it might save a bunch of DOM from being updated\n      // needlessly.\n    });\n  });\n\n  return view;\n};\n\n// XXX COMPAT WITH 0.9.0\nSpacebars.TemplateWith = Blaze._TemplateWith;\n\n///////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nPackage._define(\"spacebars\", {\n  Spacebars: Spacebars\n});\n\n})();\n","servePath":"/packages/spacebars.js"}]