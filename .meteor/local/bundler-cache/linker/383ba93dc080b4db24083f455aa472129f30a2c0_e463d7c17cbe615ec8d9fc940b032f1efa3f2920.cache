[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar Tracker = Package.tracker.Tracker;\nvar Deps = Package.tracker.Deps;\n\n/* Package-scope variables */\nvar ReactiveVar;\n\n(function(){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                              //\n// packages/reactive-var/reactive-var.js                                                                        //\n//                                                                                                              //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                //\n/*\n * ## [new] ReactiveVar(initialValue, [equalsFunc])\n *\n * A ReactiveVar holds a single value that can be get and set,\n * such that calling `set` will invalidate any Computations that\n * called `get`, according to the usual contract for reactive\n * data sources.\n *\n * A ReactiveVar is much like a Session variable -- compare `foo.get()`\n * to `Session.get(\"foo\")` -- but it doesn't have a global name and isn't\n * automatically migrated across hot code pushes.  Also, while Session\n * variables can only hold JSON or EJSON, ReactiveVars can hold any value.\n *\n * An important property of ReactiveVars, which is sometimes the reason\n * to use one, is that setting the value to the same value as before has\n * no effect, meaning ReactiveVars can be used to absorb extra\n * invalidations that wouldn't serve a purpose.  However, by default,\n * ReactiveVars are extremely conservative about what changes they\n * absorb.  Calling `set` with an object argument will *always* trigger\n * invalidations, because even if the new value is `===` the old value,\n * the object may have been mutated.  You can change the default behavior\n * by passing a function of two arguments, `oldValue` and `newValue`,\n * to the constructor as `equalsFunc`.\n *\n * This class is extremely basic right now, but the idea is to evolve\n * it into the ReactiveVar of Geoff's Lickable Forms proposal.\n */\n\n/**\n * @class \n * @instanceName reactiveVar\n * @summary Constructor for a ReactiveVar, which represents a single reactive variable.\n * @locus Client\n * @param {Any} initialValue The initial value to set.  `equalsFunc` is ignored when setting the initial value.\n * @param {Function} [equalsFunc] Optional.  A function of two arguments, called on the old value and the new value whenever the ReactiveVar is set.  If it returns true, no set is performed.  If omitted, the default `equalsFunc` returns true if its arguments are `===` and are of type number, boolean, string, undefined, or null.\n */\nReactiveVar = function (initialValue, equalsFunc) {\n  if (! (this instanceof ReactiveVar))\n    // called without `new`\n    return new ReactiveVar(initialValue, equalsFunc);\n\n  this.curValue = initialValue;\n  this.equalsFunc = equalsFunc;\n  this.dep = new Tracker.Dependency;\n};\n\nReactiveVar._isEqual = function (oldValue, newValue) {\n  var a = oldValue, b = newValue;\n  // Two values are \"equal\" here if they are `===` and are\n  // number, boolean, string, undefined, or null.\n  if (a !== b)\n    return false;\n  else\n    return ((!a) || (typeof a === 'number') || (typeof a === 'boolean') ||\n            (typeof a === 'string'));\n};\n\n/**\n * @summary Returns the current value of the ReactiveVar, establishing a reactive dependency.\n * @locus Client\n */\nReactiveVar.prototype.get = function () {\n  if (Tracker.active)\n    this.dep.depend();\n\n  return this.curValue;\n};\n\n/**\n * @summary Sets the current value of the ReactiveVar, invalidating the Computations that called `get` if `newValue` is different from the old value.\n * @locus Client\n * @param {Any} newValue\n */\nReactiveVar.prototype.set = function (newValue) {\n  var oldValue = this.curValue;\n\n  if ((this.equalsFunc || ReactiveVar._isEqual)(oldValue, newValue))\n    // value is same as last time\n    return;\n\n  this.curValue = newValue;\n  this.dep.changed();\n};\n\nReactiveVar.prototype.toString = function () {\n  return 'ReactiveVar{' + this.get() + '}';\n};\n\nReactiveVar.prototype._numListeners = function() {\n  // Tests want to know.\n  // Accesses a private field of Tracker.Dependency.\n  var count = 0;\n  for (var id in this.dep._dependentsById)\n    count++;\n  return count;\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nPackage._define(\"reactive-var\", {\n  ReactiveVar: ReactiveVar\n});\n\n})();\n","servePath":"/packages/reactive-var.js"}]