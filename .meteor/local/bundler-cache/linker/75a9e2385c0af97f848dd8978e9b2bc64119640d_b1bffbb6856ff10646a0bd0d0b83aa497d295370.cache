[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar WebApp = Package.webapp.WebApp;\nvar WebAppInternals = Package.webapp.WebAppInternals;\nvar main = Package.webapp.main;\nvar Accounts = Package['accounts-base'].Accounts;\nvar ECMAScript = Package.ecmascript.ECMAScript;\nvar OAuth = Package.oauth.OAuth;\nvar meteorInstall = Package.modules.meteorInstall;\nvar Promise = Package.promise.Promise;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"accounts-oauth\":{\"oauth_common.js\":function module(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                 //\n// packages/accounts-oauth/oauth_common.js                                                                         //\n//                                                                                                                 //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                   //\nAccounts.oauth = {};\nconst services = {};\nconst hasOwn = Object.prototype.hasOwnProperty; // Helper for registering OAuth based accounts packages.\n// On the server, adds an index to the user collection.\n\nAccounts.oauth.registerService = name => {\n  if (hasOwn.call(services, name)) throw new Error(\"Duplicate service: \".concat(name));\n  services[name] = true;\n\n  if (Meteor.server) {\n    // Accounts.updateOrCreateUserFromExternalService does a lookup by this id,\n    // so this should be a unique index. You might want to add indexes for other\n    // fields returned by your service (eg services.github.login) but you can do\n    // that in your app.\n    Meteor.users.createIndex(\"services.\".concat(name, \".id\"), {\n      unique: true,\n      sparse: true\n    });\n  }\n}; // Removes a previously registered service.\n// This will disable logging in with this service, and serviceNames() will not\n// contain it.\n// It's worth noting that already logged in users will remain logged in unless\n// you manually expire their sessions.\n\n\nAccounts.oauth.unregisterService = name => {\n  if (!hasOwn.call(services, name)) throw new Error(\"Service not found: \".concat(name));\n  delete services[name];\n};\n\nAccounts.oauth.serviceNames = () => Object.keys(services);\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"oauth_server.js\":function module(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                 //\n// packages/accounts-oauth/oauth_server.js                                                                         //\n//                                                                                                                 //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                   //\n// Listen to calls to `login` with an oauth option set. This is where\n// users actually get logged in to meteor via oauth.\nAccounts.registerLoginHandler(options => {\n  if (!options.oauth) return undefined; // don't handle\n\n  check(options.oauth, {\n    credentialToken: String,\n    // When an error occurs while retrieving the access token, we store\n    // the error in the pending credentials table, with a secret of\n    // null. The client can call the login method with a secret of null\n    // to retrieve the error.\n    credentialSecret: Match.OneOf(null, String)\n  });\n  const result = OAuth.retrieveCredential(options.oauth.credentialToken, options.oauth.credentialSecret);\n\n  if (!result) {\n    // OAuth credentialToken is not recognized, which could be either\n    // because the popup was closed by the user before completion, or\n    // some sort of error where the oauth provider didn't talk to our\n    // server correctly and closed the popup somehow.\n    //\n    // We assume it was user canceled and report it as such, using a\n    // numeric code that the client recognizes (XXX this will get\n    // replaced by a symbolic error code at some point\n    // https://trello.com/c/kMkw800Z/53-official-ddp-specification). This\n    // will mask failures where things are misconfigured such that the\n    // server doesn't see the request but does close the window. This\n    // seems unlikely.\n    //\n    // XXX we want `type` to be the service name such as \"facebook\"\n    return {\n      type: \"oauth\",\n      error: new Meteor.Error(Accounts.LoginCancelledError.numericError, \"No matching login attempt found\")\n    };\n  }\n\n  if (result instanceof Error) // We tried to login, but there was a fatal error. Report it back\n    // to the user.\n    throw result;else {\n    if (!Accounts.oauth.serviceNames().includes(result.serviceName)) {\n      // serviceName was not found in the registered services list.\n      // This could happen because the service never registered itself or\n      // unregisterService was called on it.\n      return {\n        type: \"oauth\",\n        error: new Meteor.Error(Accounts.LoginCancelledError.numericError, \"No registered oauth service found for: \".concat(result.serviceName))\n      };\n    }\n\n    return Accounts.updateOrCreateUserFromExternalService(result.serviceName, result.serviceData, result.options);\n  }\n});\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\n\nrequire(\"/node_modules/meteor/accounts-oauth/oauth_common.js\");\nrequire(\"/node_modules/meteor/accounts-oauth/oauth_server.js\");\n\n/* Exports */\nPackage._define(\"accounts-oauth\");\n\n})();\n","servePath":"/packages/accounts-oauth.js","sourceMap":{"version":3,"sources":["packages/accounts-oauth/oauth_common.js","packages/accounts-oauth/oauth_server.js"],"names":["Accounts","oauth","services","hasOwn","Object","prototype","hasOwnProperty","registerService","name","call","Error","Meteor","server","users","createIndex","unique","sparse","unregisterService","serviceNames","keys","registerLoginHandler","options","undefined","check","credentialToken","String","credentialSecret","Match","OneOf","result","OAuth","retrieveCredential","type","error","LoginCancelledError","numericError","includes","serviceName","updateOrCreateUserFromExternalService","serviceData"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAAA,QAAQ,CAACC,KAAT,GAAiB,EAAjB;AAEA,MAAMC,QAAQ,GAAG,EAAjB;AACA,MAAMC,MAAM,GAAGC,MAAM,CAACC,SAAP,CAAiBC,cAAhC,C,CAEA;AACA;;AACAN,QAAQ,CAACC,KAAT,CAAeM,eAAf,GAAiCC,IAAI,IAAI;AACvC,MAAIL,MAAM,CAACM,IAAP,CAAYP,QAAZ,EAAsBM,IAAtB,CAAJ,EACE,MAAM,IAAIE,KAAJ,8BAAgCF,IAAhC,EAAN;AACFN,UAAQ,CAACM,IAAD,CAAR,GAAiB,IAAjB;;AAEA,MAAIG,MAAM,CAACC,MAAX,EAAmB;AACjB;AACA;AACA;AACA;AACAD,UAAM,CAACE,KAAP,CAAaC,WAAb,oBAAqCN,IAArC,UAAgD;AAACO,YAAM,EAAE,IAAT;AAAeC,YAAM,EAAE;AAAvB,KAAhD;AACD;AACF,CAZD,C,CAcA;AACA;AACA;AACA;AACA;;;AACAhB,QAAQ,CAACC,KAAT,CAAegB,iBAAf,GAAmCT,IAAI,IAAI;AACzC,MAAI,CAACL,MAAM,CAACM,IAAP,CAAYP,QAAZ,EAAsBM,IAAtB,CAAL,EACE,MAAM,IAAIE,KAAJ,8BAAgCF,IAAhC,EAAN;AACF,SAAON,QAAQ,CAACM,IAAD,CAAf;AACD,CAJD;;AAMAR,QAAQ,CAACC,KAAT,CAAeiB,YAAf,GAA8B,MAAMd,MAAM,CAACe,IAAP,CAAYjB,QAAZ,CAApC,C;;;;;;;;;;;AChCA;AACA;AACAF,QAAQ,CAACoB,oBAAT,CAA8BC,OAAO,IAAI;AACvC,MAAI,CAACA,OAAO,CAACpB,KAAb,EACE,OAAOqB,SAAP,CAFqC,CAEnB;;AAEpBC,OAAK,CAACF,OAAO,CAACpB,KAAT,EAAgB;AACnBuB,mBAAe,EAAEC,MADE;AAEnB;AACA;AACA;AACA;AACAC,oBAAgB,EAAEC,KAAK,CAACC,KAAN,CAAY,IAAZ,EAAkBH,MAAlB;AANC,GAAhB,CAAL;AASA,QAAMI,MAAM,GAAGC,KAAK,CAACC,kBAAN,CAAyBV,OAAO,CAACpB,KAAR,CAAcuB,eAAvC,EACuBH,OAAO,CAACpB,KAAR,CAAcyB,gBADrC,CAAf;;AAGA,MAAI,CAACG,MAAL,EAAa;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAO;AAAEG,UAAI,EAAE,OAAR;AACEC,WAAK,EAAE,IAAItB,MAAM,CAACD,KAAX,CACLV,QAAQ,CAACkC,mBAAT,CAA6BC,YADxB,EAEL,iCAFK;AADT,KAAP;AAID;;AAED,MAAIN,MAAM,YAAYnB,KAAtB,EACE;AACA;AACA,UAAMmB,MAAN,CAHF,KAIK;AACH,QAAI,CAAE7B,QAAQ,CAACC,KAAT,CAAeiB,YAAf,GAA8BkB,QAA9B,CAAuCP,MAAM,CAACQ,WAA9C,CAAN,EAAkE;AAChE;AACA;AACA;AACA,aAAO;AAAEL,YAAI,EAAE,OAAR;AACEC,aAAK,EAAE,IAAItB,MAAM,CAACD,KAAX,CACLV,QAAQ,CAACkC,mBAAT,CAA6BC,YADxB,mDAEqCN,MAAM,CAACQ,WAF5C;AADT,OAAP;AAKD;;AACD,WAAOrC,QAAQ,CAACsC,qCAAT,CAA+CT,MAAM,CAACQ,WAAtD,EAAmER,MAAM,CAACU,WAA1E,EAAuFV,MAAM,CAACR,OAA9F,CAAP;AACD;AACF,CAtDD,E","file":"/packages/accounts-oauth.js","sourcesContent":["Accounts.oauth = {};\n\nconst services = {};\nconst hasOwn = Object.prototype.hasOwnProperty;\n\n// Helper for registering OAuth based accounts packages.\n// On the server, adds an index to the user collection.\nAccounts.oauth.registerService = name => {\n  if (hasOwn.call(services, name))\n    throw new Error(`Duplicate service: ${name}`);\n  services[name] = true;\n\n  if (Meteor.server) {\n    // Accounts.updateOrCreateUserFromExternalService does a lookup by this id,\n    // so this should be a unique index. You might want to add indexes for other\n    // fields returned by your service (eg services.github.login) but you can do\n    // that in your app.\n    Meteor.users.createIndex(`services.${name}.id`, {unique: true, sparse: true});\n  }\n};\n\n// Removes a previously registered service.\n// This will disable logging in with this service, and serviceNames() will not\n// contain it.\n// It's worth noting that already logged in users will remain logged in unless\n// you manually expire their sessions.\nAccounts.oauth.unregisterService = name => {\n  if (!hasOwn.call(services, name))\n    throw new Error(`Service not found: ${name}`);\n  delete services[name];\n};\n\nAccounts.oauth.serviceNames = () => Object.keys(services);\n","// Listen to calls to `login` with an oauth option set. This is where\n// users actually get logged in to meteor via oauth.\nAccounts.registerLoginHandler(options => {\n  if (!options.oauth)\n    return undefined; // don't handle\n\n  check(options.oauth, {\n    credentialToken: String,\n    // When an error occurs while retrieving the access token, we store\n    // the error in the pending credentials table, with a secret of\n    // null. The client can call the login method with a secret of null\n    // to retrieve the error.\n    credentialSecret: Match.OneOf(null, String)\n  });\n\n  const result = OAuth.retrieveCredential(options.oauth.credentialToken,\n                                        options.oauth.credentialSecret);\n\n  if (!result) {\n    // OAuth credentialToken is not recognized, which could be either\n    // because the popup was closed by the user before completion, or\n    // some sort of error where the oauth provider didn't talk to our\n    // server correctly and closed the popup somehow.\n    //\n    // We assume it was user canceled and report it as such, using a\n    // numeric code that the client recognizes (XXX this will get\n    // replaced by a symbolic error code at some point\n    // https://trello.com/c/kMkw800Z/53-official-ddp-specification). This\n    // will mask failures where things are misconfigured such that the\n    // server doesn't see the request but does close the window. This\n    // seems unlikely.\n    //\n    // XXX we want `type` to be the service name such as \"facebook\"\n    return { type: \"oauth\",\n             error: new Meteor.Error(\n               Accounts.LoginCancelledError.numericError,\n               \"No matching login attempt found\") };\n  }\n\n  if (result instanceof Error)\n    // We tried to login, but there was a fatal error. Report it back\n    // to the user.\n    throw result;\n  else {\n    if (! Accounts.oauth.serviceNames().includes(result.serviceName)) {\n      // serviceName was not found in the registered services list.\n      // This could happen because the service never registered itself or\n      // unregisterService was called on it.\n      return { type: \"oauth\",\n               error: new Meteor.Error(\n                 Accounts.LoginCancelledError.numericError,\n                 `No registered oauth service found for: ${result.serviceName}`) };\n\n    }\n    return Accounts.updateOrCreateUserFromExternalService(result.serviceName, result.serviceData, result.options);\n  }\n});\n"]}}]