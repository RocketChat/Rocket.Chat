[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar _ = Package.underscore._;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar MongoInternals = Package.mongo.MongoInternals;\nvar Mongo = Package.mongo.Mongo;\nvar Log = Package.logging.Log;\n\n/* Package-scope variables */\nvar SyncedCron, Later;\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                     //\n// packages/littledata_synced-cron/synced-cron-server.js                               //\n//                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////\n                                                                                       //\n// A package for running jobs synchronized across multiple processes\nSyncedCron = {\n  _entries: {},\n  running: false,\n  options: {\n    //Log job run details to console\n    log: true,\n\n    logger: null,\n\n    //Name of collection to use for synchronisation and logging\n    collectionName: 'cronHistory',\n\n    //Default to using localTime\n    utc: false,\n\n    //TTL in seconds for history records in collection to expire\n    //NOTE: Unset to remove expiry but ensure you remove the index from\n    //mongo by hand\n    collectionTTL: 172800\n  },\n  config: function(opts) {\n    this.options = _.extend({}, this.options, opts);\n  }\n}\n\nLater = Npm.require('later');\n\n/*\n  Logger factory function. Takes a prefix string and options object\n  and uses an injected `logger` if provided, else falls back to\n  Meteor's `Log` package.\n\n  Will send a log object to the injected logger, on the following form:\n\n    message: String\n    level: String (info, warn, error, debug)\n    tag: 'SyncedCron'\n*/\nfunction createLogger(prefix) {\n  check(prefix, String);\n\n  // Return noop if logging is disabled.\n  if(SyncedCron.options.log === false) {\n    return function() {};\n  }\n\n  return function(level, message) {\n    check(level, Match.OneOf('info', 'error', 'warn', 'debug'));\n    check(message, String);\n\n    var logger = SyncedCron.options && SyncedCron.options.logger;\n\n    if(logger && _.isFunction(logger)) {\n\n      logger({\n        level: level,\n        message: message,\n        tag: prefix\n      });\n\n    } else {\n      Log[level]({ message: prefix + ': ' + message });\n    }\n  }\n}\n\nvar log;\n\nMeteor.startup(function() {\n  var options = SyncedCron.options;\n\n  log = createLogger('SyncedCron');\n\n  ['info', 'warn', 'error', 'debug'].forEach(function(level) {\n    log[level] = _.partial(log, level);\n  });\n\n  // Don't allow TTL less than 5 minutes so we don't break synchronization\n  var minTTL = 300;\n\n  // Use UTC or localtime for evaluating schedules\n  if (options.utc)\n    Later.date.UTC();\n  else\n    Later.date.localTime();\n\n  // collection holding the job history records\n  SyncedCron._collection = new Mongo.Collection(options.collectionName);\n  SyncedCron._collection._ensureIndex({intendedAt: 1, name: 1}, {unique: true});\n\n  if (options.collectionTTL) {\n    if (options.collectionTTL > minTTL)\n      SyncedCron._collection._ensureIndex({startedAt: 1 },\n        { expireAfterSeconds: options.collectionTTL } );\n    else\n      log.warn('Not going to use a TTL that is shorter than:' + minTTL);\n  }\n});\n\nvar scheduleEntry = function(entry) {\n  var schedule = entry.schedule(Later.parse);\n  entry._timer =\n    SyncedCron._laterSetInterval(SyncedCron._entryWrapper(entry), schedule);\n\n  log.info('Scheduled \"' + entry.name + '\" next run @'\n    + Later.schedule(schedule).next(1));\n}\n\n// add a scheduled job\n// SyncedCron.add({\n//   name: String, //*required* unique name of the job\n//   schedule: function(laterParser) {},//*required* when to run the job\n//   job: function() {}, //*required* the code to run\n// });\nSyncedCron.add = function(entry) {\n  check(entry.name, String);\n  check(entry.schedule, Function);\n  check(entry.job, Function);\n  check(entry.persist, Match.Optional(Boolean));\n\n  if (entry.persist === undefined) {\n    entry.persist = true;\n  }\n\n  // check\n  if (!this._entries[entry.name]) {\n    this._entries[entry.name] = entry;\n\n    // If cron is already running, start directly.\n    if (this.running) {\n      scheduleEntry(entry);\n    }\n  }\n}\n\n// Start processing added jobs\nSyncedCron.start = function() {\n  var self = this;\n\n  Meteor.startup(function() {\n    // Schedule each job with later.js\n    _.each(self._entries, function(entry) {\n      scheduleEntry(entry);\n    });\n    self.running = true;\n  });\n}\n\n// Return the next scheduled date of the first matching entry or undefined\nSyncedCron.nextScheduledAtDate = function(jobName) {\n  var entry = this._entries[jobName];\n\n  if (entry)\n    return Later.schedule(entry.schedule(Later.parse)).next(1);\n}\n\n// Remove and stop the entry referenced by jobName\nSyncedCron.remove = function(jobName) {\n  var entry = this._entries[jobName];\n\n  if (entry) {\n    if (entry._timer)\n      entry._timer.clear();\n\n    delete this._entries[jobName];\n    log.info('Removed \"' + entry.name + '\"');\n  }\n}\n\n// Pause processing, but do not remove jobs so that the start method will\n// restart existing jobs\nSyncedCron.pause = function() {\n  if (this.running) {\n    _.each(this._entries, function(entry) {\n      entry._timer.clear();\n    });\n    this.running = false;\n  }\n}\n\n// Stop processing and remove ALL jobs\nSyncedCron.stop = function() {\n  _.each(this._entries, function(entry, name) {\n    SyncedCron.remove(name);\n  });\n  this.running = false;\n}\n\n// The meat of our logic. Checks if the specified has already run. If not,\n// records that it's running the job, runs it, and records the output\nSyncedCron._entryWrapper = function(entry) {\n  var self = this;\n\n  return function(intendedAt) {\n    intendedAt = new Date(intendedAt.getTime());\n    intendedAt.setMilliseconds(0);\n\n    var jobHistory;\n\n    if (entry.persist) {\n      jobHistory = {\n        intendedAt: intendedAt,\n        name: entry.name,\n        startedAt: new Date()\n      };\n\n      // If we have a dup key error, another instance has already tried to run\n      // this job.\n      try {\n        jobHistory._id = self._collection.insert(jobHistory);\n      } catch(e) {\n        // http://www.mongodb.org/about/contributors/error-codes/\n        // 11000 == duplicate key error\n        if (e.code === 11000) {\n          log.info('Not running \"' + entry.name + '\" again.');\n          return;\n        }\n\n        throw e;\n      };\n    }\n\n    // run and record the job\n    try {\n      log.info('Starting \"' + entry.name + '\".');\n      var output = entry.job(intendedAt,entry.name); // <- Run the actual job\n\n      log.info('Finished \"' + entry.name + '\".');\n      if(entry.persist) {\n        self._collection.update({_id: jobHistory._id}, {\n          $set: {\n            finishedAt: new Date(),\n            result: output\n          }\n        });\n      }\n    } catch(e) {\n      log.info('Exception \"' + entry.name +'\" ' + ((e && e.stack) ? e.stack : e));\n      if(entry.persist) {\n        self._collection.update({_id: jobHistory._id}, {\n          $set: {\n            finishedAt: new Date(),\n            error: (e && e.stack) ? e.stack : e\n          }\n        });\n      }\n    }\n  };\n}\n\n// for tests\nSyncedCron._reset = function() {\n  this._entries = {};\n  this._collection.remove({});\n  this.running = false;\n}\n\n// ---------------------------------------------------------------------------\n// The following two functions are lifted from the later.js package, however\n// I've made the following changes:\n// - Use Meteor.setTimeout and Meteor.clearTimeout\n// - Added an 'intendedAt' parameter to the callback fn that specifies the precise\n//   time the callback function *should* be run (so we can co-ordinate jobs)\n//   between multiple, potentially laggy and unsynced machines\n\n// From: https://github.com/bunkat/later/blob/master/src/core/setinterval.js\nSyncedCron._laterSetInterval = function(fn, sched) {\n\n  var t = SyncedCron._laterSetTimeout(scheduleTimeout, sched),\n      done = false;\n\n  /**\n  * Executes the specified function and then sets the timeout for the next\n  * interval.\n  */\n  function scheduleTimeout(intendedAt) {\n    if(!done) {\n      try {\n        fn(intendedAt);\n      } catch(e) {\n        log.info('Exception running scheduled job ' + ((e && e.stack) ? e.stack : e));\n      }\n\n      t = SyncedCron._laterSetTimeout(scheduleTimeout, sched);\n    }\n  }\n\n  return {\n\n    /**\n    * Clears the timeout.\n    */\n    clear: function() {\n      done = true;\n      t.clear();\n    }\n\n  };\n\n};\n\n// From: https://github.com/bunkat/later/blob/master/src/core/settimeout.js\nSyncedCron._laterSetTimeout = function(fn, sched) {\n\n  var s = Later.schedule(sched), t;\n  scheduleTimeout();\n\n  /**\n  * Schedules the timeout to occur. If the next occurrence is greater than the\n  * max supported delay (2147483647 ms) than we delay for that amount before\n  * attempting to schedule the timeout again.\n  */\n  function scheduleTimeout() {\n    var now = Date.now(),\n        next = s.next(2, now);\n\n    // don't schedlue another occurence if no more exist synced-cron#41\n    if (! next[0])\n      return;\n\n    var diff = next[0].getTime() - now,\n        intendedAt = next[0];\n\n    // minimum time to fire is one second, use next occurrence instead\n    if(diff < 1000) {\n      diff = next[1].getTime() - now;\n      intendedAt = next[1];\n    }\n\n    if(diff < 2147483647) {\n      t = Meteor.setTimeout(function() { fn(intendedAt); }, diff);\n    }\n    else {\n      t = Meteor.setTimeout(scheduleTimeout, 2147483647);\n    }\n  }\n\n  return {\n\n    /**\n    * Clears the timeout.\n    */\n    clear: function() {\n      Meteor.clearTimeout(t);\n    }\n\n  };\n\n};\n// ---------------------------------------------------------------------------\n\n/////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nPackage._define(\"littledata:synced-cron\", {\n  SyncedCron: SyncedCron\n});\n\n})();\n","servePath":"/packages/littledata_synced-cron.js"}]