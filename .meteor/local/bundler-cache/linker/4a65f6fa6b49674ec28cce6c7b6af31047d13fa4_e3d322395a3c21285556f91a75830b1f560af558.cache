[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar RoutePolicy = Package.routepolicy.RoutePolicy;\nvar WebApp = Package.webapp.WebApp;\nvar WebAppInternals = Package.webapp.WebAppInternals;\nvar main = Package.webapp.main;\nvar EJSON = Package.ejson.EJSON;\nvar _ = Package.underscore._;\n\n/* Package-scope variables */\nvar Inject, id;\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                   //\n// packages/meteorhacks_inject-initial/lib/inject-server.js                                          //\n//                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                     //\nfunction escapeReplaceString(str) {\n  /*\n   * When using string.replace(str, newSubStr), the dollar sign (\"$\") is\n   * considered a special character in newSubStr, and needs to be escaped\n   * as \"$$\".  We have to do this twice, for escaping the newSubStr in\n   * this function, and for the resulting string which is passed back.\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace\n   */\n   return str.replace(/\\$/g, '$$$$');\n}\n\nInject = {\n  // stores in a script type=application/ejson tag, accessed with Injected.obj('id')\n  obj: function(id, data, res) {\n    this._checkForObjOrFunction(data,\n      'Inject.obj(id, data [,res]) expects `data` to be an Object or Function');\n\n    if (res) {\n      this._resAssign(res, 'objList', id, data);\n    } else {\n      this.objList[id] = data;\n    }\n  },\n  objList: {},\n\n  // Inserts a META called `id`, whose `content` can be accessed with Injected.meta()\n  meta: function(id, data, res) {\n    this._checkForTextOrFunction(data,\n      'Inject.meta(id, data [,res]) expects `data` to be an String or Function');\n\n    if (res) {\n      this._resAssign(res, 'metaList', id, data);\n    } else {\n      this.metaList[id] = data;\n    }\n  },\n  metaList: {},\n\n  rawHead: function(id, textOrFunc, res) {\n    this._checkForTextOrFunction(textOrFunc,\n      'Inject.rawHead(id, content [,res]) expects `content` to be an String or Function');\n\n    if (res) {\n      this._resAssign(res, 'rawHeads', id, textOrFunc);\n    } else {\n      this.rawHeads[id] = textOrFunc;\n    }\n  },\n  rawHeads: {},\n\n  rawBody: function(id, textOrFunc, res) {\n    this._checkForTextOrFunction(textOrFunc,\n      'Inject.rawBody(id, content [,res]) expects `content` to be an String or Function');\n\n    if (res) {\n      this._resAssign(res, 'rawBodies', id, textOrFunc);\n    } else {\n      this.rawBodies[id] = textOrFunc;\n    }\n  },\n  rawBodies: {},\n\n  // The callback receives the entire HTML page and must return a modified version\n  rawModHtml: function(id, func) {\n    if (!_.isFunction(func)) {\n      var message = 'Inject func id \"' + id + '\" should be a function, not ' + typeof(func);\n      throw new Error(message);\n    }\n\n    this.rawModHtmlFuncs[id] = func;\n  },\n  rawModHtmlFuncs: {},\n\n  _injectObjects: function(html, res) {\n    var objs = _.extend({}, Inject.objList, res.Inject && res.Inject.objList);\n    if (_.isEmpty(objs)) {\n      return html;\n    }\n\n    var obj, injectHtml = '';\n    for (id in objs) {\n      obj = _.isFunction(objs[id]) ? objs[id](res) : objs[id];\n      injectHtml += \"  <script id='\" + id.replace(\"'\", '&apos;')\n        + \"' type='application/ejson'>\" + EJSON.stringify(obj)\n        + \"</script>\\n\";\n    }\n\n    return html.replace('<head>', '<head>\\n' + escapeReplaceString(injectHtml));\n  },\n\n  _injectMeta: function(html, res) {\n    var metas = _.extend({}, Inject.metaList, res.Inject && res.Inject.metaList);\n    if (_.isEmpty(metas))\n      return html;\n\n    var injectHtml = '';\n    for (id in metas) {\n      var meta = this._evalToText(metas[id], res, html);\n      injectHtml += \"  <meta id='\" + id.replace(\"'\", '&apos;')\n        + \"' content='\" + meta.replace(\"'\", '&apos;') + \"'>\\n\", res;\n    }\n\n    return html.replace('<head>', '<head>\\n' + escapeReplaceString(injectHtml));\n  },\n\n  _injectHeads: function(html, res) {\n    var heads = _.extend({}, Inject.rawHeads, res.Inject && res.Inject.rawHeads);\n    if (_.isEmpty(heads))\n      return html;\n\n    var injectHtml = '';\n    for (id in heads) {\n      var head = this._evalToText(heads[id], res, html);\n      injectHtml += head + '\\n';\n    }\n\n    return html.replace('<head>', '<head>\\n' + escapeReplaceString(injectHtml));\n  },\n\n  _injectBodies: function(html, res) {\n    var bodies = _.extend({}, Inject.rawBodies, res.Inject && res.Inject.rawBodies);\n    if (_.isEmpty(bodies))\n      return html;\n\n    var injectHtml = '';\n    for (id in bodies) {\n      var body = this._evalToText(bodies[id], res, html);\n      injectHtml += body + '\\n';\n    }\n\n    return html.replace('<body>', '<body>\\n' + escapeReplaceString(injectHtml));\n  },\n\n  // ensure object exists and store there\n  _resAssign: function(res, key, id, value) {\n    if (!res.Inject)\n      res.Inject = {};\n    if (!res.Inject[key])\n      res.Inject[key] = {};\n    res.Inject[key][id] = value;\n  },\n\n  _checkForTextOrFunction: function (arg, message) {\n    if(!(_.isString(arg) || _.isFunction(arg))) {\n      throw new Error(message);\n    }\n  },\n\n  _checkForObjOrFunction: function (arg, message) {\n    if(!(_.isObject(arg) || _.isFunction(arg))) {\n      throw new Error(message);\n    }\n  },\n\n  // we don't handle errors here. Let them to handle in a higher level\n  _evalToText: function(textOrFunc, res, html) {\n    if(_.isFunction(textOrFunc)) {\n      return textOrFunc(res, html);\n    } else {\n      return textOrFunc;\n    }\n  }\n};\n\nInject.rawModHtml('injectHeads', Inject._injectHeads.bind(Inject));\nInject.rawModHtml('injectMeta', Inject._injectMeta.bind(Inject));\nInject.rawModHtml('injectBodies', Inject._injectBodies.bind(Inject));\nInject.rawModHtml('injectObjects', Inject._injectObjects.bind(Inject));\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                   //\n// packages/meteorhacks_inject-initial/lib/inject-core.js                                            //\n//                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                     //\n// Hijack core node API and attach data to the response dynamically\n// We are simply using this hack because, there is no way to alter\n// Meteor's html content on the server side\n\nInject._hijackWrite = function(res) {\n  var originalWrite = res.write;\n  res.write = function(chunk, encoding) {\n    //prevent hijacking other http requests\n    if(!res.iInjected &&\n      encoding === undefined && /^<!DOCTYPE html>/.test(chunk)) {\n      chunk = chunk.toString();\n\n      for (id in Inject.rawModHtmlFuncs) {\n        chunk = Inject.rawModHtmlFuncs[id](chunk, res);\n        if (!_.isString(chunk)) {\n          throw new Error('Inject func id \"' + id + '\" must return HTML, not '\n            + typeof(chunk) + '\\n' + JSON.stringify(chunk, null, 2));\n        }\n      }\n\n      res.iInjected = true;\n    }\n\n    originalWrite.call(res, chunk, encoding);\n  };\n}\n\nWebApp.connectHandlers.use(function(req, res, next) {\n  // We only separate this to make testing easier\n  Inject._hijackWrite(res);\n\n  next();\n});\n\n//meteor algorithm to check if this is a meteor serving http request or not\nInject.appUrl = function(url) {\n  if (url === '/favicon.ico' || url === '/robots.txt')\n    return false;\n\n  // NOTE: app.manifest is not a web standard like favicon.ico and\n  // robots.txt. It is a file id we have chosen to use for HTML5\n  // appcache URLs. It is included here to prevent using an appcache\n  // then removing it from poisoning an app permanently. Eventually,\n  // once we have server side routing, this won't be needed as\n  // unknown URLs with return a 404 automatically.\n  if (url === '/app.manifest')\n    return false;\n\n  // Avoid serving app HTML for declared routes such as /sockjs/.\n  if (typeof(RoutePolicy) != 'undefined' && RoutePolicy.classify(url))\n    return false;\n\n  // we currently return app HTML on all URLs by default\n  return true;\n};\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nPackage._define(\"meteorhacks:inject-initial\", {\n  Inject: Inject\n});\n\n})();\n","servePath":"/packages/meteorhacks_inject-initial.js"}]