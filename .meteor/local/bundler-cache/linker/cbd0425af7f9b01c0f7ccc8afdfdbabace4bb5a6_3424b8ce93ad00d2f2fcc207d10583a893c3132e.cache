[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar ECMAScript = Package.ecmascript.ECMAScript;\nvar Random = Package.random.Random;\nvar ServiceConfiguration = Package['service-configuration'].ServiceConfiguration;\nvar OAuth = Package.oauth.OAuth;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar HTTP = Package.http.HTTP;\nvar HTTPInternals = Package.http.HTTPInternals;\nvar MongoInternals = Package.mongo.MongoInternals;\nvar Mongo = Package.mongo.Mongo;\nvar meteorInstall = Package.modules.meteorInstall;\nvar Promise = Package.promise.Promise;\n\n/* Package-scope variables */\nvar params, url, OAuth1Binding, OAuth1Test;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"oauth1\":{\"oauth1_binding.js\":function module(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/oauth1/oauth1_binding.js                                                                                  //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nlet _objectSpread;\n\nmodule.link(\"@babel/runtime/helpers/objectSpread2\", {\n  default(v) {\n    _objectSpread = v;\n  }\n\n}, 0);\nmodule.export({\n  OAuth1Binding: () => OAuth1Binding\n});\nlet crypto;\nmodule.link(\"crypto\", {\n  default(v) {\n    crypto = v;\n  }\n\n}, 0);\nlet querystring;\nmodule.link(\"querystring\", {\n  default(v) {\n    querystring = v;\n  }\n\n}, 1);\nlet urlModule;\nmodule.link(\"url\", {\n  default(v) {\n    urlModule = v;\n  }\n\n}, 2);\n\nclass OAuth1Binding {\n  constructor(config, urls) {\n    this._config = config;\n    this._urls = urls;\n  }\n\n  prepareRequestToken(callbackUrl) {\n    const headers = this._buildHeader({\n      oauth_callback: callbackUrl\n    });\n\n    const response = this._call('POST', this._urls.requestToken, headers);\n\n    const tokens = querystring.parse(response.content);\n    if (!tokens.oauth_callback_confirmed) throw Object.assign(new Error(\"oauth_callback_confirmed false when requesting oauth1 token\"), {\n      response: response\n    });\n    this.requestToken = tokens.oauth_token;\n    this.requestTokenSecret = tokens.oauth_token_secret;\n  }\n\n  prepareAccessToken(query, requestTokenSecret) {\n    // support implementations that use request token secrets. This is\n    // read by this._call.\n    //\n    // XXX make it a param to call, not something stashed on self? It's\n    // kinda confusing right now, everything except this is passed as\n    // arguments, but this is stored.\n    if (requestTokenSecret) this.accessTokenSecret = requestTokenSecret;\n\n    const headers = this._buildHeader({\n      oauth_token: query.oauth_token,\n      oauth_verifier: query.oauth_verifier\n    });\n\n    const response = this._call('POST', this._urls.accessToken, headers);\n\n    const tokens = querystring.parse(response.content);\n\n    if (!tokens.oauth_token || !tokens.oauth_token_secret) {\n      const error = new Error(\"missing oauth token or secret\"); // We provide response only if no token is available, we do not want to leak any tokens\n\n      if (!tokens.oauth_token && !tokens.oauth_token_secret) {\n        Object.assign(error, {\n          response: response\n        });\n      }\n\n      throw error;\n    }\n\n    this.accessToken = tokens.oauth_token;\n    this.accessTokenSecret = tokens.oauth_token_secret;\n  }\n\n  call(method, url, params, callback) {\n    const headers = this._buildHeader({\n      oauth_token: this.accessToken\n    });\n\n    if (!params) {\n      params = {};\n    }\n\n    return this._call(method, url, headers, params, callback);\n  }\n\n  get(url, params, callback) {\n    return this.call('GET', url, params, callback);\n  }\n\n  post(url, params, callback) {\n    return this.call('POST', url, params, callback);\n  }\n\n  _buildHeader(headers) {\n    return _objectSpread({\n      oauth_consumer_key: this._config.consumerKey,\n      oauth_nonce: Random.secret().replace(/\\W/g, ''),\n      oauth_signature_method: 'HMAC-SHA1',\n      oauth_timestamp: (new Date().valueOf() / 1000).toFixed().toString(),\n      oauth_version: '1.0'\n    }, headers);\n  }\n\n  _getSignature(method, url, rawHeaders, accessTokenSecret, params) {\n    const headers = this._encodeHeader(_objectSpread(_objectSpread({}, rawHeaders), params));\n\n    const parameters = Object.keys(headers).map(key => \"\".concat(key, \"=\").concat(headers[key])).sort().join('&');\n    const signatureBase = [method, this._encodeString(url), this._encodeString(parameters)].join('&');\n    const secret = OAuth.openSecret(this._config.secret);\n    let signingKey = \"\".concat(this._encodeString(secret), \"&\");\n    if (accessTokenSecret) signingKey += this._encodeString(accessTokenSecret);\n    return crypto.createHmac('SHA1', signingKey).update(signatureBase).digest('base64');\n  }\n\n  _call(method, url) {\n    let headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let params = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    let callback = arguments.length > 4 ? arguments[4] : undefined;\n\n    // all URLs to be functions to support parameters/customization\n    if (typeof url === \"function\") {\n      url = url(this);\n    } // Extract all query string parameters from the provided URL\n\n\n    const parsedUrl = urlModule.parse(url, true); // Merge them in a way that params given to the method call have precedence\n\n    params = _objectSpread(_objectSpread({}, parsedUrl.query), params); // Reconstruct the URL back without any query string parameters\n    // (they are now in params)\n\n    parsedUrl.query = {};\n    parsedUrl.search = '';\n    url = urlModule.format(parsedUrl); // Get the signature\n\n    headers.oauth_signature = this._getSignature(method, url, headers, this.accessTokenSecret, params); // Make a authorization string according to oauth1 spec\n\n    const authString = this._getAuthHeaderString(headers); // Make signed request\n\n\n    try {\n      const response = HTTP.call(method, url, {\n        params,\n        headers: {\n          Authorization: authString\n        }\n      }, callback && ((error, response) => {\n        if (!error) {\n          response.nonce = headers.oauth_nonce;\n        }\n\n        callback(error, response);\n      })); // We store nonce so that JWTs can be validated\n\n      if (response) response.nonce = headers.oauth_nonce;\n      return response;\n    } catch (err) {\n      throw Object.assign(new Error(\"Failed to send OAuth1 request to \".concat(url, \". \").concat(err.message)), {\n        response: err.response\n      });\n    }\n  }\n\n  _encodeHeader(header) {\n    return Object.keys(header).reduce((memo, key) => {\n      memo[this._encodeString(key)] = this._encodeString(header[key]);\n      return memo;\n    }, {});\n  }\n\n  _encodeString(str) {\n    return encodeURIComponent(str).replace(/[!'()]/g, escape).replace(/\\*/g, \"%2A\");\n  }\n\n  _getAuthHeaderString(headers) {\n    return 'OAuth ' + Object.keys(headers).map(key => \"\".concat(this._encodeString(key), \"=\\\"\").concat(this._encodeString(headers[key]), \"\\\"\")).sort().join(', ');\n  }\n\n}\n\n;\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"oauth1_server.js\":function module(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/oauth1/oauth1_server.js                                                                                   //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\n!function (module1) {\n  let _objectSpread;\n\n  module1.link(\"@babel/runtime/helpers/objectSpread2\", {\n    default(v) {\n      _objectSpread = v;\n    }\n\n  }, 0);\n  let url;\n  module1.link(\"url\", {\n    default(v) {\n      url = v;\n    }\n\n  }, 0);\n  let OAuth1Binding;\n  module1.link(\"./oauth1_binding\", {\n    OAuth1Binding(v) {\n      OAuth1Binding = v;\n    }\n\n  }, 1);\n\n  OAuth._queryParamsWithAuthTokenUrl = function (authUrl, oauthBinding) {\n    let params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let whitelistedQueryParams = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n    const redirectUrlObj = url.parse(authUrl, true);\n    Object.assign(redirectUrlObj.query, whitelistedQueryParams.reduce((prev, param) => params.query[param] ? _objectSpread(_objectSpread({}, prev), {}, {\n      param: params.query[param]\n    }) : prev, {}), {\n      oauth_token: oauthBinding.requestToken\n    }); // Clear the `search` so it is rebuilt by Node's `url` from the `query` above.\n    // Using previous versions of the Node `url` module, this was just set to \"\"\n    // However, Node 6 docs seem to indicate that this should be `undefined`.\n\n    delete redirectUrlObj.search; // Reconstruct the URL back with provided query parameters merged with oauth_token\n\n    return url.format(redirectUrlObj);\n  }; // connect middleware\n\n\n  OAuth._requestHandlers['1'] = (service, query, res) => {\n    const config = ServiceConfiguration.configurations.findOne({\n      service: service.serviceName\n    });\n\n    if (!config) {\n      throw new ServiceConfiguration.ConfigError(service.serviceName);\n    }\n\n    const {\n      urls\n    } = service;\n    const oauthBinding = new OAuth1Binding(config, urls);\n    let credentialSecret;\n\n    if (query.requestTokenAndRedirect) {\n      // step 1 - get and store a request token\n      const callbackUrl = OAuth._redirectUri(service.serviceName, config, {\n        state: query.state,\n        cordova: query.cordova === \"true\",\n        android: query.android === \"true\"\n      }); // Get a request token to start auth process\n\n\n      oauthBinding.prepareRequestToken(callbackUrl); // Keep track of request token so we can verify it on the next step\n\n      OAuth._storeRequestToken(OAuth._credentialTokenFromQuery(query), oauthBinding.requestToken, oauthBinding.requestTokenSecret); // support for scope/name parameters\n\n\n      let redirectUrl;\n      const authParams = {\n        query\n      };\n\n      if (typeof urls.authenticate === \"function\") {\n        redirectUrl = urls.authenticate(oauthBinding, authParams);\n      } else {\n        redirectUrl = OAuth._queryParamsWithAuthTokenUrl(urls.authenticate, oauthBinding, authParams);\n      } // redirect to provider login, which will redirect back to \"step 2\" below\n\n\n      res.writeHead(302, {\n        'Location': redirectUrl\n      });\n      res.end();\n    } else {\n      // step 2, redirected from provider login - store the result\n      // and close the window to allow the login handler to proceed\n      // Get the user's request token so we can verify it and clear it\n      const requestTokenInfo = OAuth._retrieveRequestToken(OAuth._credentialTokenFromQuery(query));\n\n      if (!requestTokenInfo) {\n        throw new Error(\"Unable to retrieve request token\");\n      } // Verify user authorized access and the oauth_token matches\n      // the requestToken from previous step\n\n\n      if (query.oauth_token && query.oauth_token === requestTokenInfo.requestToken) {\n        // Prepare the login results before returning.  This way the\n        // subsequent call to the `login` method will be immediate.\n        // Get the access token for signing requests\n        oauthBinding.prepareAccessToken(query, requestTokenInfo.requestTokenSecret); // Run service-specific handler.\n\n        const oauthResult = service.handleOauthRequest(oauthBinding, {\n          query: query\n        });\n\n        const credentialToken = OAuth._credentialTokenFromQuery(query);\n\n        credentialSecret = Random.secret(); // Store the login result so it can be retrieved in another\n        // browser tab by the result handler\n\n        OAuth._storePendingCredential(credentialToken, {\n          serviceName: service.serviceName,\n          serviceData: oauthResult.serviceData,\n          options: oauthResult.options\n        }, credentialSecret);\n      } // Either close the window, redirect, or render nothing\n      // if all else fails\n\n\n      OAuth._renderOauthResults(res, query, credentialSecret);\n    }\n  };\n}.call(this, module);\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"oauth1_pending_request_tokens.js\":function module(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/oauth1/oauth1_pending_request_tokens.js                                                                   //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\n//\n// _pendingRequestTokens are request tokens that have been received\n// but not yet fully authorized (processed).\n//\n// During the oauth1 authorization process, the Meteor App opens\n// a pop-up, requests a request token from the oauth1 service, and\n// redirects the browser to the oauth1 service for the user\n// to grant authorization.  The user is then returned to the\n// Meteor Apps' callback url and the request token is verified.\n//\n// When Meteor Apps run on multiple servers, it's possible that\n// 2 different servers may be used to generate the request token\n// and to verify it in the callback once the user has authorized.\n//\n// For this reason, the _pendingRequestTokens are stored in the database\n// so they can be shared across Meteor App servers.\n//\n// XXX This code is fairly similar to oauth/pending_credentials.js --\n// maybe we can combine them somehow.\n// Collection containing pending request tokens\n// Has key, requestToken, requestTokenSecret, and createdAt fields.\nOAuth._pendingRequestTokens = new Mongo.Collection(\"meteor_oauth_pendingRequestTokens\", {\n  _preventAutopublish: true\n});\n\nOAuth._pendingRequestTokens.createIndex('key', {\n  unique: true\n});\n\nOAuth._pendingRequestTokens.createIndex('createdAt'); // Periodically clear old entries that never got completed\n\n\nconst _cleanStaleResults = () => {\n  // Remove request tokens older than 5 minute\n  const timeCutoff = new Date();\n  timeCutoff.setMinutes(timeCutoff.getMinutes() - 5);\n\n  OAuth._pendingRequestTokens.remove({\n    createdAt: {\n      $lt: timeCutoff\n    }\n  });\n};\n\nconst _cleanupHandle = Meteor.setInterval(_cleanStaleResults, 60 * 1000); // Stores the key and request token in the _pendingRequestTokens collection.\n// Will throw an exception if `key` is not a string.\n//\n// @param key {string}\n// @param requestToken {string}\n// @param requestTokenSecret {string}\n//\n\n\nOAuth._storeRequestToken = (key, requestToken, requestTokenSecret) => {\n  check(key, String); // We do an upsert here instead of an insert in case the user happens\n  // to somehow send the same `state` parameter twice during an OAuth\n  // login; we don't want a duplicate key error.\n\n  OAuth._pendingRequestTokens.upsert({\n    key\n  }, {\n    key,\n    requestToken: OAuth.sealSecret(requestToken),\n    requestTokenSecret: OAuth.sealSecret(requestTokenSecret),\n    createdAt: new Date()\n  });\n}; // Retrieves and removes a request token from the _pendingRequestTokens collection\n// Returns an object containing requestToken and requestTokenSecret properties\n//\n// @param key {string}\n//\n\n\nOAuth._retrieveRequestToken = key => {\n  check(key, String);\n\n  const pendingRequestToken = OAuth._pendingRequestTokens.findOne({\n    key: key\n  });\n\n  if (pendingRequestToken) {\n    OAuth._pendingRequestTokens.remove({\n      _id: pendingRequestToken._id\n    });\n\n    return {\n      requestToken: OAuth.openSecret(pendingRequestToken.requestToken),\n      requestTokenSecret: OAuth.openSecret(pendingRequestToken.requestTokenSecret)\n    };\n  } else {\n    return undefined;\n  }\n};\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\n\nrequire(\"/node_modules/meteor/oauth1/oauth1_binding.js\");\nrequire(\"/node_modules/meteor/oauth1/oauth1_server.js\");\nrequire(\"/node_modules/meteor/oauth1/oauth1_pending_request_tokens.js\");\n\n/* Exports */\nPackage._define(\"oauth1\", {\n  OAuth1Binding: OAuth1Binding,\n  OAuth1Test: OAuth1Test\n});\n\n})();\n","servePath":"/packages/oauth1.js","sourceMap":{"version":3,"sources":["packages/oauth1/oauth1_binding.js","packages/oauth1/oauth1_server.js","packages/oauth1/oauth1_pending_request_tokens.js"],"names":["_objectSpread","module","link","default","v","export","OAuth1Binding","crypto","querystring","urlModule","constructor","config","urls","_config","_urls","prepareRequestToken","callbackUrl","headers","_buildHeader","oauth_callback","response","_call","requestToken","tokens","parse","content","oauth_callback_confirmed","Object","assign","Error","oauth_token","requestTokenSecret","oauth_token_secret","prepareAccessToken","query","accessTokenSecret","oauth_verifier","accessToken","error","call","method","url","params","callback","get","post","oauth_consumer_key","consumerKey","oauth_nonce","Random","secret","replace","oauth_signature_method","oauth_timestamp","Date","valueOf","toFixed","toString","oauth_version","_getSignature","rawHeaders","_encodeHeader","parameters","keys","map","key","sort","join","signatureBase","_encodeString","OAuth","openSecret","signingKey","createHmac","update","digest","parsedUrl","search","format","oauth_signature","authString","_getAuthHeaderString","HTTP","Authorization","nonce","err","message","header","reduce","memo","str","encodeURIComponent","escape","module1","_queryParamsWithAuthTokenUrl","authUrl","oauthBinding","whitelistedQueryParams","redirectUrlObj","prev","param","_requestHandlers","service","res","ServiceConfiguration","configurations","findOne","serviceName","ConfigError","credentialSecret","requestTokenAndRedirect","_redirectUri","state","cordova","android","_storeRequestToken","_credentialTokenFromQuery","redirectUrl","authParams","authenticate","writeHead","end","requestTokenInfo","_retrieveRequestToken","oauthResult","handleOauthRequest","credentialToken","_storePendingCredential","serviceData","options","_renderOauthResults","_pendingRequestTokens","Mongo","Collection","_preventAutopublish","createIndex","unique","_cleanStaleResults","timeCutoff","setMinutes","getMinutes","remove","createdAt","$lt","_cleanupHandle","Meteor","setInterval","check","String","upsert","sealSecret","pendingRequestToken","_id","undefined"],"mappings":"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","file":"/packages/oauth1.js","sourcesContent":["import crypto from 'crypto';\nimport querystring from 'querystring';\nimport urlModule from 'url';\n\n// An OAuth1 wrapper around http calls which helps get tokens and\n// takes care of HTTP headers\n//\n// @param config {Object}\n//   - consumerKey (String): oauth consumer key\n//   - secret (String): oauth consumer secret\n// @param urls {Object}\n//   - requestToken (String): url\n//   - authorize (String): url\n//   - accessToken (String): url\n//   - authenticate (String): url\nexport class OAuth1Binding {\n  constructor(config, urls) {\n    this._config = config;\n    this._urls = urls;\n  }\n\n  prepareRequestToken(callbackUrl) {\n    const headers = this._buildHeader({\n      oauth_callback: callbackUrl\n    });\n\n    const response = this._call('POST', this._urls.requestToken, headers);\n    const tokens = querystring.parse(response.content);\n\n    if (! tokens.oauth_callback_confirmed)\n      throw Object.assign(new Error(\"oauth_callback_confirmed false when requesting oauth1 token\"),\n                               {response: response});\n\n    this.requestToken = tokens.oauth_token;\n    this.requestTokenSecret = tokens.oauth_token_secret;\n  }\n\n  prepareAccessToken(query, requestTokenSecret) {\n    // support implementations that use request token secrets. This is\n    // read by this._call.\n    //\n    // XXX make it a param to call, not something stashed on self? It's\n    // kinda confusing right now, everything except this is passed as\n    // arguments, but this is stored.\n    if (requestTokenSecret)\n      this.accessTokenSecret = requestTokenSecret;\n\n    const headers = this._buildHeader({\n      oauth_token: query.oauth_token,\n      oauth_verifier: query.oauth_verifier\n    });\n\n    const response = this._call('POST', this._urls.accessToken, headers);\n    const tokens = querystring.parse(response.content);\n\n    if (! tokens.oauth_token || ! tokens.oauth_token_secret) {\n      const error = new Error(\"missing oauth token or secret\");\n      // We provide response only if no token is available, we do not want to leak any tokens\n      if (! tokens.oauth_token && ! tokens.oauth_token_secret) {\n        Object.assign(error, {response: response});\n      }\n      throw error;\n    }\n\n    this.accessToken = tokens.oauth_token;\n    this.accessTokenSecret = tokens.oauth_token_secret;\n  }\n\n  call(method, url, params, callback) {\n    const headers = this._buildHeader({\n      oauth_token: this.accessToken\n    });\n\n    if(! params) {\n      params = {};\n    }\n\n    return this._call(method, url, headers, params, callback);\n  }\n\n  get(url, params, callback) {\n    return this.call('GET', url, params, callback);\n  }\n\n  post(url, params, callback) {\n    return this.call('POST', url, params, callback);\n  }\n\n  _buildHeader(headers) {\n    return {\n      oauth_consumer_key: this._config.consumerKey,\n      oauth_nonce: Random.secret().replace(/\\W/g, ''),\n      oauth_signature_method: 'HMAC-SHA1',\n      oauth_timestamp: (new Date().valueOf()/1000).toFixed().toString(),\n      oauth_version: '1.0',\n      ...headers,\n    }\n  }\n\n  _getSignature(method, url, rawHeaders, accessTokenSecret, params) {\n    const headers = this._encodeHeader({ ...rawHeaders, ...params });\n\n    const parameters = Object.keys(headers).map(key => `${key}=${headers[key]}`)\n      .sort().join('&');\n\n    const signatureBase = [\n      method,\n      this._encodeString(url),\n      this._encodeString(parameters)\n    ].join('&');\n\n    const secret = OAuth.openSecret(this._config.secret);\n\n    let signingKey = `${this._encodeString(secret)}&`;\n    if (accessTokenSecret)\n      signingKey += this._encodeString(accessTokenSecret);\n\n    return crypto.createHmac('SHA1', signingKey).update(signatureBase).digest('base64');\n  };\n\n  _call(method, url, headers = {}, params = {}, callback) {\n    // all URLs to be functions to support parameters/customization\n    if(typeof url === \"function\") {\n      url = url(this);\n    }\n\n    // Extract all query string parameters from the provided URL\n    const parsedUrl = urlModule.parse(url, true);\n    // Merge them in a way that params given to the method call have precedence\n    params = { ...parsedUrl.query, ...params };\n\n    // Reconstruct the URL back without any query string parameters\n    // (they are now in params)\n    parsedUrl.query = {};\n    parsedUrl.search = '';\n    url = urlModule.format(parsedUrl);\n\n    // Get the signature\n    headers.oauth_signature =\n      this._getSignature(method, url, headers, this.accessTokenSecret, params);\n\n    // Make a authorization string according to oauth1 spec\n    const authString = this._getAuthHeaderString(headers);\n\n    // Make signed request\n    try {\n      const response = HTTP.call(method, url, {\n        params,\n        headers: {\n          Authorization: authString\n        }\n      }, callback && ((error, response) => {\n        if (! error) {\n          response.nonce = headers.oauth_nonce;\n        }\n        callback(error, response);\n      }));\n      // We store nonce so that JWTs can be validated\n      if (response)\n        response.nonce = headers.oauth_nonce;\n      return response;\n    } catch (err) {\n      throw Object.assign(new Error(`Failed to send OAuth1 request to ${url}. ${err.message}`),\n                     {response: err.response});\n    }\n  };\n\n  _encodeHeader(header) {\n    return Object.keys(header).reduce((memo, key) => {\n      memo[this._encodeString(key)] = this._encodeString(header[key]);\n      return memo;\n    }, {});\n  };\n\n  _encodeString(str) {\n    return encodeURIComponent(str).replace(/[!'()]/g, escape).replace(/\\*/g, \"%2A\");\n  };\n\n  _getAuthHeaderString(headers) {\n    return 'OAuth ' +  Object.keys(headers).map(key =>\n      `${this._encodeString(key)}=\"${this._encodeString(headers[key])}\"`\n    ).sort().join(', ');\n  };\n\n};\n","import url from 'url';\nimport { OAuth1Binding } from './oauth1_binding';\n\nOAuth._queryParamsWithAuthTokenUrl = (authUrl, oauthBinding, params = {}, whitelistedQueryParams = []) => {\n  const redirectUrlObj = url.parse(authUrl, true);\n\n  Object.assign(\n    redirectUrlObj.query,\n    whitelistedQueryParams.reduce((prev, param) => \n      params.query[param] ? { ...prev, param: params.query[param] } : prev,\n      {}\n    ),\n    {\n      oauth_token: oauthBinding.requestToken,\n    }\n  );\n\n  // Clear the `search` so it is rebuilt by Node's `url` from the `query` above.\n  // Using previous versions of the Node `url` module, this was just set to \"\"\n  // However, Node 6 docs seem to indicate that this should be `undefined`.\n  delete redirectUrlObj.search;\n\n  // Reconstruct the URL back with provided query parameters merged with oauth_token\n  return url.format(redirectUrlObj);\n};\n\n// connect middleware\nOAuth._requestHandlers['1'] = (service, query, res) => {\n  const config = ServiceConfiguration.configurations.findOne({service: service.serviceName});\n  if (! config) {\n    throw new ServiceConfiguration.ConfigError(service.serviceName);\n  }\n\n  const { urls } = service;\n  const oauthBinding = new OAuth1Binding(config, urls);\n\n  let credentialSecret;\n\n  if (query.requestTokenAndRedirect) {\n    // step 1 - get and store a request token\n    const callbackUrl = OAuth._redirectUri(service.serviceName, config, {\n      state: query.state,\n      cordova: (query.cordova === \"true\"),\n      android: (query.android === \"true\")\n    });\n\n    // Get a request token to start auth process\n    oauthBinding.prepareRequestToken(callbackUrl);\n\n    // Keep track of request token so we can verify it on the next step\n    OAuth._storeRequestToken(\n      OAuth._credentialTokenFromQuery(query),\n      oauthBinding.requestToken,\n      oauthBinding.requestTokenSecret);\n\n    // support for scope/name parameters\n    let redirectUrl;\n    const authParams = { query };\n\n    if(typeof urls.authenticate === \"function\") {\n      redirectUrl = urls.authenticate(oauthBinding, authParams);\n    } else {\n      redirectUrl = OAuth._queryParamsWithAuthTokenUrl(\n        urls.authenticate,\n        oauthBinding,\n        authParams\n      );\n    }\n\n    // redirect to provider login, which will redirect back to \"step 2\" below\n\n    res.writeHead(302, {'Location': redirectUrl});\n    res.end();\n  } else {\n    // step 2, redirected from provider login - store the result\n    // and close the window to allow the login handler to proceed\n\n    // Get the user's request token so we can verify it and clear it\n    const requestTokenInfo = OAuth._retrieveRequestToken(\n      OAuth._credentialTokenFromQuery(query));\n\n    if (! requestTokenInfo) {\n      throw new Error(\"Unable to retrieve request token\");\n    }\n\n    // Verify user authorized access and the oauth_token matches\n    // the requestToken from previous step\n    if (query.oauth_token && query.oauth_token === requestTokenInfo.requestToken) {\n\n      // Prepare the login results before returning.  This way the\n      // subsequent call to the `login` method will be immediate.\n\n      // Get the access token for signing requests\n      oauthBinding.prepareAccessToken(query, requestTokenInfo.requestTokenSecret);\n\n      // Run service-specific handler.\n      const oauthResult = service.handleOauthRequest(\n        oauthBinding, { query: query });\n\n      const credentialToken = OAuth._credentialTokenFromQuery(query);\n      credentialSecret = Random.secret();\n\n      // Store the login result so it can be retrieved in another\n      // browser tab by the result handler\n      OAuth._storePendingCredential(credentialToken, {\n        serviceName: service.serviceName,\n        serviceData: oauthResult.serviceData,\n        options: oauthResult.options\n      }, credentialSecret);\n    }\n\n    // Either close the window, redirect, or render nothing\n    // if all else fails\n    OAuth._renderOauthResults(res, query, credentialSecret);\n  }\n};\n","//\n// _pendingRequestTokens are request tokens that have been received\n// but not yet fully authorized (processed).\n//\n// During the oauth1 authorization process, the Meteor App opens\n// a pop-up, requests a request token from the oauth1 service, and\n// redirects the browser to the oauth1 service for the user\n// to grant authorization.  The user is then returned to the\n// Meteor Apps' callback url and the request token is verified.\n//\n// When Meteor Apps run on multiple servers, it's possible that\n// 2 different servers may be used to generate the request token\n// and to verify it in the callback once the user has authorized.\n//\n// For this reason, the _pendingRequestTokens are stored in the database\n// so they can be shared across Meteor App servers.\n//\n// XXX This code is fairly similar to oauth/pending_credentials.js --\n// maybe we can combine them somehow.\n\n// Collection containing pending request tokens\n// Has key, requestToken, requestTokenSecret, and createdAt fields.\nOAuth._pendingRequestTokens = new Mongo.Collection(\n  \"meteor_oauth_pendingRequestTokens\", {\n    _preventAutopublish: true\n  });\n\nOAuth._pendingRequestTokens.createIndex('key', { unique: true });\nOAuth._pendingRequestTokens.createIndex('createdAt');\n\n\n\n// Periodically clear old entries that never got completed\nconst _cleanStaleResults = () => {\n  // Remove request tokens older than 5 minute\n  const timeCutoff = new Date();\n  timeCutoff.setMinutes(timeCutoff.getMinutes() - 5);\n  OAuth._pendingRequestTokens.remove({ createdAt: { $lt: timeCutoff } });\n};\nconst _cleanupHandle = Meteor.setInterval(_cleanStaleResults, 60 * 1000);\n\n\n// Stores the key and request token in the _pendingRequestTokens collection.\n// Will throw an exception if `key` is not a string.\n//\n// @param key {string}\n// @param requestToken {string}\n// @param requestTokenSecret {string}\n//\nOAuth._storeRequestToken = (key, requestToken, requestTokenSecret) => {\n  check(key, String);\n\n  // We do an upsert here instead of an insert in case the user happens\n  // to somehow send the same `state` parameter twice during an OAuth\n  // login; we don't want a duplicate key error.\n  OAuth._pendingRequestTokens.upsert({\n    key,\n  }, {\n    key,\n    requestToken: OAuth.sealSecret(requestToken),\n    requestTokenSecret: OAuth.sealSecret(requestTokenSecret),\n    createdAt: new Date()\n  });\n};\n\n\n// Retrieves and removes a request token from the _pendingRequestTokens collection\n// Returns an object containing requestToken and requestTokenSecret properties\n//\n// @param key {string}\n//\nOAuth._retrieveRequestToken = key => {\n  check(key, String);\n\n  const pendingRequestToken = OAuth._pendingRequestTokens.findOne({ key: key });\n  if (pendingRequestToken) {\n    OAuth._pendingRequestTokens.remove({ _id: pendingRequestToken._id });\n    return {\n      requestToken: OAuth.openSecret(pendingRequestToken.requestToken),\n      requestTokenSecret: OAuth.openSecret(\n        pendingRequestToken.requestTokenSecret)\n    };\n  } else {\n    return undefined;\n  }\n};\n"]}}]