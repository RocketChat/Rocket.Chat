[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar meteorInstall = Package.modules.meteorInstall;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"modern-browsers\":{\"modern.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////\n//                                                                                 //\n// packages/modern-browsers/modern.js                                              //\n//                                                                                 //\n/////////////////////////////////////////////////////////////////////////////////////\n                                                                                   //\nconst minimumVersions = Object.create(null);\nconst hasOwn = Object.prototype.hasOwnProperty;\n\n// This map defines aliasing behavior in a generic way which still permits\n// minimum versions to be specified for a specific browser family.\nconst browserAliases = {\n  chrome: [\n    // chromeMobile*, per https://github.com/meteor/meteor/pull/9793,\n    'chromeMobile',\n    'chromeMobileIOS',\n    'chromeMobileWebView',\n\n    // The major version number of Chromium and Headless Chrome track with the\n    // releases of Chrome Dev, Canary and Stable, so we should be okay to\n    // alias them to Chrome in a generic sense.\n    // https://www.chromium.org/developers/version-numbers\n    //\n    // Chromium is particularly important to list here since, unlike macOS\n    // builds, Linux builds list Chromium in the userAgent along with Chrome:\n    //   e.g. Chromium/70.0.3538.77 Chrome/70.0.3538.77\n    'chromium',\n    'headlesschrome',\n  ],\n\n  // If a call to setMinimumBrowserVersions specifies Edge 12 as a minimum\n  // version, that means no version of Internet Explorer pre-Edge should\n  // be classified as modern. This edge:[\"ie\"] alias effectively enforces\n  // that logic, because there is no IE12. #9818 #9839\n  edge: ['ie'],\n\n  firefox: ['firefoxMobile'],\n\n  // The webapp package converts browser names to camel case, so\n  // mobile_safari and mobileSafari should be synonymous.\n  mobile_safari: ['mobileSafari', 'mobileSafariUI', 'mobileSafariUI/WKWebView'],\n};\n\n// Expand the given minimum versions by reusing chrome versions for\n// chromeMobile (according to browserAliases above).\nfunction applyAliases(versions) {\n  const lowerCaseVersions = Object.create(null);\n\n  Object.keys(versions).forEach(browser => {\n    lowerCaseVersions[browser.toLowerCase()] = versions[browser];\n  });\n\n  Object.keys(browserAliases).forEach(original => {\n    const aliases = browserAliases[original];\n    original = original.toLowerCase();\n\n    if (hasOwn.call(lowerCaseVersions, original)) {\n      aliases.forEach(alias => {\n        alias = alias.toLowerCase();\n        if (!hasOwn.call(lowerCaseVersions, alias)) {\n          lowerCaseVersions[alias] = lowerCaseVersions[original];\n        }\n      });\n    }\n  });\n\n  return lowerCaseVersions;\n}\n\n// TODO Should it be possible for callers to setMinimumBrowserVersions to\n// forbid any version of a particular browser?\n\n// Given a { name, major, minor, patch } object like the one provided by\n// webapp via request.browser, return true if that browser qualifies as\n// \"modern\" according to all requested version constraints.\nfunction isModern(browser) {\n  const lowerCaseName =\n    browser && typeof browser.name === 'string' && browser.name.toLowerCase();\n\n  return (\n    !!lowerCaseName &&\n    hasOwn.call(minimumVersions, lowerCaseName) &&\n    greaterThanOrEqualTo(\n      [~~browser.major, ~~browser.minor, ~~browser.patch],\n      minimumVersions[lowerCaseName].version\n    )\n  );\n}\n\n// Any package that depends on the modern-browsers package can call this\n// function to communicate its expectations for the minimum browser\n// versions that qualify as \"modern.\" The final decision between\n// web.browser.legacy and web.browser will be based on the maximum of all\n// requested minimum versions for each browser.\nfunction setMinimumBrowserVersions(versions, source) {\n  const lowerCaseVersions = applyAliases(versions);\n\n  Object.keys(lowerCaseVersions).forEach(lowerCaseName => {\n    const version = lowerCaseVersions[lowerCaseName];\n\n    if (\n      hasOwn.call(minimumVersions, lowerCaseName) &&\n      !greaterThan(version, minimumVersions[lowerCaseName].version)\n    ) {\n      return;\n    }\n\n    minimumVersions[lowerCaseName] = {\n      version: copy(version),\n      source: source || getCaller('setMinimumBrowserVersions'),\n    };\n  });\n}\n\nfunction getCaller(calleeName) {\n  const error = new Error();\n  Error.captureStackTrace(error);\n  const lines = error.stack.split('\\n');\n  let caller;\n  lines.some((line, i) => {\n    if (line.indexOf(calleeName) >= 0) {\n      caller = lines[i + 1].trim();\n      return true;\n    }\n  });\n  return caller;\n}\n\nObject.assign(exports, {\n  isModern,\n  setMinimumBrowserVersions,\n  calculateHashOfMinimumVersions() {\n    const { createHash } = require('crypto');\n    return createHash('sha1')\n      .update(JSON.stringify(minimumVersions))\n      .digest('hex');\n  },\n});\n\n// For making defensive copies of [major, minor, ...] version arrays, so\n// they don't change unexpectedly.\nfunction copy(version) {\n  if (typeof version === 'number') {\n    return version;\n  }\n\n  if (Array.isArray(version)) {\n    return version.map(copy);\n  }\n\n  return version;\n}\n\nfunction greaterThanOrEqualTo(a, b) {\n  return !greaterThan(b, a);\n}\n\nfunction greaterThan(a, b) {\n  const as = typeof a === 'number' ? [a] : a;\n  const bs = typeof b === 'number' ? [b] : b;\n  const maxLen = Math.max(as.length, bs.length);\n\n  for (let i = 0; i < maxLen; ++i) {\n    a = i < as.length ? as[i] : 0;\n    b = i < bs.length ? bs[i] : 0;\n\n    if (a > b) {\n      return true;\n    }\n\n    if (a < b) {\n      return false;\n    }\n  }\n\n  return false;\n}\n\nfunction makeSource(feature) {\n  return module.id + ' (' + feature + ')';\n}\n\nsetMinimumBrowserVersions(\n  {\n    chrome: 49,\n    edge: 12,\n    firefox: 45,\n    mobileSafari: [9, 2],\n    opera: 36,\n    safari: 9,\n    // Electron 1.0.0+ matches Chromium 49, per\n    // https://github.com/Kilian/electron-to-chromium/blob/master/full-versions.js\n    electron: 1,\n  },\n  makeSource('classes')\n);\n\nsetMinimumBrowserVersions(\n  {\n    chrome: 39,\n    edge: 13,\n    firefox: 26,\n    mobileSafari: 10,\n    opera: 26,\n    safari: 10,\n    // Disallow any version of PhantomJS.\n    phantomjs: Infinity,\n    electron: [0, 20],\n  },\n  makeSource('generator functions')\n);\n\nsetMinimumBrowserVersions(\n  {\n    chrome: 41,\n    edge: 13,\n    firefox: 34,\n    mobileSafari: [9, 2],\n    opera: 29,\n    safari: [9, 1],\n    electron: [0, 24],\n  },\n  makeSource('template literals')\n);\n\nsetMinimumBrowserVersions(\n  {\n    chrome: 38,\n    edge: 12,\n    firefox: 36,\n    mobileSafari: 9,\n    opera: 25,\n    safari: 9,\n    electron: [0, 20],\n  },\n  makeSource('symbols')\n);\n\n/////////////////////////////////////////////////////////////////////////////////////\n\n}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\n\nvar exports = require(\"/node_modules/meteor/modern-browsers/modern.js\");\n\n/* Exports */\nPackage._define(\"modern-browsers\", exports);\n\n})();\n","servePath":"/packages/modern-browsers.js"}]