[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\n\n/* Package-scope variables */\nvar makeInstaller, meteorInstall;\n\n///////////////////////////////////////////////////////////////////////////////\n//                                                                           //\n// packages/modules-runtime/.npm/package/node_modules/install/install.js     //\n// This file is in bare mode and is not in its own closure.                  //\n//                                                                           //\n///////////////////////////////////////////////////////////////////////////////\n                                                                             //\nmakeInstaller = function (options) {\n  \"use strict\";\n\n  options = options || {};\n\n  // These file extensions will be appended to required module identifiers\n  // if they do not exactly match an installed module.\n  var defaultExtensions = options.extensions || [\".js\", \".json\"];\n\n  // If defined, the options.fallback function will be called when no\n  // installed module is found for a required module identifier. Often\n  // options.fallback will be implemented in terms of the native Node\n  // require function, which has the ability to load binary modules.\n  var fallback = options.fallback;\n\n  // List of fields to look for in package.json files to determine the\n  // main entry module of the package. The first field listed here whose\n  // value is a string will be used to resolve the entry module.\n  var mainFields = options.mainFields ||\n    // If options.mainFields is absent and options.browser is truthy,\n    // package resolution will prefer the \"browser\" field of package.json\n    // files to the \"main\" field. Note that this only supports\n    // string-valued \"browser\" fields for now, though in the future it\n    // might make sense to support the object version, a la browserify.\n    (options.browser ? [\"browser\", \"main\"] : [\"main\"]);\n\n  var hasOwn = {}.hasOwnProperty;\n  function strictHasOwn(obj, key) {\n    return isObject(obj) && isString(key) && hasOwn.call(obj, key);\n  }\n\n  // Cache for looking up File objects given absolute module identifiers.\n  // Invariants:\n  //   filesByModuleId[module.id] === fileAppendId(root, module.id)\n  //   filesByModuleId[module.id].module === module\n  var filesByModuleId = {};\n\n  // The file object representing the root directory of the installed\n  // module tree.\n  var root = new File(\"/\", new File(\"/..\"));\n  var rootRequire = makeRequire(root);\n\n  // Merges the given tree of directories and module factory functions\n  // into the tree of installed modules and returns a require function\n  // that behaves as if called from a module in the root directory.\n  function install(tree, options) {\n    if (isObject(tree)) {\n      fileMergeContents(root, tree, options);\n    }\n    return rootRequire;\n  }\n\n  // Replace this function to enable Module.prototype.prefetch.\n  install.fetch = function (ids) {\n    throw new Error(\"fetch not implemented\");\n  };\n\n  // This constructor will be used to instantiate the module objects\n  // passed to module factory functions (i.e. the third argument after\n  // require and exports), and is exposed as install.Module in case the\n  // caller of makeInstaller wishes to modify Module.prototype.\n  function Module(id) {\n    this.id = id;\n\n    // The Node implementation of module.children unfortunately includes\n    // only those child modules that were imported for the first time by\n    // this parent module (i.e., child.parent === this).\n    this.children = [];\n\n    // This object is an install.js extension that includes all child\n    // modules imported by this module, even if this module is not the\n    // first to import them.\n    this.childrenById = {};\n  }\n\n  // Used to keep module.prefetch promise resolutions well-ordered.\n  var lastPrefetchPromise;\n\n  // May be shared by multiple sequential calls to module.prefetch.\n  // Initialized to {} only when necessary.\n  var missing;\n\n  Module.prototype.prefetch = function (id) {\n    var module = this;\n    var parentFile = getOwn(filesByModuleId, module.id);\n\n    lastPrefetchPromise = lastPrefetchPromise || Promise.resolve();\n    var previousPromise = lastPrefetchPromise;\n\n    function walk(module) {\n      var file = getOwn(filesByModuleId, module.id);\n      if (fileIsDynamic(file) && ! file.pending) {\n        file.pending = true;\n        missing = missing || {};\n\n        // These are the data that will be exposed to the install.fetch\n        // callback, so it's worth documenting each item with a comment.\n        missing[module.id] = {\n          // The CommonJS module object that will be exposed to this\n          // dynamic module when it is evaluated. Note that install.fetch\n          // could decide to populate module.exports directly, instead of\n          // fetching anything. In that case, install.fetch should omit\n          // this module from the tree that it produces.\n          module: file.module,\n          // List of module identifier strings imported by this module.\n          // Note that the missing object already contains all available\n          // dependencies (including transitive dependencies), so\n          // install.fetch should not need to traverse these dependencies\n          // in most cases; however, they may be useful for other reasons.\n          // Though the strings are unique, note that two different\n          // strings could resolve to the same module.\n          deps: Object.keys(file.deps),\n          // The options (if any) that were passed as the second argument\n          // to the install(tree, options) function when this stub was\n          // first registered. Typically contains options.extensions, but\n          // could contain any information appropriate for the entire tree\n          // as originally installed. These options will be automatically\n          // inherited by the newly fetched modules, so install.fetch\n          // should not need to modify them.\n          options: file.options,\n          // Any stub data included in the array notation from the\n          // original entry for this dynamic module. Typically contains\n          // \"main\" and/or \"browser\" fields for package.json files, and is\n          // otherwise undefined.\n          stub: file.stub\n        };\n\n        each(file.deps, function (parentId, id) {\n          fileResolve(file, id);\n        });\n\n        each(module.childrenById, walk);\n      }\n    }\n\n    return lastPrefetchPromise = new Promise(function (resolve) {\n      var absChildId = module.resolve(id);\n      each(module.childrenById, walk);\n      resolve(absChildId);\n\n    }).then(function (absChildId) {\n      // Grab the current missing object and fetch its contents.\n      var toBeFetched = missing;\n      missing = null;\n\n      function clearPending() {\n        if (toBeFetched) {\n          Object.keys(toBeFetched).forEach(function (id) {\n            getOwn(filesByModuleId, id).pending = false;\n          });\n        }\n      }\n\n      return new Promise(function (resolve) {\n        // The install.fetch function takes an object mapping missing\n        // dynamic module identifiers to options objects, and should\n        // return a Promise that resolves to a module tree that can be\n        // installed. As an optimization, if there were no missing dynamic\n        // modules, then we can skip calling install.fetch entirely.\n        resolve(toBeFetched && install.fetch(toBeFetched));\n\n      }).then(function (tree) {\n        function both() {\n          install(tree);\n          clearPending();\n          return absChildId;\n        }\n\n        // Although we want multiple install.fetch calls to run in\n        // parallel, it is important that the promises returned by\n        // module.prefetch are resolved in the same order as the original\n        // calls to module.prefetch, because previous fetches may include\n        // modules assumed to exist by more recent module.prefetch calls.\n        // Whether previousPromise was resolved or rejected, carry on with\n        // the installation regardless.\n        return previousPromise.then(both, both);\n\n      }, function (error) {\n        // Fixes https://github.com/meteor/meteor/issues/10182.\n        clearPending();\n        throw error;\n      });\n    });\n  };\n\n  install.Module = Module;\n\n  function getOwn(obj, key) {\n    return strictHasOwn(obj, key) && obj[key];\n  }\n\n  function isObject(value) {\n    return value !== null && typeof value === \"object\";\n  }\n\n  function isFunction(value) {\n    return typeof value === \"function\";\n  }\n\n  function isString(value) {\n    return typeof value === \"string\";\n  }\n\n  function makeMissingError(id) {\n    return new Error(\"Cannot find module '\" + id + \"'\");\n  }\n\n  Module.prototype.resolve = function (id) {\n    var file = fileResolve(filesByModuleId[this.id], id);\n    if (file) return file.module.id;\n    var error = makeMissingError(id);\n    if (fallback && isFunction(fallback.resolve)) {\n      return fallback.resolve(id, this.id, error);\n    }\n    throw error;\n  };\n\n  Module.prototype.require = function require(id) {\n    var result = fileResolve(filesByModuleId[this.id], id);\n    if (result) {\n      return fileEvaluate(result, this);\n    }\n\n    var error = makeMissingError(id);\n\n    if (isFunction(fallback)) {\n      return fallback(\n        id, // The missing module identifier.\n        this.id, // ID of the parent module.\n        error // The error we would have thrown.\n      );\n    }\n\n    throw error;\n  };\n\n  function makeRequire(file) {\n    var module = file.module;\n\n    function require(id) {\n      return module.require(id);\n    }\n\n    require.extensions = fileGetExtensions(file).slice(0);\n\n    require.resolve = function resolve(id) {\n      return module.resolve(id);\n    };\n\n    return require;\n  }\n\n  // File objects represent either directories or modules that have been\n  // installed. When a `File` respresents a directory, its `.contents`\n  // property is an object containing the names of the files (or\n  // directories) that it contains. When a `File` represents a module, its\n  // `.contents` property is a function that can be invoked with the\n  // appropriate `(require, exports, module)` arguments to evaluate the\n  // module. If the `.contents` property is a string, that string will be\n  // resolved as a module identifier, and the exports of the resulting\n  // module will provide the exports of the original file. The `.parent`\n  // property of a File is either a directory `File` or `null`. Note that\n  // a child may claim another `File` as its parent even if the parent\n  // does not have an entry for that child in its `.contents` object.\n  // This is important for implementing anonymous files, and preventing\n  // child modules from using `../relative/identifier` syntax to examine\n  // unrelated modules.\n  function File(moduleId, parent) {\n    var file = this;\n\n    // Link to the parent file.\n    file.parent = parent = parent || null;\n\n    // The module object for this File, which will eventually boast an\n    // .exports property when/if the file is evaluated.\n    file.module = new Module(moduleId);\n    filesByModuleId[moduleId] = file;\n\n    // The .contents of the file can be either (1) an object, if the file\n    // represents a directory containing other files; (2) a factory\n    // function, if the file represents a module that can be imported; (3)\n    // a string, if the file is an alias for another file; or (4) null, if\n    // the file's contents are not (yet) available.\n    file.contents = null;\n\n    // Set of module identifiers imported by this module. Note that this\n    // set is not necessarily complete, so don't rely on it unless you\n    // know what you're doing.\n    file.deps = {};\n  }\n\n  function fileEvaluate(file, parentModule) {\n    var module = file.module;\n    if (! strictHasOwn(module, \"exports\")) {\n      var contents = file.contents;\n      if (! contents) {\n        // If this file was installed with array notation, and the array\n        // contained one or more objects but no functions, then the combined\n        // properties of the objects are treated as a temporary stub for\n        // file.module.exports. This is particularly important for partial\n        // package.json modules, so that the resolution logic can know the\n        // value of the \"main\" and/or \"browser\" fields, at least, even if\n        // the rest of the package.json file is not (yet) available.\n        if (file.stub) {\n          return file.stub;\n        }\n\n        throw makeMissingError(module.id);\n      }\n\n      if (parentModule) {\n        module.parent = parentModule;\n        var children = parentModule.children;\n        if (Array.isArray(children)) {\n          children.push(module);\n        }\n      }\n\n      contents(\n        makeRequire(file),\n        // If the file had a .stub, reuse the same object for exports.\n        module.exports = file.stub || {},\n        module,\n        file.module.id,\n        file.parent.module.id\n      );\n\n      module.loaded = true;\n    }\n\n    // The module.runModuleSetters method will be deprecated in favor of\n    // just module.runSetters: https://github.com/benjamn/reify/pull/160\n    var runSetters = module.runSetters || module.runModuleSetters;\n    if (isFunction(runSetters)) {\n      runSetters.call(module);\n    }\n\n    return module.exports;\n  }\n\n  function fileIsDirectory(file) {\n    return file && isObject(file.contents);\n  }\n\n  function fileIsDynamic(file) {\n    return file && file.contents === null;\n  }\n\n  function fileMergeContents(file, contents, options) {\n    if (Array.isArray(contents)) {\n      contents.forEach(function (item) {\n        if (isString(item)) {\n          file.deps[item] = file.module.id;\n        } else if (isFunction(item)) {\n          contents = item;\n        } else if (isObject(item)) {\n          file.stub = file.stub || {};\n          each(item, function (value, key) {\n            file.stub[key] = value;\n          });\n        }\n      });\n\n      if (! isFunction(contents)) {\n        // If the array did not contain a function, merge nothing.\n        contents = null;\n      }\n\n    } else if (! isFunction(contents) &&\n               ! isString(contents) &&\n               ! isObject(contents)) {\n      // If contents is neither an array nor a function nor a string nor\n      // an object, just give up and merge nothing.\n      contents = null;\n    }\n\n    if (contents) {\n      file.contents = file.contents || (isObject(contents) ? {} : contents);\n      if (isObject(contents) && fileIsDirectory(file)) {\n        each(contents, function (value, key) {\n          if (key === \"..\") {\n            child = file.parent;\n\n          } else {\n            var child = getOwn(file.contents, key);\n\n            if (! child) {\n              child = file.contents[key] = new File(\n                file.module.id.replace(/\\/*$/, \"/\") + key,\n                file\n              );\n\n              child.options = options;\n            }\n          }\n\n          fileMergeContents(child, value, options);\n        });\n      }\n    }\n  }\n\n  function each(obj, callback, context) {\n    Object.keys(obj).forEach(function (key) {\n      callback.call(this, obj[key], key);\n    }, context);\n  }\n\n  function fileGetExtensions(file) {\n    return file.options\n      && file.options.extensions\n      || defaultExtensions;\n  }\n\n  function fileAppendIdPart(file, part, extensions) {\n    // Always append relative to a directory.\n    while (file && ! fileIsDirectory(file)) {\n      file = file.parent;\n    }\n\n    if (! file || ! part || part === \".\") {\n      return file;\n    }\n\n    if (part === \"..\") {\n      return file.parent;\n    }\n\n    var exactChild = getOwn(file.contents, part);\n\n    // Only consider multiple file extensions if this part is the last\n    // part of a module identifier and not equal to `.` or `..`, and there\n    // was no exact match or the exact match was a directory.\n    if (extensions && (! exactChild || fileIsDirectory(exactChild))) {\n      for (var e = 0; e < extensions.length; ++e) {\n        var child = getOwn(file.contents, part + extensions[e]);\n        if (child && ! fileIsDirectory(child)) {\n          return child;\n        }\n      }\n    }\n\n    return exactChild;\n  }\n\n  function fileAppendId(file, id, extensions) {\n    var parts = id.split(\"/\");\n\n    // Use `Array.prototype.every` to terminate iteration early if\n    // `fileAppendIdPart` returns a falsy value.\n    parts.every(function (part, i) {\n      return file = i < parts.length - 1\n        ? fileAppendIdPart(file, part)\n        : fileAppendIdPart(file, part, extensions);\n    });\n\n    return file;\n  }\n\n  function recordChild(parentModule, childFile) {\n    var childModule = childFile && childFile.module;\n    if (parentModule && childModule) {\n      parentModule.childrenById[childModule.id] = childModule;\n    }\n  }\n\n  function fileResolve(file, id, parentModule, seenDirFiles) {\n    var parentModule = parentModule || file.module;\n    var extensions = fileGetExtensions(file);\n\n    file =\n      // Absolute module identifiers (i.e. those that begin with a `/`\n      // character) are interpreted relative to the root directory, which\n      // is a slight deviation from Node, which has access to the entire\n      // file system.\n      id.charAt(0) === \"/\" ? fileAppendId(root, id, extensions) :\n      // Relative module identifiers are interpreted relative to the\n      // current file, naturally.\n      id.charAt(0) === \".\" ? fileAppendId(file, id, extensions) :\n      // Top-level module identifiers are interpreted as referring to\n      // packages in `node_modules` directories.\n      nodeModulesLookup(file, id, extensions);\n\n    // If the identifier resolves to a directory, we use the same logic as\n    // Node to find an `index.js` or `package.json` file to evaluate.\n    while (fileIsDirectory(file)) {\n      seenDirFiles = seenDirFiles || [];\n\n      // If the \"main\" field of a `package.json` file resolves to a\n      // directory we've already considered, then we should not attempt to\n      // read the same `package.json` file again. Using an array as a set\n      // is acceptable here because the number of directories to consider\n      // is rarely greater than 1 or 2. Also, using indexOf allows us to\n      // store File objects instead of strings.\n      if (seenDirFiles.indexOf(file) < 0) {\n        seenDirFiles.push(file);\n\n        var pkgJsonFile = fileAppendIdPart(file, \"package.json\");\n        var pkg = pkgJsonFile && fileEvaluate(pkgJsonFile, parentModule);\n        var mainFile, resolved = pkg && mainFields.some(function (name) {\n          var main = pkg[name];\n          if (isString(main)) {\n            // The \"main\" field of package.json does not have to begin\n            // with ./ to be considered relative, so first we try\n            // simply appending it to the directory path before\n            // falling back to a full fileResolve, which might return\n            // a package from a node_modules directory.\n            return mainFile = fileAppendId(file, main, extensions) ||\n              fileResolve(file, main, parentModule, seenDirFiles);\n          }\n        });\n\n        if (resolved && mainFile) {\n          file = mainFile;\n          recordChild(parentModule, pkgJsonFile);\n          // The fileAppendId call above may have returned a directory,\n          // so continue the loop to make sure we resolve it to a\n          // non-directory file.\n          continue;\n        }\n      }\n\n      // If we didn't find a `package.json` file, or it didn't have a\n      // resolvable `.main` property, the only possibility left to\n      // consider is that this directory contains an `index.js` module.\n      // This assignment almost always terminates the while loop, because\n      // there's very little chance `fileIsDirectory(file)` will be true\n      // for `fileAppendIdPart(file, \"index\", extensions)`. However, in\n      // principle it is remotely possible that a file called `index.js`\n      // could be a directory instead of a file.\n      file = fileAppendIdPart(file, \"index\", extensions);\n    }\n\n    if (file && isString(file.contents)) {\n      file = fileResolve(file, file.contents, parentModule, seenDirFiles);\n    }\n\n    recordChild(parentModule, file);\n\n    return file;\n  };\n\n  function nodeModulesLookup(file, id, extensions) {\n    for (var resolved; file && ! resolved; file = file.parent) {\n      resolved = fileIsDirectory(file) &&\n        fileAppendId(file, \"node_modules/\" + id, extensions);\n    }\n    return resolved;\n  }\n\n  return install;\n};\n\nif (typeof exports === \"object\") {\n  exports.makeInstaller = makeInstaller;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////\n//                                                                           //\n// packages/modules-runtime/modern.js                                        //\n//                                                                           //\n///////////////////////////////////////////////////////////////////////////////\n                                                                             //\nmeteorInstall = makeInstaller({\n  // On the client, make package resolution prefer the \"browser\" field of\n  // package.json over the \"module\" field over the \"main\" field.\n  browser: true,\n  mainFields: [\"browser\", \"module\", \"main\"],\n\n  fallback: function(id, parentId, error) {\n    if (id && id.startsWith('meteor/')) {\n      var packageName = id.split('/', 2)[1];\n      throw new Error(\n        'Cannot find package \"' + packageName + '\". ' +\n          'Try \"meteor add ' + packageName + '\".'\n      );\n    }\n\n    throw error;\n  }\n});\n\n///////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////\n//                                                                           //\n// packages/modules-runtime/legacy.js                                        //\n//                                                                           //\n///////////////////////////////////////////////////////////////////////////////\n                                                                             //\nmeteorInstall = makeInstaller({\n  // On the client, make package resolution prefer the \"browser\" field of\n  // package.json over the \"module\" field over the \"main\" field.\n  browser: true,\n\n  // The difference between legacy.js and modern.js is that this module\n  // prefers \"main\" over \"module\" (see issue #10658).\n  mainFields: [\"browser\", \"main\", \"module\"],\n\n  fallback: function(id, parentId, error) {\n    if (id && id.startsWith('meteor/')) {\n      var packageName = id.split('/', 2)[1];\n      throw new Error(\n        'Cannot find package \"' + packageName + '\". ' +\n          'Try \"meteor add ' + packageName + '\".'\n      );\n    }\n\n    throw error;\n  }\n});\n\n///////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////\n//                                                                           //\n// packages/modules-runtime/profile.js                                       //\n//                                                                           //\n///////////////////////////////////////////////////////////////////////////////\n                                                                             //\nif (typeof Profile === \"function\" &&\n    process.env.METEOR_PROFILE) {\n  var Mp = meteorInstall.Module.prototype;\n  Mp.require = Profile(function (id) {\n    return \"require(\" + JSON.stringify(id) + \")\";\n  }, Mp.require);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nPackage._define(\"modules-runtime\", {\n  meteorInstall: meteorInstall\n});\n\n})();\n","servePath":"/packages/modules-runtime.js"}]