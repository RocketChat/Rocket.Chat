{"code":"function module(t,r,e){/*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Licensed under the MIT License.\n */\"use strict\";let n=t(\"util\"),i=t(\"to-regex-range\"),a=t=>null!==t&&\"object\"==typeof t&&!Array.isArray(t),s=t=>r=>!0===t?Number(r):String(r),o=t=>\"number\"==typeof t||\"string\"==typeof t&&\"\"!==t,u=t=>Number.isInteger(+t),g=t=>{let r=`${t}`,e=-1;if(\"-\"===r[0]&&(r=r.slice(1)),\"0\"===r)return!1;for(;\"0\"===r[++e];);return e>0},l=(t,r,e)=>\"string\"==typeof t||\"string\"==typeof r||!0===e.stringify,f=(t,r,e)=>{if(r>0){let e=\"-\"===t[0]?\"-\":\"\";e&&(t=t.slice(1)),t=e+t.padStart(e?r-1:r,\"0\")}return!1===e?String(t):t},p=(t,r)=>{let e=\"-\"===t[0]?\"-\":\"\";for(e&&(t=t.slice(1),r--);t.length<r;)t=\"0\"+t;return e?\"-\"+t:t},h=(t,r)=>{let e;t.negatives.sort((t,r)=>t<r?-1:t>r?1:0),t.positives.sort((t,r)=>t<r?-1:t>r?1:0);let n=r.capture?\"\":\"?:\",i=\"\",a=\"\";return(t.positives.length&&(i=t.positives.join(\"|\")),t.negatives.length&&(a=`-(${n}${t.negatives.join(\"|\")})`),e=i&&a?`${i}|${a}`:i||a,r.wrap)?`(${n}${e})`:e},m=(t,r,e,n)=>{if(e)return i(t,r,{wrap:!1,...n});let a=String.fromCharCode(t);if(t===r)return a;let s=String.fromCharCode(r);return`[${a}-${s}]`},c=(t,r,e)=>{if(Array.isArray(t)){let r=!0===e.wrap,n=e.capture?\"\":\"?:\";return r?`(${n}${t.join(\"|\")})`:t.join(\"|\")}return i(t,r,e)},$=(...t)=>RangeError(\"Invalid range arguments: \"+n.inspect(...t)),b=(t,r,e)=>{if(!0===e.strictRanges)throw $([t,r]);return[]},x=(t,r)=>{if(!0===r.strictRanges)throw TypeError(`Expected step \"${t}\" to be a number`);return[]},y=(t,r,e=1,n={})=>{let i=Number(t),a=Number(r);if(!Number.isInteger(i)||!Number.isInteger(a)){if(!0===n.strictRanges)throw $([t,r]);return[]}0===i&&(i=0),0===a&&(a=0);let o=i>a,u=String(t),b=String(r),x=String(e);e=Math.max(Math.abs(e),1);let y=g(u)||g(b)||g(x),v=y?Math.max(u.length,b.length,x.length):0,d=!1===y&&!1===l(t,r,n),w=n.transform||s(d);if(n.toRegex&&1===e)return m(p(t,v),p(r,v),!0,n);let R={negatives:[],positives:[]},S=t=>R[t<0?\"negatives\":\"positives\"].push(Math.abs(t)),C=[],M=0;for(;o?i>=a:i<=a;)!0===n.toRegex&&e>1?S(i):C.push(f(w(i,M),v,d)),i=o?i-e:i+e,M++;return!0===n.toRegex?e>1?h(R,n):c(C,null,{wrap:!1,...n}):C},v=(t,r,e=1,n={})=>{if(!u(t)&&t.length>1||!u(r)&&r.length>1)return b(t,r,n);let i=n.transform||(t=>String.fromCharCode(t)),a=`${t}`.charCodeAt(0),s=`${r}`.charCodeAt(0),o=a>s,g=Math.min(a,s),l=Math.max(a,s);if(n.toRegex&&1===e)return m(g,l,!1,n);let f=[],p=0;for(;o?a>=s:a<=s;)f.push(i(a,p)),a=o?a-e:a+e,p++;return!0===n.toRegex?c(f,null,{wrap:!1,options:n}):f},d=(t,r,e,n={})=>{if(null==r&&o(t))return[t];if(!o(t)||!o(r))return b(t,r,n);if(\"function\"==typeof e)return d(t,r,1,{transform:e});if(a(e))return d(t,r,0,e);let i={...n};return(!0===i.capture&&(i.wrap=!0),u(e=e||i.step||1))?u(t)&&u(r)?y(t,r,e,i):v(t,r,Math.max(Math.abs(e),1),i):null==e||a(e)?d(t,r,1,e):x(e,i)};e.exports=d}","map":"{\"version\":3,\"sources\":[\"<anon>\"],\"names\":[],\"mappings\":\"\"}"}