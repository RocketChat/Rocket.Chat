{"code":"function module(t,e,r){\"use strict\";let n=t(\"util\"),o=t(\"braces\"),a=t(\"picomatch\"),s=t(\"picomatch/lib/utils\"),c=t=>\"\"===t||\"./\"===t,i=(t,e,r)=>{e=[].concat(e),t=[].concat(t);let n=new Set,o=new Set,s=new Set,c=0,i=t=>{s.add(t.output),r&&r.onResult&&r.onResult(t)};for(let s=0;s<e.length;s++){let l=a(String(e[s]),{...r,onResult:i},!0),u=l.state.negated||l.state.negatedExtglob;for(let e of(u&&c++,t)){let t=l(e,!0);(u?!t.isMatch:t.isMatch)&&(u?n.add(t.output):(n.delete(t.output),o.add(t.output)))}}let l=(c===e.length?[...s]:[...o]).filter(t=>!n.has(t));if(r&&0===l.length){if(!0===r.failglob)throw Error(`No matches found for \"${e.join(\", \")}\"`);if(!0===r.nonull||!0===r.nullglob)return r.unescape?e.map(t=>t.replace(/\\\\/g,\"\")):e}return l};i.match=i,i.matcher=(t,e)=>a(t,e),i.isMatch=(t,e,r)=>a(e,r)(t),i.any=i.isMatch,i.not=(t,e,r={})=>{e=[].concat(e).map(String);let n=new Set,o=[],a=new Set(i(t,e,{...r,onResult:t=>{r.onResult&&r.onResult(t),o.push(t.output)}}));for(let t of o)a.has(t)||n.add(t);return[...n]},i.contains=(t,e,r)=>{if(\"string\"!=typeof t)throw TypeError(`Expected a string: \"${n.inspect(t)}\"`);if(Array.isArray(e))return e.some(e=>i.contains(t,e,r));if(\"string\"==typeof e){if(c(t)||c(e))return!1;if(t.includes(e)||t.startsWith(\"./\")&&t.slice(2).includes(e))return!0}return i.isMatch(t,e,{...r,contains:!0})},i.matchKeys=(t,e,r)=>{if(!s.isObject(t))throw TypeError(\"Expected the first argument to be an object\");let n=i(Object.keys(t),e,r),o={};for(let e of n)o[e]=t[e];return o},i.some=(t,e,r)=>{let n=[].concat(t);for(let t of[].concat(e)){let e=a(String(t),r);if(n.some(t=>e(t)))return!0}return!1},i.every=(t,e,r)=>{let n=[].concat(t);for(let t of[].concat(e)){let e=a(String(t),r);if(!n.every(t=>e(t)))return!1}return!0},i.all=(t,e,r)=>{if(\"string\"!=typeof t)throw TypeError(`Expected a string: \"${n.inspect(t)}\"`);return[].concat(e).every(e=>a(e,r)(t))},i.capture=(t,e,r)=>{let n=s.isWindows(r),o=a.makeRe(String(t),{...r,capture:!0}).exec(n?s.toPosixSlashes(e):e);if(o)return o.slice(1).map(t=>void 0===t?\"\":t)},i.makeRe=(...t)=>a.makeRe(...t),i.scan=(...t)=>a.scan(...t),i.parse=(t,e)=>{let r=[];for(let n of[].concat(t||[]))for(let t of o(String(n),e))r.push(a.parse(t,e));return r},i.braces=(t,e)=>{if(\"string\"!=typeof t)throw TypeError(\"Expected a string\");return e&&!0===e.nobrace||!/\\{.*\\}/.test(t)?[t]:o(t,e)},i.braceExpand=(t,e)=>{if(\"string\"!=typeof t)throw TypeError(\"Expected a string\");return i.braces(t,{...e,expand:!0})},r.exports=i}","map":"{\"version\":3,\"sources\":[\"<anon>\"],\"names\":[],\"mappings\":\"\"}"}