{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/ddp-server/writefence.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.arm64"},"sourceFileName":"packages/ddp-server/writefence.js","filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/ddp-server/writefence.js","targets":{"android":"125.0.0","chrome":"125.0.0","edge":"125.0.0","firefox":"115.0.0","ie":"10.0.0","ios":"17.4.0","opera":"110.0.0","opera_mobile":"80.0.0","safari":"17.4.0","samsung":"24.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","root":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true,"topLevelAwait":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/ddp-server/writefence.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/ddp-server/writefence.js"}},"code":"// A write fence collects a group of writes, and provides a callback\n// when all of the writes are fully committed and propagated (all\n// observers have been notified of the write and acknowledged it.)\n//\nDDPServer._WriteFence = class {\n  constructor() {\n    this.armed = false;\n    this.fired = false;\n    this.retired = false;\n    this.outstanding_writes = 0;\n    this.before_fire_callbacks = [];\n    this.completion_callbacks = [];\n  }\n\n  // Start tracking a write, and return an object to represent it. The\n  // object has a single method, committed(). This method should be\n  // called when the write is fully committed and propagated. You can\n  // continue to add writes to the WriteFence up until it is triggered\n  // (calls its callbacks because all writes have committed.)\n  beginWrite() {\n    if (this.retired) return {\n      committed: function () {}\n    };\n    if (this.fired) throw new Error(\"fence has already activated -- too late to add writes\");\n    this.outstanding_writes++;\n    let committed = false;\n    const _committedFn = async () => {\n      if (committed) throw new Error(\"committed called twice on the same write\");\n      committed = true;\n      this.outstanding_writes--;\n      await this._maybeFire();\n    };\n    return {\n      committed: _committedFn\n    };\n  }\n\n  // Arm the fence. Once the fence is armed, and there are no more\n  // uncommitted writes, it will activate.\n  arm() {\n    if (this === DDPServer._getCurrentFence()) throw Error(\"Can't arm the current fence\");\n    this.armed = true;\n    return this._maybeFire();\n  }\n\n  // Register a function to be called once before firing the fence.\n  // Callback function can add new writes to the fence, in which case\n  // it won't fire until those writes are done as well.\n  onBeforeFire(func) {\n    if (this.fired) throw new Error(\"fence has already activated -- too late to \" + \"add a callback\");\n    this.before_fire_callbacks.push(func);\n  }\n\n  // Register a function to be called when the fence fires.\n  onAllCommitted(func) {\n    if (this.fired) throw new Error(\"fence has already activated -- too late to \" + \"add a callback\");\n    this.completion_callbacks.push(func);\n  }\n  async _armAndWait() {\n    let resolver;\n    const returnValue = new Promise(r => resolver = r);\n    this.onAllCommitted(resolver);\n    await this.arm();\n    return returnValue;\n  }\n  // Convenience function. Arms the fence, then blocks until it fires.\n  async armAndWait() {\n    return this._armAndWait();\n  }\n  async _maybeFire() {\n    if (this.fired) throw new Error(\"write fence already activated?\");\n    if (this.armed && !this.outstanding_writes) {\n      const invokeCallback = async func => {\n        try {\n          await func(this);\n        } catch (err) {\n          Meteor._debug(\"exception in write fence callback:\", err);\n        }\n      };\n      this.outstanding_writes++;\n      while (this.before_fire_callbacks.length > 0) {\n        const cb = this.before_fire_callbacks.shift();\n        await invokeCallback(cb);\n      }\n      this.outstanding_writes--;\n      if (!this.outstanding_writes) {\n        this.fired = true;\n        const callbacks = this.completion_callbacks || [];\n        this.completion_callbacks = [];\n        while (callbacks.length > 0) {\n          const cb = callbacks.shift();\n          await invokeCallback(cb);\n        }\n      }\n    }\n  }\n\n  // Deactivate this fence so that adding more writes has no effect.\n  // The fence must have already fired.\n  retire() {\n    if (!this.fired) throw new Error(\"Can't retire a fence that hasn't fired.\");\n    this.retired = true;\n  }\n};\n\n// The current write fence. When there is a current write fence, code\n// that writes to databases should register their writes with it using\n// beginWrite().\n//\nDDPServer._CurrentWriteFence = new Meteor.EnvironmentVariable();","map":{"version":3,"names":["DDPServer","_WriteFence","constructor","armed","fired","retired","outstanding_writes","before_fire_callbacks","completion_callbacks","beginWrite","committed","Error","_committedFn","_maybeFire","arm","_getCurrentFence","onBeforeFire","func","push","onAllCommitted","_armAndWait","resolver","returnValue","Promise","r","armAndWait","invokeCallback","err","Meteor","_debug","length","cb","shift","callbacks","retire","_CurrentWriteFence","EnvironmentVariable"],"sources":["packages/ddp-server/writefence.js"],"sourcesContent":["// A write fence collects a group of writes, and provides a callback\n// when all of the writes are fully committed and propagated (all\n// observers have been notified of the write and acknowledged it.)\n//\nDDPServer._WriteFence = class {\n  constructor() {\n    this.armed = false;\n    this.fired = false;\n    this.retired = false;\n    this.outstanding_writes = 0;\n    this.before_fire_callbacks = [];\n    this.completion_callbacks = [];\n  }\n\n  // Start tracking a write, and return an object to represent it. The\n  // object has a single method, committed(). This method should be\n  // called when the write is fully committed and propagated. You can\n  // continue to add writes to the WriteFence up until it is triggered\n  // (calls its callbacks because all writes have committed.)\n  beginWrite() {\n    if (this.retired)\n      return { committed: function () {} };\n\n    if (this.fired)\n      throw new Error(\"fence has already activated -- too late to add writes\");\n\n    this.outstanding_writes++;\n    let committed = false;\n    const _committedFn = async () => {\n      if (committed)\n        throw new Error(\"committed called twice on the same write\");\n      committed = true;\n      this.outstanding_writes--;\n      await this._maybeFire();\n    };\n\n    return {\n      committed: _committedFn,\n    };\n  }\n\n  // Arm the fence. Once the fence is armed, and there are no more\n  // uncommitted writes, it will activate.\n  arm() {\n\n    if (this === DDPServer._getCurrentFence())\n      throw Error(\"Can't arm the current fence\");\n    this.armed = true;\n    return this._maybeFire();\n  }\n\n  // Register a function to be called once before firing the fence.\n  // Callback function can add new writes to the fence, in which case\n  // it won't fire until those writes are done as well.\n  onBeforeFire(func) {\n    if (this.fired)\n      throw new Error(\"fence has already activated -- too late to \" +\n          \"add a callback\");\n    this.before_fire_callbacks.push(func);\n  }\n\n  // Register a function to be called when the fence fires.\n  onAllCommitted(func) {\n    if (this.fired)\n      throw new Error(\"fence has already activated -- too late to \" +\n          \"add a callback\");\n    this.completion_callbacks.push(func);\n  }\n\n  async _armAndWait() {\n    let resolver;\n    const returnValue = new Promise(r => resolver = r);\n    this.onAllCommitted(resolver);\n    await this.arm();\n\n    return returnValue;\n  }\n  // Convenience function. Arms the fence, then blocks until it fires.\n  async armAndWait() {\n    return this._armAndWait();\n  }\n\n  async _maybeFire() {\n    if (this.fired)\n      throw new Error(\"write fence already activated?\");\n    if (this.armed && !this.outstanding_writes) {\n      const invokeCallback = async (func) => {\n        try {\n          await func(this);\n        } catch (err) {\n          Meteor._debug(\"exception in write fence callback:\", err);\n        }\n      };\n\n      this.outstanding_writes++;\n      while (this.before_fire_callbacks.length > 0) {\n        const cb = this.before_fire_callbacks.shift();\n        await invokeCallback(cb);\n      }\n      this.outstanding_writes--;\n\n      if (!this.outstanding_writes) {\n        this.fired = true;\n        const callbacks = this.completion_callbacks || [];\n        this.completion_callbacks = [];\n        while (callbacks.length > 0) {\n          const cb = callbacks.shift();\n          await invokeCallback(cb);\n        }\n      }\n    }\n  }\n\n  // Deactivate this fence so that adding more writes has no effect.\n  // The fence must have already fired.\n  retire() {\n    if (!this.fired)\n      throw new Error(\"Can't retire a fence that hasn't fired.\");\n    this.retired = true;\n  }\n};\n\n// The current write fence. When there is a current write fence, code\n// that writes to databases should register their writes with it using\n// beginWrite().\n//\nDDPServer._CurrentWriteFence = new Meteor.EnvironmentVariable;\n"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"d1dcb6300f3c39cc5253dcfcacb02d3c134436aa"}
