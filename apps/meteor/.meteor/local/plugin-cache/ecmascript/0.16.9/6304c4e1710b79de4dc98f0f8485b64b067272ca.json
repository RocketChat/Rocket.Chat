{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/ddp-server/livedata_server.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.arm64"},"sourceFileName":"packages/ddp-server/livedata_server.js","filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/ddp-server/livedata_server.js","targets":{"android":"125.0.0","chrome":"125.0.0","edge":"125.0.0","firefox":"115.0.0","ie":"10.0.0","ios":"17.4.0","opera":"110.0.0","opera_mobile":"80.0.0","safari":"17.4.0","samsung":"24.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","root":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true,"topLevelAwait":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/ddp-server/livedata_server.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/ddp-server/livedata_server.js"}},"code":"!module.wrapAsync(async function (module, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    let _objectSpread;\n    module.link(\"@babel/runtime/helpers/objectSpread2\", {\n      default(v) {\n        _objectSpread = v;\n      }\n    }, 0);\n    let isEmpty;\n    module.link(\"lodash.isempty\", {\n      default(v) {\n        isEmpty = v;\n      }\n    }, 0);\n    let isString;\n    module.link(\"lodash.isstring\", {\n      default(v) {\n        isString = v;\n      }\n    }, 1);\n    let isObject;\n    module.link(\"lodash.isobject\", {\n      default(v) {\n        isObject = v;\n      }\n    }, 2);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    DDPServer = {};\n\n    // Publication strategies define how we handle data from published cursors at the collection level\n    // This allows someone to:\n    // - Choose a trade-off between client-server bandwidth and server memory usage\n    // - Implement special (non-mongo) collections like volatile message queues\n    const publicationStrategies = {\n      // SERVER_MERGE is the default strategy.\n      // When using this strategy, the server maintains a copy of all data a connection is subscribed to.\n      // This allows us to only send deltas over multiple publications.\n      SERVER_MERGE: {\n        useDummyDocumentView: false,\n        useCollectionView: true,\n        doAccountingForCollection: true\n      },\n      // The NO_MERGE_NO_HISTORY strategy results in the server sending all publication data\n      // directly to the client. It does not remember what it has previously sent\n      // to it will not trigger removed messages when a subscription is stopped.\n      // This should only be chosen for special use cases like send-and-forget queues.\n      NO_MERGE_NO_HISTORY: {\n        useDummyDocumentView: false,\n        useCollectionView: false,\n        doAccountingForCollection: false\n      },\n      // NO_MERGE is similar to NO_MERGE_NO_HISTORY but the server will remember the IDs it has\n      // sent to the client so it can remove them when a subscription is stopped.\n      // This strategy can be used when a collection is only used in a single publication.\n      NO_MERGE: {\n        useDummyDocumentView: false,\n        useCollectionView: false,\n        doAccountingForCollection: true\n      },\n      // NO_MERGE_MULTI is similar to `NO_MERGE`, but it does track whether a document is\n      // used by multiple publications. This has some memory overhead, but it still does not do\n      // diffing so it's faster and slimmer than SERVER_MERGE.\n      NO_MERGE_MULTI: {\n        useDummyDocumentView: true,\n        useCollectionView: true,\n        doAccountingForCollection: true\n      }\n    };\n    DDPServer.publicationStrategies = publicationStrategies;\n\n    // This file contains classes:\n    // * Session - The server's connection to a single DDP client\n    // * Subscription - A single subscription for a single client\n    // * Server - An entire server that may talk to > 1 client. A DDP endpoint.\n    //\n    // Session and Subscription are file scope. For now, until we freeze\n    // the interface, Server is package scope (in the future it should be\n    // exported).\n    var DummyDocumentView = function () {\n      var self = this;\n      self.existsIn = new Set(); // set of subscriptionHandle\n      self.dataByKey = new Map(); // key-> [ {subscriptionHandle, value} by precedence]\n    };\n    Object.assign(DummyDocumentView.prototype, {\n      getFields: function () {\n        return {};\n      },\n      clearField: function (subscriptionHandle, key, changeCollector) {\n        changeCollector[key] = undefined;\n      },\n      changeField: function (subscriptionHandle, key, value, changeCollector, isAdd) {\n        changeCollector[key] = value;\n      }\n    });\n\n    // Represents a single document in a SessionCollectionView\n    var SessionDocumentView = function () {\n      var self = this;\n      self.existsIn = new Set(); // set of subscriptionHandle\n      self.dataByKey = new Map(); // key-> [ {subscriptionHandle, value} by precedence]\n    };\n    DDPServer._SessionDocumentView = SessionDocumentView;\n    DDPServer._getCurrentFence = function () {\n      let currentInvocation = this._CurrentWriteFence.get();\n      if (currentInvocation) {\n        return currentInvocation;\n      }\n      currentInvocation = DDP._CurrentMethodInvocation.get();\n      return currentInvocation ? currentInvocation.fence : undefined;\n    };\n    Object.assign(SessionDocumentView.prototype, {\n      getFields: function () {\n        var self = this;\n        var ret = {};\n        self.dataByKey.forEach(function (precedenceList, key) {\n          ret[key] = precedenceList[0].value;\n        });\n        return ret;\n      },\n      clearField: function (subscriptionHandle, key, changeCollector) {\n        var self = this;\n        // Publish API ignores _id if present in fields\n        if (key === \"_id\") return;\n        var precedenceList = self.dataByKey.get(key);\n\n        // It's okay to clear fields that didn't exist. No need to throw\n        // an error.\n        if (!precedenceList) return;\n        var removedValue = undefined;\n        for (var i = 0; i < precedenceList.length; i++) {\n          var precedence = precedenceList[i];\n          if (precedence.subscriptionHandle === subscriptionHandle) {\n            // The view's value can only change if this subscription is the one that\n            // used to have precedence.\n            if (i === 0) removedValue = precedence.value;\n            precedenceList.splice(i, 1);\n            break;\n          }\n        }\n        if (precedenceList.length === 0) {\n          self.dataByKey.delete(key);\n          changeCollector[key] = undefined;\n        } else if (removedValue !== undefined && !EJSON.equals(removedValue, precedenceList[0].value)) {\n          changeCollector[key] = precedenceList[0].value;\n        }\n      },\n      changeField: function (subscriptionHandle, key, value, changeCollector, isAdd) {\n        var self = this;\n        // Publish API ignores _id if present in fields\n        if (key === \"_id\") return;\n\n        // Don't share state with the data passed in by the user.\n        value = EJSON.clone(value);\n        if (!self.dataByKey.has(key)) {\n          self.dataByKey.set(key, [{\n            subscriptionHandle: subscriptionHandle,\n            value: value\n          }]);\n          changeCollector[key] = value;\n          return;\n        }\n        var precedenceList = self.dataByKey.get(key);\n        var elt;\n        if (!isAdd) {\n          elt = precedenceList.find(function (precedence) {\n            return precedence.subscriptionHandle === subscriptionHandle;\n          });\n        }\n        if (elt) {\n          if (elt === precedenceList[0] && !EJSON.equals(value, elt.value)) {\n            // this subscription is changing the value of this field.\n            changeCollector[key] = value;\n          }\n          elt.value = value;\n        } else {\n          // this subscription is newly caring about this field\n          precedenceList.push({\n            subscriptionHandle: subscriptionHandle,\n            value: value\n          });\n        }\n      }\n    });\n\n    /**\n     * Represents a client's view of a single collection\n     * @param {String} collectionName Name of the collection it represents\n     * @param {Object.<String, Function>} sessionCallbacks The callbacks for added, changed, removed\n     * @class SessionCollectionView\n     */\n    var SessionCollectionView = function (collectionName, sessionCallbacks) {\n      var self = this;\n      self.collectionName = collectionName;\n      self.documents = new Map();\n      self.callbacks = sessionCallbacks;\n    };\n    DDPServer._SessionCollectionView = SessionCollectionView;\n    Object.assign(SessionCollectionView.prototype, {\n      isEmpty: function () {\n        var self = this;\n        return self.documents.size === 0;\n      },\n      diff: function (previous) {\n        var self = this;\n        DiffSequence.diffMaps(previous.documents, self.documents, {\n          both: self.diffDocument.bind(self),\n          rightOnly: function (id, nowDV) {\n            self.callbacks.added(self.collectionName, id, nowDV.getFields());\n          },\n          leftOnly: function (id, prevDV) {\n            self.callbacks.removed(self.collectionName, id);\n          }\n        });\n      },\n      diffDocument: function (id, prevDV, nowDV) {\n        var self = this;\n        var fields = {};\n        DiffSequence.diffObjects(prevDV.getFields(), nowDV.getFields(), {\n          both: function (key, prev, now) {\n            if (!EJSON.equals(prev, now)) fields[key] = now;\n          },\n          rightOnly: function (key, now) {\n            fields[key] = now;\n          },\n          leftOnly: function (key, prev) {\n            fields[key] = undefined;\n          }\n        });\n        self.callbacks.changed(self.collectionName, id, fields);\n      },\n      added: function (subscriptionHandle, id, fields) {\n        var self = this;\n        var docView = self.documents.get(id);\n        var added = false;\n        if (!docView) {\n          added = true;\n          if (Meteor.server.getPublicationStrategy(this.collectionName).useDummyDocumentView) {\n            docView = new DummyDocumentView();\n          } else {\n            docView = new SessionDocumentView();\n          }\n          self.documents.set(id, docView);\n        }\n        docView.existsIn.add(subscriptionHandle);\n        var changeCollector = {};\n        Object.entries(fields).forEach(function (_ref) {\n          let [key, value] = _ref;\n          docView.changeField(subscriptionHandle, key, value, changeCollector, true);\n        });\n        if (added) self.callbacks.added(self.collectionName, id, changeCollector);else self.callbacks.changed(self.collectionName, id, changeCollector);\n      },\n      changed: function (subscriptionHandle, id, changed) {\n        var self = this;\n        var changedResult = {};\n        var docView = self.documents.get(id);\n        if (!docView) throw new Error(\"Could not find element with id \" + id + \" to change\");\n        Object.entries(changed).forEach(function (_ref2) {\n          let [key, value] = _ref2;\n          if (value === undefined) docView.clearField(subscriptionHandle, key, changedResult);else docView.changeField(subscriptionHandle, key, value, changedResult);\n        });\n        self.callbacks.changed(self.collectionName, id, changedResult);\n      },\n      removed: function (subscriptionHandle, id) {\n        var self = this;\n        var docView = self.documents.get(id);\n        if (!docView) {\n          var err = new Error(\"Removed nonexistent document \" + id);\n          throw err;\n        }\n        docView.existsIn.delete(subscriptionHandle);\n        if (docView.existsIn.size === 0) {\n          // it is gone from everyone\n          self.callbacks.removed(self.collectionName, id);\n          self.documents.delete(id);\n        } else {\n          var changed = {};\n          // remove this subscription from every precedence list\n          // and record the changes\n          docView.dataByKey.forEach(function (precedenceList, key) {\n            docView.clearField(subscriptionHandle, key, changed);\n          });\n          self.callbacks.changed(self.collectionName, id, changed);\n        }\n      }\n    });\n\n    /******************************************************************************/\n    /* Session                                                                    */\n    /******************************************************************************/\n\n    var Session = function (server, version, socket, options) {\n      var self = this;\n      self.id = Random.id();\n      self.server = server;\n      self.version = version;\n      self.initialized = false;\n      self.socket = socket;\n\n      // Set to null when the session is destroyed. Multiple places below\n      // use this to determine if the session is alive or not.\n      self.inQueue = new Meteor._DoubleEndedQueue();\n      self.blocked = false;\n      self.workerRunning = false;\n      self.cachedUnblock = null;\n\n      // Sub objects for active subscriptions\n      self._namedSubs = new Map();\n      self._universalSubs = [];\n      self.userId = null;\n      self.collectionViews = new Map();\n\n      // Set this to false to not send messages when collectionViews are\n      // modified. This is done when rerunning subs in _setUserId and those messages\n      // are calculated via a diff instead.\n      self._isSending = true;\n\n      // If this is true, don't start a newly-created universal publisher on this\n      // session. The session will take care of starting it when appropriate.\n      self._dontStartNewUniversalSubs = false;\n\n      // When we are rerunning subscriptions, any ready messages\n      // we want to buffer up for when we are done rerunning subscriptions\n      self._pendingReady = [];\n\n      // List of callbacks to call when this connection is closed.\n      self._closeCallbacks = [];\n\n      // XXX HACK: If a sockjs connection, save off the URL. This is\n      // temporary and will go away in the near future.\n      self._socketUrl = socket.url;\n\n      // Allow tests to disable responding to pings.\n      self._respondToPings = options.respondToPings;\n\n      // This object is the public interface to the session. In the public\n      // API, it is called the `connection` object.  Internally we call it\n      // a `connectionHandle` to avoid ambiguity.\n      self.connectionHandle = {\n        id: self.id,\n        close: function () {\n          self.close();\n        },\n        onClose: function (fn) {\n          var cb = Meteor.bindEnvironment(fn, \"connection onClose callback\");\n          if (self.inQueue) {\n            self._closeCallbacks.push(cb);\n          } else {\n            // if we're already closed, call the callback.\n            Meteor.defer(cb);\n          }\n        },\n        clientAddress: self._clientAddress(),\n        httpHeaders: self.socket.headers\n      };\n      self.send({\n        msg: 'connected',\n        session: self.id\n      });\n\n      // On initial connect, spin up all the universal publishers.\n      self.startUniversalSubs();\n      if (version !== 'pre1' && options.heartbeatInterval !== 0) {\n        // We no longer need the low level timeout because we have heartbeats.\n        socket.setWebsocketTimeout(0);\n        self.heartbeat = new DDPCommon.Heartbeat({\n          heartbeatInterval: options.heartbeatInterval,\n          heartbeatTimeout: options.heartbeatTimeout,\n          onTimeout: function () {\n            self.close();\n          },\n          sendPing: function () {\n            self.send({\n              msg: 'ping'\n            });\n          }\n        });\n        self.heartbeat.start();\n      }\n      Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"livedata\", \"sessions\", 1);\n    };\n    Object.assign(Session.prototype, {\n      sendReady: function (subscriptionIds) {\n        var self = this;\n        if (self._isSending) {\n          self.send({\n            msg: \"ready\",\n            subs: subscriptionIds\n          });\n        } else {\n          subscriptionIds.forEach(function (subscriptionId) {\n            self._pendingReady.push(subscriptionId);\n          });\n        }\n      },\n      _canSend(collectionName) {\n        return this._isSending || !this.server.getPublicationStrategy(collectionName).useCollectionView;\n      },\n      sendAdded(collectionName, id, fields) {\n        if (this._canSend(collectionName)) {\n          this.send({\n            msg: 'added',\n            collection: collectionName,\n            id,\n            fields\n          });\n        }\n      },\n      sendChanged(collectionName, id, fields) {\n        if (isEmpty(fields)) return;\n        if (this._canSend(collectionName)) {\n          this.send({\n            msg: \"changed\",\n            collection: collectionName,\n            id,\n            fields\n          });\n        }\n      },\n      sendRemoved(collectionName, id) {\n        if (this._canSend(collectionName)) {\n          this.send({\n            msg: \"removed\",\n            collection: collectionName,\n            id\n          });\n        }\n      },\n      getSendCallbacks: function () {\n        var self = this;\n        return {\n          added: self.sendAdded.bind(self),\n          changed: self.sendChanged.bind(self),\n          removed: self.sendRemoved.bind(self)\n        };\n      },\n      getCollectionView: function (collectionName) {\n        var self = this;\n        var ret = self.collectionViews.get(collectionName);\n        if (!ret) {\n          ret = new SessionCollectionView(collectionName, self.getSendCallbacks());\n          self.collectionViews.set(collectionName, ret);\n        }\n        return ret;\n      },\n      added(subscriptionHandle, collectionName, id, fields) {\n        if (this.server.getPublicationStrategy(collectionName).useCollectionView) {\n          const view = this.getCollectionView(collectionName);\n          view.added(subscriptionHandle, id, fields);\n        } else {\n          this.sendAdded(collectionName, id, fields);\n        }\n      },\n      removed(subscriptionHandle, collectionName, id) {\n        if (this.server.getPublicationStrategy(collectionName).useCollectionView) {\n          const view = this.getCollectionView(collectionName);\n          view.removed(subscriptionHandle, id);\n          if (view.isEmpty()) {\n            this.collectionViews.delete(collectionName);\n          }\n        } else {\n          this.sendRemoved(collectionName, id);\n        }\n      },\n      changed(subscriptionHandle, collectionName, id, fields) {\n        if (this.server.getPublicationStrategy(collectionName).useCollectionView) {\n          const view = this.getCollectionView(collectionName);\n          view.changed(subscriptionHandle, id, fields);\n        } else {\n          this.sendChanged(collectionName, id, fields);\n        }\n      },\n      startUniversalSubs: function () {\n        var self = this;\n        // Make a shallow copy of the set of universal handlers and start them. If\n        // additional universal publishers start while we're running them (due to\n        // yielding), they will run separately as part of Server.publish.\n        var handlers = [...self.server.universal_publish_handlers];\n        handlers.forEach(function (handler) {\n          self._startSubscription(handler);\n        });\n      },\n      // Destroy this session and unregister it at the server.\n      close: function () {\n        var self = this;\n\n        // Destroy this session, even if it's not registered at the\n        // server. Stop all processing and tear everything down. If a socket\n        // was attached, close it.\n\n        // Already destroyed.\n        if (!self.inQueue) return;\n\n        // Drop the merge box data immediately.\n        self.inQueue = null;\n        self.collectionViews = new Map();\n        if (self.heartbeat) {\n          self.heartbeat.stop();\n          self.heartbeat = null;\n        }\n        if (self.socket) {\n          self.socket.close();\n          self.socket._meteorSession = null;\n        }\n        Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"livedata\", \"sessions\", -1);\n        Meteor.defer(function () {\n          // Stop callbacks can yield, so we defer this on close.\n          // sub._isDeactivated() detects that we set inQueue to null and\n          // treats it as semi-deactivated (it will ignore incoming callbacks, etc).\n          self._deactivateAllSubscriptions();\n\n          // Defer calling the close callbacks, so that the caller closing\n          // the session isn't waiting for all the callbacks to complete.\n          self._closeCallbacks.forEach(function (callback) {\n            callback();\n          });\n        });\n\n        // Unregister the session.\n        self.server._removeSession(self);\n      },\n      // Send a message (doing nothing if no socket is connected right now).\n      // It should be a JSON object (it will be stringified).\n      send: function (msg) {\n        const self = this;\n        if (self.socket) {\n          if (Meteor._printSentDDP) Meteor._debug(\"Sent DDP\", DDPCommon.stringifyDDP(msg));\n          self.socket.send(DDPCommon.stringifyDDP(msg));\n        }\n      },\n      // Send a connection error.\n      sendError: function (reason, offendingMessage) {\n        var self = this;\n        var msg = {\n          msg: 'error',\n          reason: reason\n        };\n        if (offendingMessage) msg.offendingMessage = offendingMessage;\n        self.send(msg);\n      },\n      // Process 'msg' as an incoming message. As a guard against\n      // race conditions during reconnection, ignore the message if\n      // 'socket' is not the currently connected socket.\n      //\n      // We run the messages from the client one at a time, in the order\n      // given by the client. The message handler is passed an idempotent\n      // function 'unblock' which it may call to allow other messages to\n      // begin running in parallel in another fiber (for example, a method\n      // that wants to yield). Otherwise, it is automatically unblocked\n      // when it returns.\n      //\n      // Actually, we don't have to 'totally order' the messages in this\n      // way, but it's the easiest thing that's correct. (unsub needs to\n      // be ordered against sub, methods need to be ordered against each\n      // other).\n      processMessage: function (msg_in) {\n        var self = this;\n        if (!self.inQueue)\n          // we have been destroyed.\n          return;\n\n        // Respond to ping and pong messages immediately without queuing.\n        // If the negotiated DDP version is \"pre1\" which didn't support\n        // pings, preserve the \"pre1\" behavior of responding with a \"bad\n        // request\" for the unknown messages.\n        //\n        // Fibers are needed because heartbeats use Meteor.setTimeout, which\n        // needs a Fiber. We could actually use regular setTimeout and avoid\n        // these new fibers, but it is easier to just make everything use\n        // Meteor.setTimeout and not think too hard.\n        //\n        // Any message counts as receiving a pong, as it demonstrates that\n        // the client is still alive.\n        if (self.heartbeat) {\n          self.heartbeat.messageReceived();\n        }\n        ;\n        if (self.version !== 'pre1' && msg_in.msg === 'ping') {\n          if (self._respondToPings) self.send({\n            msg: \"pong\",\n            id: msg_in.id\n          });\n          return;\n        }\n        if (self.version !== 'pre1' && msg_in.msg === 'pong') {\n          // Since everything is a pong, there is nothing to do\n          return;\n        }\n        self.inQueue.push(msg_in);\n        if (self.workerRunning) return;\n        self.workerRunning = true;\n        var processNext = function () {\n          var msg = self.inQueue && self.inQueue.shift();\n          if (!msg) {\n            self.workerRunning = false;\n            return;\n          }\n          function runHandlers() {\n            var blocked = true;\n            var unblock = function () {\n              if (!blocked) return; // idempotent\n              blocked = false;\n              processNext();\n            };\n            self.server.onMessageHook.each(function (callback) {\n              callback(msg, self);\n              return true;\n            });\n            if (msg.msg in self.protocol_handlers) {\n              const result = self.protocol_handlers[msg.msg].call(self, msg, unblock);\n              if (Meteor._isPromise(result)) {\n                result.finally(() => unblock());\n              } else {\n                unblock();\n              }\n            } else {\n              self.sendError('Bad request', msg);\n              unblock(); // in case the handler didn't already do it\n            }\n          }\n          runHandlers();\n        };\n        processNext();\n      },\n      protocol_handlers: {\n        sub: async function (msg, unblock) {\n          var self = this;\n\n          // cacheUnblock temporarly, so we can capture it later\n          // we will use unblock in current eventLoop, so this is safe\n          self.cachedUnblock = unblock;\n\n          // reject malformed messages\n          if (typeof msg.id !== \"string\" || typeof msg.name !== \"string\" || 'params' in msg && !(msg.params instanceof Array)) {\n            self.sendError(\"Malformed subscription\", msg);\n            return;\n          }\n          if (!self.server.publish_handlers[msg.name]) {\n            self.send({\n              msg: 'nosub',\n              id: msg.id,\n              error: new Meteor.Error(404, \"Subscription '\".concat(msg.name, \"' not found\"))\n            });\n            return;\n          }\n          if (self._namedSubs.has(msg.id))\n            // subs are idempotent, or rather, they are ignored if a sub\n            // with that id already exists. this is important during\n            // reconnect.\n            return;\n\n          // XXX It'd be much better if we had generic hooks where any package can\n          // hook into subscription handling, but in the mean while we special case\n          // ddp-rate-limiter package. This is also done for weak requirements to\n          // add the ddp-rate-limiter package in case we don't have Accounts. A\n          // user trying to use the ddp-rate-limiter must explicitly require it.\n          if (Package['ddp-rate-limiter']) {\n            var DDPRateLimiter = Package['ddp-rate-limiter'].DDPRateLimiter;\n            var rateLimiterInput = {\n              userId: self.userId,\n              clientAddress: self.connectionHandle.clientAddress,\n              type: \"subscription\",\n              name: msg.name,\n              connectionId: self.id\n            };\n            DDPRateLimiter._increment(rateLimiterInput);\n            var rateLimitResult = DDPRateLimiter._check(rateLimiterInput);\n            if (!rateLimitResult.allowed) {\n              self.send({\n                msg: 'nosub',\n                id: msg.id,\n                error: new Meteor.Error('too-many-requests', DDPRateLimiter.getErrorMessage(rateLimitResult), {\n                  timeToReset: rateLimitResult.timeToReset\n                })\n              });\n              return;\n            }\n          }\n          var handler = self.server.publish_handlers[msg.name];\n          await self._startSubscription(handler, msg.id, msg.params, msg.name);\n\n          // cleaning cached unblock\n          self.cachedUnblock = null;\n        },\n        unsub: function (msg) {\n          var self = this;\n          self._stopSubscription(msg.id);\n        },\n        method: async function (msg, unblock) {\n          var self = this;\n\n          // Reject malformed messages.\n          // For now, we silently ignore unknown attributes,\n          // for forwards compatibility.\n          if (typeof msg.id !== \"string\" || typeof msg.method !== \"string\" || 'params' in msg && !(msg.params instanceof Array) || 'randomSeed' in msg && typeof msg.randomSeed !== \"string\") {\n            self.sendError(\"Malformed method invocation\", msg);\n            return;\n          }\n          var randomSeed = msg.randomSeed || null;\n\n          // Set up to mark the method as satisfied once all observers\n          // (and subscriptions) have reacted to any writes that were\n          // done.\n          var fence = new DDPServer._WriteFence();\n          fence.onAllCommitted(function () {\n            // Retire the fence so that future writes are allowed.\n            // This means that callbacks like timers are free to use\n            // the fence, and if they fire before it's armed (for\n            // example, because the method waits for them) their\n            // writes will be included in the fence.\n            fence.retire();\n            self.send({\n              msg: 'updated',\n              methods: [msg.id]\n            });\n          });\n\n          // Find the handler\n          var handler = self.server.method_handlers[msg.method];\n          if (!handler) {\n            self.send({\n              msg: 'result',\n              id: msg.id,\n              error: new Meteor.Error(404, \"Method '\".concat(msg.method, \"' not found\"))\n            });\n            await fence.arm();\n            return;\n          }\n          var invocation = new DDPCommon.MethodInvocation({\n            name: msg.method,\n            isSimulation: false,\n            userId: self.userId,\n            setUserId(userId) {\n              return self._setUserId(userId);\n            },\n            unblock: unblock,\n            connection: self.connectionHandle,\n            randomSeed: randomSeed,\n            fence\n          });\n          const promise = new Promise((resolve, reject) => {\n            // XXX It'd be better if we could hook into method handlers better but\n            // for now, we need to check if the ddp-rate-limiter exists since we\n            // have a weak requirement for the ddp-rate-limiter package to be added\n            // to our application.\n            if (Package['ddp-rate-limiter']) {\n              var DDPRateLimiter = Package['ddp-rate-limiter'].DDPRateLimiter;\n              var rateLimiterInput = {\n                userId: self.userId,\n                clientAddress: self.connectionHandle.clientAddress,\n                type: \"method\",\n                name: msg.method,\n                connectionId: self.id\n              };\n              DDPRateLimiter._increment(rateLimiterInput);\n              var rateLimitResult = DDPRateLimiter._check(rateLimiterInput);\n              if (!rateLimitResult.allowed) {\n                reject(new Meteor.Error(\"too-many-requests\", DDPRateLimiter.getErrorMessage(rateLimitResult), {\n                  timeToReset: rateLimitResult.timeToReset\n                }));\n                return;\n              }\n            }\n            resolve(DDPServer._CurrentWriteFence.withValue(fence, () => DDP._CurrentMethodInvocation.withValue(invocation, () => maybeAuditArgumentChecks(handler, invocation, msg.params, \"call to '\" + msg.method + \"'\"))));\n          });\n          async function finish() {\n            await fence.arm();\n            unblock();\n          }\n          const payload = {\n            msg: \"result\",\n            id: msg.id\n          };\n          return promise.then(async result => {\n            await finish();\n            if (result !== undefined) {\n              payload.result = result;\n            }\n            self.send(payload);\n          }, async exception => {\n            await finish();\n            payload.error = wrapInternalException(exception, \"while invoking method '\".concat(msg.method, \"'\"));\n            self.send(payload);\n          });\n        }\n      },\n      _eachSub: function (f) {\n        var self = this;\n        self._namedSubs.forEach(f);\n        self._universalSubs.forEach(f);\n      },\n      _diffCollectionViews: function (beforeCVs) {\n        var self = this;\n        DiffSequence.diffMaps(beforeCVs, self.collectionViews, {\n          both: function (collectionName, leftValue, rightValue) {\n            rightValue.diff(leftValue);\n          },\n          rightOnly: function (collectionName, rightValue) {\n            rightValue.documents.forEach(function (docView, id) {\n              self.sendAdded(collectionName, id, docView.getFields());\n            });\n          },\n          leftOnly: function (collectionName, leftValue) {\n            leftValue.documents.forEach(function (doc, id) {\n              self.sendRemoved(collectionName, id);\n            });\n          }\n        });\n      },\n      // Sets the current user id in all appropriate contexts and reruns\n      // all subscriptions\n      async _setUserId(userId) {\n        var self = this;\n        if (userId !== null && typeof userId !== \"string\") throw new Error(\"setUserId must be called on string or null, not \" + typeof userId);\n\n        // Prevent newly-created universal subscriptions from being added to our\n        // session. They will be found below when we call startUniversalSubs.\n        //\n        // (We don't have to worry about named subscriptions, because we only add\n        // them when we process a 'sub' message. We are currently processing a\n        // 'method' message, and the method did not unblock, because it is illegal\n        // to call setUserId after unblock. Thus we cannot be concurrently adding a\n        // new named subscription).\n        self._dontStartNewUniversalSubs = true;\n\n        // Prevent current subs from updating our collectionViews and call their\n        // stop callbacks. This may yield.\n        self._eachSub(function (sub) {\n          sub._deactivate();\n        });\n\n        // All subs should now be deactivated. Stop sending messages to the client,\n        // save the state of the published collections, reset to an empty view, and\n        // update the userId.\n        self._isSending = false;\n        var beforeCVs = self.collectionViews;\n        self.collectionViews = new Map();\n        self.userId = userId;\n\n        // _setUserId is normally called from a Meteor method with\n        // DDP._CurrentMethodInvocation set. But DDP._CurrentMethodInvocation is not\n        // expected to be set inside a publish function, so we temporary unset it.\n        // Inside a publish function DDP._CurrentPublicationInvocation is set.\n        await DDP._CurrentMethodInvocation.withValue(undefined, async function () {\n          // Save the old named subs, and reset to having no subscriptions.\n          var oldNamedSubs = self._namedSubs;\n          self._namedSubs = new Map();\n          self._universalSubs = [];\n          await Promise.all([...oldNamedSubs].map(async _ref3 => {\n            let [subscriptionId, sub] = _ref3;\n            const newSub = sub._recreate();\n            self._namedSubs.set(subscriptionId, newSub);\n            // nb: if the handler throws or calls this.error(), it will in fact\n            // immediately send its 'nosub'. This is OK, though.\n            await newSub._runHandler();\n          }));\n\n          // Allow newly-created universal subs to be started on our connection in\n          // parallel with the ones we're spinning up here, and spin up universal\n          // subs.\n          self._dontStartNewUniversalSubs = false;\n          self.startUniversalSubs();\n        }, {\n          name: '_setUserId'\n        });\n\n        // Start sending messages again, beginning with the diff from the previous\n        // state of the world to the current state. No yields are allowed during\n        // this diff, so that other changes cannot interleave.\n        Meteor._noYieldsAllowed(function () {\n          self._isSending = true;\n          self._diffCollectionViews(beforeCVs);\n          if (!isEmpty(self._pendingReady)) {\n            self.sendReady(self._pendingReady);\n            self._pendingReady = [];\n          }\n        });\n      },\n      _startSubscription: function (handler, subId, params, name) {\n        var self = this;\n        var sub = new Subscription(self, handler, subId, params, name);\n        let unblockHander = self.cachedUnblock;\n        // _startSubscription may call from a lot places\n        // so cachedUnblock might be null in somecases\n        // assign the cachedUnblock\n        sub.unblock = unblockHander || (() => {});\n        if (subId) self._namedSubs.set(subId, sub);else self._universalSubs.push(sub);\n        return sub._runHandler();\n      },\n      // Tear down specified subscription\n      _stopSubscription: function (subId, error) {\n        var self = this;\n        var subName = null;\n        if (subId) {\n          var maybeSub = self._namedSubs.get(subId);\n          if (maybeSub) {\n            subName = maybeSub._name;\n            maybeSub._removeAllDocuments();\n            maybeSub._deactivate();\n            self._namedSubs.delete(subId);\n          }\n        }\n        var response = {\n          msg: 'nosub',\n          id: subId\n        };\n        if (error) {\n          response.error = wrapInternalException(error, subName ? \"from sub \" + subName + \" id \" + subId : \"from sub id \" + subId);\n        }\n        self.send(response);\n      },\n      // Tear down all subscriptions. Note that this does NOT send removed or nosub\n      // messages, since we assume the client is gone.\n      _deactivateAllSubscriptions: function () {\n        var self = this;\n        self._namedSubs.forEach(function (sub, id) {\n          sub._deactivate();\n        });\n        self._namedSubs = new Map();\n        self._universalSubs.forEach(function (sub) {\n          sub._deactivate();\n        });\n        self._universalSubs = [];\n      },\n      // Determine the remote client's IP address, based on the\n      // HTTP_FORWARDED_COUNT environment variable representing how many\n      // proxies the server is behind.\n      _clientAddress: function () {\n        var self = this;\n\n        // For the reported client address for a connection to be correct,\n        // the developer must set the HTTP_FORWARDED_COUNT environment\n        // variable to an integer representing the number of hops they\n        // expect in the `x-forwarded-for` header. E.g., set to \"1\" if the\n        // server is behind one proxy.\n        //\n        // This could be computed once at startup instead of every time.\n        var httpForwardedCount = parseInt(process.env['HTTP_FORWARDED_COUNT']) || 0;\n        if (httpForwardedCount === 0) return self.socket.remoteAddress;\n        var forwardedFor = self.socket.headers[\"x-forwarded-for\"];\n        if (!isString(forwardedFor)) return null;\n        forwardedFor = forwardedFor.trim().split(/\\s*,\\s*/);\n\n        // Typically the first value in the `x-forwarded-for` header is\n        // the original IP address of the client connecting to the first\n        // proxy.  However, the end user can easily spoof the header, in\n        // which case the first value(s) will be the fake IP address from\n        // the user pretending to be a proxy reporting the original IP\n        // address value.  By counting HTTP_FORWARDED_COUNT back from the\n        // end of the list, we ensure that we get the IP address being\n        // reported by *our* first proxy.\n\n        if (httpForwardedCount < 0 || httpForwardedCount > forwardedFor.length) return null;\n        return forwardedFor[forwardedFor.length - httpForwardedCount];\n      }\n    });\n\n    /******************************************************************************/\n    /* Subscription                                                               */\n    /******************************************************************************/\n\n    // Ctor for a sub handle: the input to each publish function\n\n    // Instance name is this because it's usually referred to as this inside a\n    // publish\n    /**\n     * @summary The server's side of a subscription\n     * @class Subscription\n     * @instanceName this\n     * @showInstanceName true\n     */\n    var Subscription = function (session, handler, subscriptionId, params, name) {\n      var self = this;\n      self._session = session; // type is Session\n\n      /**\n       * @summary Access inside the publish function. The incoming [connection](#meteor_onconnection) for this subscription.\n       * @locus Server\n       * @name  connection\n       * @memberOf Subscription\n       * @instance\n       */\n      self.connection = session.connectionHandle; // public API object\n\n      self._handler = handler;\n\n      // My subscription ID (generated by client, undefined for universal subs).\n      self._subscriptionId = subscriptionId;\n      // Undefined for universal subs\n      self._name = name;\n      self._params = params || [];\n\n      // Only named subscriptions have IDs, but we need some sort of string\n      // internally to keep track of all subscriptions inside\n      // SessionDocumentViews. We use this subscriptionHandle for that.\n      if (self._subscriptionId) {\n        self._subscriptionHandle = 'N' + self._subscriptionId;\n      } else {\n        self._subscriptionHandle = 'U' + Random.id();\n      }\n\n      // Has _deactivate been called?\n      self._deactivated = false;\n\n      // Stop callbacks to g/c this sub.  called w/ zero arguments.\n      self._stopCallbacks = [];\n\n      // The set of (collection, documentid) that this subscription has\n      // an opinion about.\n      self._documents = new Map();\n\n      // Remember if we are ready.\n      self._ready = false;\n\n      // Part of the public API: the user of this sub.\n\n      /**\n       * @summary Access inside the publish function. The id of the logged-in user, or `null` if no user is logged in.\n       * @locus Server\n       * @memberOf Subscription\n       * @name  userId\n       * @instance\n       */\n      self.userId = session.userId;\n\n      // For now, the id filter is going to default to\n      // the to/from DDP methods on MongoID, to\n      // specifically deal with mongo/minimongo ObjectIds.\n\n      // Later, you will be able to make this be \"raw\"\n      // if you want to publish a collection that you know\n      // just has strings for keys and no funny business, to\n      // a DDP consumer that isn't minimongo.\n\n      self._idFilter = {\n        idStringify: MongoID.idStringify,\n        idParse: MongoID.idParse\n      };\n      Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"livedata\", \"subscriptions\", 1);\n    };\n    Object.assign(Subscription.prototype, {\n      _runHandler: async function () {\n        // XXX should we unblock() here? Either before running the publish\n        // function, or before running _publishCursor.\n        //\n        // Right now, each publish function blocks all future publishes and\n        // methods waiting on data from Mongo (or whatever else the function\n        // blocks on). This probably slows page load in common cases.\n\n        if (!this.unblock) {\n          this.unblock = () => {};\n        }\n        const self = this;\n        let resultOrThenable = null;\n        try {\n          resultOrThenable = DDP._CurrentPublicationInvocation.withValue(self, () => maybeAuditArgumentChecks(self._handler, self, EJSON.clone(self._params),\n          // It's OK that this would look weird for universal subscriptions,\n          // because they have no arguments so there can never be an\n          // audit-argument-checks failure.\n          \"publisher '\" + self._name + \"'\"), {\n            name: self._name\n          });\n        } catch (e) {\n          self.error(e);\n          return;\n        }\n\n        // Did the handler call this.error or this.stop?\n        if (self._isDeactivated()) return;\n\n        // Both conventional and async publish handler functions are supported.\n        // If an object is returned with a then() function, it is either a promise\n        // or thenable and will be resolved asynchronously.\n        const isThenable = resultOrThenable && typeof resultOrThenable.then === 'function';\n        if (isThenable) {\n          try {\n            await self._publishHandlerResult(await resultOrThenable);\n          } catch (e) {\n            self.error(e);\n          }\n        } else {\n          await self._publishHandlerResult(resultOrThenable);\n        }\n      },\n      async _publishHandlerResult(res) {\n        // SPECIAL CASE: Instead of writing their own callbacks that invoke\n        // this.added/changed/ready/etc, the user can just return a collection\n        // cursor or array of cursors from the publish function; we call their\n        // _publishCursor method which starts observing the cursor and publishes the\n        // results. Note that _publishCursor does NOT call ready().\n        //\n        // XXX This uses an undocumented interface which only the Mongo cursor\n        // interface publishes. Should we make this interface public and encourage\n        // users to implement it themselves? Arguably, it's unnecessary; users can\n        // already write their own functions like\n        //   var publishMyReactiveThingy = function (name, handler) {\n        //     Meteor.publish(name, function () {\n        //       var reactiveThingy = handler();\n        //       reactiveThingy.publishMe();\n        //     });\n        //   };\n\n        var self = this;\n        var isCursor = function (c) {\n          return c && c._publishCursor;\n        };\n        if (isCursor(res)) {\n          try {\n            await res._publishCursor(self);\n          } catch (e) {\n            self.error(e);\n            return;\n          }\n          // _publishCursor only returns after the initial added callbacks have run.\n          // mark subscription as ready.\n          self.ready();\n        } else if (Array.isArray(res)) {\n          // Check all the elements are cursors\n          if (!res.every(isCursor)) {\n            self.error(new Error(\"Publish function returned an array of non-Cursors\"));\n            return;\n          }\n          // Find duplicate collection names\n          // XXX we should support overlapping cursors, but that would require the\n          // merge box to allow overlap within a subscription\n          var collectionNames = {};\n          for (var i = 0; i < res.length; ++i) {\n            var collectionName = res[i]._getCollectionName();\n            if (collectionNames[collectionName]) {\n              self.error(new Error(\"Publish function returned multiple cursors for collection \" + collectionName));\n              return;\n            }\n            collectionNames[collectionName] = true;\n          }\n          try {\n            await Promise.all(res.map(cur => cur._publishCursor(self)));\n          } catch (e) {\n            self.error(e);\n            return;\n          }\n          self.ready();\n        } else if (res) {\n          // Truthy values other than cursors or arrays are probably a\n          // user mistake (possible returning a Mongo document via, say,\n          // `coll.findOne()`).\n          self.error(new Error(\"Publish function can only return a Cursor or \" + \"an array of Cursors\"));\n        }\n      },\n      // This calls all stop callbacks and prevents the handler from updating any\n      // SessionCollectionViews further. It's used when the user unsubscribes or\n      // disconnects, as well as during setUserId re-runs. It does *NOT* send\n      // removed messages for the published objects; if that is necessary, call\n      // _removeAllDocuments first.\n      _deactivate: function () {\n        var self = this;\n        if (self._deactivated) return;\n        self._deactivated = true;\n        self._callStopCallbacks();\n        Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"livedata\", \"subscriptions\", -1);\n      },\n      _callStopCallbacks: function () {\n        var self = this;\n        // Tell listeners, so they can clean up\n        var callbacks = self._stopCallbacks;\n        self._stopCallbacks = [];\n        callbacks.forEach(function (callback) {\n          callback();\n        });\n      },\n      // Send remove messages for every document.\n      _removeAllDocuments: function () {\n        var self = this;\n        Meteor._noYieldsAllowed(function () {\n          self._documents.forEach(function (collectionDocs, collectionName) {\n            collectionDocs.forEach(function (strId) {\n              self.removed(collectionName, self._idFilter.idParse(strId));\n            });\n          });\n        });\n      },\n      // Returns a new Subscription for the same session with the same\n      // initial creation parameters. This isn't a clone: it doesn't have\n      // the same _documents cache, stopped state or callbacks; may have a\n      // different _subscriptionHandle, and gets its userId from the\n      // session, not from this object.\n      _recreate: function () {\n        var self = this;\n        return new Subscription(self._session, self._handler, self._subscriptionId, self._params, self._name);\n      },\n      /**\n       * @summary Call inside the publish function.  Stops this client's subscription, triggering a call on the client to the `onStop` callback passed to [`Meteor.subscribe`](#meteor_subscribe), if any. If `error` is not a [`Meteor.Error`](#meteor_error), it will be [sanitized](#meteor_error).\n       * @locus Server\n       * @param {Error} error The error to pass to the client.\n       * @instance\n       * @memberOf Subscription\n       */\n      error: function (error) {\n        var self = this;\n        if (self._isDeactivated()) return;\n        self._session._stopSubscription(self._subscriptionId, error);\n      },\n      // Note that while our DDP client will notice that you've called stop() on the\n      // server (and clean up its _subscriptions table) we don't actually provide a\n      // mechanism for an app to notice this (the subscribe onError callback only\n      // triggers if there is an error).\n\n      /**\n       * @summary Call inside the publish function.  Stops this client's subscription and invokes the client's `onStop` callback with no error.\n       * @locus Server\n       * @instance\n       * @memberOf Subscription\n       */\n      stop: function () {\n        var self = this;\n        if (self._isDeactivated()) return;\n        self._session._stopSubscription(self._subscriptionId);\n      },\n      /**\n       * @summary Call inside the publish function.  Registers a callback function to run when the subscription is stopped.\n       * @locus Server\n       * @memberOf Subscription\n       * @instance\n       * @param {Function} func The callback function\n       */\n      onStop: function (callback) {\n        var self = this;\n        callback = Meteor.bindEnvironment(callback, 'onStop callback', self);\n        if (self._isDeactivated()) callback();else self._stopCallbacks.push(callback);\n      },\n      // This returns true if the sub has been deactivated, *OR* if the session was\n      // destroyed but the deferred call to _deactivateAllSubscriptions hasn't\n      // happened yet.\n      _isDeactivated: function () {\n        var self = this;\n        return self._deactivated || self._session.inQueue === null;\n      },\n      /**\n       * @summary Call inside the publish function.  Informs the subscriber that a document has been added to the record set.\n       * @locus Server\n       * @memberOf Subscription\n       * @instance\n       * @param {String} collection The name of the collection that contains the new document.\n       * @param {String} id The new document's ID.\n       * @param {Object} fields The fields in the new document.  If `_id` is present it is ignored.\n       */\n      added(collectionName, id, fields) {\n        if (this._isDeactivated()) return;\n        id = this._idFilter.idStringify(id);\n        if (this._session.server.getPublicationStrategy(collectionName).doAccountingForCollection) {\n          let ids = this._documents.get(collectionName);\n          if (ids == null) {\n            ids = new Set();\n            this._documents.set(collectionName, ids);\n          }\n          ids.add(id);\n        }\n        this._session.added(this._subscriptionHandle, collectionName, id, fields);\n      },\n      /**\n       * @summary Call inside the publish function.  Informs the subscriber that a document in the record set has been modified.\n       * @locus Server\n       * @memberOf Subscription\n       * @instance\n       * @param {String} collection The name of the collection that contains the changed document.\n       * @param {String} id The changed document's ID.\n       * @param {Object} fields The fields in the document that have changed, together with their new values.  If a field is not present in `fields` it was left unchanged; if it is present in `fields` and has a value of `undefined` it was removed from the document.  If `_id` is present it is ignored.\n       */\n      changed(collectionName, id, fields) {\n        if (this._isDeactivated()) return;\n        id = this._idFilter.idStringify(id);\n        this._session.changed(this._subscriptionHandle, collectionName, id, fields);\n      },\n      /**\n       * @summary Call inside the publish function.  Informs the subscriber that a document has been removed from the record set.\n       * @locus Server\n       * @memberOf Subscription\n       * @instance\n       * @param {String} collection The name of the collection that the document has been removed from.\n       * @param {String} id The ID of the document that has been removed.\n       */\n      removed(collectionName, id) {\n        if (this._isDeactivated()) return;\n        id = this._idFilter.idStringify(id);\n        if (this._session.server.getPublicationStrategy(collectionName).doAccountingForCollection) {\n          // We don't bother to delete sets of things in a collection if the\n          // collection is empty.  It could break _removeAllDocuments.\n          this._documents.get(collectionName).delete(id);\n        }\n        this._session.removed(this._subscriptionHandle, collectionName, id);\n      },\n      /**\n       * @summary Call inside the publish function.  Informs the subscriber that an initial, complete snapshot of the record set has been sent.  This will trigger a call on the client to the `onReady` callback passed to  [`Meteor.subscribe`](#meteor_subscribe), if any.\n       * @locus Server\n       * @memberOf Subscription\n       * @instance\n       */\n      ready: function () {\n        var self = this;\n        if (self._isDeactivated()) return;\n        if (!self._subscriptionId) return; // Unnecessary but ignored for universal sub\n        if (!self._ready) {\n          self._session.sendReady([self._subscriptionId]);\n          self._ready = true;\n        }\n      }\n    });\n\n    /******************************************************************************/\n    /* Server                                                                     */\n    /******************************************************************************/\n\n    Server = function () {\n      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var self = this;\n\n      // The default heartbeat interval is 30 seconds on the server and 35\n      // seconds on the client.  Since the client doesn't need to send a\n      // ping as long as it is receiving pings, this means that pings\n      // normally go from the server to the client.\n      //\n      // Note: Troposphere depends on the ability to mutate\n      // Meteor.server.options.heartbeatTimeout! This is a hack, but it's life.\n      self.options = _objectSpread({\n        heartbeatInterval: 15000,\n        heartbeatTimeout: 15000,\n        // For testing, allow responding to pings to be disabled.\n        respondToPings: true,\n        defaultPublicationStrategy: publicationStrategies.SERVER_MERGE\n      }, options);\n\n      // Map of callbacks to call when a new connection comes in to the\n      // server and completes DDP version negotiation. Use an object instead\n      // of an array so we can safely remove one from the list while\n      // iterating over it.\n      self.onConnectionHook = new Hook({\n        debugPrintExceptions: \"onConnection callback\"\n      });\n\n      // Map of callbacks to call when a new message comes in.\n      self.onMessageHook = new Hook({\n        debugPrintExceptions: \"onMessage callback\"\n      });\n      self.publish_handlers = {};\n      self.universal_publish_handlers = [];\n      self.method_handlers = {};\n      self._publicationStrategies = {};\n      self.sessions = new Map(); // map from id to session\n\n      self.stream_server = new StreamServer();\n      self.stream_server.register(function (socket) {\n        // socket implements the SockJSConnection interface\n        socket._meteorSession = null;\n        var sendError = function (reason, offendingMessage) {\n          var msg = {\n            msg: 'error',\n            reason: reason\n          };\n          if (offendingMessage) msg.offendingMessage = offendingMessage;\n          socket.send(DDPCommon.stringifyDDP(msg));\n        };\n        socket.on('data', function (raw_msg) {\n          if (Meteor._printReceivedDDP) {\n            Meteor._debug(\"Received DDP\", raw_msg);\n          }\n          try {\n            try {\n              var msg = DDPCommon.parseDDP(raw_msg);\n            } catch (err) {\n              sendError('Parse error');\n              return;\n            }\n            if (msg === null || !msg.msg) {\n              sendError('Bad request', msg);\n              return;\n            }\n            if (msg.msg === 'connect') {\n              if (socket._meteorSession) {\n                sendError(\"Already connected\", msg);\n                return;\n              }\n              self._handleConnect(socket, msg);\n              return;\n            }\n            if (!socket._meteorSession) {\n              sendError('Must connect first', msg);\n              return;\n            }\n            socket._meteorSession.processMessage(msg);\n          } catch (e) {\n            // XXX print stack nicely\n            Meteor._debug(\"Internal exception while processing message\", msg, e);\n          }\n        });\n        socket.on('close', function () {\n          if (socket._meteorSession) {\n            socket._meteorSession.close();\n          }\n        });\n      });\n    };\n    Object.assign(Server.prototype, {\n      /**\n       * @summary Register a callback to be called when a new DDP connection is made to the server.\n       * @locus Server\n       * @param {function} callback The function to call when a new DDP connection is established.\n       * @memberOf Meteor\n       * @importFromPackage meteor\n       */\n      onConnection: function (fn) {\n        var self = this;\n        return self.onConnectionHook.register(fn);\n      },\n      /**\n       * @summary Set publication strategy for the given publication. Publications strategies are available from `DDPServer.publicationStrategies`. You call this method from `Meteor.server`, like `Meteor.server.setPublicationStrategy()`\n       * @locus Server\n       * @alias setPublicationStrategy\n       * @param publicationName {String}\n       * @param strategy {{useCollectionView: boolean, doAccountingForCollection: boolean}}\n       * @memberOf Meteor.server\n       * @importFromPackage meteor\n       */\n      setPublicationStrategy(publicationName, strategy) {\n        if (!Object.values(publicationStrategies).includes(strategy)) {\n          throw new Error(\"Invalid merge strategy: \".concat(strategy, \" \\n        for collection \").concat(publicationName));\n        }\n        this._publicationStrategies[publicationName] = strategy;\n      },\n      /**\n       * @summary Gets the publication strategy for the requested publication. You call this method from `Meteor.server`, like `Meteor.server.getPublicationStrategy()`\n       * @locus Server\n       * @alias getPublicationStrategy\n       * @param publicationName {String}\n       * @memberOf Meteor.server\n       * @importFromPackage meteor\n       * @return {{useCollectionView: boolean, doAccountingForCollection: boolean}}\n       */\n      getPublicationStrategy(publicationName) {\n        return this._publicationStrategies[publicationName] || this.options.defaultPublicationStrategy;\n      },\n      /**\n       * @summary Register a callback to be called when a new DDP message is received.\n       * @locus Server\n       * @param {function} callback The function to call when a new DDP message is received.\n       * @memberOf Meteor\n       * @importFromPackage meteor\n       */\n      onMessage: function (fn) {\n        var self = this;\n        return self.onMessageHook.register(fn);\n      },\n      _handleConnect: function (socket, msg) {\n        var self = this;\n\n        // The connect message must specify a version and an array of supported\n        // versions, and it must claim to support what it is proposing.\n        if (!(typeof msg.version === 'string' && Array.isArray(msg.support) && msg.support.every(isString) && msg.support.includes(msg.version))) {\n          socket.send(DDPCommon.stringifyDDP({\n            msg: 'failed',\n            version: DDPCommon.SUPPORTED_DDP_VERSIONS[0]\n          }));\n          socket.close();\n          return;\n        }\n\n        // In the future, handle session resumption: something like:\n        //  socket._meteorSession = self.sessions[msg.session]\n        var version = calculateVersion(msg.support, DDPCommon.SUPPORTED_DDP_VERSIONS);\n        if (msg.version !== version) {\n          // The best version to use (according to the client's stated preferences)\n          // is not the one the client is trying to use. Inform them about the best\n          // version to use.\n          socket.send(DDPCommon.stringifyDDP({\n            msg: 'failed',\n            version: version\n          }));\n          socket.close();\n          return;\n        }\n\n        // Yay, version matches! Create a new session.\n        // Note: Troposphere depends on the ability to mutate\n        // Meteor.server.options.heartbeatTimeout! This is a hack, but it's life.\n        socket._meteorSession = new Session(self, version, socket, self.options);\n        self.sessions.set(socket._meteorSession.id, socket._meteorSession);\n        self.onConnectionHook.each(function (callback) {\n          if (socket._meteorSession) callback(socket._meteorSession.connectionHandle);\n          return true;\n        });\n      },\n      /**\n       * Register a publish handler function.\n       *\n       * @param name {String} identifier for query\n       * @param handler {Function} publish handler\n       * @param options {Object}\n       *\n       * Server will call handler function on each new subscription,\n       * either when receiving DDP sub message for a named subscription, or on\n       * DDP connect for a universal subscription.\n       *\n       * If name is null, this will be a subscription that is\n       * automatically established and permanently on for all connected\n       * client, instead of a subscription that can be turned on and off\n       * with subscribe().\n       *\n       * options to contain:\n       *  - (mostly internal) is_auto: true if generated automatically\n       *    from an autopublish hook. this is for cosmetic purposes only\n       *    (it lets us determine whether to print a warning suggesting\n       *    that you turn off autopublish).\n       */\n\n      /**\n       * @summary Publish a record set.\n       * @memberOf Meteor\n       * @importFromPackage meteor\n       * @locus Server\n       * @param {String|Object} name If String, name of the record set.  If Object, publications Dictionary of publish functions by name.  If `null`, the set has no name, and the record set is automatically sent to all connected clients.\n       * @param {Function} func Function called on the server each time a client subscribes.  Inside the function, `this` is the publish handler object, described below.  If the client passed arguments to `subscribe`, the function is called with the same arguments.\n       */\n      publish: function (name, handler, options) {\n        var self = this;\n        if (!isObject(name)) {\n          options = options || {};\n          if (name && name in self.publish_handlers) {\n            Meteor._debug(\"Ignoring duplicate publish named '\" + name + \"'\");\n            return;\n          }\n          if (Package.autopublish && !options.is_auto) {\n            // They have autopublish on, yet they're trying to manually\n            // pick stuff to publish. They probably should turn off\n            // autopublish. (This check isn't perfect -- if you create a\n            // publish before you turn on autopublish, it won't catch\n            // it, but this will definitely handle the simple case where\n            // you've added the autopublish package to your app, and are\n            // calling publish from your app code).\n            if (!self.warned_about_autopublish) {\n              self.warned_about_autopublish = true;\n              Meteor._debug(\"** You've set up some data subscriptions with Meteor.publish(), but\\n\" + \"** you still have autopublish turned on. Because autopublish is still\\n\" + \"** on, your Meteor.publish() calls won't have much effect. All data\\n\" + \"** will still be sent to all clients.\\n\" + \"**\\n\" + \"** Turn off autopublish by removing the autopublish package:\\n\" + \"**\\n\" + \"**   $ meteor remove autopublish\\n\" + \"**\\n\" + \"** .. and make sure you have Meteor.publish() and Meteor.subscribe() calls\\n\" + \"** for each collection that you want clients to see.\\n\");\n            }\n          }\n          if (name) self.publish_handlers[name] = handler;else {\n            self.universal_publish_handlers.push(handler);\n            // Spin up the new publisher on any existing session too. Run each\n            // session's subscription in a new Fiber, so that there's no change for\n            // self.sessions to change while we're running this loop.\n            self.sessions.forEach(function (session) {\n              if (!session._dontStartNewUniversalSubs) {\n                session._startSubscription(handler);\n              }\n            });\n          }\n        } else {\n          Object.entries(name).forEach(function (_ref4) {\n            let [key, value] = _ref4;\n            self.publish(key, value, {});\n          });\n        }\n      },\n      _removeSession: function (session) {\n        var self = this;\n        self.sessions.delete(session.id);\n      },\n      /**\n       * @summary Tells if the method call came from a call or a callAsync.\n       * @locus Anywhere\n       * @memberOf Meteor\n       * @importFromPackage meteor\n       * @returns boolean\n       */\n      isAsyncCall: function () {\n        return DDP._CurrentMethodInvocation._isCallAsyncMethodRunning();\n      },\n      /**\n       * @summary Defines functions that can be invoked over the network by clients.\n       * @locus Anywhere\n       * @param {Object} methods Dictionary whose keys are method names and values are functions.\n       * @memberOf Meteor\n       * @importFromPackage meteor\n       */\n      methods: function (methods) {\n        var self = this;\n        Object.entries(methods).forEach(function (_ref5) {\n          let [name, func] = _ref5;\n          if (typeof func !== 'function') throw new Error(\"Method '\" + name + \"' must be a function\");\n          if (self.method_handlers[name]) throw new Error(\"A method named '\" + name + \"' is already defined\");\n          self.method_handlers[name] = func;\n        });\n      },\n      call: function (name) {\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n        if (args.length && typeof args[args.length - 1] === \"function\") {\n          // If it's a function, the last argument is the result callback, not\n          // a parameter to the remote method.\n          var callback = args.pop();\n        }\n        return this.apply(name, args, callback);\n      },\n      // A version of the call method that always returns a Promise.\n      callAsync: function (name) {\n        var _args$;\n        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          args[_key2 - 1] = arguments[_key2];\n        }\n        const options = (_args$ = args[0]) !== null && _args$ !== void 0 && _args$.hasOwnProperty('returnStubValue') ? args.shift() : {};\n        DDP._CurrentMethodInvocation._set();\n        DDP._CurrentMethodInvocation._setCallAsyncMethodRunning(true);\n        const promise = new Promise((resolve, reject) => {\n          DDP._CurrentCallAsyncInvocation._set({\n            name,\n            hasCallAsyncParent: true\n          });\n          this.applyAsync(name, args, _objectSpread({\n            isFromCallAsync: true\n          }, options)).then(resolve).catch(reject).finally(() => {\n            DDP._CurrentCallAsyncInvocation._set();\n          });\n        });\n        return promise.finally(() => DDP._CurrentMethodInvocation._setCallAsyncMethodRunning(false));\n      },\n      apply: function (name, args, options, callback) {\n        // We were passed 3 arguments. They may be either (name, args, options)\n        // or (name, args, callback)\n        if (!callback && typeof options === 'function') {\n          callback = options;\n          options = {};\n        } else {\n          options = options || {};\n        }\n        const promise = this.applyAsync(name, args, options);\n\n        // Return the result in whichever way the caller asked for it. Note that we\n        // do NOT block on the write fence in an analogous way to how the client\n        // blocks on the relevant data being visible, so you are NOT guaranteed that\n        // cursor observe callbacks have fired when your callback is invoked. (We\n        // can change this if there's a real use case).\n        if (callback) {\n          promise.then(result => callback(undefined, result), exception => callback(exception));\n        } else {\n          return promise;\n        }\n      },\n      // @param options {Optional Object}\n      applyAsync: function (name, args, options) {\n        // Run the handler\n        var handler = this.method_handlers[name];\n        if (!handler) {\n          return Promise.reject(new Meteor.Error(404, \"Method '\".concat(name, \"' not found\")));\n        }\n        // If this is a method call from within another method or publish function,\n        // get the user state from the outer method or publish function, otherwise\n        // don't allow setUserId to be called\n        var userId = null;\n        let setUserId = () => {\n          throw new Error(\"Can't call setUserId on a server initiated method call\");\n        };\n        var connection = null;\n        var currentMethodInvocation = DDP._CurrentMethodInvocation.get();\n        var currentPublicationInvocation = DDP._CurrentPublicationInvocation.get();\n        var randomSeed = null;\n        if (currentMethodInvocation) {\n          userId = currentMethodInvocation.userId;\n          setUserId = userId => currentMethodInvocation.setUserId(userId);\n          connection = currentMethodInvocation.connection;\n          randomSeed = DDPCommon.makeRpcSeed(currentMethodInvocation, name);\n        } else if (currentPublicationInvocation) {\n          userId = currentPublicationInvocation.userId;\n          setUserId = userId => currentPublicationInvocation._session._setUserId(userId);\n          connection = currentPublicationInvocation.connection;\n        }\n        var invocation = new DDPCommon.MethodInvocation({\n          isSimulation: false,\n          userId,\n          setUserId,\n          connection,\n          randomSeed\n        });\n        return new Promise((resolve, reject) => {\n          let result;\n          try {\n            result = DDP._CurrentMethodInvocation.withValue(invocation, () => maybeAuditArgumentChecks(handler, invocation, EJSON.clone(args), \"internal call to '\" + name + \"'\"));\n          } catch (e) {\n            return reject(e);\n          }\n          if (!Meteor._isPromise(result)) {\n            return resolve(result);\n          }\n          result.then(r => resolve(r)).catch(reject);\n        }).then(EJSON.clone);\n      },\n      _urlForSession: function (sessionId) {\n        var self = this;\n        var session = self.sessions.get(sessionId);\n        if (session) return session._socketUrl;else return null;\n      }\n    });\n    var calculateVersion = function (clientSupportedVersions, serverSupportedVersions) {\n      var correctVersion = clientSupportedVersions.find(function (version) {\n        return serverSupportedVersions.includes(version);\n      });\n      if (!correctVersion) {\n        correctVersion = serverSupportedVersions[0];\n      }\n      return correctVersion;\n    };\n    DDPServer._calculateVersion = calculateVersion;\n\n    // \"blind\" exceptions other than those that were deliberately thrown to signal\n    // errors to the client\n    var wrapInternalException = function (exception, context) {\n      if (!exception) return exception;\n\n      // To allow packages to throw errors intended for the client but not have to\n      // depend on the Meteor.Error class, `isClientSafe` can be set to true on any\n      // error before it is thrown.\n      if (exception.isClientSafe) {\n        if (!(exception instanceof Meteor.Error)) {\n          const originalMessage = exception.message;\n          exception = new Meteor.Error(exception.error, exception.reason, exception.details);\n          exception.message = originalMessage;\n        }\n        return exception;\n      }\n\n      // Tests can set the '_expectedByTest' flag on an exception so it won't go to\n      // the server log.\n      if (!exception._expectedByTest) {\n        Meteor._debug(\"Exception \" + context, exception.stack);\n        if (exception.sanitizedError) {\n          Meteor._debug(\"Sanitized and reported to the client as:\", exception.sanitizedError);\n          Meteor._debug();\n        }\n      }\n\n      // Did the error contain more details that could have been useful if caught in\n      // server code (or if thrown from non-client-originated code), but also\n      // provided a \"sanitized\" version with more context than 500 Internal server error? Use that.\n      if (exception.sanitizedError) {\n        if (exception.sanitizedError.isClientSafe) return exception.sanitizedError;\n        Meteor._debug(\"Exception \" + context + \" provides a sanitizedError that \" + \"does not have isClientSafe property set; ignoring\");\n      }\n      return new Meteor.Error(500, \"Internal server error\");\n    };\n\n    // Audit argument checks, if the audit-argument-checks package exists (it is a\n    // weak dependency of this package).\n    var maybeAuditArgumentChecks = function (f, context, args, description) {\n      args = args || [];\n      if (Package['audit-argument-checks']) {\n        return Match._failIfArgumentsAreNotAllChecked(f, context, args, description);\n      }\n      return f.apply(context, args);\n    };\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: false\n});","map":{"version":3,"names":["_objectSpread","module","link","default","v","isEmpty","isString","isObject","__reifyWaitForDeps__","DDPServer","publicationStrategies","SERVER_MERGE","useDummyDocumentView","useCollectionView","doAccountingForCollection","NO_MERGE_NO_HISTORY","NO_MERGE","NO_MERGE_MULTI","DummyDocumentView","self","existsIn","Set","dataByKey","Map","Object","assign","prototype","getFields","clearField","subscriptionHandle","key","changeCollector","undefined","changeField","value","isAdd","SessionDocumentView","_SessionDocumentView","_getCurrentFence","currentInvocation","_CurrentWriteFence","get","DDP","_CurrentMethodInvocation","fence","ret","forEach","precedenceList","removedValue","i","length","precedence","splice","delete","EJSON","equals","clone","has","set","elt","find","push","SessionCollectionView","collectionName","sessionCallbacks","documents","callbacks","_SessionCollectionView","size","diff","previous","DiffSequence","diffMaps","both","diffDocument","bind","rightOnly","id","nowDV","added","leftOnly","prevDV","removed","fields","diffObjects","prev","now","changed","docView","Meteor","server","getPublicationStrategy","add","entries","_ref","changedResult","Error","_ref2","err","Session","version","socket","options","Random","initialized","inQueue","_DoubleEndedQueue","blocked","workerRunning","cachedUnblock","_namedSubs","_universalSubs","userId","collectionViews","_isSending","_dontStartNewUniversalSubs","_pendingReady","_closeCallbacks","_socketUrl","url","_respondToPings","respondToPings","connectionHandle","close","onClose","fn","cb","bindEnvironment","defer","clientAddress","_clientAddress","httpHeaders","headers","send","msg","session","startUniversalSubs","heartbeatInterval","setWebsocketTimeout","heartbeat","DDPCommon","Heartbeat","heartbeatTimeout","onTimeout","sendPing","start","Package","Facts","incrementServerFact","sendReady","subscriptionIds","subs","subscriptionId","_canSend","sendAdded","collection","sendChanged","sendRemoved","getSendCallbacks","getCollectionView","view","handlers","universal_publish_handlers","handler","_startSubscription","stop","_meteorSession","_deactivateAllSubscriptions","callback","_removeSession","_printSentDDP","_debug","stringifyDDP","sendError","reason","offendingMessage","processMessage","msg_in","messageReceived","processNext","shift","runHandlers","unblock","onMessageHook","each","protocol_handlers","result","call","_isPromise","finally","sub","name","params","Array","publish_handlers","error","concat","DDPRateLimiter","rateLimiterInput","type","connectionId","_increment","rateLimitResult","_check","allowed","getErrorMessage","timeToReset","unsub","_stopSubscription","method","randomSeed","_WriteFence","onAllCommitted","retire","methods","method_handlers","arm","invocation","MethodInvocation","isSimulation","setUserId","_setUserId","connection","promise","Promise","resolve","reject","withValue","maybeAuditArgumentChecks","finish","payload","then","exception","wrapInternalException","_eachSub","f","_diffCollectionViews","beforeCVs","leftValue","rightValue","doc","_deactivate","oldNamedSubs","all","map","_ref3","newSub","_recreate","_runHandler","_noYieldsAllowed","subId","Subscription","unblockHander","subName","maybeSub","_name","_removeAllDocuments","response","httpForwardedCount","parseInt","process","env","remoteAddress","forwardedFor","trim","split","_session","_handler","_subscriptionId","_params","_subscriptionHandle","_deactivated","_stopCallbacks","_documents","_ready","_idFilter","idStringify","MongoID","idParse","resultOrThenable","_CurrentPublicationInvocation","e","_isDeactivated","isThenable","_publishHandlerResult","res","isCursor","c","_publishCursor","ready","isArray","every","collectionNames","_getCollectionName","cur","_callStopCallbacks","collectionDocs","strId","onStop","ids","Server","arguments","defaultPublicationStrategy","onConnectionHook","Hook","debugPrintExceptions","_publicationStrategies","sessions","stream_server","StreamServer","register","on","raw_msg","_printReceivedDDP","parseDDP","_handleConnect","onConnection","setPublicationStrategy","publicationName","strategy","values","includes","onMessage","support","SUPPORTED_DDP_VERSIONS","calculateVersion","publish","autopublish","is_auto","warned_about_autopublish","_ref4","isAsyncCall","_isCallAsyncMethodRunning","_ref5","func","_len","args","_key","pop","apply","callAsync","_args$","_len2","_key2","hasOwnProperty","_set","_setCallAsyncMethodRunning","_CurrentCallAsyncInvocation","hasCallAsyncParent","applyAsync","isFromCallAsync","catch","currentMethodInvocation","currentPublicationInvocation","makeRpcSeed","r","_urlForSession","sessionId","clientSupportedVersions","serverSupportedVersions","correctVersion","_calculateVersion","context","isClientSafe","originalMessage","message","details","_expectedByTest","stack","sanitizedError","description","Match","_failIfArgumentsAreNotAllChecked","__reify_async_result__","_reifyError","async"],"sources":["packages/ddp-server/livedata_server.js"],"sourcesContent":["import isEmpty from 'lodash.isempty';\nimport isString from 'lodash.isstring';\nimport isObject from 'lodash.isobject';\n\nDDPServer = {};\n\n\n// Publication strategies define how we handle data from published cursors at the collection level\n// This allows someone to:\n// - Choose a trade-off between client-server bandwidth and server memory usage\n// - Implement special (non-mongo) collections like volatile message queues\nconst publicationStrategies = {\n  // SERVER_MERGE is the default strategy.\n  // When using this strategy, the server maintains a copy of all data a connection is subscribed to.\n  // This allows us to only send deltas over multiple publications.\n  SERVER_MERGE: {\n    useDummyDocumentView: false,\n    useCollectionView: true,\n    doAccountingForCollection: true,\n  },\n  // The NO_MERGE_NO_HISTORY strategy results in the server sending all publication data\n  // directly to the client. It does not remember what it has previously sent\n  // to it will not trigger removed messages when a subscription is stopped.\n  // This should only be chosen for special use cases like send-and-forget queues.\n  NO_MERGE_NO_HISTORY: {\n    useDummyDocumentView: false,\n    useCollectionView: false,\n    doAccountingForCollection: false,\n  },\n  // NO_MERGE is similar to NO_MERGE_NO_HISTORY but the server will remember the IDs it has\n  // sent to the client so it can remove them when a subscription is stopped.\n  // This strategy can be used when a collection is only used in a single publication.\n  NO_MERGE: {\n    useDummyDocumentView: false,\n    useCollectionView: false,\n    doAccountingForCollection: true,\n  },\n  // NO_MERGE_MULTI is similar to `NO_MERGE`, but it does track whether a document is\n  // used by multiple publications. This has some memory overhead, but it still does not do\n  // diffing so it's faster and slimmer than SERVER_MERGE.\n  NO_MERGE_MULTI: {\n    useDummyDocumentView: true,\n    useCollectionView: true,\n    doAccountingForCollection: true\n  }\n};\n\nDDPServer.publicationStrategies = publicationStrategies;\n\n// This file contains classes:\n// * Session - The server's connection to a single DDP client\n// * Subscription - A single subscription for a single client\n// * Server - An entire server that may talk to > 1 client. A DDP endpoint.\n//\n// Session and Subscription are file scope. For now, until we freeze\n// the interface, Server is package scope (in the future it should be\n// exported).\nvar DummyDocumentView = function () {\n  var self = this;\n  self.existsIn = new Set(); // set of subscriptionHandle\n  self.dataByKey = new Map(); // key-> [ {subscriptionHandle, value} by precedence]\n};\n\nObject.assign(DummyDocumentView.prototype, {\n  getFields: function () {\n    return {}\n  },\n\n  clearField: function (subscriptionHandle, key, changeCollector) {\n    changeCollector[key] = undefined\n  },\n\n  changeField: function (subscriptionHandle, key, value,\n                         changeCollector, isAdd) {\n    changeCollector[key] = value\n  }\n});\n\n// Represents a single document in a SessionCollectionView\nvar SessionDocumentView = function () {\n  var self = this;\n  self.existsIn = new Set(); // set of subscriptionHandle\n  self.dataByKey = new Map(); // key-> [ {subscriptionHandle, value} by precedence]\n};\n\nDDPServer._SessionDocumentView = SessionDocumentView;\n\nDDPServer._getCurrentFence = function () {\n  let currentInvocation = this._CurrentWriteFence.get();\n  if (currentInvocation) {\n    return currentInvocation;\n  }\n  currentInvocation = DDP._CurrentMethodInvocation.get();\n  return currentInvocation ? currentInvocation.fence : undefined;\n};\n\nObject.assign(SessionDocumentView.prototype, {\n\n  getFields: function () {\n    var self = this;\n    var ret = {};\n    self.dataByKey.forEach(function (precedenceList, key) {\n      ret[key] = precedenceList[0].value;\n    });\n    return ret;\n  },\n\n  clearField: function (subscriptionHandle, key, changeCollector) {\n    var self = this;\n    // Publish API ignores _id if present in fields\n    if (key === \"_id\")\n      return;\n    var precedenceList = self.dataByKey.get(key);\n\n    // It's okay to clear fields that didn't exist. No need to throw\n    // an error.\n    if (!precedenceList)\n      return;\n\n    var removedValue = undefined;\n    for (var i = 0; i < precedenceList.length; i++) {\n      var precedence = precedenceList[i];\n      if (precedence.subscriptionHandle === subscriptionHandle) {\n        // The view's value can only change if this subscription is the one that\n        // used to have precedence.\n        if (i === 0)\n          removedValue = precedence.value;\n        precedenceList.splice(i, 1);\n        break;\n      }\n    }\n    if (precedenceList.length === 0) {\n      self.dataByKey.delete(key);\n      changeCollector[key] = undefined;\n    } else if (removedValue !== undefined &&\n               !EJSON.equals(removedValue, precedenceList[0].value)) {\n      changeCollector[key] = precedenceList[0].value;\n    }\n  },\n\n  changeField: function (subscriptionHandle, key, value,\n                         changeCollector, isAdd) {\n    var self = this;\n    // Publish API ignores _id if present in fields\n    if (key === \"_id\")\n      return;\n\n    // Don't share state with the data passed in by the user.\n    value = EJSON.clone(value);\n\n    if (!self.dataByKey.has(key)) {\n      self.dataByKey.set(key, [{subscriptionHandle: subscriptionHandle,\n                                value: value}]);\n      changeCollector[key] = value;\n      return;\n    }\n    var precedenceList = self.dataByKey.get(key);\n    var elt;\n    if (!isAdd) {\n      elt = precedenceList.find(function (precedence) {\n          return precedence.subscriptionHandle === subscriptionHandle;\n      });\n    }\n\n    if (elt) {\n      if (elt === precedenceList[0] && !EJSON.equals(value, elt.value)) {\n        // this subscription is changing the value of this field.\n        changeCollector[key] = value;\n      }\n      elt.value = value;\n    } else {\n      // this subscription is newly caring about this field\n      precedenceList.push({subscriptionHandle: subscriptionHandle, value: value});\n    }\n\n  }\n});\n\n/**\n * Represents a client's view of a single collection\n * @param {String} collectionName Name of the collection it represents\n * @param {Object.<String, Function>} sessionCallbacks The callbacks for added, changed, removed\n * @class SessionCollectionView\n */\nvar SessionCollectionView = function (collectionName, sessionCallbacks) {\n  var self = this;\n  self.collectionName = collectionName;\n  self.documents = new Map();\n  self.callbacks = sessionCallbacks;\n};\n\nDDPServer._SessionCollectionView = SessionCollectionView;\n\n\nObject.assign(SessionCollectionView.prototype, {\n\n  isEmpty: function () {\n    var self = this;\n    return self.documents.size === 0;\n  },\n\n  diff: function (previous) {\n    var self = this;\n    DiffSequence.diffMaps(previous.documents, self.documents, {\n      both: self.diffDocument.bind(self),\n\n      rightOnly: function (id, nowDV) {\n        self.callbacks.added(self.collectionName, id, nowDV.getFields());\n      },\n\n      leftOnly: function (id, prevDV) {\n        self.callbacks.removed(self.collectionName, id);\n      }\n    });\n  },\n\n  diffDocument: function (id, prevDV, nowDV) {\n    var self = this;\n    var fields = {};\n    DiffSequence.diffObjects(prevDV.getFields(), nowDV.getFields(), {\n      both: function (key, prev, now) {\n        if (!EJSON.equals(prev, now))\n          fields[key] = now;\n      },\n      rightOnly: function (key, now) {\n        fields[key] = now;\n      },\n      leftOnly: function(key, prev) {\n        fields[key] = undefined;\n      }\n    });\n    self.callbacks.changed(self.collectionName, id, fields);\n  },\n\n  added: function (subscriptionHandle, id, fields) {\n    var self = this;\n    var docView = self.documents.get(id);\n    var added = false;\n    if (!docView) {\n      added = true;\n      if (Meteor.server.getPublicationStrategy(this.collectionName).useDummyDocumentView) {\n        docView = new DummyDocumentView();\n      } else {\n        docView = new SessionDocumentView();\n      }\n\n      self.documents.set(id, docView);\n    }\n    docView.existsIn.add(subscriptionHandle);\n    var changeCollector = {};\n    Object.entries(fields).forEach(function ([key, value]) {\n      docView.changeField(\n        subscriptionHandle, key, value, changeCollector, true);\n    });\n    if (added)\n      self.callbacks.added(self.collectionName, id, changeCollector);\n    else\n      self.callbacks.changed(self.collectionName, id, changeCollector);\n  },\n\n  changed: function (subscriptionHandle, id, changed) {\n    var self = this;\n    var changedResult = {};\n    var docView = self.documents.get(id);\n    if (!docView)\n      throw new Error(\"Could not find element with id \" + id + \" to change\");\n      Object.entries(changed).forEach(function ([key, value]) {\n      if (value === undefined)\n        docView.clearField(subscriptionHandle, key, changedResult);\n      else\n        docView.changeField(subscriptionHandle, key, value, changedResult);\n    });\n    self.callbacks.changed(self.collectionName, id, changedResult);\n  },\n\n  removed: function (subscriptionHandle, id) {\n    var self = this;\n    var docView = self.documents.get(id);\n    if (!docView) {\n      var err = new Error(\"Removed nonexistent document \" + id);\n      throw err;\n    }\n    docView.existsIn.delete(subscriptionHandle);\n    if (docView.existsIn.size === 0) {\n      // it is gone from everyone\n      self.callbacks.removed(self.collectionName, id);\n      self.documents.delete(id);\n    } else {\n      var changed = {};\n      // remove this subscription from every precedence list\n      // and record the changes\n      docView.dataByKey.forEach(function (precedenceList, key) {\n        docView.clearField(subscriptionHandle, key, changed);\n      });\n\n      self.callbacks.changed(self.collectionName, id, changed);\n    }\n  }\n});\n\n/******************************************************************************/\n/* Session                                                                    */\n/******************************************************************************/\n\nvar Session = function (server, version, socket, options) {\n  var self = this;\n  self.id = Random.id();\n\n  self.server = server;\n  self.version = version;\n\n  self.initialized = false;\n  self.socket = socket;\n\n  // Set to null when the session is destroyed. Multiple places below\n  // use this to determine if the session is alive or not.\n  self.inQueue = new Meteor._DoubleEndedQueue();\n\n  self.blocked = false;\n  self.workerRunning = false;\n\n  self.cachedUnblock = null;\n\n  // Sub objects for active subscriptions\n  self._namedSubs = new Map();\n  self._universalSubs = [];\n\n  self.userId = null;\n\n  self.collectionViews = new Map();\n\n  // Set this to false to not send messages when collectionViews are\n  // modified. This is done when rerunning subs in _setUserId and those messages\n  // are calculated via a diff instead.\n  self._isSending = true;\n\n  // If this is true, don't start a newly-created universal publisher on this\n  // session. The session will take care of starting it when appropriate.\n  self._dontStartNewUniversalSubs = false;\n\n  // When we are rerunning subscriptions, any ready messages\n  // we want to buffer up for when we are done rerunning subscriptions\n  self._pendingReady = [];\n\n  // List of callbacks to call when this connection is closed.\n  self._closeCallbacks = [];\n\n\n  // XXX HACK: If a sockjs connection, save off the URL. This is\n  // temporary and will go away in the near future.\n  self._socketUrl = socket.url;\n\n  // Allow tests to disable responding to pings.\n  self._respondToPings = options.respondToPings;\n\n  // This object is the public interface to the session. In the public\n  // API, it is called the `connection` object.  Internally we call it\n  // a `connectionHandle` to avoid ambiguity.\n  self.connectionHandle = {\n    id: self.id,\n    close: function () {\n      self.close();\n    },\n    onClose: function (fn) {\n      var cb = Meteor.bindEnvironment(fn, \"connection onClose callback\");\n      if (self.inQueue) {\n        self._closeCallbacks.push(cb);\n      } else {\n        // if we're already closed, call the callback.\n        Meteor.defer(cb);\n      }\n    },\n    clientAddress: self._clientAddress(),\n    httpHeaders: self.socket.headers\n  };\n\n  self.send({ msg: 'connected', session: self.id });\n\n  // On initial connect, spin up all the universal publishers.\n  self.startUniversalSubs();\n\n  if (version !== 'pre1' && options.heartbeatInterval !== 0) {\n    // We no longer need the low level timeout because we have heartbeats.\n    socket.setWebsocketTimeout(0);\n\n    self.heartbeat = new DDPCommon.Heartbeat({\n      heartbeatInterval: options.heartbeatInterval,\n      heartbeatTimeout: options.heartbeatTimeout,\n      onTimeout: function () {\n        self.close();\n      },\n      sendPing: function () {\n        self.send({msg: 'ping'});\n      }\n    });\n    self.heartbeat.start();\n  }\n\n  Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n    \"livedata\", \"sessions\", 1);\n};\n\nObject.assign(Session.prototype, {\n  sendReady: function (subscriptionIds) {\n    var self = this;\n    if (self._isSending) {\n      self.send({msg: \"ready\", subs: subscriptionIds});\n    } else {\n      subscriptionIds.forEach(function (subscriptionId) {\n        self._pendingReady.push(subscriptionId);\n      });\n    }\n  },\n\n  _canSend(collectionName) {\n    return this._isSending || !this.server.getPublicationStrategy(collectionName).useCollectionView;\n  },\n\n\n  sendAdded(collectionName, id, fields) {\n    if (this._canSend(collectionName)) {\n      this.send({ msg: 'added', collection: collectionName, id, fields });\n    }\n  },\n\n  sendChanged(collectionName, id, fields) {\n    if (isEmpty(fields))\n      return;\n\n    if (this._canSend(collectionName)) {\n      this.send({\n        msg: \"changed\",\n        collection: collectionName,\n        id,\n        fields\n      });\n    }\n  },\n\n  sendRemoved(collectionName, id) {\n    if (this._canSend(collectionName)) {\n      this.send({msg: \"removed\", collection: collectionName, id});\n    }\n  },\n\n  getSendCallbacks: function () {\n    var self = this;\n    return {\n      added: self.sendAdded.bind(self),\n      changed: self.sendChanged.bind(self),\n      removed: self.sendRemoved.bind(self)\n    };\n  },\n\n  getCollectionView: function (collectionName) {\n    var self = this;\n    var ret = self.collectionViews.get(collectionName);\n    if (!ret) {\n      ret = new SessionCollectionView(collectionName,\n                                        self.getSendCallbacks());\n      self.collectionViews.set(collectionName, ret);\n    }\n    return ret;\n  },\n\n  added(subscriptionHandle, collectionName, id, fields) {\n    if (this.server.getPublicationStrategy(collectionName).useCollectionView) {\n      const view = this.getCollectionView(collectionName);\n      view.added(subscriptionHandle, id, fields);\n    } else {\n      this.sendAdded(collectionName, id, fields);\n    }\n  },\n\n  removed(subscriptionHandle, collectionName, id) {\n    if (this.server.getPublicationStrategy(collectionName).useCollectionView) {\n      const view = this.getCollectionView(collectionName);\n      view.removed(subscriptionHandle, id);\n      if (view.isEmpty()) {\n         this.collectionViews.delete(collectionName);\n      }\n    } else {\n      this.sendRemoved(collectionName, id);\n    }\n  },\n\n  changed(subscriptionHandle, collectionName, id, fields) {\n    if (this.server.getPublicationStrategy(collectionName).useCollectionView) {\n      const view = this.getCollectionView(collectionName);\n      view.changed(subscriptionHandle, id, fields);\n    } else {\n      this.sendChanged(collectionName, id, fields);\n    }\n  },\n\n  startUniversalSubs: function () {\n    var self = this;\n    // Make a shallow copy of the set of universal handlers and start them. If\n    // additional universal publishers start while we're running them (due to\n    // yielding), they will run separately as part of Server.publish.\n    var handlers = [...self.server.universal_publish_handlers];\n    handlers.forEach(function (handler) {\n      self._startSubscription(handler);\n    });\n  },\n\n  // Destroy this session and unregister it at the server.\n  close: function () {\n    var self = this;\n\n    // Destroy this session, even if it's not registered at the\n    // server. Stop all processing and tear everything down. If a socket\n    // was attached, close it.\n\n    // Already destroyed.\n    if (! self.inQueue)\n      return;\n\n    // Drop the merge box data immediately.\n    self.inQueue = null;\n    self.collectionViews = new Map();\n\n    if (self.heartbeat) {\n      self.heartbeat.stop();\n      self.heartbeat = null;\n    }\n\n    if (self.socket) {\n      self.socket.close();\n      self.socket._meteorSession = null;\n    }\n\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n      \"livedata\", \"sessions\", -1);\n\n    Meteor.defer(function () {\n      // Stop callbacks can yield, so we defer this on close.\n      // sub._isDeactivated() detects that we set inQueue to null and\n      // treats it as semi-deactivated (it will ignore incoming callbacks, etc).\n      self._deactivateAllSubscriptions();\n\n      // Defer calling the close callbacks, so that the caller closing\n      // the session isn't waiting for all the callbacks to complete.\n      self._closeCallbacks.forEach(function (callback) {\n        callback();\n      });\n    });\n\n    // Unregister the session.\n    self.server._removeSession(self);\n  },\n\n  // Send a message (doing nothing if no socket is connected right now).\n  // It should be a JSON object (it will be stringified).\n  send: function (msg) {\n    const self = this;\n    if (self.socket) {\n      if (Meteor._printSentDDP)\n        Meteor._debug(\"Sent DDP\", DDPCommon.stringifyDDP(msg));\n      self.socket.send(DDPCommon.stringifyDDP(msg));\n    }\n  },\n\n  // Send a connection error.\n  sendError: function (reason, offendingMessage) {\n    var self = this;\n    var msg = {msg: 'error', reason: reason};\n    if (offendingMessage)\n      msg.offendingMessage = offendingMessage;\n    self.send(msg);\n  },\n\n  // Process 'msg' as an incoming message. As a guard against\n  // race conditions during reconnection, ignore the message if\n  // 'socket' is not the currently connected socket.\n  //\n  // We run the messages from the client one at a time, in the order\n  // given by the client. The message handler is passed an idempotent\n  // function 'unblock' which it may call to allow other messages to\n  // begin running in parallel in another fiber (for example, a method\n  // that wants to yield). Otherwise, it is automatically unblocked\n  // when it returns.\n  //\n  // Actually, we don't have to 'totally order' the messages in this\n  // way, but it's the easiest thing that's correct. (unsub needs to\n  // be ordered against sub, methods need to be ordered against each\n  // other).\n  processMessage: function (msg_in) {\n    var self = this;\n    if (!self.inQueue) // we have been destroyed.\n      return;\n\n    // Respond to ping and pong messages immediately without queuing.\n    // If the negotiated DDP version is \"pre1\" which didn't support\n    // pings, preserve the \"pre1\" behavior of responding with a \"bad\n    // request\" for the unknown messages.\n    //\n    // Fibers are needed because heartbeats use Meteor.setTimeout, which\n    // needs a Fiber. We could actually use regular setTimeout and avoid\n    // these new fibers, but it is easier to just make everything use\n    // Meteor.setTimeout and not think too hard.\n    //\n    // Any message counts as receiving a pong, as it demonstrates that\n    // the client is still alive.\n    if (self.heartbeat) {\n      self.heartbeat.messageReceived();\n    };\n\n    if (self.version !== 'pre1' && msg_in.msg === 'ping') {\n      if (self._respondToPings)\n        self.send({msg: \"pong\", id: msg_in.id});\n      return;\n    }\n    if (self.version !== 'pre1' && msg_in.msg === 'pong') {\n      // Since everything is a pong, there is nothing to do\n      return;\n    }\n\n    self.inQueue.push(msg_in);\n    if (self.workerRunning)\n      return;\n    self.workerRunning = true;\n\n    var processNext = function () {\n      var msg = self.inQueue && self.inQueue.shift();\n\n      if (!msg) {\n        self.workerRunning = false;\n        return;\n      }\n\n      function runHandlers() {\n        var blocked = true;\n\n        var unblock = function () {\n          if (!blocked)\n            return; // idempotent\n          blocked = false;\n          processNext();\n        };\n\n        self.server.onMessageHook.each(function (callback) {\n          callback(msg, self);\n          return true;\n        });\n\n        if (msg.msg in self.protocol_handlers) {\n          const result = self.protocol_handlers[msg.msg].call(\n            self,\n            msg,\n            unblock\n          );\n\n          if (Meteor._isPromise(result)) {\n            result.finally(() => unblock());\n          } else {\n            unblock();\n          }\n        } else {\n          self.sendError('Bad request', msg);\n          unblock(); // in case the handler didn't already do it\n        }\n      }\n\n      runHandlers();\n    };\n\n    processNext();\n  },\n\n  protocol_handlers: {\n    sub: async function (msg, unblock) {\n      var self = this;\n\n      // cacheUnblock temporarly, so we can capture it later\n      // we will use unblock in current eventLoop, so this is safe\n      self.cachedUnblock = unblock;\n\n      // reject malformed messages\n      if (typeof (msg.id) !== \"string\" ||\n          typeof (msg.name) !== \"string\" ||\n          ('params' in msg && !(msg.params instanceof Array))) {\n        self.sendError(\"Malformed subscription\", msg);\n        return;\n      }\n\n      if (!self.server.publish_handlers[msg.name]) {\n        self.send({\n          msg: 'nosub', id: msg.id,\n          error: new Meteor.Error(404, `Subscription '${msg.name}' not found`)});\n        return;\n      }\n\n      if (self._namedSubs.has(msg.id))\n        // subs are idempotent, or rather, they are ignored if a sub\n        // with that id already exists. this is important during\n        // reconnect.\n        return;\n\n      // XXX It'd be much better if we had generic hooks where any package can\n      // hook into subscription handling, but in the mean while we special case\n      // ddp-rate-limiter package. This is also done for weak requirements to\n      // add the ddp-rate-limiter package in case we don't have Accounts. A\n      // user trying to use the ddp-rate-limiter must explicitly require it.\n      if (Package['ddp-rate-limiter']) {\n        var DDPRateLimiter = Package['ddp-rate-limiter'].DDPRateLimiter;\n        var rateLimiterInput = {\n          userId: self.userId,\n          clientAddress: self.connectionHandle.clientAddress,\n          type: \"subscription\",\n          name: msg.name,\n          connectionId: self.id\n        };\n\n        DDPRateLimiter._increment(rateLimiterInput);\n        var rateLimitResult = DDPRateLimiter._check(rateLimiterInput);\n        if (!rateLimitResult.allowed) {\n          self.send({\n            msg: 'nosub', id: msg.id,\n            error: new Meteor.Error(\n              'too-many-requests',\n              DDPRateLimiter.getErrorMessage(rateLimitResult),\n              {timeToReset: rateLimitResult.timeToReset})\n          });\n          return;\n        }\n      }\n\n      var handler = self.server.publish_handlers[msg.name];\n\n      await self._startSubscription(handler, msg.id, msg.params, msg.name);\n\n      // cleaning cached unblock\n      self.cachedUnblock = null;\n    },\n\n    unsub: function (msg) {\n      var self = this;\n\n      self._stopSubscription(msg.id);\n    },\n\n    method: async function (msg, unblock) {\n      var self = this;\n\n      // Reject malformed messages.\n      // For now, we silently ignore unknown attributes,\n      // for forwards compatibility.\n      if (typeof (msg.id) !== \"string\" ||\n          typeof (msg.method) !== \"string\" ||\n          ('params' in msg && !(msg.params instanceof Array)) ||\n          (('randomSeed' in msg) && (typeof msg.randomSeed !== \"string\"))) {\n        self.sendError(\"Malformed method invocation\", msg);\n        return;\n      }\n\n      var randomSeed = msg.randomSeed || null;\n\n      // Set up to mark the method as satisfied once all observers\n      // (and subscriptions) have reacted to any writes that were\n      // done.\n      var fence = new DDPServer._WriteFence;\n      fence.onAllCommitted(function () {\n        // Retire the fence so that future writes are allowed.\n        // This means that callbacks like timers are free to use\n        // the fence, and if they fire before it's armed (for\n        // example, because the method waits for them) their\n        // writes will be included in the fence.\n        fence.retire();\n        self.send({msg: 'updated', methods: [msg.id]});\n      });\n\n      // Find the handler\n      var handler = self.server.method_handlers[msg.method];\n      if (!handler) {\n        self.send({\n          msg: 'result', id: msg.id,\n          error: new Meteor.Error(404, `Method '${msg.method}' not found`)});\n        await fence.arm();\n        return;\n      }\n\n      var invocation = new DDPCommon.MethodInvocation({\n        name: msg.method,\n        isSimulation: false,\n        userId: self.userId,\n        setUserId(userId) {\n          return self._setUserId(userId);\n        },\n        unblock: unblock,\n        connection: self.connectionHandle,\n        randomSeed: randomSeed,\n        fence,\n      });\n\n      const promise = new Promise((resolve, reject) => {\n        // XXX It'd be better if we could hook into method handlers better but\n        // for now, we need to check if the ddp-rate-limiter exists since we\n        // have a weak requirement for the ddp-rate-limiter package to be added\n        // to our application.\n        if (Package['ddp-rate-limiter']) {\n          var DDPRateLimiter = Package['ddp-rate-limiter'].DDPRateLimiter;\n          var rateLimiterInput = {\n            userId: self.userId,\n            clientAddress: self.connectionHandle.clientAddress,\n            type: \"method\",\n            name: msg.method,\n            connectionId: self.id\n          };\n          DDPRateLimiter._increment(rateLimiterInput);\n          var rateLimitResult = DDPRateLimiter._check(rateLimiterInput)\n          if (!rateLimitResult.allowed) {\n            reject(new Meteor.Error(\n              \"too-many-requests\",\n              DDPRateLimiter.getErrorMessage(rateLimitResult),\n              {timeToReset: rateLimitResult.timeToReset}\n            ));\n            return;\n          }\n        }\n\n        resolve(DDPServer._CurrentWriteFence.withValue(\n          fence,\n          () => DDP._CurrentMethodInvocation.withValue(\n            invocation,\n            () => maybeAuditArgumentChecks(\n              handler, invocation, msg.params,\n              \"call to '\" + msg.method + \"'\"\n            )\n          )\n        ));\n      });\n\n      async function finish() {\n        await fence.arm();\n        unblock();\n      }\n\n      const payload = {\n        msg: \"result\",\n        id: msg.id\n      };\n      return promise.then(async result => {\n        await finish();\n        if (result !== undefined) {\n          payload.result = result;\n        }\n        self.send(payload);\n      }, async (exception) => {\n        await finish();\n        payload.error = wrapInternalException(\n          exception,\n          `while invoking method '${msg.method}'`\n        );\n        self.send(payload);\n      });\n    }\n  },\n\n  _eachSub: function (f) {\n    var self = this;\n    self._namedSubs.forEach(f);\n    self._universalSubs.forEach(f);\n  },\n\n  _diffCollectionViews: function (beforeCVs) {\n    var self = this;\n    DiffSequence.diffMaps(beforeCVs, self.collectionViews, {\n      both: function (collectionName, leftValue, rightValue) {\n        rightValue.diff(leftValue);\n      },\n      rightOnly: function (collectionName, rightValue) {\n        rightValue.documents.forEach(function (docView, id) {\n          self.sendAdded(collectionName, id, docView.getFields());\n        });\n      },\n      leftOnly: function (collectionName, leftValue) {\n        leftValue.documents.forEach(function (doc, id) {\n          self.sendRemoved(collectionName, id);\n        });\n      }\n    });\n  },\n\n  // Sets the current user id in all appropriate contexts and reruns\n  // all subscriptions\n  async _setUserId(userId) {\n    var self = this;\n\n    if (userId !== null && typeof userId !== \"string\")\n      throw new Error(\"setUserId must be called on string or null, not \" +\n                      typeof userId);\n\n    // Prevent newly-created universal subscriptions from being added to our\n    // session. They will be found below when we call startUniversalSubs.\n    //\n    // (We don't have to worry about named subscriptions, because we only add\n    // them when we process a 'sub' message. We are currently processing a\n    // 'method' message, and the method did not unblock, because it is illegal\n    // to call setUserId after unblock. Thus we cannot be concurrently adding a\n    // new named subscription).\n    self._dontStartNewUniversalSubs = true;\n\n    // Prevent current subs from updating our collectionViews and call their\n    // stop callbacks. This may yield.\n    self._eachSub(function (sub) {\n      sub._deactivate();\n    });\n\n    // All subs should now be deactivated. Stop sending messages to the client,\n    // save the state of the published collections, reset to an empty view, and\n    // update the userId.\n    self._isSending = false;\n    var beforeCVs = self.collectionViews;\n    self.collectionViews = new Map();\n    self.userId = userId;\n\n    // _setUserId is normally called from a Meteor method with\n    // DDP._CurrentMethodInvocation set. But DDP._CurrentMethodInvocation is not\n    // expected to be set inside a publish function, so we temporary unset it.\n    // Inside a publish function DDP._CurrentPublicationInvocation is set.\n    await DDP._CurrentMethodInvocation.withValue(undefined, async function () {\n      // Save the old named subs, and reset to having no subscriptions.\n      var oldNamedSubs = self._namedSubs;\n      self._namedSubs = new Map();\n      self._universalSubs = [];\n\n\n\n      await Promise.all([...oldNamedSubs].map(async ([subscriptionId, sub]) => {\n        const newSub = sub._recreate();\n        self._namedSubs.set(subscriptionId, newSub);\n        // nb: if the handler throws or calls this.error(), it will in fact\n        // immediately send its 'nosub'. This is OK, though.\n        await newSub._runHandler();\n      }));\n\n      // Allow newly-created universal subs to be started on our connection in\n      // parallel with the ones we're spinning up here, and spin up universal\n      // subs.\n      self._dontStartNewUniversalSubs = false;\n      self.startUniversalSubs();\n    }, { name: '_setUserId' });\n\n    // Start sending messages again, beginning with the diff from the previous\n    // state of the world to the current state. No yields are allowed during\n    // this diff, so that other changes cannot interleave.\n    Meteor._noYieldsAllowed(function () {\n      self._isSending = true;\n      self._diffCollectionViews(beforeCVs);\n      if (!isEmpty(self._pendingReady)) {\n        self.sendReady(self._pendingReady);\n        self._pendingReady = [];\n      }\n    });\n  },\n\n  _startSubscription: function (handler, subId, params, name) {\n    var self = this;\n\n    var sub = new Subscription(\n      self, handler, subId, params, name);\n\n    let unblockHander = self.cachedUnblock;\n    // _startSubscription may call from a lot places\n    // so cachedUnblock might be null in somecases\n    // assign the cachedUnblock\n    sub.unblock = unblockHander || (() => {});\n\n    if (subId)\n      self._namedSubs.set(subId, sub);\n    else\n      self._universalSubs.push(sub);\n\n    return sub._runHandler();\n  },\n\n  // Tear down specified subscription\n  _stopSubscription: function (subId, error) {\n    var self = this;\n\n    var subName = null;\n    if (subId) {\n      var maybeSub = self._namedSubs.get(subId);\n      if (maybeSub) {\n        subName = maybeSub._name;\n        maybeSub._removeAllDocuments();\n        maybeSub._deactivate();\n        self._namedSubs.delete(subId);\n      }\n    }\n\n    var response = {msg: 'nosub', id: subId};\n\n    if (error) {\n      response.error = wrapInternalException(\n        error,\n        subName ? (\"from sub \" + subName + \" id \" + subId)\n          : (\"from sub id \" + subId));\n    }\n\n    self.send(response);\n  },\n\n  // Tear down all subscriptions. Note that this does NOT send removed or nosub\n  // messages, since we assume the client is gone.\n  _deactivateAllSubscriptions: function () {\n    var self = this;\n\n    self._namedSubs.forEach(function (sub, id) {\n      sub._deactivate();\n    });\n    self._namedSubs = new Map();\n\n    self._universalSubs.forEach(function (sub) {\n      sub._deactivate();\n    });\n    self._universalSubs = [];\n  },\n\n  // Determine the remote client's IP address, based on the\n  // HTTP_FORWARDED_COUNT environment variable representing how many\n  // proxies the server is behind.\n  _clientAddress: function () {\n    var self = this;\n\n    // For the reported client address for a connection to be correct,\n    // the developer must set the HTTP_FORWARDED_COUNT environment\n    // variable to an integer representing the number of hops they\n    // expect in the `x-forwarded-for` header. E.g., set to \"1\" if the\n    // server is behind one proxy.\n    //\n    // This could be computed once at startup instead of every time.\n    var httpForwardedCount = parseInt(process.env['HTTP_FORWARDED_COUNT']) || 0;\n\n    if (httpForwardedCount === 0)\n      return self.socket.remoteAddress;\n\n    var forwardedFor = self.socket.headers[\"x-forwarded-for\"];\n    if (!isString(forwardedFor))\n      return null;\n    forwardedFor = forwardedFor.trim().split(/\\s*,\\s*/);\n\n    // Typically the first value in the `x-forwarded-for` header is\n    // the original IP address of the client connecting to the first\n    // proxy.  However, the end user can easily spoof the header, in\n    // which case the first value(s) will be the fake IP address from\n    // the user pretending to be a proxy reporting the original IP\n    // address value.  By counting HTTP_FORWARDED_COUNT back from the\n    // end of the list, we ensure that we get the IP address being\n    // reported by *our* first proxy.\n\n    if (httpForwardedCount < 0 || httpForwardedCount > forwardedFor.length)\n      return null;\n\n    return forwardedFor[forwardedFor.length - httpForwardedCount];\n  }\n});\n\n/******************************************************************************/\n/* Subscription                                                               */\n/******************************************************************************/\n\n// Ctor for a sub handle: the input to each publish function\n\n// Instance name is this because it's usually referred to as this inside a\n// publish\n/**\n * @summary The server's side of a subscription\n * @class Subscription\n * @instanceName this\n * @showInstanceName true\n */\nvar Subscription = function (\n    session, handler, subscriptionId, params, name) {\n  var self = this;\n  self._session = session; // type is Session\n\n  /**\n   * @summary Access inside the publish function. The incoming [connection](#meteor_onconnection) for this subscription.\n   * @locus Server\n   * @name  connection\n   * @memberOf Subscription\n   * @instance\n   */\n  self.connection = session.connectionHandle; // public API object\n\n  self._handler = handler;\n\n  // My subscription ID (generated by client, undefined for universal subs).\n  self._subscriptionId = subscriptionId;\n  // Undefined for universal subs\n  self._name = name;\n\n  self._params = params || [];\n\n  // Only named subscriptions have IDs, but we need some sort of string\n  // internally to keep track of all subscriptions inside\n  // SessionDocumentViews. We use this subscriptionHandle for that.\n  if (self._subscriptionId) {\n    self._subscriptionHandle = 'N' + self._subscriptionId;\n  } else {\n    self._subscriptionHandle = 'U' + Random.id();\n  }\n\n  // Has _deactivate been called?\n  self._deactivated = false;\n\n  // Stop callbacks to g/c this sub.  called w/ zero arguments.\n  self._stopCallbacks = [];\n\n  // The set of (collection, documentid) that this subscription has\n  // an opinion about.\n  self._documents = new Map();\n\n  // Remember if we are ready.\n  self._ready = false;\n\n  // Part of the public API: the user of this sub.\n\n  /**\n   * @summary Access inside the publish function. The id of the logged-in user, or `null` if no user is logged in.\n   * @locus Server\n   * @memberOf Subscription\n   * @name  userId\n   * @instance\n   */\n  self.userId = session.userId;\n\n  // For now, the id filter is going to default to\n  // the to/from DDP methods on MongoID, to\n  // specifically deal with mongo/minimongo ObjectIds.\n\n  // Later, you will be able to make this be \"raw\"\n  // if you want to publish a collection that you know\n  // just has strings for keys and no funny business, to\n  // a DDP consumer that isn't minimongo.\n\n  self._idFilter = {\n    idStringify: MongoID.idStringify,\n    idParse: MongoID.idParse\n  };\n\n  Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n    \"livedata\", \"subscriptions\", 1);\n};\n\nObject.assign(Subscription.prototype, {\n  _runHandler: async function() {\n    // XXX should we unblock() here? Either before running the publish\n    // function, or before running _publishCursor.\n    //\n    // Right now, each publish function blocks all future publishes and\n    // methods waiting on data from Mongo (or whatever else the function\n    // blocks on). This probably slows page load in common cases.\n\n    if (!this.unblock) {\n      this.unblock = () => {};\n    }\n\n    const self = this;\n    let resultOrThenable = null;\n    try {\n      resultOrThenable = DDP._CurrentPublicationInvocation.withValue(\n        self,\n        () =>\n          maybeAuditArgumentChecks(\n            self._handler,\n            self,\n            EJSON.clone(self._params),\n            // It's OK that this would look weird for universal subscriptions,\n            // because they have no arguments so there can never be an\n            // audit-argument-checks failure.\n            \"publisher '\" + self._name + \"'\"\n          ),\n        { name: self._name }\n      );\n    } catch (e) {\n      self.error(e);\n      return;\n    }\n\n    // Did the handler call this.error or this.stop?\n    if (self._isDeactivated()) return;\n\n    // Both conventional and async publish handler functions are supported.\n    // If an object is returned with a then() function, it is either a promise\n    // or thenable and will be resolved asynchronously.\n    const isThenable =\n      resultOrThenable && typeof resultOrThenable.then === 'function';\n    if (isThenable) {\n      try {\n        await self._publishHandlerResult(await resultOrThenable);\n      } catch(e) {\n        self.error(e)\n      }\n    } else {\n      await self._publishHandlerResult(resultOrThenable);\n    }\n  },\n\n  async _publishHandlerResult (res) {\n    // SPECIAL CASE: Instead of writing their own callbacks that invoke\n    // this.added/changed/ready/etc, the user can just return a collection\n    // cursor or array of cursors from the publish function; we call their\n    // _publishCursor method which starts observing the cursor and publishes the\n    // results. Note that _publishCursor does NOT call ready().\n    //\n    // XXX This uses an undocumented interface which only the Mongo cursor\n    // interface publishes. Should we make this interface public and encourage\n    // users to implement it themselves? Arguably, it's unnecessary; users can\n    // already write their own functions like\n    //   var publishMyReactiveThingy = function (name, handler) {\n    //     Meteor.publish(name, function () {\n    //       var reactiveThingy = handler();\n    //       reactiveThingy.publishMe();\n    //     });\n    //   };\n\n    var self = this;\n    var isCursor = function (c) {\n      return c && c._publishCursor;\n    };\n    if (isCursor(res)) {\n      try {\n        await res._publishCursor(self);\n      } catch (e) {\n        self.error(e);\n        return;\n      }\n      // _publishCursor only returns after the initial added callbacks have run.\n      // mark subscription as ready.\n      self.ready();\n    } else if (Array.isArray(res)) {\n      // Check all the elements are cursors\n      if (! res.every(isCursor)) {\n        self.error(new Error(\"Publish function returned an array of non-Cursors\"));\n        return;\n      }\n      // Find duplicate collection names\n      // XXX we should support overlapping cursors, but that would require the\n      // merge box to allow overlap within a subscription\n      var collectionNames = {};\n\n      for (var i = 0; i < res.length; ++i) {\n        var collectionName = res[i]._getCollectionName();\n        if (collectionNames[collectionName]) {\n          self.error(new Error(\n            \"Publish function returned multiple cursors for collection \" +\n              collectionName));\n          return;\n        }\n        collectionNames[collectionName] = true;\n      }\n\n      try {\n        await Promise.all(res.map(cur => cur._publishCursor(self)));\n      } catch (e) {\n        self.error(e);\n        return;\n      }\n      self.ready();\n    } else if (res) {\n      // Truthy values other than cursors or arrays are probably a\n      // user mistake (possible returning a Mongo document via, say,\n      // `coll.findOne()`).\n      self.error(new Error(\"Publish function can only return a Cursor or \"\n                           + \"an array of Cursors\"));\n    }\n  },\n\n  // This calls all stop callbacks and prevents the handler from updating any\n  // SessionCollectionViews further. It's used when the user unsubscribes or\n  // disconnects, as well as during setUserId re-runs. It does *NOT* send\n  // removed messages for the published objects; if that is necessary, call\n  // _removeAllDocuments first.\n  _deactivate: function() {\n    var self = this;\n    if (self._deactivated)\n      return;\n    self._deactivated = true;\n    self._callStopCallbacks();\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n      \"livedata\", \"subscriptions\", -1);\n  },\n\n  _callStopCallbacks: function () {\n    var self = this;\n    // Tell listeners, so they can clean up\n    var callbacks = self._stopCallbacks;\n    self._stopCallbacks = [];\n    callbacks.forEach(function (callback) {\n      callback();\n    });\n  },\n\n  // Send remove messages for every document.\n  _removeAllDocuments: function () {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._documents.forEach(function (collectionDocs, collectionName) {\n        collectionDocs.forEach(function (strId) {\n          self.removed(collectionName, self._idFilter.idParse(strId));\n        });\n      });\n    });\n  },\n\n  // Returns a new Subscription for the same session with the same\n  // initial creation parameters. This isn't a clone: it doesn't have\n  // the same _documents cache, stopped state or callbacks; may have a\n  // different _subscriptionHandle, and gets its userId from the\n  // session, not from this object.\n  _recreate: function () {\n    var self = this;\n    return new Subscription(\n      self._session, self._handler, self._subscriptionId, self._params,\n      self._name);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Stops this client's subscription, triggering a call on the client to the `onStop` callback passed to [`Meteor.subscribe`](#meteor_subscribe), if any. If `error` is not a [`Meteor.Error`](#meteor_error), it will be [sanitized](#meteor_error).\n   * @locus Server\n   * @param {Error} error The error to pass to the client.\n   * @instance\n   * @memberOf Subscription\n   */\n  error: function (error) {\n    var self = this;\n    if (self._isDeactivated())\n      return;\n    self._session._stopSubscription(self._subscriptionId, error);\n  },\n\n  // Note that while our DDP client will notice that you've called stop() on the\n  // server (and clean up its _subscriptions table) we don't actually provide a\n  // mechanism for an app to notice this (the subscribe onError callback only\n  // triggers if there is an error).\n\n  /**\n   * @summary Call inside the publish function.  Stops this client's subscription and invokes the client's `onStop` callback with no error.\n   * @locus Server\n   * @instance\n   * @memberOf Subscription\n   */\n  stop: function () {\n    var self = this;\n    if (self._isDeactivated())\n      return;\n    self._session._stopSubscription(self._subscriptionId);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Registers a callback function to run when the subscription is stopped.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {Function} func The callback function\n   */\n  onStop: function (callback) {\n    var self = this;\n    callback = Meteor.bindEnvironment(callback, 'onStop callback', self);\n    if (self._isDeactivated())\n      callback();\n    else\n      self._stopCallbacks.push(callback);\n  },\n\n  // This returns true if the sub has been deactivated, *OR* if the session was\n  // destroyed but the deferred call to _deactivateAllSubscriptions hasn't\n  // happened yet.\n  _isDeactivated: function () {\n    var self = this;\n    return self._deactivated || self._session.inQueue === null;\n  },\n\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that a document has been added to the record set.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {String} collection The name of the collection that contains the new document.\n   * @param {String} id The new document's ID.\n   * @param {Object} fields The fields in the new document.  If `_id` is present it is ignored.\n   */\n  added (collectionName, id, fields) {\n    if (this._isDeactivated())\n      return;\n    id = this._idFilter.idStringify(id);\n\n    if (this._session.server.getPublicationStrategy(collectionName).doAccountingForCollection) {\n      let ids = this._documents.get(collectionName);\n      if (ids == null) {\n        ids = new Set();\n        this._documents.set(collectionName, ids);\n      }\n      ids.add(id);\n    }\n\n    this._session.added(this._subscriptionHandle, collectionName, id, fields);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that a document in the record set has been modified.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {String} collection The name of the collection that contains the changed document.\n   * @param {String} id The changed document's ID.\n   * @param {Object} fields The fields in the document that have changed, together with their new values.  If a field is not present in `fields` it was left unchanged; if it is present in `fields` and has a value of `undefined` it was removed from the document.  If `_id` is present it is ignored.\n   */\n  changed (collectionName, id, fields) {\n    if (this._isDeactivated())\n      return;\n    id = this._idFilter.idStringify(id);\n    this._session.changed(this._subscriptionHandle, collectionName, id, fields);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that a document has been removed from the record set.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {String} collection The name of the collection that the document has been removed from.\n   * @param {String} id The ID of the document that has been removed.\n   */\n  removed (collectionName, id) {\n    if (this._isDeactivated())\n      return;\n    id = this._idFilter.idStringify(id);\n\n    if (this._session.server.getPublicationStrategy(collectionName).doAccountingForCollection) {\n      // We don't bother to delete sets of things in a collection if the\n      // collection is empty.  It could break _removeAllDocuments.\n      this._documents.get(collectionName).delete(id);\n    }\n\n    this._session.removed(this._subscriptionHandle, collectionName, id);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that an initial, complete snapshot of the record set has been sent.  This will trigger a call on the client to the `onReady` callback passed to  [`Meteor.subscribe`](#meteor_subscribe), if any.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   */\n  ready: function () {\n    var self = this;\n    if (self._isDeactivated())\n      return;\n    if (!self._subscriptionId)\n      return;  // Unnecessary but ignored for universal sub\n    if (!self._ready) {\n      self._session.sendReady([self._subscriptionId]);\n      self._ready = true;\n    }\n  }\n});\n\n/******************************************************************************/\n/* Server                                                                     */\n/******************************************************************************/\n\nServer = function (options = {}) {\n  var self = this;\n\n  // The default heartbeat interval is 30 seconds on the server and 35\n  // seconds on the client.  Since the client doesn't need to send a\n  // ping as long as it is receiving pings, this means that pings\n  // normally go from the server to the client.\n  //\n  // Note: Troposphere depends on the ability to mutate\n  // Meteor.server.options.heartbeatTimeout! This is a hack, but it's life.\n  self.options = {\n    heartbeatInterval: 15000,\n    heartbeatTimeout: 15000,\n    // For testing, allow responding to pings to be disabled.\n    respondToPings: true,\n    defaultPublicationStrategy: publicationStrategies.SERVER_MERGE,\n    ...options,\n  };\n\n  // Map of callbacks to call when a new connection comes in to the\n  // server and completes DDP version negotiation. Use an object instead\n  // of an array so we can safely remove one from the list while\n  // iterating over it.\n  self.onConnectionHook = new Hook({\n    debugPrintExceptions: \"onConnection callback\"\n  });\n\n  // Map of callbacks to call when a new message comes in.\n  self.onMessageHook = new Hook({\n    debugPrintExceptions: \"onMessage callback\"\n  });\n\n  self.publish_handlers = {};\n  self.universal_publish_handlers = [];\n\n  self.method_handlers = {};\n\n  self._publicationStrategies = {};\n\n  self.sessions = new Map(); // map from id to session\n\n  self.stream_server = new StreamServer();\n\n  self.stream_server.register(function (socket) {\n    // socket implements the SockJSConnection interface\n    socket._meteorSession = null;\n\n    var sendError = function (reason, offendingMessage) {\n      var msg = {msg: 'error', reason: reason};\n      if (offendingMessage)\n        msg.offendingMessage = offendingMessage;\n      socket.send(DDPCommon.stringifyDDP(msg));\n    };\n\n    socket.on('data', function (raw_msg) {\n      if (Meteor._printReceivedDDP) {\n        Meteor._debug(\"Received DDP\", raw_msg);\n      }\n      try {\n        try {\n          var msg = DDPCommon.parseDDP(raw_msg);\n        } catch (err) {\n          sendError('Parse error');\n          return;\n        }\n        if (msg === null || !msg.msg) {\n          sendError('Bad request', msg);\n          return;\n        }\n\n        if (msg.msg === 'connect') {\n          if (socket._meteorSession) {\n            sendError(\"Already connected\", msg);\n            return;\n          }\n\n          self._handleConnect(socket, msg);\n\n          return;\n        }\n\n        if (!socket._meteorSession) {\n          sendError('Must connect first', msg);\n          return;\n        }\n        socket._meteorSession.processMessage(msg);\n      } catch (e) {\n        // XXX print stack nicely\n        Meteor._debug(\"Internal exception while processing message\", msg, e);\n      }\n    });\n\n    socket.on('close', function () {\n      if (socket._meteorSession) {\n        socket._meteorSession.close();\n      }\n    });\n  });\n};\n\nObject.assign(Server.prototype, {\n\n  /**\n   * @summary Register a callback to be called when a new DDP connection is made to the server.\n   * @locus Server\n   * @param {function} callback The function to call when a new DDP connection is established.\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */\n  onConnection: function (fn) {\n    var self = this;\n    return self.onConnectionHook.register(fn);\n  },\n\n  /**\n   * @summary Set publication strategy for the given publication. Publications strategies are available from `DDPServer.publicationStrategies`. You call this method from `Meteor.server`, like `Meteor.server.setPublicationStrategy()`\n   * @locus Server\n   * @alias setPublicationStrategy\n   * @param publicationName {String}\n   * @param strategy {{useCollectionView: boolean, doAccountingForCollection: boolean}}\n   * @memberOf Meteor.server\n   * @importFromPackage meteor\n   */\n  setPublicationStrategy(publicationName, strategy) {\n    if (!Object.values(publicationStrategies).includes(strategy)) {\n      throw new Error(`Invalid merge strategy: ${strategy} \n        for collection ${publicationName}`);\n    }\n    this._publicationStrategies[publicationName] = strategy;\n  },\n\n  /**\n   * @summary Gets the publication strategy for the requested publication. You call this method from `Meteor.server`, like `Meteor.server.getPublicationStrategy()`\n   * @locus Server\n   * @alias getPublicationStrategy\n   * @param publicationName {String}\n   * @memberOf Meteor.server\n   * @importFromPackage meteor\n   * @return {{useCollectionView: boolean, doAccountingForCollection: boolean}}\n   */\n  getPublicationStrategy(publicationName) {\n    return this._publicationStrategies[publicationName]\n      || this.options.defaultPublicationStrategy;\n  },\n\n  /**\n   * @summary Register a callback to be called when a new DDP message is received.\n   * @locus Server\n   * @param {function} callback The function to call when a new DDP message is received.\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */\n  onMessage: function (fn) {\n    var self = this;\n    return self.onMessageHook.register(fn);\n  },\n\n  _handleConnect: function (socket, msg) {\n    var self = this;\n\n    // The connect message must specify a version and an array of supported\n    // versions, and it must claim to support what it is proposing.\n    if (!(typeof (msg.version) === 'string' &&\n          Array.isArray(msg.support) &&\n          msg.support.every(isString) &&\n          msg.support.includes(msg.version))) {\n      socket.send(DDPCommon.stringifyDDP({msg: 'failed',\n                                version: DDPCommon.SUPPORTED_DDP_VERSIONS[0]}));\n      socket.close();\n      return;\n    }\n\n    // In the future, handle session resumption: something like:\n    //  socket._meteorSession = self.sessions[msg.session]\n    var version = calculateVersion(msg.support, DDPCommon.SUPPORTED_DDP_VERSIONS);\n\n    if (msg.version !== version) {\n      // The best version to use (according to the client's stated preferences)\n      // is not the one the client is trying to use. Inform them about the best\n      // version to use.\n      socket.send(DDPCommon.stringifyDDP({msg: 'failed', version: version}));\n      socket.close();\n      return;\n    }\n\n    // Yay, version matches! Create a new session.\n    // Note: Troposphere depends on the ability to mutate\n    // Meteor.server.options.heartbeatTimeout! This is a hack, but it's life.\n    socket._meteorSession = new Session(self, version, socket, self.options);\n    self.sessions.set(socket._meteorSession.id, socket._meteorSession);\n    self.onConnectionHook.each(function (callback) {\n      if (socket._meteorSession)\n        callback(socket._meteorSession.connectionHandle);\n      return true;\n    });\n  },\n  /**\n   * Register a publish handler function.\n   *\n   * @param name {String} identifier for query\n   * @param handler {Function} publish handler\n   * @param options {Object}\n   *\n   * Server will call handler function on each new subscription,\n   * either when receiving DDP sub message for a named subscription, or on\n   * DDP connect for a universal subscription.\n   *\n   * If name is null, this will be a subscription that is\n   * automatically established and permanently on for all connected\n   * client, instead of a subscription that can be turned on and off\n   * with subscribe().\n   *\n   * options to contain:\n   *  - (mostly internal) is_auto: true if generated automatically\n   *    from an autopublish hook. this is for cosmetic purposes only\n   *    (it lets us determine whether to print a warning suggesting\n   *    that you turn off autopublish).\n   */\n\n  /**\n   * @summary Publish a record set.\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   * @locus Server\n   * @param {String|Object} name If String, name of the record set.  If Object, publications Dictionary of publish functions by name.  If `null`, the set has no name, and the record set is automatically sent to all connected clients.\n   * @param {Function} func Function called on the server each time a client subscribes.  Inside the function, `this` is the publish handler object, described below.  If the client passed arguments to `subscribe`, the function is called with the same arguments.\n   */\n  publish: function (name, handler, options) {\n    var self = this;\n\n    if (!isObject(name)) {\n      options = options || {};\n\n      if (name && name in self.publish_handlers) {\n        Meteor._debug(\"Ignoring duplicate publish named '\" + name + \"'\");\n        return;\n      }\n\n      if (Package.autopublish && !options.is_auto) {\n        // They have autopublish on, yet they're trying to manually\n        // pick stuff to publish. They probably should turn off\n        // autopublish. (This check isn't perfect -- if you create a\n        // publish before you turn on autopublish, it won't catch\n        // it, but this will definitely handle the simple case where\n        // you've added the autopublish package to your app, and are\n        // calling publish from your app code).\n        if (!self.warned_about_autopublish) {\n          self.warned_about_autopublish = true;\n          Meteor._debug(\n    \"** You've set up some data subscriptions with Meteor.publish(), but\\n\" +\n    \"** you still have autopublish turned on. Because autopublish is still\\n\" +\n    \"** on, your Meteor.publish() calls won't have much effect. All data\\n\" +\n    \"** will still be sent to all clients.\\n\" +\n    \"**\\n\" +\n    \"** Turn off autopublish by removing the autopublish package:\\n\" +\n    \"**\\n\" +\n    \"**   $ meteor remove autopublish\\n\" +\n    \"**\\n\" +\n    \"** .. and make sure you have Meteor.publish() and Meteor.subscribe() calls\\n\" +\n    \"** for each collection that you want clients to see.\\n\");\n        }\n      }\n\n      if (name)\n        self.publish_handlers[name] = handler;\n      else {\n        self.universal_publish_handlers.push(handler);\n        // Spin up the new publisher on any existing session too. Run each\n        // session's subscription in a new Fiber, so that there's no change for\n        // self.sessions to change while we're running this loop.\n        self.sessions.forEach(function (session) {\n          if (!session._dontStartNewUniversalSubs) {\n            session._startSubscription(handler);\n          }\n        });\n      }\n    }\n    else{\n      Object.entries(name).forEach(function([key, value]) {\n        self.publish(key, value, {});\n      });\n    }\n  },\n\n  _removeSession: function (session) {\n    var self = this;\n    self.sessions.delete(session.id);\n  },\n\n  /**\n   * @summary Tells if the method call came from a call or a callAsync.\n   * @locus Anywhere\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   * @returns boolean\n   */\n  isAsyncCall: function(){\n    return DDP._CurrentMethodInvocation._isCallAsyncMethodRunning()\n  },\n\n  /**\n   * @summary Defines functions that can be invoked over the network by clients.\n   * @locus Anywhere\n   * @param {Object} methods Dictionary whose keys are method names and values are functions.\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */\n  methods: function (methods) {\n    var self = this;\n    Object.entries(methods).forEach(function ([name, func]) {\n      if (typeof func !== 'function')\n        throw new Error(\"Method '\" + name + \"' must be a function\");\n      if (self.method_handlers[name])\n        throw new Error(\"A method named '\" + name + \"' is already defined\");\n      self.method_handlers[name] = func;\n    });\n  },\n\n  call: function (name, ...args) {\n    if (args.length && typeof args[args.length - 1] === \"function\") {\n      // If it's a function, the last argument is the result callback, not\n      // a parameter to the remote method.\n      var callback = args.pop();\n    }\n\n    return this.apply(name, args, callback);\n  },\n\n  // A version of the call method that always returns a Promise.\n  callAsync: function (name, ...args) {\n    const options = args[0]?.hasOwnProperty('returnStubValue')\n      ? args.shift()\n      : {};\n    DDP._CurrentMethodInvocation._set();\n    DDP._CurrentMethodInvocation._setCallAsyncMethodRunning(true);\n    const promise = new Promise((resolve, reject) => {\n      DDP._CurrentCallAsyncInvocation._set({ name, hasCallAsyncParent: true });\n      this.applyAsync(name, args, { isFromCallAsync: true, ...options })\n        .then(resolve)\n        .catch(reject)\n        .finally(() => {\n          DDP._CurrentCallAsyncInvocation._set();\n        });\n    });\n    return promise.finally(() =>\n      DDP._CurrentMethodInvocation._setCallAsyncMethodRunning(false)\n    );\n  },\n\n  apply: function (name, args, options, callback) {\n    // We were passed 3 arguments. They may be either (name, args, options)\n    // or (name, args, callback)\n    if (! callback && typeof options === 'function') {\n      callback = options;\n      options = {};\n    } else {\n      options = options || {};\n    }\n    const promise = this.applyAsync(name, args, options);\n\n    // Return the result in whichever way the caller asked for it. Note that we\n    // do NOT block on the write fence in an analogous way to how the client\n    // blocks on the relevant data being visible, so you are NOT guaranteed that\n    // cursor observe callbacks have fired when your callback is invoked. (We\n    // can change this if there's a real use case).\n    if (callback) {\n      promise.then(\n        result => callback(undefined, result),\n        exception => callback(exception)\n      );\n    } else {\n      return promise;\n    }\n  },\n\n  // @param options {Optional Object}\n  applyAsync: function (name, args, options) {\n    // Run the handler\n    var handler = this.method_handlers[name];\n\n    if (! handler) {\n      return Promise.reject(\n        new Meteor.Error(404, `Method '${name}' not found`)\n      );\n    }\n    // If this is a method call from within another method or publish function,\n    // get the user state from the outer method or publish function, otherwise\n    // don't allow setUserId to be called\n    var userId = null;\n    let setUserId = () => {\n      throw new Error(\"Can't call setUserId on a server initiated method call\");\n    };\n    var connection = null;\n    var currentMethodInvocation = DDP._CurrentMethodInvocation.get();\n    var currentPublicationInvocation = DDP._CurrentPublicationInvocation.get();\n    var randomSeed = null;\n\n    if (currentMethodInvocation) {\n      userId = currentMethodInvocation.userId;\n      setUserId = (userId) => currentMethodInvocation.setUserId(userId);\n      connection = currentMethodInvocation.connection;\n      randomSeed = DDPCommon.makeRpcSeed(currentMethodInvocation, name);\n    } else if (currentPublicationInvocation) {\n      userId = currentPublicationInvocation.userId;\n      setUserId = (userId) => currentPublicationInvocation._session._setUserId(userId);\n      connection = currentPublicationInvocation.connection;\n    }\n\n    var invocation = new DDPCommon.MethodInvocation({\n      isSimulation: false,\n      userId,\n      setUserId,\n      connection,\n      randomSeed\n    });\n\n    return new Promise((resolve, reject) => {\n      let result;\n      try {\n        result = DDP._CurrentMethodInvocation.withValue(invocation, () =>\n          maybeAuditArgumentChecks(\n            handler,\n            invocation,\n            EJSON.clone(args),\n            \"internal call to '\" + name + \"'\"\n          )\n        );\n      } catch (e) {\n        return reject(e);\n      }\n      if (!Meteor._isPromise(result)) {\n        return resolve(result);\n      }\n      result.then(r => resolve(r)).catch(reject);\n    }).then(EJSON.clone);\n  },\n\n  _urlForSession: function (sessionId) {\n    var self = this;\n    var session = self.sessions.get(sessionId);\n    if (session)\n      return session._socketUrl;\n    else\n      return null;\n  }\n});\n\nvar calculateVersion = function (clientSupportedVersions,\n                                 serverSupportedVersions) {\n  var correctVersion = clientSupportedVersions.find(function (version) {\n    return serverSupportedVersions.includes(version);\n  });\n  if (!correctVersion) {\n    correctVersion = serverSupportedVersions[0];\n  }\n  return correctVersion;\n};\n\nDDPServer._calculateVersion = calculateVersion;\n\n\n// \"blind\" exceptions other than those that were deliberately thrown to signal\n// errors to the client\nvar wrapInternalException = function (exception, context) {\n  if (!exception) return exception;\n\n  // To allow packages to throw errors intended for the client but not have to\n  // depend on the Meteor.Error class, `isClientSafe` can be set to true on any\n  // error before it is thrown.\n  if (exception.isClientSafe) {\n    if (!(exception instanceof Meteor.Error)) {\n      const originalMessage = exception.message;\n      exception = new Meteor.Error(exception.error, exception.reason, exception.details);\n      exception.message = originalMessage;\n    }\n    return exception;\n  }\n\n  // Tests can set the '_expectedByTest' flag on an exception so it won't go to\n  // the server log.\n  if (!exception._expectedByTest) {\n    Meteor._debug(\"Exception \" + context, exception.stack);\n    if (exception.sanitizedError) {\n      Meteor._debug(\"Sanitized and reported to the client as:\", exception.sanitizedError);\n      Meteor._debug();\n    }\n  }\n\n  // Did the error contain more details that could have been useful if caught in\n  // server code (or if thrown from non-client-originated code), but also\n  // provided a \"sanitized\" version with more context than 500 Internal server error? Use that.\n  if (exception.sanitizedError) {\n    if (exception.sanitizedError.isClientSafe)\n      return exception.sanitizedError;\n    Meteor._debug(\"Exception \" + context + \" provides a sanitizedError that \" +\n                  \"does not have isClientSafe property set; ignoring\");\n  }\n\n  return new Meteor.Error(500, \"Internal server error\");\n};\n\n\n// Audit argument checks, if the audit-argument-checks package exists (it is a\n// weak dependency of this package).\nvar maybeAuditArgumentChecks = function (f, context, args, description) {\n  args = args || [];\n  if (Package['audit-argument-checks']) {\n    return Match._failIfArgumentsAreNotAllChecked(\n      f, context, args, description);\n  }\n  return f.apply(context, args);\n};"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"6304c4e1710b79de4dc98f0f8485b64b067272ca"}
