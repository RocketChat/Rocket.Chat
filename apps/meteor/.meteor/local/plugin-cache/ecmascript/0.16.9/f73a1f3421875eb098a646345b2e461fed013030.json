{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/ddp-client/client/queueStubsHelpers.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"packages/ddp-client/client/queueStubsHelpers.js","filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/ddp-client/client/queueStubsHelpers.js","targets":{"android":"125.0.0","chrome":"125.0.0","edge":"125.0.0","firefox":"115.0.0","ie":"10.0.0","ios":"17.4.0","opera":"110.0.0","opera_mobile":"80.0.0","safari":"17.4.0","samsung":"24.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","root":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/ddp-client/client/queueStubsHelpers.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/ddp-client/client/queueStubsHelpers.js"}},"code":"module.export({\n  loadAsyncStubHelpers: () => loadAsyncStubHelpers\n});\nlet DDP;\nmodule.link(\"../common/namespace.js\", {\n  DDP(v) {\n    DDP = v;\n  }\n}, 0);\nlet isEmpty, last;\nmodule.link(\"meteor/ddp-common/utils.js\", {\n  isEmpty(v) {\n    isEmpty = v;\n  },\n  last(v) {\n    last = v;\n  }\n}, 1);\nlet Connection;\nmodule.link(\"../common/livedata_connection\", {\n  Connection(v) {\n    Connection = v;\n  }\n}, 2);\n// https://forums.meteor.com/t/proposal-to-fix-issues-with-async-method-stubs/60826\n\nlet queueSize = 0;\nlet queue = Promise.resolve();\nconst loadAsyncStubHelpers = () => {\n  function queueFunction(fn) {\n    let promiseProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    queueSize += 1;\n    let resolve;\n    let reject;\n    const promise = new Promise((_resolve, _reject) => {\n      resolve = _resolve;\n      reject = _reject;\n    });\n    queue = queue.finally(() => {\n      var _promise$stubPromise;\n      fn(resolve, reject);\n      return (_promise$stubPromise = promise.stubPromise) === null || _promise$stubPromise === void 0 ? void 0 : _promise$stubPromise.catch(() => {}); // silent uncaught promise\n    });\n    promise.catch(() => {}) // silent uncaught promise\n    .finally(() => {\n      queueSize -= 1;\n      if (queueSize === 0) {\n        Meteor.connection._maybeMigrate();\n      }\n    });\n    promise.stubPromise = promiseProps.stubPromise;\n    promise.serverPromise = promiseProps.serverPromise;\n    return promise;\n  }\n  let oldReadyToMigrate = Connection.prototype._readyToMigrate;\n  Connection.prototype._readyToMigrate = function () {\n    if (queueSize > 0) {\n      return false;\n    }\n    return oldReadyToMigrate.apply(this, arguments);\n  };\n  let currentMethodInvocation = null;\n\n  /**\n   * Meteor sets CurrentMethodInvocation to undefined for the reasons explained at\n   * https://github.com/meteor/meteor/blob/c9e3551b9673a7ed607f18cb1128563ff49ca96f/packages/ddp-client/common/livedata_connection.js#L578-L605\n   * The app code could call `.then` on a promise while the async stub is running,\n   * causing the `then` callback to think it is inside the stub.\n   *\n   * With the queueing we are doing, this is no longer necessary. The point\n   * of the queueing is to prevent app/package code from running while\n   * the stub is running, so we don't need to worry about this.\n   */\n\n  let oldApplyAsync = Connection.prototype.applyAsync;\n  Connection.prototype.applyAsync = function () {\n    let args = arguments;\n    let name = args[0];\n    if (currentMethodInvocation) {\n      DDP._CurrentMethodInvocation._set(currentMethodInvocation);\n      currentMethodInvocation = null;\n    }\n    const enclosing = DDP._CurrentMethodInvocation.get();\n    const alreadyInSimulation = enclosing === null || enclosing === void 0 ? void 0 : enclosing.isSimulation;\n    const isFromCallAsync = enclosing === null || enclosing === void 0 ? void 0 : enclosing._isFromCallAsync;\n    if (Meteor.connection._getIsSimulation({\n      isFromCallAsync,\n      alreadyInSimulation\n    })) {\n      // In stub - call immediately\n      return oldApplyAsync.apply(this, args);\n    }\n    let stubPromiseResolver;\n    let serverPromiseResolver;\n    const stubPromise = new Promise(r => stubPromiseResolver = r);\n    const serverPromise = new Promise(r => serverPromiseResolver = r);\n    return queueFunction((resolve, reject) => {\n      let hasStub = false;\n      let finished = false;\n      Meteor._setImmediate(() => {\n        const applyAsyncPromise = oldApplyAsync.apply(this, args);\n        stubPromiseResolver(applyAsyncPromise.stubPromise);\n        serverPromiseResolver(applyAsyncPromise.serverPromise);\n        hasStub = !!applyAsyncPromise.stubPromise;\n        if (hasStub) {\n          applyAsyncPromise.stubPromise.catch(() => {}) // silent uncaught promise\n          .finally(() => {\n            finished = true;\n          });\n        }\n        applyAsyncPromise.then(result => {\n          resolve(result);\n        }).catch(err => {\n          reject(err);\n        });\n        serverPromise.catch(() => {}); // silent uncaught promise\n      });\n      Meteor._setImmediate(() => {\n        if (hasStub && !finished) {\n          console.warn(\"Method stub (\".concat(name, \") took too long and could cause unexpected problems. Learn more at https://v3-migration-docs.meteor.com/breaking-changes/call-x-callAsync.html#considerations-for-effective-use-of-meteor-callasync\"));\n        }\n      });\n    }, {\n      stubPromise,\n      serverPromise\n    });\n  };\n  let oldApply = Connection.prototype.apply;\n  Connection.prototype.apply = function () {\n    // [name, args, options]\n    let options = arguments[2] || {};\n    let wait = options.wait;\n\n    // Apply runs the stub before synchronously returning.\n    //\n    // However, we want the server to run the methods in the original call order\n    // so we have to queue sending the message to the server until any previous async\n    // methods run.\n    // This does mean the stubs run in a different order than the methods on the\n    // server.\n\n    let oldOutstandingMethodBlocks = Meteor.connection._outstandingMethodBlocks;\n    // Meteor only sends the method if _outstandingMethodBlocks.length is 1.\n    // Add a wait block to force Meteor to put the new method in a second block.\n    let outstandingMethodBlocks = [{\n      wait: true,\n      methods: []\n    }];\n    Meteor.connection._outstandingMethodBlocks = outstandingMethodBlocks;\n    let result;\n    try {\n      result = oldApply.apply(this, arguments);\n    } finally {\n      Meteor.connection._outstandingMethodBlocks = oldOutstandingMethodBlocks;\n    }\n    if (outstandingMethodBlocks[1]) {\n      let methodInvoker = outstandingMethodBlocks[1].methods[0];\n      if (methodInvoker) {\n        queueMethodInvoker(methodInvoker, wait);\n      }\n    }\n    return result;\n  };\n  function queueMethodInvoker(methodInvoker, wait) {\n    queueFunction(resolve => {\n      let self = Meteor.connection;\n      // based on https://github.com/meteor/meteor/blob/e0631738f2a8a914d8a50b1060e8f40cb0873680/packages/ddp-client/common/livedata_connection.js#L833-L853C1\n      if (wait) {\n        // It's a wait method! Wait methods go in their own block.\n        self._outstandingMethodBlocks.push({\n          wait: true,\n          methods: [methodInvoker]\n        });\n      } else {\n        // Not a wait method. Start a new block if the previous block was a wait\n        // block, and add it to the last block of methods.\n        if (isEmpty(self._outstandingMethodBlocks) || last(self._outstandingMethodBlocks).wait) {\n          self._outstandingMethodBlocks.push({\n            wait: false,\n            methods: []\n          });\n        }\n        last(self._outstandingMethodBlocks).methods.push(methodInvoker);\n      }\n\n      // If we added it to the first block, send it out now.\n      if (self._outstandingMethodBlocks.length === 1) methodInvoker.sendMessage();\n      resolve();\n    });\n  }\n\n  /**\n   * Queue subscriptions in case they rely on previous method calls\n   */\n  let queueSend = false;\n  let oldSubscribe = Connection.prototype.subscribe;\n  Connection.prototype.subscribe = function () {\n    if (this._stream._neverQueued) {\n      return oldSubscribe.apply(this, arguments);\n    }\n    queueSend = true;\n    try {\n      return oldSubscribe.apply(this, arguments);\n    } finally {\n      queueSend = false;\n    }\n  };\n  let oldSend = Connection.prototype._send;\n  Connection.prototype._send = function (params, shouldQueue) {\n    if (this._stream._neverQueued) {\n      return oldSend.apply(this, arguments);\n    }\n    if (!queueSend && !shouldQueue) {\n      return oldSend.call(this, params);\n    }\n    queueSend = false;\n    queueFunction(resolve => {\n      try {\n        oldSend.call(this, params);\n      } finally {\n        resolve();\n      }\n    });\n  };\n  let _oldSendOutstandingMethodBlocksMessages = Connection.prototype._sendOutstandingMethodBlocksMessages;\n  Connection.prototype._sendOutstandingMethodBlocksMessages = function () {\n    if (this._stream._neverQueued) {\n      return _oldSendOutstandingMethodBlocksMessages.apply(this, arguments);\n    }\n    queueFunction(resolve => {\n      try {\n        _oldSendOutstandingMethodBlocksMessages.apply(this, arguments);\n      } finally {\n        resolve();\n      }\n    });\n  };\n};","map":{"version":3,"names":["module","export","loadAsyncStubHelpers","DDP","link","v","isEmpty","last","Connection","queueSize","queue","Promise","resolve","queueFunction","fn","promiseProps","arguments","length","undefined","reject","promise","_resolve","_reject","finally","_promise$stubPromise","stubPromise","catch","Meteor","connection","_maybeMigrate","serverPromise","oldReadyToMigrate","prototype","_readyToMigrate","apply","currentMethodInvocation","oldApplyAsync","applyAsync","args","name","_CurrentMethodInvocation","_set","enclosing","get","alreadyInSimulation","isSimulation","isFromCallAsync","_isFromCallAsync","_getIsSimulation","stubPromiseResolver","serverPromiseResolver","r","hasStub","finished","_setImmediate","applyAsyncPromise","then","result","err","console","warn","concat","oldApply","options","wait","oldOutstandingMethodBlocks","_outstandingMethodBlocks","outstandingMethodBlocks","methods","methodInvoker","queueMethodInvoker","self","push","sendMessage","queueSend","oldSubscribe","subscribe","_stream","_neverQueued","oldSend","_send","params","shouldQueue","call","_oldSendOutstandingMethodBlocksMessages","_sendOutstandingMethodBlocksMessages"],"sources":["packages/ddp-client/client/queueStubsHelpers.js"],"sourcesContent":["import { DDP } from \"../common/namespace.js\";\nimport { isEmpty, last } from \"meteor/ddp-common/utils.js\";\nimport { Connection } from \"../common/livedata_connection\";\n\n// https://forums.meteor.com/t/proposal-to-fix-issues-with-async-method-stubs/60826\n\nlet queueSize = 0;\nlet queue = Promise.resolve();\n\nexport const loadAsyncStubHelpers = () => {\n  function queueFunction(fn, promiseProps = {}) {\n    queueSize += 1;\n\n    let resolve;\n    let reject;\n    const promise = new Promise((_resolve, _reject) => {\n      resolve = _resolve;\n      reject = _reject;\n    });\n\n    queue = queue.finally(() => {\n      fn(resolve, reject);\n\n      return promise.stubPromise?.catch(() => {}); // silent uncaught promise\n    });\n\n    promise\n      .catch(() => {}) // silent uncaught promise\n      .finally(() => {\n        queueSize -= 1;\n        if (queueSize === 0) {\n          Meteor.connection._maybeMigrate();\n        }\n      });\n\n    promise.stubPromise = promiseProps.stubPromise;\n    promise.serverPromise = promiseProps.serverPromise;\n\n    return promise;\n  }\n\n  let oldReadyToMigrate = Connection.prototype._readyToMigrate;\n  Connection.prototype._readyToMigrate = function () {\n    if (queueSize > 0) {\n      return false;\n    }\n\n    return oldReadyToMigrate.apply(this, arguments);\n  };\n\n  let currentMethodInvocation = null;\n\n  /**\n   * Meteor sets CurrentMethodInvocation to undefined for the reasons explained at\n   * https://github.com/meteor/meteor/blob/c9e3551b9673a7ed607f18cb1128563ff49ca96f/packages/ddp-client/common/livedata_connection.js#L578-L605\n   * The app code could call `.then` on a promise while the async stub is running,\n   * causing the `then` callback to think it is inside the stub.\n   *\n   * With the queueing we are doing, this is no longer necessary. The point\n   * of the queueing is to prevent app/package code from running while\n   * the stub is running, so we don't need to worry about this.\n   */\n\n  let oldApplyAsync = Connection.prototype.applyAsync;\n  Connection.prototype.applyAsync = function () {\n    let args = arguments;\n    let name = args[0];\n\n    if (currentMethodInvocation) {\n      DDP._CurrentMethodInvocation._set(currentMethodInvocation);\n      currentMethodInvocation = null;\n    }\n\n    const enclosing = DDP._CurrentMethodInvocation.get();\n    const alreadyInSimulation = enclosing?.isSimulation;\n    const isFromCallAsync = enclosing?._isFromCallAsync;\n\n    if (\n      Meteor.connection._getIsSimulation({\n        isFromCallAsync,\n        alreadyInSimulation,\n      })\n    ) {\n      // In stub - call immediately\n      return oldApplyAsync.apply(this, args);\n    }\n\n    let stubPromiseResolver;\n    let serverPromiseResolver;\n    const stubPromise = new Promise((r) => (stubPromiseResolver = r));\n    const serverPromise = new Promise((r) => (serverPromiseResolver = r));\n\n    return queueFunction(\n      (resolve, reject) => {\n        let hasStub = false;\n        let finished = false;\n\n        Meteor._setImmediate(() => {\n          const applyAsyncPromise = oldApplyAsync.apply(this, args);\n          stubPromiseResolver(applyAsyncPromise.stubPromise);\n          serverPromiseResolver(applyAsyncPromise.serverPromise);\n          hasStub = !!applyAsyncPromise.stubPromise;\n          if (hasStub) {\n            applyAsyncPromise.stubPromise\n              .catch(() => {}) // silent uncaught promise\n              .finally(() => {\n                finished = true;\n              });\n          }\n\n          applyAsyncPromise\n            .then((result) => {\n              resolve(result);\n            })\n            .catch((err) => {\n              reject(err);\n            });\n          serverPromise.catch(() => {}); // silent uncaught promise\n        });\n\n        Meteor._setImmediate(() => {\n          if (hasStub && !finished) {\n            console.warn(\n              `Method stub (${name}) took too long and could cause unexpected problems. Learn more at https://v3-migration-docs.meteor.com/breaking-changes/call-x-callAsync.html#considerations-for-effective-use-of-meteor-callasync`\n            );\n          }\n        });\n      },\n      {\n        stubPromise,\n        serverPromise,\n      }\n    );\n  };\n\n  let oldApply = Connection.prototype.apply;\n  Connection.prototype.apply = function () {\n    // [name, args, options]\n    let options = arguments[2] || {};\n    let wait = options.wait;\n\n    // Apply runs the stub before synchronously returning.\n    //\n    // However, we want the server to run the methods in the original call order\n    // so we have to queue sending the message to the server until any previous async\n    // methods run.\n    // This does mean the stubs run in a different order than the methods on the\n    // server.\n\n    let oldOutstandingMethodBlocks = Meteor.connection._outstandingMethodBlocks;\n    // Meteor only sends the method if _outstandingMethodBlocks.length is 1.\n    // Add a wait block to force Meteor to put the new method in a second block.\n    let outstandingMethodBlocks = [{ wait: true, methods: [] }];\n    Meteor.connection._outstandingMethodBlocks = outstandingMethodBlocks;\n\n    let result;\n    try {\n      result = oldApply.apply(this, arguments);\n    } finally {\n      Meteor.connection._outstandingMethodBlocks = oldOutstandingMethodBlocks;\n    }\n\n    if (outstandingMethodBlocks[1]) {\n      let methodInvoker = outstandingMethodBlocks[1].methods[0];\n\n      if (methodInvoker) {\n        queueMethodInvoker(methodInvoker, wait);\n      }\n    }\n\n    return result;\n  };\n\n  function queueMethodInvoker(methodInvoker, wait) {\n    queueFunction((resolve) => {\n      let self = Meteor.connection;\n      // based on https://github.com/meteor/meteor/blob/e0631738f2a8a914d8a50b1060e8f40cb0873680/packages/ddp-client/common/livedata_connection.js#L833-L853C1\n      if (wait) {\n        // It's a wait method! Wait methods go in their own block.\n        self._outstandingMethodBlocks.push({\n          wait: true,\n          methods: [methodInvoker],\n        });\n      } else {\n        // Not a wait method. Start a new block if the previous block was a wait\n        // block, and add it to the last block of methods.\n        if (\n          isEmpty(self._outstandingMethodBlocks) ||\n          last(self._outstandingMethodBlocks).wait\n        ) {\n          self._outstandingMethodBlocks.push({\n            wait: false,\n            methods: [],\n          });\n        }\n\n        last(self._outstandingMethodBlocks).methods.push(methodInvoker);\n      }\n\n      // If we added it to the first block, send it out now.\n      if (self._outstandingMethodBlocks.length === 1)\n        methodInvoker.sendMessage();\n\n      resolve();\n    });\n  }\n\n  /**\n   * Queue subscriptions in case they rely on previous method calls\n   */\n  let queueSend = false;\n  let oldSubscribe = Connection.prototype.subscribe;\n  Connection.prototype.subscribe = function () {\n    if (this._stream._neverQueued) {\n      return oldSubscribe.apply(this, arguments);\n    }\n\n    queueSend = true;\n    try {\n      return oldSubscribe.apply(this, arguments);\n    } finally {\n      queueSend = false;\n    }\n  };\n\n  let oldSend = Connection.prototype._send;\n  Connection.prototype._send = function (params, shouldQueue) {\n    if (this._stream._neverQueued) {\n      return oldSend.apply(this, arguments);\n    }\n\n    if (!queueSend && !shouldQueue) {\n      return oldSend.call(this, params);\n    }\n\n    queueSend = false;\n    queueFunction((resolve) => {\n      try {\n        oldSend.call(this, params);\n      } finally {\n        resolve();\n      }\n    });\n  };\n  let _oldSendOutstandingMethodBlocksMessages =\n    Connection.prototype._sendOutstandingMethodBlocksMessages;\n  Connection.prototype._sendOutstandingMethodBlocksMessages = function () {\n    if (this._stream._neverQueued) {\n      return _oldSendOutstandingMethodBlocksMessages.apply(this, arguments);\n    }\n    queueFunction((resolve) => {\n      try {\n        _oldSendOutstandingMethodBlocksMessages.apply(this, arguments);\n      } finally {\n        resolve();\n      }\n    });\n  };\n};\n"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"f73a1f3421875eb098a646345b2e461fed013030"}
