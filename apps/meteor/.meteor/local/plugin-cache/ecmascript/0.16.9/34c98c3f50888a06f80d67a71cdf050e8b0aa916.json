{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/mongo/observe_multiplex.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.arm64"},"sourceFileName":"packages/mongo/observe_multiplex.js","filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/mongo/observe_multiplex.js","targets":{"android":"125.0.0","chrome":"125.0.0","edge":"125.0.0","firefox":"115.0.0","ie":"10.0.0","ios":"17.4.0","opera":"110.0.0","opera_mobile":"80.0.0","safari":"17.4.0","samsung":"24.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","root":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true,"topLevelAwait":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/mongo/observe_multiplex.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/mongo/observe_multiplex.js"}},"code":"!module.wrapAsync(async function (module, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    let _objectWithoutProperties;\n    module.link(\"@babel/runtime/helpers/objectWithoutProperties\", {\n      default(v) {\n        _objectWithoutProperties = v;\n      }\n    }, 0);\n    const _excluded = [\"_id\"];\n    let has;\n    module.link(\"lodash.has\", {\n      default(v) {\n        has = v;\n      }\n    }, 0);\n    let isEmpty;\n    module.link(\"lodash.isempty\", {\n      default(v) {\n        isEmpty = v;\n      }\n    }, 1);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    let nextObserveHandleId = 1;\n    ObserveMultiplexer = class {\n      constructor() {\n        let {\n          ordered,\n          onStop = () => {}\n        } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (ordered === undefined) throw Error(\"must specify ordered\");\n        Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"mongo-livedata\", \"observe-multiplexers\", 1);\n        this._ordered = ordered;\n        this._onStop = onStop;\n        this._queue = new Meteor._AsynchronousQueue();\n        this._handles = {};\n        this._resolver = null;\n        this._readyPromise = new Promise(r => this._resolver = r).then(() => this._isReady = true);\n        this._cache = new LocalCollection._CachingChangeObserver({\n          ordered\n        });\n        // Number of addHandleAndSendInitialAdds tasks scheduled but not yet\n        // running. removeHandle uses this to know if it's time to call the onStop\n        // callback.\n        this._addHandleTasksScheduledButNotPerformed = 0;\n        const self = this;\n        this.callbackNames().forEach(callbackName => {\n          this[callbackName] = function /* ... */\n          () {\n            self._applyCallback(callbackName, _.toArray(arguments));\n          };\n        });\n      }\n      addHandleAndSendInitialAdds(handle) {\n        return this._addHandleAndSendInitialAdds(handle);\n      }\n      async _addHandleAndSendInitialAdds(handle) {\n        ++this._addHandleTasksScheduledButNotPerformed;\n        Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"mongo-livedata\", \"observe-handles\", 1);\n        const self = this;\n        await this._queue.runTask(async function () {\n          self._handles[handle._id] = handle;\n          // Send out whatever adds we have so far (whether the\n          // multiplexer is ready).\n          await self._sendAdds(handle);\n          --self._addHandleTasksScheduledButNotPerformed;\n        });\n        await this._readyPromise;\n      }\n\n      // Remove an observe handle. If it was the last observe handle, call the\n      // onStop callback; you cannot add any more observe handles after this.\n      //\n      // This is not synchronized with polls and handle additions: this means that\n      // you can safely call it from within an observe callback, but it also means\n      // that we have to be careful when we iterate over _handles.\n      async removeHandle(id) {\n        // This should not be possible: you can only call removeHandle by having\n        // access to the ObserveHandle, which isn't returned to user code until the\n        // multiplex is ready.\n        if (!this._ready()) throw new Error(\"Can't remove handles until the multiplex is ready\");\n        delete this._handles[id];\n        Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"mongo-livedata\", \"observe-handles\", -1);\n        if (isEmpty(this._handles) && this._addHandleTasksScheduledButNotPerformed === 0) {\n          await this._stop();\n        }\n      }\n      async _stop(options) {\n        options = options || {};\n\n        // It shouldn't be possible for us to stop when all our handles still\n        // haven't been returned from observeChanges!\n        if (!this._ready() && !options.fromQueryError) throw Error(\"surprising _stop: not ready\");\n\n        // Call stop callback (which kills the underlying process which sends us\n        // callbacks and removes us from the connection's dictionary).\n        await this._onStop();\n        Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"mongo-livedata\", \"observe-multiplexers\", -1);\n\n        // Cause future addHandleAndSendInitialAdds calls to throw (but the onStop\n        // callback should make our connection forget about us).\n        this._handles = null;\n      }\n\n      // Allows all addHandleAndSendInitialAdds calls to return, once all preceding\n      // adds have been processed. Does not block.\n      async ready() {\n        const self = this;\n        this._queue.queueTask(function () {\n          if (self._ready()) throw Error(\"can't make ObserveMultiplex ready twice!\");\n          if (!self._resolver) {\n            throw new Error(\"Missing resolver\");\n          }\n          self._resolver();\n          self._isReady = true;\n        });\n      }\n\n      // If trying to execute the query results in an error, call this. This is\n      // intended for permanent errors, not transient network errors that could be\n      // fixed. It should only be called before ready(), because if you called ready\n      // that meant that you managed to run the query once. It will stop this\n      // ObserveMultiplex and cause addHandleAndSendInitialAdds calls (and thus\n      // observeChanges calls) to throw the error.\n      async queryError(err) {\n        var self = this;\n        await this._queue.runTask(function () {\n          if (self._ready()) throw Error(\"can't claim query has an error after it worked!\");\n          self._stop({\n            fromQueryError: true\n          });\n          throw err;\n        });\n      }\n\n      // Calls \"cb\" once the effects of all \"ready\", \"addHandleAndSendInitialAdds\"\n      // and observe callbacks which came before this call have been propagated to\n      // all handles. \"ready\" must have already been called on this multiplexer.\n      async onFlush(cb) {\n        var self = this;\n        await this._queue.queueTask(async function () {\n          if (!self._ready()) throw Error(\"only call onFlush on a multiplexer that will be ready\");\n          await cb();\n        });\n      }\n      callbackNames() {\n        if (this._ordered) return [\"addedBefore\", \"changed\", \"movedBefore\", \"removed\"];else return [\"added\", \"changed\", \"removed\"];\n      }\n      _ready() {\n        return !!this._isReady;\n      }\n      _applyCallback(callbackName, args) {\n        const self = this;\n        this._queue.queueTask(async function () {\n          // If we stopped in the meantime, do nothing.\n          if (!self._handles) return;\n\n          // First, apply the change to the cache.\n          await self._cache.applyChange[callbackName].apply(null, args);\n          // If we haven't finished the initial adds, then we should only be getting\n          // adds.\n          if (!self._ready() && callbackName !== 'added' && callbackName !== 'addedBefore') {\n            throw new Error(\"Got \" + callbackName + \" during initial adds\");\n          }\n\n          // Now multiplex the callbacks out to all observe handles. It's OK if\n          // these calls yield; since we're inside a task, no other use of our queue\n          // can continue until these are done. (But we do have to be careful to not\n          // use a handle that got removed, because removeHandle does not use the\n          // queue; thus, we iterate over an array of keys that we control.)\n          for (const handleId of Object.keys(self._handles)) {\n            var handle = self._handles && self._handles[handleId];\n            if (!handle) return;\n            var callback = handle['_' + callbackName];\n            // clone arguments so that callbacks can mutate their arguments\n\n            callback && (await callback.apply(null, handle.nonMutatingCallbacks ? args : EJSON.clone(args)));\n          }\n        });\n      }\n\n      // Sends initial adds to a handle. It should only be called from within a task\n      // (the task that is processing the addHandleAndSendInitialAdds call). It\n      // synchronously invokes the handle's added or addedBefore; there's no need to\n      // flush the queue afterwards to ensure that the callbacks get out.\n      async _sendAdds(handle) {\n        var add = this._ordered ? handle._addedBefore : handle._added;\n        if (!add) return;\n        // note: docs may be an _IdMap or an OrderedDict\n        await this._cache.docs.forEachAsync(async (doc, id) => {\n          if (!has(this._handles, handle._id)) throw Error(\"handle got removed before sending initial adds!\");\n          const _ref = handle.nonMutatingCallbacks ? doc : EJSON.clone(doc),\n            {\n              _id\n            } = _ref,\n            fields = _objectWithoutProperties(_ref, _excluded);\n          if (this._ordered) await add(id, fields, null); // we're going in order, so add at end\n          else await add(id, fields);\n        });\n      }\n    };\n\n    // When the callbacks do not mutate the arguments, we can skip a lot of data clones\n    ObserveHandle = class {\n      constructor(multiplexer, callbacks) {\n        let nonMutatingCallbacks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        this._multiplexer = multiplexer;\n        multiplexer.callbackNames().forEach(name => {\n          if (callbacks[name]) {\n            this['_' + name] = callbacks[name];\n          } else if (name === \"addedBefore\" && callbacks.added) {\n            // Special case: if you specify \"added\" and \"movedBefore\", you get an\n            // ordered observe where for some reason you don't get ordering data on\n            // the adds.  I dunno, we wrote tests for it, there must have been a\n            // reason.\n            this._addedBefore = async function (id, fields, before) {\n              await callbacks.added(id, fields);\n            };\n          }\n        });\n        this._stopped = false;\n        this._id = nextObserveHandleId++;\n        this.nonMutatingCallbacks = nonMutatingCallbacks;\n      }\n      async stop() {\n        if (this._stopped) return;\n        this._stopped = true;\n        await this._multiplexer.removeHandle(this._id);\n      }\n    };\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: false\n});","map":{"version":3,"names":["_objectWithoutProperties","module","link","default","v","_excluded","has","isEmpty","__reifyWaitForDeps__","nextObserveHandleId","ObserveMultiplexer","constructor","ordered","onStop","arguments","length","undefined","Error","Package","Facts","incrementServerFact","_ordered","_onStop","_queue","Meteor","_AsynchronousQueue","_handles","_resolver","_readyPromise","Promise","r","then","_isReady","_cache","LocalCollection","_CachingChangeObserver","_addHandleTasksScheduledButNotPerformed","self","callbackNames","forEach","callbackName","_applyCallback","_","toArray","addHandleAndSendInitialAdds","handle","_addHandleAndSendInitialAdds","runTask","_id","_sendAdds","removeHandle","id","_ready","_stop","options","fromQueryError","ready","queueTask","queryError","err","onFlush","cb","args","applyChange","apply","handleId","Object","keys","callback","nonMutatingCallbacks","EJSON","clone","add","_addedBefore","_added","docs","forEachAsync","doc","_ref","fields","ObserveHandle","multiplexer","callbacks","_multiplexer","name","added","before","_stopped","stop","__reify_async_result__","_reifyError","async"],"sources":["packages/mongo/observe_multiplex.js"],"sourcesContent":["import has from 'lodash.has'; \nimport isEmpty from 'lodash.isempty';\n\nlet nextObserveHandleId = 1;\n\nObserveMultiplexer = class {\n  constructor({ ordered, onStop = () => {} } = {}) {\n    if (ordered === undefined) throw Error(\"must specify ordered\");\n\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n        \"mongo-livedata\", \"observe-multiplexers\", 1);\n\n    this._ordered = ordered;\n    this._onStop = onStop;\n    this._queue = new Meteor._AsynchronousQueue();\n    this._handles = {};\n    this._resolver = null;\n    this._readyPromise = new Promise(r => this._resolver = r).then(() => this._isReady = true);\n    this._cache = new LocalCollection._CachingChangeObserver({\n      ordered});\n    // Number of addHandleAndSendInitialAdds tasks scheduled but not yet\n    // running. removeHandle uses this to know if it's time to call the onStop\n    // callback.\n    this._addHandleTasksScheduledButNotPerformed = 0;\n\n    const self = this;\n    this.callbackNames().forEach(callbackName => {\n      this[callbackName] = function(/* ... */) {\n        self._applyCallback(callbackName, _.toArray(arguments));\n      };\n    });\n  }\n\n  addHandleAndSendInitialAdds(handle) {\n    return this._addHandleAndSendInitialAdds(handle);\n  }\n\n  async _addHandleAndSendInitialAdds(handle) {\n    ++this._addHandleTasksScheduledButNotPerformed;\n\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n        \"mongo-livedata\", \"observe-handles\", 1);\n\n    const self = this;\n    await this._queue.runTask(async function () {\n      self._handles[handle._id] = handle;\n      // Send out whatever adds we have so far (whether the\n      // multiplexer is ready).\n      await self._sendAdds(handle);\n      --self._addHandleTasksScheduledButNotPerformed;\n    });\n    await this._readyPromise;\n  }\n\n  // Remove an observe handle. If it was the last observe handle, call the\n  // onStop callback; you cannot add any more observe handles after this.\n  //\n  // This is not synchronized with polls and handle additions: this means that\n  // you can safely call it from within an observe callback, but it also means\n  // that we have to be careful when we iterate over _handles.\n  async removeHandle(id) {\n    // This should not be possible: you can only call removeHandle by having\n    // access to the ObserveHandle, which isn't returned to user code until the\n    // multiplex is ready.\n    if (!this._ready())\n      throw new Error(\"Can't remove handles until the multiplex is ready\");\n\n    delete this._handles[id];\n\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n        \"mongo-livedata\", \"observe-handles\", -1);\n\n    if (isEmpty(this._handles) &&\n        this._addHandleTasksScheduledButNotPerformed === 0) {\n      await this._stop();\n    }\n  }\n  async _stop(options) {\n    options = options || {};\n\n    // It shouldn't be possible for us to stop when all our handles still\n    // haven't been returned from observeChanges!\n    if (! this._ready() && ! options.fromQueryError)\n      throw Error(\"surprising _stop: not ready\");\n\n    // Call stop callback (which kills the underlying process which sends us\n    // callbacks and removes us from the connection's dictionary).\n    await this._onStop();\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n        \"mongo-livedata\", \"observe-multiplexers\", -1);\n\n    // Cause future addHandleAndSendInitialAdds calls to throw (but the onStop\n    // callback should make our connection forget about us).\n    this._handles = null;\n  }\n\n  // Allows all addHandleAndSendInitialAdds calls to return, once all preceding\n  // adds have been processed. Does not block.\n  async ready() {\n    const self = this;\n    this._queue.queueTask(function () {\n      if (self._ready())\n        throw Error(\"can't make ObserveMultiplex ready twice!\");\n\n      if (!self._resolver) {\n        throw new Error(\"Missing resolver\");\n      }\n\n      self._resolver();\n      self._isReady = true;\n    });\n  }\n\n  // If trying to execute the query results in an error, call this. This is\n  // intended for permanent errors, not transient network errors that could be\n  // fixed. It should only be called before ready(), because if you called ready\n  // that meant that you managed to run the query once. It will stop this\n  // ObserveMultiplex and cause addHandleAndSendInitialAdds calls (and thus\n  // observeChanges calls) to throw the error.\n  async queryError(err) {\n    var self = this;\n    await this._queue.runTask(function () {\n      if (self._ready())\n        throw Error(\"can't claim query has an error after it worked!\");\n      self._stop({fromQueryError: true});\n      throw err;\n    });\n  }\n\n  // Calls \"cb\" once the effects of all \"ready\", \"addHandleAndSendInitialAdds\"\n  // and observe callbacks which came before this call have been propagated to\n  // all handles. \"ready\" must have already been called on this multiplexer.\n  async onFlush(cb) {\n    var self = this;\n    await this._queue.queueTask(async function () {\n      if (!self._ready())\n        throw Error(\"only call onFlush on a multiplexer that will be ready\");\n      await cb();\n    });\n  }\n  callbackNames() {\n    if (this._ordered)\n      return [\"addedBefore\", \"changed\", \"movedBefore\", \"removed\"];\n    else\n      return [\"added\", \"changed\", \"removed\"];\n  }\n  _ready() {\n    return !!this._isReady;\n  }\n  _applyCallback(callbackName, args) {\n    const self = this;\n    this._queue.queueTask(async function () {\n      // If we stopped in the meantime, do nothing.\n      if (!self._handles)\n        return;\n\n      // First, apply the change to the cache.\n      await self._cache.applyChange[callbackName].apply(null, args);\n      // If we haven't finished the initial adds, then we should only be getting\n      // adds.\n      if (!self._ready() &&\n          (callbackName !== 'added' && callbackName !== 'addedBefore')) {\n        throw new Error(\"Got \" + callbackName + \" during initial adds\");\n      }\n\n      // Now multiplex the callbacks out to all observe handles. It's OK if\n      // these calls yield; since we're inside a task, no other use of our queue\n      // can continue until these are done. (But we do have to be careful to not\n      // use a handle that got removed, because removeHandle does not use the\n      // queue; thus, we iterate over an array of keys that we control.)\n      for (const handleId of Object.keys(self._handles)) {\n        var handle = self._handles && self._handles[handleId];\n        if (!handle) return;\n        var callback = handle['_' + callbackName];\n        // clone arguments so that callbacks can mutate their arguments\n\n        callback &&\n          (await callback.apply(\n            null,\n            handle.nonMutatingCallbacks ? args : EJSON.clone(args)\n          ));\n      }\n    });\n  }\n\n  // Sends initial adds to a handle. It should only be called from within a task\n  // (the task that is processing the addHandleAndSendInitialAdds call). It\n  // synchronously invokes the handle's added or addedBefore; there's no need to\n  // flush the queue afterwards to ensure that the callbacks get out.\n  async _sendAdds(handle) {\n    var add = this._ordered ? handle._addedBefore : handle._added;\n    if (!add)\n      return;\n    // note: docs may be an _IdMap or an OrderedDict\n    await this._cache.docs.forEachAsync(async (doc, id) => {\n      if (!has(this._handles, handle._id))\n        throw Error(\"handle got removed before sending initial adds!\");\n      const { _id, ...fields } = handle.nonMutatingCallbacks ? doc\n          : EJSON.clone(doc);\n      if (this._ordered)\n        await add(id, fields, null); // we're going in order, so add at end\n      else\n        await add(id, fields);\n    });\n  }\n};\n\n// When the callbacks do not mutate the arguments, we can skip a lot of data clones\nObserveHandle = class {\n  constructor(multiplexer, callbacks, nonMutatingCallbacks = false) {\n    this._multiplexer = multiplexer;\n    multiplexer.callbackNames().forEach((name) => {\n      if (callbacks[name]) {\n        this['_' + name] = callbacks[name];\n      } else if (name === \"addedBefore\" && callbacks.added) {\n        // Special case: if you specify \"added\" and \"movedBefore\", you get an\n        // ordered observe where for some reason you don't get ordering data on\n        // the adds.  I dunno, we wrote tests for it, there must have been a\n        // reason.\n        this._addedBefore = async function (id, fields, before) {\n          await callbacks.added(id, fields);\n        };\n      }\n    });\n    this._stopped = false;\n    this._id = nextObserveHandleId++;\n    this.nonMutatingCallbacks = nonMutatingCallbacks;\n  }\n\n  async stop() {\n    if (this._stopped) return;\n    this._stopped = true;\n    await this._multiplexer.removeHandle(this._id);\n  }\n};"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"34c98c3f50888a06f80d67a71cdf050e8b0aa916"}
