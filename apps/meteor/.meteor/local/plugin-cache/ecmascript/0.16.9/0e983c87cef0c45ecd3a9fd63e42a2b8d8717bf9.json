{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/mongo/mongo_driver.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.arm64"},"sourceFileName":"packages/mongo/mongo_driver.js","filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/mongo/mongo_driver.js","targets":{"android":"125.0.0","chrome":"125.0.0","edge":"125.0.0","firefox":"115.0.0","ie":"10.0.0","ios":"17.4.0","opera":"110.0.0","opera_mobile":"80.0.0","safari":"17.4.0","samsung":"24.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","root":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true,"topLevelAwait":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/mongo/mongo_driver.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/mongo/mongo_driver.js"}},"code":"!module.wrapAsync(async function (module1, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    let _objectSpread;\n    module1.link(\"@babel/runtime/helpers/objectSpread2\", {\n      default(v) {\n        _objectSpread = v;\n      }\n    }, 0);\n    let has;\n    module1.link(\"lodash.has\", {\n      default(v) {\n        has = v;\n      }\n    }, 0);\n    let identity;\n    module1.link(\"lodash.identity\", {\n      default(v) {\n        identity = v;\n      }\n    }, 1);\n    let clone;\n    module1.link(\"lodash.clone\", {\n      default(v) {\n        clone = v;\n      }\n    }, 2);\n    let DocFetcher;\n    module1.link(\"./doc_fetcher.js\", {\n      DocFetcher(v) {\n        DocFetcher = v;\n      }\n    }, 3);\n    let ASYNC_CURSOR_METHODS, CLIENT_ONLY_METHODS, getAsyncMethodName;\n    module1.link(\"meteor/minimongo/constants\", {\n      ASYNC_CURSOR_METHODS(v) {\n        ASYNC_CURSOR_METHODS = v;\n      },\n      CLIENT_ONLY_METHODS(v) {\n        CLIENT_ONLY_METHODS = v;\n      },\n      getAsyncMethodName(v) {\n        getAsyncMethodName = v;\n      }\n    }, 4);\n    let Meteor;\n    module1.link(\"meteor/meteor\", {\n      Meteor(v) {\n        Meteor = v;\n      }\n    }, 5);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    /**\n     * Provide a synchronous Collection API using fibers, backed by\n     * MongoDB.  This is only for use on the server, and mostly identical\n     * to the client API.\n     *\n     * NOTE: the public API methods must be run within a fiber. If you call\n     * these outside of a fiber they will explode!\n     */\n\n    const path = require(\"path\");\n    const util = require(\"util\");\n\n    /** @type {import('mongodb')} */\n    var MongoDB = NpmModuleMongodb;\n    MongoInternals = {};\n    MongoInternals.__packageName = 'mongo';\n    MongoInternals.NpmModules = {\n      mongodb: {\n        version: NpmModuleMongodbVersion,\n        module: MongoDB\n      }\n    };\n\n    // Older version of what is now available via\n    // MongoInternals.NpmModules.mongodb.module.  It was never documented, but\n    // people do use it.\n    // XXX COMPAT WITH 1.0.3.2\n    MongoInternals.NpmModule = MongoDB;\n    const FILE_ASSET_SUFFIX = 'Asset';\n    const ASSETS_FOLDER = 'assets';\n    const APP_FOLDER = 'app';\n\n    // This is used to add or remove EJSON from the beginning of everything nested\n    // inside an EJSON custom type. It should only be called on pure JSON!\n    var replaceNames = function (filter, thing) {\n      if (typeof thing === \"object\" && thing !== null) {\n        if (Array.isArray(thing)) {\n          return thing.map(replaceNames.bind(null, filter));\n        }\n        var ret = {};\n        Object.entries(thing).forEach(function (_ref) {\n          let [key, value] = _ref;\n          ret[filter(key)] = replaceNames(filter, value);\n        });\n        return ret;\n      }\n      return thing;\n    };\n\n    // Ensure that EJSON.clone keeps a Timestamp as a Timestamp (instead of just\n    // doing a structural clone).\n    // XXX how ok is this? what if there are multiple copies of MongoDB loaded?\n    MongoDB.Timestamp.prototype.clone = function () {\n      // Timestamps should be immutable.\n      return this;\n    };\n    var makeMongoLegal = function (name) {\n      return \"EJSON\" + name;\n    };\n    var unmakeMongoLegal = function (name) {\n      return name.substr(5);\n    };\n    var replaceMongoAtomWithMeteor = function (document) {\n      if (document instanceof MongoDB.Binary) {\n        // for backwards compatibility\n        if (document.sub_type !== 0) {\n          return document;\n        }\n        var buffer = document.value(true);\n        return new Uint8Array(buffer);\n      }\n      if (document instanceof MongoDB.ObjectID) {\n        return new Mongo.ObjectID(document.toHexString());\n      }\n      if (document instanceof MongoDB.Decimal128) {\n        return Decimal(document.toString());\n      }\n      if (document[\"EJSON$type\"] && document[\"EJSON$value\"] && Object.keys(document).length === 2) {\n        return EJSON.fromJSONValue(replaceNames(unmakeMongoLegal, document));\n      }\n      if (document instanceof MongoDB.Timestamp) {\n        // For now, the Meteor representation of a Mongo timestamp type (not a date!\n        // this is a weird internal thing used in the oplog!) is the same as the\n        // Mongo representation. We need to do this explicitly or else we would do a\n        // structural clone and lose the prototype.\n        return document;\n      }\n      return undefined;\n    };\n    var replaceMeteorAtomWithMongo = function (document) {\n      if (EJSON.isBinary(document)) {\n        // This does more copies than we'd like, but is necessary because\n        // MongoDB.BSON only looks like it takes a Uint8Array (and doesn't actually\n        // serialize it correctly).\n        return new MongoDB.Binary(Buffer.from(document));\n      }\n      if (document instanceof MongoDB.Binary) {\n        return document;\n      }\n      if (document instanceof Mongo.ObjectID) {\n        return new MongoDB.ObjectID(document.toHexString());\n      }\n      if (document instanceof MongoDB.Timestamp) {\n        // For now, the Meteor representation of a Mongo timestamp type (not a date!\n        // this is a weird internal thing used in the oplog!) is the same as the\n        // Mongo representation. We need to do this explicitly or else we would do a\n        // structural clone and lose the prototype.\n        return document;\n      }\n      if (document instanceof Decimal) {\n        return MongoDB.Decimal128.fromString(document.toString());\n      }\n      if (EJSON._isCustomType(document)) {\n        return replaceNames(makeMongoLegal, EJSON.toJSONValue(document));\n      }\n      // It is not ordinarily possible to stick dollar-sign keys into mongo\n      // so we don't bother checking for things that need escaping at this time.\n      return undefined;\n    };\n    var replaceTypes = function (document, atomTransformer) {\n      if (typeof document !== 'object' || document === null) return document;\n      var replacedTopLevelAtom = atomTransformer(document);\n      if (replacedTopLevelAtom !== undefined) return replacedTopLevelAtom;\n      var ret = document;\n      Object.entries(document).forEach(function (_ref2) {\n        let [key, val] = _ref2;\n        var valReplaced = replaceTypes(val, atomTransformer);\n        if (val !== valReplaced) {\n          // Lazy clone. Shallow copy.\n          if (ret === document) ret = clone(document);\n          ret[key] = valReplaced;\n        }\n      });\n      return ret;\n    };\n    MongoConnection = function (url, options) {\n      var _Meteor$settings, _Meteor$settings$pack, _Meteor$settings$pack2;\n      var self = this;\n      options = options || {};\n      self._observeMultiplexers = {};\n      self._onFailoverHook = new Hook();\n      const userOptions = _objectSpread(_objectSpread({}, Mongo._connectionOptions || {}), ((_Meteor$settings = Meteor.settings) === null || _Meteor$settings === void 0 ? void 0 : (_Meteor$settings$pack = _Meteor$settings.packages) === null || _Meteor$settings$pack === void 0 ? void 0 : (_Meteor$settings$pack2 = _Meteor$settings$pack.mongo) === null || _Meteor$settings$pack2 === void 0 ? void 0 : _Meteor$settings$pack2.options) || {});\n      var mongoOptions = Object.assign({\n        ignoreUndefined: true\n      }, userOptions);\n\n      // Internally the oplog connections specify their own maxPoolSize\n      // which we don't want to overwrite with any user defined value\n      if (has(options, 'maxPoolSize')) {\n        // If we just set this for \"server\", replSet will override it. If we just\n        // set it for replSet, it will be ignored if we're not using a replSet.\n        mongoOptions.maxPoolSize = options.maxPoolSize;\n      }\n      if (has(options, 'minPoolSize')) {\n        mongoOptions.minPoolSize = options.minPoolSize;\n      }\n\n      // Transform options like \"tlsCAFileAsset\": \"filename.pem\" into\n      // \"tlsCAFile\": \"/<fullpath>/filename.pem\"\n      Object.entries(mongoOptions || {}).filter(_ref3 => {\n        let [key] = _ref3;\n        return key && key.endsWith(FILE_ASSET_SUFFIX);\n      }).forEach(_ref4 => {\n        let [key, value] = _ref4;\n        const optionName = key.replace(FILE_ASSET_SUFFIX, '');\n        mongoOptions[optionName] = path.join(Assets.getServerDir(), ASSETS_FOLDER, APP_FOLDER, value);\n        delete mongoOptions[key];\n      });\n      self.db = null;\n      self._oplogHandle = null;\n      self._docFetcher = null;\n      mongoOptions.driverInfo = {\n        name: 'Meteor',\n        version: Meteor.release\n      };\n      self.client = new MongoDB.MongoClient(url, mongoOptions);\n      self.db = self.client.db();\n      self.client.on('serverDescriptionChanged', Meteor.bindEnvironment(event => {\n        // When the connection is no longer against the primary node, execute all\n        // failover hooks. This is important for the driver as it has to re-pool the\n        // query when it happens.\n        if (event.previousDescription.type !== 'RSPrimary' && event.newDescription.type === 'RSPrimary') {\n          self._onFailoverHook.each(callback => {\n            callback();\n            return true;\n          });\n        }\n      }));\n      if (options.oplogUrl && !Package['disable-oplog']) {\n        self._oplogHandle = new OplogHandle(options.oplogUrl, self.db.databaseName);\n        self._docFetcher = new DocFetcher(self);\n      }\n    };\n    MongoConnection.prototype._close = async function () {\n      var self = this;\n      if (!self.db) throw Error(\"close called before Connection created?\");\n\n      // XXX probably untested\n      var oplogHandle = self._oplogHandle;\n      self._oplogHandle = null;\n      if (oplogHandle) await oplogHandle.stop();\n\n      // Use Future.wrap so that errors get thrown. This happens to\n      // work even outside a fiber since the 'close' method is not\n      // actually asynchronous.\n      await self.client.close();\n    };\n    MongoConnection.prototype.close = function () {\n      return this._close();\n    };\n    MongoConnection.prototype._setOplogHandle = function (oplogHandle) {\n      this._oplogHandle = oplogHandle;\n      return this;\n    };\n\n    // Returns the Mongo Collection object; may yield.\n    MongoConnection.prototype.rawCollection = function (collectionName) {\n      var self = this;\n      if (!self.db) throw Error(\"rawCollection called before Connection created?\");\n      return self.db.collection(collectionName);\n    };\n    MongoConnection.prototype.createCappedCollectionAsync = async function (collectionName, byteSize, maxDocuments) {\n      var self = this;\n      if (!self.db) throw Error(\"createCappedCollectionAsync called before Connection created?\");\n      await self.db.createCollection(collectionName, {\n        capped: true,\n        size: byteSize,\n        max: maxDocuments\n      });\n    };\n\n    // This should be called synchronously with a write, to create a\n    // transaction on the current write fence, if any. After we can read\n    // the write, and after observers have been notified (or at least,\n    // after the observer notifiers have added themselves to the write\n    // fence), you should call 'committed()' on the object returned.\n    MongoConnection.prototype._maybeBeginWrite = function () {\n      const fence = DDPServer._getCurrentFence();\n      if (fence) {\n        return fence.beginWrite();\n      } else {\n        return {\n          committed: function () {}\n        };\n      }\n    };\n\n    // Internal interface: adds a callback which is called when the Mongo primary\n    // changes. Returns a stop handle.\n    MongoConnection.prototype._onFailover = function (callback) {\n      return this._onFailoverHook.register(callback);\n    };\n\n    //////////// Public API //////////\n\n    // The write methods block until the database has confirmed the write (it may\n    // not be replicated or stable on disk, but one server has confirmed it) if no\n    // callback is provided. If a callback is provided, then they call the callback\n    // when the write is confirmed. They return nothing on success, and raise an\n    // exception on failure.\n    //\n    // After making a write (with insert, update, remove), observers are\n    // notified asynchronously. If you want to receive a callback once all\n    // of the observer notifications have landed for your write, do the\n    // writes inside a write fence (set DDPServer._CurrentWriteFence to a new\n    // _WriteFence, and then set a callback on the write fence.)\n    //\n    // Since our execution environment is single-threaded, this is\n    // well-defined -- a write \"has been made\" if it's returned, and an\n    // observer \"has been notified\" if its callback has returned.\n\n    var writeCallback = function (write, refresh, callback) {\n      return function (err, result) {\n        if (!err) {\n          // XXX We don't have to run this on error, right?\n          try {\n            refresh();\n          } catch (refreshErr) {\n            if (callback) {\n              callback(refreshErr);\n              return;\n            } else {\n              throw refreshErr;\n            }\n          }\n        }\n        write.committed();\n        if (callback) {\n          callback(err, result);\n        } else if (err) {\n          throw err;\n        }\n      };\n    };\n    var bindEnvironmentForWrite = function (callback) {\n      return Meteor.bindEnvironment(callback, \"Mongo write\");\n    };\n    MongoConnection.prototype.insertAsync = async function (collection_name, document) {\n      const self = this;\n      if (collection_name === \"___meteor_failure_test_collection\") {\n        const e = new Error(\"Failure test\");\n        e._expectedByTest = true;\n        throw e;\n      }\n      if (!(LocalCollection._isPlainObject(document) && !EJSON._isCustomType(document))) {\n        throw new Error(\"Only plain objects may be inserted into MongoDB\");\n      }\n      var write = self._maybeBeginWrite();\n      var refresh = async function () {\n        await Meteor.refresh({\n          collection: collection_name,\n          id: document._id\n        });\n      };\n      return self.rawCollection(collection_name).insertOne(replaceTypes(document, replaceMeteorAtomWithMongo), {\n        safe: true\n      }).then(async _ref5 => {\n        let {\n          insertedId\n        } = _ref5;\n        await refresh();\n        await write.committed();\n        return insertedId;\n      }).catch(async e => {\n        await write.committed();\n        throw e;\n      });\n    };\n\n    // Cause queries that may be affected by the selector to poll in this write\n    // fence.\n    MongoConnection.prototype._refresh = async function (collectionName, selector) {\n      var refreshKey = {\n        collection: collectionName\n      };\n      // If we know which documents we're removing, don't poll queries that are\n      // specific to other documents. (Note that multiple notifications here should\n      // not cause multiple polls, since all our listener is doing is enqueueing a\n      // poll.)\n      var specificIds = LocalCollection._idsMatchedBySelector(selector);\n      if (specificIds) {\n        for (const id of specificIds) {\n          await Meteor.refresh(Object.assign({\n            id: id\n          }, refreshKey));\n        }\n        ;\n      } else {\n        await Meteor.refresh(refreshKey);\n      }\n    };\n    MongoConnection.prototype.removeAsync = async function (collection_name, selector) {\n      var self = this;\n      if (collection_name === \"___meteor_failure_test_collection\") {\n        var e = new Error(\"Failure test\");\n        e._expectedByTest = true;\n        throw e;\n      }\n      var write = self._maybeBeginWrite();\n      var refresh = async function () {\n        await self._refresh(collection_name, selector);\n      };\n      return self.rawCollection(collection_name).deleteMany(replaceTypes(selector, replaceMeteorAtomWithMongo), {\n        safe: true\n      }).then(async _ref6 => {\n        let {\n          deletedCount\n        } = _ref6;\n        await refresh();\n        await write.committed();\n        return transformResult({\n          result: {\n            modifiedCount: deletedCount\n          }\n        }).numberAffected;\n      }).catch(async err => {\n        await write.committed();\n        throw err;\n      });\n    };\n    MongoConnection.prototype.dropCollectionAsync = async function (collectionName) {\n      var self = this;\n      var write = self._maybeBeginWrite();\n      var refresh = function () {\n        return Meteor.refresh({\n          collection: collectionName,\n          id: null,\n          dropCollection: true\n        });\n      };\n      return self.rawCollection(collectionName).drop().then(async result => {\n        await refresh();\n        await write.committed();\n        return result;\n      }).catch(async e => {\n        await write.committed();\n        throw e;\n      });\n    };\n\n    // For testing only.  Slightly better than `c.rawDatabase().dropDatabase()`\n    // because it lets the test's fence wait for it to be complete.\n    MongoConnection.prototype.dropDatabaseAsync = async function () {\n      var self = this;\n      var write = self._maybeBeginWrite();\n      var refresh = async function () {\n        await Meteor.refresh({\n          dropDatabase: true\n        });\n      };\n      try {\n        await self.db._dropDatabase();\n        await refresh();\n        await write.committed();\n      } catch (e) {\n        await write.committed();\n        throw e;\n      }\n    };\n    MongoConnection.prototype.updateAsync = async function (collection_name, selector, mod, options) {\n      var self = this;\n      if (collection_name === \"___meteor_failure_test_collection\") {\n        var e = new Error(\"Failure test\");\n        e._expectedByTest = true;\n        throw e;\n      }\n\n      // explicit safety check. null and undefined can crash the mongo\n      // driver. Although the node driver and minimongo do 'support'\n      // non-object modifier in that they don't crash, they are not\n      // meaningful operations and do not do anything. Defensively throw an\n      // error here.\n      if (!mod || typeof mod !== 'object') {\n        const error = new Error(\"Invalid modifier. Modifier must be an object.\");\n        throw error;\n      }\n      if (!(LocalCollection._isPlainObject(mod) && !EJSON._isCustomType(mod))) {\n        const error = new Error(\"Only plain objects may be used as replacement\" + \" documents in MongoDB\");\n        throw error;\n      }\n      if (!options) options = {};\n      var write = self._maybeBeginWrite();\n      var refresh = async function () {\n        await self._refresh(collection_name, selector);\n      };\n      var collection = self.rawCollection(collection_name);\n      var mongoOpts = {\n        safe: true\n      };\n      // Add support for filtered positional operator\n      if (options.arrayFilters !== undefined) mongoOpts.arrayFilters = options.arrayFilters;\n      // explictly enumerate options that minimongo supports\n      if (options.upsert) mongoOpts.upsert = true;\n      if (options.multi) mongoOpts.multi = true;\n      // Lets you get a more more full result from MongoDB. Use with caution:\n      // might not work with C.upsert (as opposed to C.update({upsert:true}) or\n      // with simulated upsert.\n      if (options.fullResult) mongoOpts.fullResult = true;\n      var mongoSelector = replaceTypes(selector, replaceMeteorAtomWithMongo);\n      var mongoMod = replaceTypes(mod, replaceMeteorAtomWithMongo);\n      var isModify = LocalCollection._isModificationMod(mongoMod);\n      if (options._forbidReplace && !isModify) {\n        var err = new Error(\"Invalid modifier. Replacements are forbidden.\");\n        throw err;\n      }\n\n      // We've already run replaceTypes/replaceMeteorAtomWithMongo on\n      // selector and mod.  We assume it doesn't matter, as far as\n      // the behavior of modifiers is concerned, whether `_modify`\n      // is run on EJSON or on mongo-converted EJSON.\n\n      // Run this code up front so that it fails fast if someone uses\n      // a Mongo update operator we don't support.\n      let knownId;\n      if (options.upsert) {\n        try {\n          let newDoc = LocalCollection._createUpsertDocument(selector, mod);\n          knownId = newDoc._id;\n        } catch (err) {\n          throw err;\n        }\n      }\n      if (options.upsert && !isModify && !knownId && options.insertedId && !(options.insertedId instanceof Mongo.ObjectID && options.generatedId)) {\n        // In case of an upsert with a replacement, where there is no _id defined\n        // in either the query or the replacement doc, mongo will generate an id itself.\n        // Therefore we need this special strategy if we want to control the id ourselves.\n\n        // We don't need to do this when:\n        // - This is not a replacement, so we can add an _id to $setOnInsert\n        // - The id is defined by query or mod we can just add it to the replacement doc\n        // - The user did not specify any id preference and the id is a Mongo ObjectId,\n        //     then we can just let Mongo generate the id\n        return await simulateUpsertWithInsertedId(collection, mongoSelector, mongoMod, options).then(async result => {\n          await refresh();\n          await write.committed();\n          if (result && !options._returnObject) {\n            return result.numberAffected;\n          } else {\n            return result;\n          }\n        });\n      } else {\n        if (options.upsert && !knownId && options.insertedId && isModify) {\n          if (!mongoMod.hasOwnProperty('$setOnInsert')) {\n            mongoMod.$setOnInsert = {};\n          }\n          knownId = options.insertedId;\n          Object.assign(mongoMod.$setOnInsert, replaceTypes({\n            _id: options.insertedId\n          }, replaceMeteorAtomWithMongo));\n        }\n        const strings = Object.keys(mongoMod).filter(key => !key.startsWith(\"$\"));\n        let updateMethod = strings.length > 0 ? 'replaceOne' : 'updateMany';\n        updateMethod = updateMethod === 'updateMany' && !mongoOpts.multi ? 'updateOne' : updateMethod;\n        return collection[updateMethod].bind(collection)(mongoSelector, mongoMod, mongoOpts).then(async result => {\n          var meteorResult = transformResult({\n            result\n          });\n          if (meteorResult && options._returnObject) {\n            // If this was an upsertAsync() call, and we ended up\n            // inserting a new doc and we know its id, then\n            // return that id as well.\n            if (options.upsert && meteorResult.insertedId) {\n              if (knownId) {\n                meteorResult.insertedId = knownId;\n              } else if (meteorResult.insertedId instanceof MongoDB.ObjectID) {\n                meteorResult.insertedId = new Mongo.ObjectID(meteorResult.insertedId.toHexString());\n              }\n            }\n            await refresh();\n            await write.committed();\n            return meteorResult;\n          } else {\n            await refresh();\n            await write.committed();\n            return meteorResult.numberAffected;\n          }\n        }).catch(async err => {\n          await write.committed();\n          throw err;\n        });\n      }\n    };\n    var transformResult = function (driverResult) {\n      var meteorResult = {\n        numberAffected: 0\n      };\n      if (driverResult) {\n        var mongoResult = driverResult.result;\n        // On updates with upsert:true, the inserted values come as a list of\n        // upserted values -- even with options.multi, when the upsert does insert,\n        // it only inserts one element.\n        if (mongoResult.upsertedCount) {\n          meteorResult.numberAffected = mongoResult.upsertedCount;\n          if (mongoResult.upsertedId) {\n            meteorResult.insertedId = mongoResult.upsertedId;\n          }\n        } else {\n          // n was used before Mongo 5.0, in Mongo 5.0 we are not receiving this n\n          // field and so we are using modifiedCount instead\n          meteorResult.numberAffected = mongoResult.n || mongoResult.matchedCount || mongoResult.modifiedCount;\n        }\n      }\n      return meteorResult;\n    };\n    var NUM_OPTIMISTIC_TRIES = 3;\n\n    // exposed for testing\n    MongoConnection._isCannotChangeIdError = function (err) {\n      // Mongo 3.2.* returns error as next Object:\n      // {name: String, code: Number, errmsg: String}\n      // Older Mongo returns:\n      // {name: String, code: Number, err: String}\n      var error = err.errmsg || err.err;\n\n      // We don't use the error code here\n      // because the error code we observed it producing (16837) appears to be\n      // a far more generic error code based on examining the source.\n      if (error.indexOf('The _id field cannot be changed') === 0 || error.indexOf(\"the (immutable) field '_id' was found to have been altered to _id\") !== -1) {\n        return true;\n      }\n      return false;\n    };\n    var simulateUpsertWithInsertedId = async function (collection, selector, mod, options) {\n      // STRATEGY: First try doing an upsert with a generated ID.\n      // If this throws an error about changing the ID on an existing document\n      // then without affecting the database, we know we should probably try\n      // an update without the generated ID. If it affected 0 documents,\n      // then without affecting the database, we the document that first\n      // gave the error is probably removed and we need to try an insert again\n      // We go back to step one and repeat.\n      // Like all \"optimistic write\" schemes, we rely on the fact that it's\n      // unlikely our writes will continue to be interfered with under normal\n      // circumstances (though sufficiently heavy contention with writers\n      // disagreeing on the existence of an object will cause writes to fail\n      // in theory).\n\n      var insertedId = options.insertedId; // must exist\n      var mongoOptsForUpdate = {\n        safe: true,\n        multi: options.multi\n      };\n      var mongoOptsForInsert = {\n        safe: true,\n        upsert: true\n      };\n      var replacementWithId = Object.assign(replaceTypes({\n        _id: insertedId\n      }, replaceMeteorAtomWithMongo), mod);\n      var tries = NUM_OPTIMISTIC_TRIES;\n      var doUpdate = async function () {\n        tries--;\n        if (!tries) {\n          throw new Error(\"Upsert failed after \" + NUM_OPTIMISTIC_TRIES + \" tries.\");\n        } else {\n          let method = collection.updateMany;\n          if (!Object.keys(mod).some(key => key.startsWith(\"$\"))) {\n            method = collection.replaceOne.bind(collection);\n          }\n          return method(selector, mod, mongoOptsForUpdate).then(result => {\n            if (result && (result.modifiedCount || result.upsertedCount)) {\n              return {\n                numberAffected: result.modifiedCount || result.upsertedCount,\n                insertedId: result.upsertedId || undefined\n              };\n            } else {\n              return doConditionalInsert();\n            }\n          });\n        }\n      };\n      var doConditionalInsert = function () {\n        return collection.replaceOne(selector, replacementWithId, mongoOptsForInsert).then(result => ({\n          numberAffected: result.upsertedCount,\n          insertedId: result.upsertedId\n        })).catch(err => {\n          if (MongoConnection._isCannotChangeIdError(err)) {\n            return doUpdate();\n          } else {\n            throw err;\n          }\n        });\n      };\n      return doUpdate();\n    };\n\n    // XXX MongoConnection.upsertAsync() does not return the id of the inserted document\n    // unless you set it explicitly in the selector or modifier (as a replacement\n    // doc).\n    MongoConnection.prototype.upsertAsync = async function (collectionName, selector, mod, options) {\n      var self = this;\n      if (typeof options === \"function\" && !callback) {\n        callback = options;\n        options = {};\n      }\n      return self.updateAsync(collectionName, selector, mod, Object.assign({}, options, {\n        upsert: true,\n        _returnObject: true\n      }));\n    };\n    MongoConnection.prototype.find = function (collectionName, selector, options) {\n      var self = this;\n      if (arguments.length === 1) selector = {};\n      return new Cursor(self, new CursorDescription(collectionName, selector, options));\n    };\n    MongoConnection.prototype.findOneAsync = async function (collection_name, selector, options) {\n      var self = this;\n      if (arguments.length === 1) {\n        selector = {};\n      }\n      options = options || {};\n      options.limit = 1;\n      const results = await self.find(collection_name, selector, options).fetch();\n      return results[0];\n    };\n\n    // We'll actually design an index API later. For now, we just pass through to\n    // Mongo's, but make it synchronous.\n    MongoConnection.prototype.createIndexAsync = async function (collectionName, index, options) {\n      var self = this;\n\n      // We expect this function to be called at startup, not from within a method,\n      // so we don't interact with the write fence.\n      var collection = self.rawCollection(collectionName);\n      await collection.createIndex(index, options);\n    };\n\n    // just to be consistent with the other methods\n    MongoConnection.prototype.createIndex = MongoConnection.prototype.createIndexAsync;\n    MongoConnection.prototype.countDocuments = function (collectionName) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      args = args.map(arg => replaceTypes(arg, replaceMeteorAtomWithMongo));\n      const collection = this.rawCollection(collectionName);\n      return collection.countDocuments(...args);\n    };\n    MongoConnection.prototype.estimatedDocumentCount = function (collectionName) {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n      args = args.map(arg => replaceTypes(arg, replaceMeteorAtomWithMongo));\n      const collection = this.rawCollection(collectionName);\n      return collection.estimatedDocumentCount(...args);\n    };\n    MongoConnection.prototype.ensureIndexAsync = MongoConnection.prototype.createIndexAsync;\n    MongoConnection.prototype.dropIndexAsync = async function (collectionName, index) {\n      var self = this;\n\n      // This function is only used by test code, not within a method, so we don't\n      // interact with the write fence.\n      var collection = self.rawCollection(collectionName);\n      var indexName = await collection.dropIndex(index);\n    };\n    CLIENT_ONLY_METHODS.forEach(function (m) {\n      MongoConnection.prototype[m] = function () {\n        throw new Error(\"\".concat(m, \" +  is not available on the server. Please use \").concat(getAsyncMethodName(m), \"() instead.\"));\n      };\n    });\n\n    // CURSORS\n\n    // There are several classes which relate to cursors:\n    //\n    // CursorDescription represents the arguments used to construct a cursor:\n    // collectionName, selector, and (find) options.  Because it is used as a key\n    // for cursor de-dup, everything in it should either be JSON-stringifiable or\n    // not affect observeChanges output (eg, options.transform functions are not\n    // stringifiable but do not affect observeChanges).\n    //\n    // SynchronousCursor is a wrapper around a MongoDB cursor\n    // which includes fully-synchronous versions of forEach, etc.\n    //\n    // Cursor is the cursor object returned from find(), which implements the\n    // documented Mongo.Collection cursor API.  It wraps a CursorDescription and a\n    // SynchronousCursor (lazily: it doesn't contact Mongo until you call a method\n    // like fetch or forEach on it).\n    //\n    // ObserveHandle is the \"observe handle\" returned from observeChanges. It has a\n    // reference to an ObserveMultiplexer.\n    //\n    // ObserveMultiplexer allows multiple identical ObserveHandles to be driven by a\n    // single observe driver.\n    //\n    // There are two \"observe drivers\" which drive ObserveMultiplexers:\n    //   - PollingObserveDriver caches the results of a query and reruns it when\n    //     necessary.\n    //   - OplogObserveDriver follows the Mongo operation log to directly observe\n    //     database changes.\n    // Both implementations follow the same simple interface: when you create them,\n    // they start sending observeChanges callbacks (and a ready() invocation) to\n    // their ObserveMultiplexer, and you stop them by calling their stop() method.\n\n    CursorDescription = function (collectionName, selector, options) {\n      var self = this;\n      self.collectionName = collectionName;\n      self.selector = Mongo.Collection._rewriteSelector(selector);\n      self.options = options || {};\n    };\n    Cursor = function (mongo, cursorDescription) {\n      var self = this;\n      self._mongo = mongo;\n      self._cursorDescription = cursorDescription;\n      self._synchronousCursor = null;\n    };\n    function setupSynchronousCursor(cursor, method) {\n      // You can only observe a tailable cursor.\n      if (cursor._cursorDescription.options.tailable) throw new Error('Cannot call ' + method + ' on a tailable cursor');\n      if (!cursor._synchronousCursor) {\n        cursor._synchronousCursor = cursor._mongo._createSynchronousCursor(cursor._cursorDescription, {\n          // Make sure that the \"cursor\" argument to forEach/map callbacks is the\n          // Cursor, not the SynchronousCursor.\n          selfForIteration: cursor,\n          useTransform: true\n        });\n      }\n      return cursor._synchronousCursor;\n    }\n    Cursor.prototype.countAsync = async function () {\n      const collection = this._mongo.rawCollection(this._cursorDescription.collectionName);\n      return await collection.countDocuments(replaceTypes(this._cursorDescription.selector, replaceMeteorAtomWithMongo), replaceTypes(this._cursorDescription.options, replaceMeteorAtomWithMongo));\n    };\n    Cursor.prototype.count = function () {\n      throw new Error(\"count() is not available on the server. Please use countAsync() instead.\");\n    };\n    [...ASYNC_CURSOR_METHODS, Symbol.iterator, Symbol.asyncIterator].forEach(methodName => {\n      // count is handled specially since we don't want to create a cursor.\n      // it is still included in ASYNC_CURSOR_METHODS because we still want an async version of it to exist.\n      if (methodName === 'count') {\n        return;\n      }\n      Cursor.prototype[methodName] = function () {\n        const cursor = setupSynchronousCursor(this, methodName);\n        return cursor[methodName](...arguments);\n      };\n\n      // These methods are handled separately.\n      if (methodName === Symbol.iterator || methodName === Symbol.asyncIterator) {\n        return;\n      }\n      const methodNameAsync = getAsyncMethodName(methodName);\n      Cursor.prototype[methodNameAsync] = function () {\n        try {\n          return Promise.resolve(this[methodName](...arguments));\n        } catch (error) {\n          return Promise.reject(error);\n        }\n      };\n    });\n    Cursor.prototype.getTransform = function () {\n      return this._cursorDescription.options.transform;\n    };\n\n    // When you call Meteor.publish() with a function that returns a Cursor, we need\n    // to transmute it into the equivalent subscription.  This is the function that\n    // does that.\n    Cursor.prototype._publishCursor = function (sub) {\n      var self = this;\n      var collection = self._cursorDescription.collectionName;\n      return Mongo.Collection._publishCursor(self, sub, collection);\n    };\n\n    // Used to guarantee that publish functions return at most one cursor per\n    // collection. Private, because we might later have cursors that include\n    // documents from multiple collections somehow.\n    Cursor.prototype._getCollectionName = function () {\n      var self = this;\n      return self._cursorDescription.collectionName;\n    };\n    Cursor.prototype.observe = function (callbacks) {\n      var self = this;\n      return LocalCollection._observeFromObserveChanges(self, callbacks);\n    };\n    Cursor.prototype.observeAsync = function (callbacks) {\n      return new Promise(resolve => resolve(this.observe(callbacks)));\n    };\n    Cursor.prototype.observeChanges = function (callbacks) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var self = this;\n      var methods = ['addedAt', 'added', 'changedAt', 'changed', 'removedAt', 'removed', 'movedTo'];\n      var ordered = LocalCollection._observeChangesCallbacksAreOrdered(callbacks);\n      let exceptionName = callbacks._fromObserve ? 'observe' : 'observeChanges';\n      exceptionName += ' callback';\n      methods.forEach(function (method) {\n        if (callbacks[method] && typeof callbacks[method] == \"function\") {\n          callbacks[method] = Meteor.bindEnvironment(callbacks[method], method + exceptionName);\n        }\n      });\n      return self._mongo._observeChanges(self._cursorDescription, ordered, callbacks, options.nonMutatingCallbacks);\n    };\n    Cursor.prototype.observeChangesAsync = async function (callbacks) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.observeChanges(callbacks, options);\n    };\n    MongoConnection.prototype._createSynchronousCursor = function (cursorDescription) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var self = this;\n      const {\n        selfForIteration,\n        useTransform\n      } = options;\n      options = {\n        selfForIteration,\n        useTransform\n      };\n      var collection = self.rawCollection(cursorDescription.collectionName);\n      var cursorOptions = cursorDescription.options;\n      var mongoOptions = {\n        sort: cursorOptions.sort,\n        limit: cursorOptions.limit,\n        skip: cursorOptions.skip,\n        projection: cursorOptions.fields || cursorOptions.projection,\n        readPreference: cursorOptions.readPreference\n      };\n\n      // Do we want a tailable cursor (which only works on capped collections)?\n      if (cursorOptions.tailable) {\n        mongoOptions.numberOfRetries = -1;\n      }\n      var dbCursor = collection.find(replaceTypes(cursorDescription.selector, replaceMeteorAtomWithMongo), mongoOptions);\n\n      // Do we want a tailable cursor (which only works on capped collections)?\n      if (cursorOptions.tailable) {\n        // We want a tailable cursor...\n        dbCursor.addCursorFlag(\"tailable\", true);\n        // ... and for the server to wait a bit if any getMore has no data (rather\n        // than making us put the relevant sleeps in the client)...\n        dbCursor.addCursorFlag(\"awaitData\", true);\n\n        // And if this is on the oplog collection and the cursor specifies a 'ts',\n        // then set the undocumented oplog replay flag, which does a special scan to\n        // find the first document (instead of creating an index on ts). This is a\n        // very hard-coded Mongo flag which only works on the oplog collection and\n        // only works with the ts field.\n        if (cursorDescription.collectionName === OPLOG_COLLECTION && cursorDescription.selector.ts) {\n          dbCursor.addCursorFlag(\"oplogReplay\", true);\n        }\n      }\n      if (typeof cursorOptions.maxTimeMs !== 'undefined') {\n        dbCursor = dbCursor.maxTimeMS(cursorOptions.maxTimeMs);\n      }\n      if (typeof cursorOptions.hint !== 'undefined') {\n        dbCursor = dbCursor.hint(cursorOptions.hint);\n      }\n      return new AsynchronousCursor(dbCursor, cursorDescription, options, collection);\n    };\n\n    /**\n     * This is just a light wrapper for the cursor. The goal here is to ensure compatibility even if\n     * there are breaking changes on the MongoDB driver.\n     *\n     * @constructor\n     */\n    class AsynchronousCursor {\n      constructor(dbCursor, cursorDescription, options) {\n        this._dbCursor = dbCursor;\n        this._cursorDescription = cursorDescription;\n        this._selfForIteration = options.selfForIteration || this;\n        if (options.useTransform && cursorDescription.options.transform) {\n          this._transform = LocalCollection.wrapTransform(cursorDescription.options.transform);\n        } else {\n          this._transform = null;\n        }\n        this._visitedIds = new LocalCollection._IdMap();\n      }\n      [Symbol.asyncIterator]() {\n        var cursor = this;\n        return {\n          async next() {\n            const value = await cursor._nextObjectPromise();\n            return {\n              done: !value,\n              value\n            };\n          }\n        };\n      }\n\n      // Returns a Promise for the next object from the underlying cursor (before\n      // the Mongo->Meteor type replacement).\n      async _rawNextObjectPromise() {\n        try {\n          return this._dbCursor.next();\n        } catch (e) {\n          console.error(e);\n        }\n      }\n\n      // Returns a Promise for the next object from the cursor, skipping those whose\n      // IDs we've already seen and replacing Mongo atoms with Meteor atoms.\n      async _nextObjectPromise() {\n        while (true) {\n          var doc = await this._rawNextObjectPromise();\n          if (!doc) return null;\n          doc = replaceTypes(doc, replaceMongoAtomWithMeteor);\n          if (!this._cursorDescription.options.tailable && _.has(doc, '_id')) {\n            // Did Mongo give us duplicate documents in the same cursor? If so,\n            // ignore this one. (Do this before the transform, since transform might\n            // return some unrelated value.) We don't do this for tailable cursors,\n            // because we want to maintain O(1) memory usage. And if there isn't _id\n            // for some reason (maybe it's the oplog), then we don't do this either.\n            // (Be careful to do this for falsey but existing _id, though.)\n            if (this._visitedIds.has(doc._id)) continue;\n            this._visitedIds.set(doc._id, true);\n          }\n          if (this._transform) doc = this._transform(doc);\n          return doc;\n        }\n      }\n\n      // Returns a promise which is resolved with the next object (like with\n      // _nextObjectPromise) or rejected if the cursor doesn't return within\n      // timeoutMS ms.\n      _nextObjectPromiseWithTimeout(timeoutMS) {\n        if (!timeoutMS) {\n          return this._nextObjectPromise();\n        }\n        const nextObjectPromise = this._nextObjectPromise();\n        const timeoutErr = new Error('Client-side timeout waiting for next object');\n        const timeoutPromise = new Promise((resolve, reject) => {\n          setTimeout(() => {\n            reject(timeoutErr);\n          }, timeoutMS);\n        });\n        return Promise.race([nextObjectPromise, timeoutPromise]).catch(err => {\n          if (err === timeoutErr) {\n            this.close();\n          }\n          throw err;\n        });\n      }\n      async forEach(callback, thisArg) {\n        // Get back to the beginning.\n        this._rewind();\n        let idx = 0;\n        while (true) {\n          const doc = await this._nextObjectPromise();\n          if (!doc) return;\n          await callback.call(thisArg, doc, idx++, this._selfForIteration);\n        }\n      }\n      async map(callback, thisArg) {\n        const results = [];\n        await this.forEach(async (doc, index) => {\n          results.push(await callback.call(thisArg, doc, index, this._selfForIteration));\n        });\n        return results;\n      }\n      _rewind() {\n        // known to be synchronous\n        this._dbCursor.rewind();\n        this._visitedIds = new LocalCollection._IdMap();\n      }\n\n      // Mostly usable for tailable cursors.\n      close() {\n        this._dbCursor.close();\n      }\n      fetch() {\n        return this.map(_.identity);\n      }\n\n      /**\n       * FIXME: (node:34680) [MONGODB DRIVER] Warning: cursor.count is deprecated and will be\n       *  removed in the next major version, please use `collection.estimatedDocumentCount` or\n       *  `collection.countDocuments` instead.\n       */\n      count() {\n        return this._dbCursor.count();\n      }\n\n      // This method is NOT wrapped in Cursor.\n      async getRawObjects(ordered) {\n        var self = this;\n        if (ordered) {\n          return self.fetch();\n        } else {\n          var results = new LocalCollection._IdMap();\n          await self.forEach(function (doc) {\n            results.set(doc._id, doc);\n          });\n          return results;\n        }\n      }\n    }\n    var SynchronousCursor = function (dbCursor, cursorDescription, options, collection) {\n      var self = this;\n      const {\n        selfForIteration,\n        useTransform\n      } = options;\n      options = {\n        selfForIteration,\n        useTransform\n      };\n      self._dbCursor = dbCursor;\n      self._cursorDescription = cursorDescription;\n      // The \"self\" argument passed to forEach/map callbacks. If we're wrapped\n      // inside a user-visible Cursor, we want to provide the outer cursor!\n      self._selfForIteration = options.selfForIteration || self;\n      if (options.useTransform && cursorDescription.options.transform) {\n        self._transform = LocalCollection.wrapTransform(cursorDescription.options.transform);\n      } else {\n        self._transform = null;\n      }\n      self._synchronousCount = Future.wrap(collection.countDocuments.bind(collection, replaceTypes(cursorDescription.selector, replaceMeteorAtomWithMongo), replaceTypes(cursorDescription.options, replaceMeteorAtomWithMongo)));\n      self._visitedIds = new LocalCollection._IdMap();\n    };\n    Object.assign(SynchronousCursor.prototype, {\n      // Returns a Promise for the next object from the underlying cursor (before\n      // the Mongo->Meteor type replacement).\n      _rawNextObjectPromise: function () {\n        const self = this;\n        return new Promise((resolve, reject) => {\n          self._dbCursor.next((err, doc) => {\n            if (err) {\n              reject(err);\n            } else {\n              resolve(doc);\n            }\n          });\n        });\n      },\n      // Returns a Promise for the next object from the cursor, skipping those whose\n      // IDs we've already seen and replacing Mongo atoms with Meteor atoms.\n      _nextObjectPromise: async function () {\n        var self = this;\n        while (true) {\n          var doc = await self._rawNextObjectPromise();\n          if (!doc) return null;\n          doc = replaceTypes(doc, replaceMongoAtomWithMeteor);\n          if (!self._cursorDescription.options.tailable && has(doc, '_id')) {\n            // Did Mongo give us duplicate documents in the same cursor? If so,\n            // ignore this one. (Do this before the transform, since transform might\n            // return some unrelated value.) We don't do this for tailable cursors,\n            // because we want to maintain O(1) memory usage. And if there isn't _id\n            // for some reason (maybe it's the oplog), then we don't do this either.\n            // (Be careful to do this for falsey but existing _id, though.)\n            if (self._visitedIds.has(doc._id)) continue;\n            self._visitedIds.set(doc._id, true);\n          }\n          if (self._transform) doc = self._transform(doc);\n          return doc;\n        }\n      },\n      // Returns a promise which is resolved with the next object (like with\n      // _nextObjectPromise) or rejected if the cursor doesn't return within\n      // timeoutMS ms.\n      _nextObjectPromiseWithTimeout: function (timeoutMS) {\n        const self = this;\n        if (!timeoutMS) {\n          return self._nextObjectPromise();\n        }\n        const nextObjectPromise = self._nextObjectPromise();\n        const timeoutErr = new Error('Client-side timeout waiting for next object');\n        const timeoutPromise = new Promise((resolve, reject) => {\n          const timer = setTimeout(() => {\n            reject(timeoutErr);\n          }, timeoutMS);\n        });\n        return Promise.race([nextObjectPromise, timeoutPromise]).catch(err => {\n          if (err === timeoutErr) {\n            self.close();\n          }\n          throw err;\n        });\n      },\n      _nextObject: function () {\n        var self = this;\n        return self._nextObjectPromise().await();\n      },\n      forEach: function (callback, thisArg) {\n        var self = this;\n        const wrappedFn = Meteor.wrapFn(callback);\n\n        // Get back to the beginning.\n        self._rewind();\n\n        // We implement the loop ourself instead of using self._dbCursor.each,\n        // because \"each\" will call its callback outside of a fiber which makes it\n        // much more complex to make this function synchronous.\n        var index = 0;\n        while (true) {\n          var doc = self._nextObject();\n          if (!doc) return;\n          wrappedFn.call(thisArg, doc, index++, self._selfForIteration);\n        }\n      },\n      // XXX Allow overlapping callback executions if callback yields.\n      map: function (callback, thisArg) {\n        var self = this;\n        const wrappedFn = Meteor.wrapFn(callback);\n        var res = [];\n        self.forEach(function (doc, index) {\n          res.push(wrappedFn.call(thisArg, doc, index, self._selfForIteration));\n        });\n        return res;\n      },\n      _rewind: function () {\n        var self = this;\n\n        // known to be synchronous\n        self._dbCursor.rewind();\n        self._visitedIds = new LocalCollection._IdMap();\n      },\n      // Mostly usable for tailable cursors.\n      close: function () {\n        var self = this;\n        self._dbCursor.close();\n      },\n      fetch: function () {\n        var self = this;\n        return self.map(identity);\n      },\n      count: function () {\n        var self = this;\n        return self._synchronousCount().wait();\n      },\n      // This method is NOT wrapped in Cursor.\n      getRawObjects: function (ordered) {\n        var self = this;\n        if (ordered) {\n          return self.fetch();\n        } else {\n          var results = new LocalCollection._IdMap();\n          self.forEach(function (doc) {\n            results.set(doc._id, doc);\n          });\n          return results;\n        }\n      }\n    });\n    SynchronousCursor.prototype[Symbol.iterator] = function () {\n      var self = this;\n\n      // Get back to the beginning.\n      self._rewind();\n      return {\n        next() {\n          const doc = self._nextObject();\n          return doc ? {\n            value: doc\n          } : {\n            done: true\n          };\n        }\n      };\n    };\n    SynchronousCursor.prototype[Symbol.asyncIterator] = function () {\n      const syncResult = this[Symbol.iterator]();\n      return {\n        async next() {\n          return Promise.resolve(syncResult.next());\n        }\n      };\n    };\n\n    // Tails the cursor described by cursorDescription, most likely on the\n    // oplog. Calls docCallback with each document found. Ignores errors and just\n    // restarts the tail on error.\n    //\n    // If timeoutMS is set, then if we don't get a new document every timeoutMS,\n    // kill and restart the cursor. This is primarily a workaround for #8598.\n    MongoConnection.prototype.tail = function (cursorDescription, docCallback, timeoutMS) {\n      var self = this;\n      if (!cursorDescription.options.tailable) throw new Error(\"Can only tail a tailable cursor\");\n      var cursor = self._createSynchronousCursor(cursorDescription);\n      var stopped = false;\n      var lastTS;\n      Meteor.defer(async function loop() {\n        var doc = null;\n        while (true) {\n          if (stopped) return;\n          try {\n            doc = await cursor._nextObjectPromiseWithTimeout(timeoutMS);\n          } catch (err) {\n            // There's no good way to figure out if this was actually an error from\n            // Mongo, or just client-side (including our own timeout error). Ah\n            // well. But either way, we need to retry the cursor (unless the failure\n            // was because the observe got stopped).\n            doc = null;\n          }\n          // Since we awaited a promise above, we need to check again to see if\n          // we've been stopped before calling the callback.\n          if (stopped) return;\n          if (doc) {\n            // If a tailable cursor contains a \"ts\" field, use it to recreate the\n            // cursor on error. (\"ts\" is a standard that Mongo uses internally for\n            // the oplog, and there's a special flag that lets you do binary search\n            // on it instead of needing to use an index.)\n            lastTS = doc.ts;\n            docCallback(doc);\n          } else {\n            var newSelector = Object.assign({}, cursorDescription.selector);\n            if (lastTS) {\n              newSelector.ts = {\n                $gt: lastTS\n              };\n            }\n            cursor = self._createSynchronousCursor(new CursorDescription(cursorDescription.collectionName, newSelector, cursorDescription.options));\n            // Mongo failover takes many seconds.  Retry in a bit.  (Without this\n            // setTimeout, we peg the CPU at 100% and never notice the actual\n            // failover.\n            setTimeout(loop, 100);\n            break;\n          }\n        }\n      });\n      return {\n        stop: function () {\n          stopped = true;\n          cursor.close();\n        }\n      };\n    };\n    const oplogCollectionWarnings = [];\n    Object.assign(MongoConnection.prototype, {\n      _observeChanges: async function (cursorDescription, ordered, callbacks, nonMutatingCallbacks) {\n        var _self$_oplogHandle;\n        var self = this;\n        const collectionName = cursorDescription.collectionName;\n        if (cursorDescription.options.tailable) {\n          return self._observeChangesTailable(cursorDescription, ordered, callbacks);\n        }\n\n        // You may not filter out _id when observing changes, because the id is a core\n        // part of the observeChanges API.\n        const fieldsOptions = cursorDescription.options.projection || cursorDescription.options.fields;\n        if (fieldsOptions && (fieldsOptions._id === 0 || fieldsOptions._id === false)) {\n          throw Error(\"You may not observe a cursor with {fields: {_id: 0}}\");\n        }\n        var observeKey = EJSON.stringify(Object.assign({\n          ordered: ordered\n        }, cursorDescription));\n        var multiplexer, observeDriver;\n        var firstHandle = false;\n\n        // Find a matching ObserveMultiplexer, or create a new one. This next block is\n        // guaranteed to not yield (and it doesn't call anything that can observe a\n        // new query), so no other calls to this function can interleave with it.\n        if (has(self._observeMultiplexers, observeKey)) {\n          multiplexer = self._observeMultiplexers[observeKey];\n        } else {\n          firstHandle = true;\n          // Create a new ObserveMultiplexer.\n          multiplexer = new ObserveMultiplexer({\n            ordered: ordered,\n            onStop: function () {\n              delete self._observeMultiplexers[observeKey];\n              return observeDriver.stop();\n            }\n          });\n        }\n        var observeHandle = new ObserveHandle(multiplexer, callbacks, nonMutatingCallbacks);\n        const oplogOptions = (self === null || self === void 0 ? void 0 : (_self$_oplogHandle = self._oplogHandle) === null || _self$_oplogHandle === void 0 ? void 0 : _self$_oplogHandle._oplogOptions) || {};\n        const {\n          includeCollections,\n          excludeCollections\n        } = oplogOptions;\n        if (firstHandle) {\n          var matcher, sorter;\n          var canUseOplog = [function () {\n            // At a bare minimum, using the oplog requires us to have an oplog, to\n            // want unordered callbacks, and to not want a callback on the polls\n            // that won't happen.\n            return self._oplogHandle && !ordered && !callbacks._testOnlyPollCallback;\n          }, function () {\n            // We also need to check, if the collection of this Cursor is actually being \"watched\" by the Oplog handle\n            // if not, we have to fallback to long polling\n            if (excludeCollections !== null && excludeCollections !== void 0 && excludeCollections.length && excludeCollections.includes(collectionName)) {\n              if (!oplogCollectionWarnings.includes(collectionName)) {\n                console.warn(\"Meteor.settings.packages.mongo.oplogExcludeCollections includes the collection \".concat(collectionName, \" - your subscriptions will only use long polling!\"));\n                oplogCollectionWarnings.push(collectionName); // we only want to show the warnings once per collection!\n              }\n              return false;\n            }\n            if (includeCollections !== null && includeCollections !== void 0 && includeCollections.length && !includeCollections.includes(collectionName)) {\n              if (!oplogCollectionWarnings.includes(collectionName)) {\n                console.warn(\"Meteor.settings.packages.mongo.oplogIncludeCollections does not include the collection \".concat(collectionName, \" - your subscriptions will only use long polling!\"));\n                oplogCollectionWarnings.push(collectionName); // we only want to show the warnings once per collection!\n              }\n              return false;\n            }\n            return true;\n          }, function () {\n            // We need to be able to compile the selector. Fall back to polling for\n            // some newfangled $selector that minimongo doesn't support yet.\n            try {\n              matcher = new Minimongo.Matcher(cursorDescription.selector);\n              return true;\n            } catch (e) {\n              // XXX make all compilation errors MinimongoError or something\n              //     so that this doesn't ignore unrelated exceptions\n              return false;\n            }\n          }, function () {\n            // ... and the selector itself needs to support oplog.\n            return OplogObserveDriver.cursorSupported(cursorDescription, matcher);\n          }, function () {\n            // And we need to be able to compile the sort, if any.  eg, can't be\n            // {$natural: 1}.\n            if (!cursorDescription.options.sort) return true;\n            try {\n              sorter = new Minimongo.Sorter(cursorDescription.options.sort);\n              return true;\n            } catch (e) {\n              // XXX make all compilation errors MinimongoError or something\n              //     so that this doesn't ignore unrelated exceptions\n              return false;\n            }\n          }].every(f => f()); // invoke each function and check if all return true\n\n          var driverClass = canUseOplog ? OplogObserveDriver : PollingObserveDriver;\n          observeDriver = new driverClass({\n            cursorDescription: cursorDescription,\n            mongoHandle: self,\n            multiplexer: multiplexer,\n            ordered: ordered,\n            matcher: matcher,\n            // ignored by polling\n            sorter: sorter,\n            // ignored by polling\n            _testOnlyPollCallback: callbacks._testOnlyPollCallback\n          });\n          if (observeDriver._init) {\n            await observeDriver._init();\n          }\n\n          // This field is only set for use in tests.\n          multiplexer._observeDriver = observeDriver;\n        }\n        self._observeMultiplexers[observeKey] = multiplexer;\n        // Blocks until the initial adds have been sent.\n        await multiplexer.addHandleAndSendInitialAdds(observeHandle);\n        return observeHandle;\n      }\n    });\n\n    // Listen for the invalidation messages that will trigger us to poll the\n    // database for changes. If this selector specifies specific IDs, specify them\n    // here, so that updates to different specific IDs don't cause us to poll.\n    // listenCallback is the same kind of (notification, complete) callback passed\n    // to InvalidationCrossbar.listen.\n\n    listenAll = async function (cursorDescription, listenCallback) {\n      const listeners = [];\n      await forEachTrigger(cursorDescription, function (trigger) {\n        listeners.push(DDPServer._InvalidationCrossbar.listen(trigger, listenCallback));\n      });\n      return {\n        stop: function () {\n          listeners.forEach(function (listener) {\n            listener.stop();\n          });\n        }\n      };\n    };\n    forEachTrigger = async function (cursorDescription, triggerCallback) {\n      const key = {\n        collection: cursorDescription.collectionName\n      };\n      const specificIds = LocalCollection._idsMatchedBySelector(cursorDescription.selector);\n      if (specificIds) {\n        for (const id of specificIds) {\n          await triggerCallback(_.extend({\n            id: id\n          }, key));\n        }\n        await triggerCallback(_.extend({\n          dropCollection: true,\n          id: null\n        }, key));\n      } else {\n        await triggerCallback(key);\n      }\n      // Everyone cares about the database being dropped.\n      await triggerCallback({\n        dropDatabase: true\n      });\n    };\n\n    // observeChanges for tailable cursors on capped collections.\n    //\n    // Some differences from normal cursors:\n    //   - Will never produce anything other than 'added' or 'addedBefore'. If you\n    //     do update a document that has already been produced, this will not notice\n    //     it.\n    //   - If you disconnect and reconnect from Mongo, it will essentially restart\n    //     the query, which will lead to duplicate results. This is pretty bad,\n    //     but if you include a field called 'ts' which is inserted as\n    //     new MongoInternals.MongoTimestamp(0, 0) (which is initialized to the\n    //     current Mongo-style timestamp), we'll be able to find the place to\n    //     restart properly. (This field is specifically understood by Mongo with an\n    //     optimization which allows it to find the right place to start without\n    //     an index on ts. It's how the oplog works.)\n    //   - No callbacks are triggered synchronously with the call (there's no\n    //     differentiation between \"initial data\" and \"later changes\"; everything\n    //     that matches the query gets sent asynchronously).\n    //   - De-duplication is not implemented.\n    //   - Does not yet interact with the write fence. Probably, this should work by\n    //     ignoring removes (which don't work on capped collections) and updates\n    //     (which don't affect tailable cursors), and just keeping track of the ID\n    //     of the inserted object, and closing the write fence once you get to that\n    //     ID (or timestamp?).  This doesn't work well if the document doesn't match\n    //     the query, though.  On the other hand, the write fence can close\n    //     immediately if it does not match the query. So if we trust minimongo\n    //     enough to accurately evaluate the query against the write fence, we\n    //     should be able to do this...  Of course, minimongo doesn't even support\n    //     Mongo Timestamps yet.\n    MongoConnection.prototype._observeChangesTailable = function (cursorDescription, ordered, callbacks) {\n      var self = this;\n\n      // Tailable cursors only ever call added/addedBefore callbacks, so it's an\n      // error if you didn't provide them.\n      if (ordered && !callbacks.addedBefore || !ordered && !callbacks.added) {\n        throw new Error(\"Can't observe an \" + (ordered ? \"ordered\" : \"unordered\") + \" tailable cursor without a \" + (ordered ? \"addedBefore\" : \"added\") + \" callback\");\n      }\n      return self.tail(cursorDescription, function (doc) {\n        var id = doc._id;\n        delete doc._id;\n        // The ts is an implementation detail. Hide it.\n        delete doc.ts;\n        if (ordered) {\n          callbacks.addedBefore(id, doc, null);\n        } else {\n          callbacks.added(id, doc);\n        }\n      });\n    };\n\n    // XXX We probably need to find a better way to expose this. Right now\n    // it's only used by tests, but in fact you need it in normal\n    // operation to interact with capped collections.\n    MongoInternals.MongoTimestamp = MongoDB.Timestamp;\n    MongoInternals.Connection = MongoConnection;\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: false\n});","map":{"version":3,"names":["_objectSpread","module1","link","default","v","has","identity","clone","DocFetcher","ASYNC_CURSOR_METHODS","CLIENT_ONLY_METHODS","getAsyncMethodName","Meteor","__reifyWaitForDeps__","path","require","util","MongoDB","NpmModuleMongodb","MongoInternals","__packageName","NpmModules","mongodb","version","NpmModuleMongodbVersion","module","NpmModule","FILE_ASSET_SUFFIX","ASSETS_FOLDER","APP_FOLDER","replaceNames","filter","thing","Array","isArray","map","bind","ret","Object","entries","forEach","_ref","key","value","Timestamp","prototype","makeMongoLegal","name","unmakeMongoLegal","substr","replaceMongoAtomWithMeteor","document","Binary","sub_type","buffer","Uint8Array","ObjectID","Mongo","toHexString","Decimal128","Decimal","toString","keys","length","EJSON","fromJSONValue","undefined","replaceMeteorAtomWithMongo","isBinary","Buffer","from","fromString","_isCustomType","toJSONValue","replaceTypes","atomTransformer","replacedTopLevelAtom","_ref2","val","valReplaced","MongoConnection","url","options","_Meteor$settings","_Meteor$settings$pack","_Meteor$settings$pack2","self","_observeMultiplexers","_onFailoverHook","Hook","userOptions","_connectionOptions","settings","packages","mongo","mongoOptions","assign","ignoreUndefined","maxPoolSize","minPoolSize","_ref3","endsWith","_ref4","optionName","replace","join","Assets","getServerDir","db","_oplogHandle","_docFetcher","driverInfo","release","client","MongoClient","on","bindEnvironment","event","previousDescription","type","newDescription","each","callback","oplogUrl","Package","OplogHandle","databaseName","_close","Error","oplogHandle","stop","close","_setOplogHandle","rawCollection","collectionName","collection","createCappedCollectionAsync","byteSize","maxDocuments","createCollection","capped","size","max","_maybeBeginWrite","fence","DDPServer","_getCurrentFence","beginWrite","committed","_onFailover","register","writeCallback","write","refresh","err","result","refreshErr","bindEnvironmentForWrite","insertAsync","collection_name","e","_expectedByTest","LocalCollection","_isPlainObject","id","_id","insertOne","safe","then","_ref5","insertedId","catch","_refresh","selector","refreshKey","specificIds","_idsMatchedBySelector","removeAsync","deleteMany","_ref6","deletedCount","transformResult","modifiedCount","numberAffected","dropCollectionAsync","dropCollection","drop","dropDatabaseAsync","dropDatabase","_dropDatabase","updateAsync","mod","error","mongoOpts","arrayFilters","upsert","multi","fullResult","mongoSelector","mongoMod","isModify","_isModificationMod","_forbidReplace","knownId","newDoc","_createUpsertDocument","generatedId","simulateUpsertWithInsertedId","_returnObject","hasOwnProperty","$setOnInsert","strings","startsWith","updateMethod","meteorResult","driverResult","mongoResult","upsertedCount","upsertedId","n","matchedCount","NUM_OPTIMISTIC_TRIES","_isCannotChangeIdError","errmsg","indexOf","mongoOptsForUpdate","mongoOptsForInsert","replacementWithId","tries","doUpdate","method","updateMany","some","replaceOne","doConditionalInsert","upsertAsync","find","arguments","Cursor","CursorDescription","findOneAsync","limit","results","fetch","createIndexAsync","index","createIndex","countDocuments","_len","args","_key","arg","estimatedDocumentCount","_len2","_key2","ensureIndexAsync","dropIndexAsync","indexName","dropIndex","m","concat","Collection","_rewriteSelector","cursorDescription","_mongo","_cursorDescription","_synchronousCursor","setupSynchronousCursor","cursor","tailable","_createSynchronousCursor","selfForIteration","useTransform","countAsync","count","Symbol","iterator","asyncIterator","methodName","methodNameAsync","Promise","resolve","reject","getTransform","transform","_publishCursor","sub","_getCollectionName","observe","callbacks","_observeFromObserveChanges","observeAsync","observeChanges","methods","ordered","_observeChangesCallbacksAreOrdered","exceptionName","_fromObserve","_observeChanges","nonMutatingCallbacks","observeChangesAsync","cursorOptions","sort","skip","projection","fields","readPreference","numberOfRetries","dbCursor","addCursorFlag","OPLOG_COLLECTION","ts","maxTimeMs","maxTimeMS","hint","AsynchronousCursor","constructor","_dbCursor","_selfForIteration","_transform","wrapTransform","_visitedIds","_IdMap","next","_nextObjectPromise","done","_rawNextObjectPromise","console","doc","_","set","_nextObjectPromiseWithTimeout","timeoutMS","nextObjectPromise","timeoutErr","timeoutPromise","setTimeout","race","thisArg","_rewind","idx","call","push","rewind","getRawObjects","SynchronousCursor","_synchronousCount","Future","wrap","timer","_nextObject","await","wrappedFn","wrapFn","res","wait","syncResult","tail","docCallback","stopped","lastTS","defer","loop","newSelector","$gt","oplogCollectionWarnings","_self$_oplogHandle","_observeChangesTailable","fieldsOptions","observeKey","stringify","multiplexer","observeDriver","firstHandle","ObserveMultiplexer","onStop","observeHandle","ObserveHandle","oplogOptions","_oplogOptions","includeCollections","excludeCollections","matcher","sorter","canUseOplog","_testOnlyPollCallback","includes","warn","Minimongo","Matcher","OplogObserveDriver","cursorSupported","Sorter","every","f","driverClass","PollingObserveDriver","mongoHandle","_init","_observeDriver","addHandleAndSendInitialAdds","listenAll","listenCallback","listeners","forEachTrigger","trigger","_InvalidationCrossbar","listen","listener","triggerCallback","extend","addedBefore","added","MongoTimestamp","Connection","__reify_async_result__","_reifyError","async"],"sources":["packages/mongo/mongo_driver.js"],"sourcesContent":["import has from 'lodash.has';\nimport identity from 'lodash.identity';\nimport clone from 'lodash.clone';\n\n/**\n * Provide a synchronous Collection API using fibers, backed by\n * MongoDB.  This is only for use on the server, and mostly identical\n * to the client API.\n *\n * NOTE: the public API methods must be run within a fiber. If you call\n * these outside of a fiber they will explode!\n */\n\nconst path = require(\"path\");\nconst util = require(\"util\");\n\n/** @type {import('mongodb')} */\nvar MongoDB = NpmModuleMongodb;\nimport { DocFetcher } from \"./doc_fetcher.js\";\nimport {\n  ASYNC_CURSOR_METHODS,\n  CLIENT_ONLY_METHODS,\n  getAsyncMethodName\n} from \"meteor/minimongo/constants\";\nimport { Meteor } from \"meteor/meteor\";\n\nMongoInternals = {};\n\nMongoInternals.__packageName = 'mongo';\n\nMongoInternals.NpmModules = {\n  mongodb: {\n    version: NpmModuleMongodbVersion,\n    module: MongoDB\n  }\n};\n\n// Older version of what is now available via\n// MongoInternals.NpmModules.mongodb.module.  It was never documented, but\n// people do use it.\n// XXX COMPAT WITH 1.0.3.2\nMongoInternals.NpmModule = MongoDB;\n\nconst FILE_ASSET_SUFFIX = 'Asset';\nconst ASSETS_FOLDER = 'assets';\nconst APP_FOLDER = 'app';\n\n// This is used to add or remove EJSON from the beginning of everything nested\n// inside an EJSON custom type. It should only be called on pure JSON!\nvar replaceNames = function (filter, thing) {\n  if (typeof thing === \"object\" && thing !== null) {\n    if (Array.isArray(thing)) {\n      return thing.map(replaceNames.bind(null, filter));\n    }\n    var ret = {};\n    Object.entries(thing).forEach(function ([key, value]) {\n      ret[filter(key)] = replaceNames(filter, value);\n    });\n    return ret;\n  }\n  return thing;\n};\n\n// Ensure that EJSON.clone keeps a Timestamp as a Timestamp (instead of just\n// doing a structural clone).\n// XXX how ok is this? what if there are multiple copies of MongoDB loaded?\nMongoDB.Timestamp.prototype.clone = function () {\n  // Timestamps should be immutable.\n  return this;\n};\n\nvar makeMongoLegal = function (name) { return \"EJSON\" + name; };\nvar unmakeMongoLegal = function (name) { return name.substr(5); };\n\nvar replaceMongoAtomWithMeteor = function (document) {\n  if (document instanceof MongoDB.Binary) {\n    // for backwards compatibility\n    if (document.sub_type !== 0) {\n      return document;\n    }\n    var buffer = document.value(true);\n    return new Uint8Array(buffer);\n  }\n  if (document instanceof MongoDB.ObjectID) {\n    return new Mongo.ObjectID(document.toHexString());\n  }\n  if (document instanceof MongoDB.Decimal128) {\n    return Decimal(document.toString());\n  }\n  if (document[\"EJSON$type\"] && document[\"EJSON$value\"] && Object.keys(document).length === 2) {\n    return EJSON.fromJSONValue(replaceNames(unmakeMongoLegal, document));\n  }\n  if (document instanceof MongoDB.Timestamp) {\n    // For now, the Meteor representation of a Mongo timestamp type (not a date!\n    // this is a weird internal thing used in the oplog!) is the same as the\n    // Mongo representation. We need to do this explicitly or else we would do a\n    // structural clone and lose the prototype.\n    return document;\n  }\n  return undefined;\n};\n\nvar replaceMeteorAtomWithMongo = function (document) {\n  if (EJSON.isBinary(document)) {\n    // This does more copies than we'd like, but is necessary because\n    // MongoDB.BSON only looks like it takes a Uint8Array (and doesn't actually\n    // serialize it correctly).\n    return new MongoDB.Binary(Buffer.from(document));\n  }\n  if (document instanceof MongoDB.Binary) {\n     return document;\n  }\n  if (document instanceof Mongo.ObjectID) {\n    return new MongoDB.ObjectID(document.toHexString());\n  }\n  if (document instanceof MongoDB.Timestamp) {\n    // For now, the Meteor representation of a Mongo timestamp type (not a date!\n    // this is a weird internal thing used in the oplog!) is the same as the\n    // Mongo representation. We need to do this explicitly or else we would do a\n    // structural clone and lose the prototype.\n    return document;\n  }\n  if (document instanceof Decimal) {\n    return MongoDB.Decimal128.fromString(document.toString());\n  }\n  if (EJSON._isCustomType(document)) {\n    return replaceNames(makeMongoLegal, EJSON.toJSONValue(document));\n  }\n  // It is not ordinarily possible to stick dollar-sign keys into mongo\n  // so we don't bother checking for things that need escaping at this time.\n  return undefined;\n};\n\nvar replaceTypes = function (document, atomTransformer) {\n  if (typeof document !== 'object' || document === null)\n    return document;\n\n  var replacedTopLevelAtom = atomTransformer(document);\n  if (replacedTopLevelAtom !== undefined)\n    return replacedTopLevelAtom;\n\n  var ret = document;\n  Object.entries(document).forEach(function ([key, val]) {\n    var valReplaced = replaceTypes(val, atomTransformer);\n    if (val !== valReplaced) {\n      // Lazy clone. Shallow copy.\n      if (ret === document)\n        ret = clone(document);\n      ret[key] = valReplaced;\n    }\n  });\n  return ret;\n};\n\n\nMongoConnection = function (url, options) {\n  var self = this;\n  options = options || {};\n  self._observeMultiplexers = {};\n  self._onFailoverHook = new Hook;\n\n  const userOptions = {\n    ...(Mongo._connectionOptions || {}),\n    ...(Meteor.settings?.packages?.mongo?.options || {})\n  };\n\n  var mongoOptions = Object.assign({\n    ignoreUndefined: true,\n  }, userOptions);\n\n\n\n  // Internally the oplog connections specify their own maxPoolSize\n  // which we don't want to overwrite with any user defined value\n  if (has(options, 'maxPoolSize')) {\n    // If we just set this for \"server\", replSet will override it. If we just\n    // set it for replSet, it will be ignored if we're not using a replSet.\n    mongoOptions.maxPoolSize = options.maxPoolSize;\n  }\n  if (has(options, 'minPoolSize')) {\n    mongoOptions.minPoolSize = options.minPoolSize;\n  }\n\n  // Transform options like \"tlsCAFileAsset\": \"filename.pem\" into\n  // \"tlsCAFile\": \"/<fullpath>/filename.pem\"\n  Object.entries(mongoOptions || {})\n    .filter(([key]) => key && key.endsWith(FILE_ASSET_SUFFIX))\n    .forEach(([key, value]) => {\n      const optionName = key.replace(FILE_ASSET_SUFFIX, '');\n      mongoOptions[optionName] = path.join(Assets.getServerDir(),\n        ASSETS_FOLDER, APP_FOLDER, value);\n      delete mongoOptions[key];\n    });\n\n  self.db = null;\n  self._oplogHandle = null;\n  self._docFetcher = null;\n\n  mongoOptions.driverInfo = {\n    name: 'Meteor',\n    version: Meteor.release\n  }\n  \n  self.client = new MongoDB.MongoClient(url, mongoOptions);\n  self.db = self.client.db();\n\n  self.client.on('serverDescriptionChanged', Meteor.bindEnvironment(event => {\n    // When the connection is no longer against the primary node, execute all\n    // failover hooks. This is important for the driver as it has to re-pool the\n    // query when it happens.\n    if (\n      event.previousDescription.type !== 'RSPrimary' &&\n      event.newDescription.type === 'RSPrimary'\n    ) {\n      self._onFailoverHook.each(callback => {\n        callback();\n        return true;\n      });\n    }\n  }));\n\n  if (options.oplogUrl && ! Package['disable-oplog']) {\n    self._oplogHandle = new OplogHandle(options.oplogUrl, self.db.databaseName);\n    self._docFetcher = new DocFetcher(self);\n  }\n\n};\n\nMongoConnection.prototype._close = async function() {\n  var self = this;\n\n  if (! self.db)\n    throw Error(\"close called before Connection created?\");\n\n  // XXX probably untested\n  var oplogHandle = self._oplogHandle;\n  self._oplogHandle = null;\n  if (oplogHandle)\n    await oplogHandle.stop();\n\n  // Use Future.wrap so that errors get thrown. This happens to\n  // work even outside a fiber since the 'close' method is not\n  // actually asynchronous.\n  await self.client.close();\n};\n\nMongoConnection.prototype.close = function () {\n  return this._close();\n};\n\nMongoConnection.prototype._setOplogHandle = function(oplogHandle) {\n  this._oplogHandle = oplogHandle;\n  return this;\n};\n\n// Returns the Mongo Collection object; may yield.\nMongoConnection.prototype.rawCollection = function (collectionName) {\n  var self = this;\n\n  if (! self.db)\n    throw Error(\"rawCollection called before Connection created?\");\n\n  return self.db.collection(collectionName);\n};\n\nMongoConnection.prototype.createCappedCollectionAsync = async function (\n    collectionName, byteSize, maxDocuments) {\n  var self = this;\n\n  if (! self.db)\n    throw Error(\"createCappedCollectionAsync called before Connection created?\");\n\n\n  await self.db.createCollection(collectionName,\n    { capped: true, size: byteSize, max: maxDocuments });\n};\n\n// This should be called synchronously with a write, to create a\n// transaction on the current write fence, if any. After we can read\n// the write, and after observers have been notified (or at least,\n// after the observer notifiers have added themselves to the write\n// fence), you should call 'committed()' on the object returned.\nMongoConnection.prototype._maybeBeginWrite = function () {\n  const fence = DDPServer._getCurrentFence();\n  if (fence) {\n    return fence.beginWrite();\n  } else {\n    return {committed: function () {}};\n  }\n};\n\n// Internal interface: adds a callback which is called when the Mongo primary\n// changes. Returns a stop handle.\nMongoConnection.prototype._onFailover = function (callback) {\n  return this._onFailoverHook.register(callback);\n};\n\n\n//////////// Public API //////////\n\n// The write methods block until the database has confirmed the write (it may\n// not be replicated or stable on disk, but one server has confirmed it) if no\n// callback is provided. If a callback is provided, then they call the callback\n// when the write is confirmed. They return nothing on success, and raise an\n// exception on failure.\n//\n// After making a write (with insert, update, remove), observers are\n// notified asynchronously. If you want to receive a callback once all\n// of the observer notifications have landed for your write, do the\n// writes inside a write fence (set DDPServer._CurrentWriteFence to a new\n// _WriteFence, and then set a callback on the write fence.)\n//\n// Since our execution environment is single-threaded, this is\n// well-defined -- a write \"has been made\" if it's returned, and an\n// observer \"has been notified\" if its callback has returned.\n\nvar writeCallback = function (write, refresh, callback) {\n  return function (err, result) {\n    if (! err) {\n      // XXX We don't have to run this on error, right?\n      try {\n        refresh();\n      } catch (refreshErr) {\n        if (callback) {\n          callback(refreshErr);\n          return;\n        } else {\n          throw refreshErr;\n        }\n      }\n    }\n    write.committed();\n    if (callback) {\n      callback(err, result);\n    } else if (err) {\n      throw err;\n    }\n  };\n};\n\nvar bindEnvironmentForWrite = function (callback) {\n  return Meteor.bindEnvironment(callback, \"Mongo write\");\n};\n\nMongoConnection.prototype.insertAsync = async function (collection_name, document) {\n  const self = this;\n\n  if (collection_name === \"___meteor_failure_test_collection\") {\n    const e = new Error(\"Failure test\");\n    e._expectedByTest = true;\n    throw e;\n  }\n\n  if (!(LocalCollection._isPlainObject(document) &&\n        !EJSON._isCustomType(document))) {\n    throw new Error(\"Only plain objects may be inserted into MongoDB\");\n  }\n\n  var write = self._maybeBeginWrite();\n  var refresh = async function () {\n    await Meteor.refresh({collection: collection_name, id: document._id });\n  };\n  return self.rawCollection(collection_name).insertOne(\n    replaceTypes(document, replaceMeteorAtomWithMongo),\n    {\n      safe: true,\n    }\n  ).then(async ({insertedId}) => {\n    await refresh();\n    await write.committed();\n    return insertedId;\n  }).catch(async e => {\n    await write.committed();\n    throw e;\n  });\n};\n\n\n// Cause queries that may be affected by the selector to poll in this write\n// fence.\nMongoConnection.prototype._refresh = async function (collectionName, selector) {\n  var refreshKey = {collection: collectionName};\n  // If we know which documents we're removing, don't poll queries that are\n  // specific to other documents. (Note that multiple notifications here should\n  // not cause multiple polls, since all our listener is doing is enqueueing a\n  // poll.)\n  var specificIds = LocalCollection._idsMatchedBySelector(selector);\n  if (specificIds) {\n    for (const id of specificIds) {\n      await Meteor.refresh(Object.assign({id: id}, refreshKey));\n    };\n  } else {\n    await Meteor.refresh(refreshKey);\n  }\n};\n\nMongoConnection.prototype.removeAsync = async function (collection_name, selector) {\n  var self = this;\n\n  if (collection_name === \"___meteor_failure_test_collection\") {\n    var e = new Error(\"Failure test\");\n    e._expectedByTest = true;\n    throw e;\n  }\n\n  var write = self._maybeBeginWrite();\n  var refresh = async function () {\n    await self._refresh(collection_name, selector);\n  };\n\n  return self.rawCollection(collection_name)\n    .deleteMany(replaceTypes(selector, replaceMeteorAtomWithMongo), {\n      safe: true,\n    })\n    .then(async ({ deletedCount }) => {\n      await refresh();\n      await write.committed();\n      return transformResult({ result : {modifiedCount : deletedCount} }).numberAffected;\n    }).catch(async (err) => {\n        await write.committed();\n        throw err;\n    });\n};\n\nMongoConnection.prototype.dropCollectionAsync = async function(collectionName) {\n  var self = this;\n\n\n  var write = self._maybeBeginWrite();\n  var refresh = function() {\n    return Meteor.refresh({\n      collection: collectionName,\n      id: null,\n      dropCollection: true,\n    });\n  };\n\n  return self\n    .rawCollection(collectionName)\n    .drop()\n    .then(async result => {\n      await refresh();\n      await write.committed();\n      return result;\n    })\n    .catch(async e => {\n      await write.committed();\n      throw e;\n    });\n};\n\n// For testing only.  Slightly better than `c.rawDatabase().dropDatabase()`\n// because it lets the test's fence wait for it to be complete.\nMongoConnection.prototype.dropDatabaseAsync = async function () {\n  var self = this;\n\n  var write = self._maybeBeginWrite();\n  var refresh = async function () {\n    await Meteor.refresh({ dropDatabase: true });\n  };\n\n  try {\n    await self.db._dropDatabase();\n    await refresh();\n    await write.committed();\n  } catch (e) {\n    await write.committed();\n    throw e;\n  }\n};\n\nMongoConnection.prototype.updateAsync = async function (collection_name, selector, mod, options) {\n  var self = this;\n\n  if (collection_name === \"___meteor_failure_test_collection\") {\n    var e = new Error(\"Failure test\");\n    e._expectedByTest = true;\n    throw e;\n  }\n\n  // explicit safety check. null and undefined can crash the mongo\n  // driver. Although the node driver and minimongo do 'support'\n  // non-object modifier in that they don't crash, they are not\n  // meaningful operations and do not do anything. Defensively throw an\n  // error here.\n  if (!mod || typeof mod !== 'object') {\n    const error = new Error(\"Invalid modifier. Modifier must be an object.\");\n\n    throw error;\n  }\n\n  if (!(LocalCollection._isPlainObject(mod) && !EJSON._isCustomType(mod))) {\n    const error = new Error(\n        \"Only plain objects may be used as replacement\" +\n        \" documents in MongoDB\");\n\n    throw error;\n  }\n\n  if (!options) options = {};\n\n  var write = self._maybeBeginWrite();\n  var refresh = async function () {\n    await self._refresh(collection_name, selector);\n  };\n\n  var collection = self.rawCollection(collection_name);\n  var mongoOpts = {safe: true};\n  // Add support for filtered positional operator\n  if (options.arrayFilters !== undefined) mongoOpts.arrayFilters = options.arrayFilters;\n  // explictly enumerate options that minimongo supports\n  if (options.upsert) mongoOpts.upsert = true;\n  if (options.multi) mongoOpts.multi = true;\n  // Lets you get a more more full result from MongoDB. Use with caution:\n  // might not work with C.upsert (as opposed to C.update({upsert:true}) or\n  // with simulated upsert.\n  if (options.fullResult) mongoOpts.fullResult = true;\n\n  var mongoSelector = replaceTypes(selector, replaceMeteorAtomWithMongo);\n  var mongoMod = replaceTypes(mod, replaceMeteorAtomWithMongo);\n\n  var isModify = LocalCollection._isModificationMod(mongoMod);\n\n  if (options._forbidReplace && !isModify) {\n    var err = new Error(\"Invalid modifier. Replacements are forbidden.\");\n    throw err;\n  }\n\n  // We've already run replaceTypes/replaceMeteorAtomWithMongo on\n  // selector and mod.  We assume it doesn't matter, as far as\n  // the behavior of modifiers is concerned, whether `_modify`\n  // is run on EJSON or on mongo-converted EJSON.\n\n  // Run this code up front so that it fails fast if someone uses\n  // a Mongo update operator we don't support.\n  let knownId;\n  if (options.upsert) {\n    try {\n      let newDoc = LocalCollection._createUpsertDocument(selector, mod);\n      knownId = newDoc._id;\n    } catch (err) {\n      throw err;\n    }\n  }\n  if (options.upsert &&\n      ! isModify &&\n      ! knownId &&\n      options.insertedId &&\n      ! (options.insertedId instanceof Mongo.ObjectID &&\n         options.generatedId)) {\n    // In case of an upsert with a replacement, where there is no _id defined\n    // in either the query or the replacement doc, mongo will generate an id itself.\n    // Therefore we need this special strategy if we want to control the id ourselves.\n\n    // We don't need to do this when:\n    // - This is not a replacement, so we can add an _id to $setOnInsert\n    // - The id is defined by query or mod we can just add it to the replacement doc\n    // - The user did not specify any id preference and the id is a Mongo ObjectId,\n    //     then we can just let Mongo generate the id\n    return await simulateUpsertWithInsertedId(collection, mongoSelector, mongoMod, options)\n        .then(async result => {\n          await refresh();\n          await write.committed();\n          if (result && ! options._returnObject) {\n            return result.numberAffected;\n          } else {\n            return result;\n          }\n        });\n  } else {\n    if (options.upsert && !knownId && options.insertedId && isModify) {\n      if (!mongoMod.hasOwnProperty('$setOnInsert')) {\n        mongoMod.$setOnInsert = {};\n      }\n      knownId = options.insertedId;\n      Object.assign(mongoMod.$setOnInsert, replaceTypes({_id: options.insertedId}, replaceMeteorAtomWithMongo));\n    }\n\n    const strings = Object.keys(mongoMod).filter((key) => !key.startsWith(\"$\"));\n    let updateMethod = strings.length > 0 ? 'replaceOne' : 'updateMany';\n    updateMethod =\n        updateMethod === 'updateMany' && !mongoOpts.multi\n            ? 'updateOne'\n            : updateMethod;\n    return collection[updateMethod]\n        .bind(collection)(mongoSelector, mongoMod, mongoOpts)\n        .then(async result => {\n          var meteorResult = transformResult({result});\n          if (meteorResult && options._returnObject) {\n            // If this was an upsertAsync() call, and we ended up\n            // inserting a new doc and we know its id, then\n            // return that id as well.\n            if (options.upsert && meteorResult.insertedId) {\n              if (knownId) {\n                meteorResult.insertedId = knownId;\n              } else if (meteorResult.insertedId instanceof MongoDB.ObjectID) {\n                meteorResult.insertedId = new Mongo.ObjectID(meteorResult.insertedId.toHexString());\n              }\n            }\n            await refresh();\n            await write.committed();\n            return meteorResult;\n          } else {\n            await refresh();\n            await write.committed();\n            return meteorResult.numberAffected;\n          }\n        }).catch(async (err) => {\n          await write.committed();\n          throw err;\n        });\n  }\n};\n\nvar transformResult = function (driverResult) {\n  var meteorResult = { numberAffected: 0 };\n  if (driverResult) {\n    var mongoResult = driverResult.result;\n    // On updates with upsert:true, the inserted values come as a list of\n    // upserted values -- even with options.multi, when the upsert does insert,\n    // it only inserts one element.\n    if (mongoResult.upsertedCount) {\n      meteorResult.numberAffected = mongoResult.upsertedCount;\n\n      if (mongoResult.upsertedId) {\n        meteorResult.insertedId = mongoResult.upsertedId;\n      }\n    } else {\n      // n was used before Mongo 5.0, in Mongo 5.0 we are not receiving this n\n      // field and so we are using modifiedCount instead\n      meteorResult.numberAffected = mongoResult.n || mongoResult.matchedCount || mongoResult.modifiedCount;\n    }\n  }\n\n  return meteorResult;\n};\n\n\nvar NUM_OPTIMISTIC_TRIES = 3;\n\n// exposed for testing\nMongoConnection._isCannotChangeIdError = function (err) {\n\n  // Mongo 3.2.* returns error as next Object:\n  // {name: String, code: Number, errmsg: String}\n  // Older Mongo returns:\n  // {name: String, code: Number, err: String}\n  var error = err.errmsg || err.err;\n\n  // We don't use the error code here\n  // because the error code we observed it producing (16837) appears to be\n  // a far more generic error code based on examining the source.\n  if (error.indexOf('The _id field cannot be changed') === 0\n    || error.indexOf(\"the (immutable) field '_id' was found to have been altered to _id\") !== -1) {\n    return true;\n  }\n\n  return false;\n};\n\nvar simulateUpsertWithInsertedId = async function (collection, selector, mod, options) {\n  // STRATEGY: First try doing an upsert with a generated ID.\n  // If this throws an error about changing the ID on an existing document\n  // then without affecting the database, we know we should probably try\n  // an update without the generated ID. If it affected 0 documents,\n  // then without affecting the database, we the document that first\n  // gave the error is probably removed and we need to try an insert again\n  // We go back to step one and repeat.\n  // Like all \"optimistic write\" schemes, we rely on the fact that it's\n  // unlikely our writes will continue to be interfered with under normal\n  // circumstances (though sufficiently heavy contention with writers\n  // disagreeing on the existence of an object will cause writes to fail\n  // in theory).\n\n  var insertedId = options.insertedId; // must exist\n  var mongoOptsForUpdate = {\n    safe: true,\n    multi: options.multi\n  };\n  var mongoOptsForInsert = {\n    safe: true,\n    upsert: true\n  };\n\n  var replacementWithId = Object.assign(\n    replaceTypes({_id: insertedId}, replaceMeteorAtomWithMongo),\n    mod);\n\n  var tries = NUM_OPTIMISTIC_TRIES;\n\n  var doUpdate = async function () {\n    tries--;\n    if (! tries) {\n      throw new Error(\"Upsert failed after \" + NUM_OPTIMISTIC_TRIES + \" tries.\");\n    } else {\n      let method = collection.updateMany;\n      if(!Object.keys(mod).some(key => key.startsWith(\"$\"))){\n        method = collection.replaceOne.bind(collection);\n      }\n      return method(\n        selector,\n        mod,\n        mongoOptsForUpdate).then(result => {\n        if (result && (result.modifiedCount || result.upsertedCount)) {\n          return {\n            numberAffected: result.modifiedCount || result.upsertedCount,\n            insertedId: result.upsertedId || undefined,\n          };\n        } else {\n          return doConditionalInsert();\n        }\n      });\n    }\n  };\n\n  var doConditionalInsert = function() {\n    return collection.replaceOne(selector, replacementWithId, mongoOptsForInsert)\n        .then(result => ({\n            numberAffected: result.upsertedCount,\n            insertedId: result.upsertedId,\n          })).catch(err => {\n        if (MongoConnection._isCannotChangeIdError(err)) {\n          return doUpdate();\n        } else {\n          throw err;\n        }\n      });\n\n  };\n  return doUpdate();\n};\n\n\n// XXX MongoConnection.upsertAsync() does not return the id of the inserted document\n// unless you set it explicitly in the selector or modifier (as a replacement\n// doc).\nMongoConnection.prototype.upsertAsync = async function (collectionName, selector, mod, options) {\n  var self = this;\n\n\n\n  if (typeof options === \"function\" && ! callback) {\n    callback = options;\n    options = {};\n  }\n\n  return self.updateAsync(collectionName, selector, mod,\n                     Object.assign({}, options, {\n                       upsert: true,\n                       _returnObject: true\n                     }));\n};\n\nMongoConnection.prototype.find = function (collectionName, selector, options) {\n  var self = this;\n\n  if (arguments.length === 1)\n    selector = {};\n\n  return new Cursor(\n    self, new CursorDescription(collectionName, selector, options));\n};\n\nMongoConnection.prototype.findOneAsync = async function (collection_name, selector, options) {\n  var self = this;\n  if (arguments.length === 1) {\n    selector = {};\n  }\n\n  options = options || {};\n  options.limit = 1;\n\n  const results = await self.find(collection_name, selector, options).fetch();\n\n  return results[0];\n};\n\n// We'll actually design an index API later. For now, we just pass through to\n// Mongo's, but make it synchronous.\nMongoConnection.prototype.createIndexAsync = async function (collectionName, index,\n                                                   options) {\n  var self = this;\n\n  // We expect this function to be called at startup, not from within a method,\n  // so we don't interact with the write fence.\n  var collection = self.rawCollection(collectionName);\n  await collection.createIndex(index, options);\n};\n\n// just to be consistent with the other methods\nMongoConnection.prototype.createIndex =\n  MongoConnection.prototype.createIndexAsync;\n\nMongoConnection.prototype.countDocuments = function (collectionName, ...args) {\n  args = args.map(arg => replaceTypes(arg, replaceMeteorAtomWithMongo));\n  const collection = this.rawCollection(collectionName);\n  return collection.countDocuments(...args);\n};\n\nMongoConnection.prototype.estimatedDocumentCount = function (collectionName, ...args) {\n  args = args.map(arg => replaceTypes(arg, replaceMeteorAtomWithMongo));\n  const collection = this.rawCollection(collectionName);\n  return collection.estimatedDocumentCount(...args);\n};\n\nMongoConnection.prototype.ensureIndexAsync = MongoConnection.prototype.createIndexAsync;\n\nMongoConnection.prototype.dropIndexAsync = async function (collectionName, index) {\n  var self = this;\n\n\n  // This function is only used by test code, not within a method, so we don't\n  // interact with the write fence.\n  var collection = self.rawCollection(collectionName);\n  var indexName =  await collection.dropIndex(index);\n};\n\n\nCLIENT_ONLY_METHODS.forEach(function (m) {\n  MongoConnection.prototype[m] = function () {\n    throw new Error(\n      `${m} +  is not available on the server. Please use ${getAsyncMethodName(\n        m\n      )}() instead.`\n    );\n  };\n});\n\n// CURSORS\n\n// There are several classes which relate to cursors:\n//\n// CursorDescription represents the arguments used to construct a cursor:\n// collectionName, selector, and (find) options.  Because it is used as a key\n// for cursor de-dup, everything in it should either be JSON-stringifiable or\n// not affect observeChanges output (eg, options.transform functions are not\n// stringifiable but do not affect observeChanges).\n//\n// SynchronousCursor is a wrapper around a MongoDB cursor\n// which includes fully-synchronous versions of forEach, etc.\n//\n// Cursor is the cursor object returned from find(), which implements the\n// documented Mongo.Collection cursor API.  It wraps a CursorDescription and a\n// SynchronousCursor (lazily: it doesn't contact Mongo until you call a method\n// like fetch or forEach on it).\n//\n// ObserveHandle is the \"observe handle\" returned from observeChanges. It has a\n// reference to an ObserveMultiplexer.\n//\n// ObserveMultiplexer allows multiple identical ObserveHandles to be driven by a\n// single observe driver.\n//\n// There are two \"observe drivers\" which drive ObserveMultiplexers:\n//   - PollingObserveDriver caches the results of a query and reruns it when\n//     necessary.\n//   - OplogObserveDriver follows the Mongo operation log to directly observe\n//     database changes.\n// Both implementations follow the same simple interface: when you create them,\n// they start sending observeChanges callbacks (and a ready() invocation) to\n// their ObserveMultiplexer, and you stop them by calling their stop() method.\n\nCursorDescription = function (collectionName, selector, options) {\n  var self = this;\n  self.collectionName = collectionName;\n  self.selector = Mongo.Collection._rewriteSelector(selector);\n  self.options = options || {};\n};\n\nCursor = function (mongo, cursorDescription) {\n  var self = this;\n\n  self._mongo = mongo;\n  self._cursorDescription = cursorDescription;\n  self._synchronousCursor = null;\n};\n\nfunction setupSynchronousCursor(cursor, method) {\n  // You can only observe a tailable cursor.\n  if (cursor._cursorDescription.options.tailable)\n    throw new Error('Cannot call ' + method + ' on a tailable cursor');\n\n  if (!cursor._synchronousCursor) {\n    cursor._synchronousCursor = cursor._mongo._createSynchronousCursor(\n      cursor._cursorDescription,\n      {\n        // Make sure that the \"cursor\" argument to forEach/map callbacks is the\n        // Cursor, not the SynchronousCursor.\n        selfForIteration: cursor,\n        useTransform: true,\n      }\n    );\n  }\n\n  return cursor._synchronousCursor;\n}\n\n\nCursor.prototype.countAsync = async function () {\n  const collection = this._mongo.rawCollection(this._cursorDescription.collectionName);\n  return await collection.countDocuments(\n    replaceTypes(this._cursorDescription.selector, replaceMeteorAtomWithMongo),\n    replaceTypes(this._cursorDescription.options, replaceMeteorAtomWithMongo),\n  );\n};\n\nCursor.prototype.count = function () {\n  throw new Error(\n    \"count() is not available on the server. Please use countAsync() instead.\"\n  );\n};\n\n[...ASYNC_CURSOR_METHODS, Symbol.iterator, Symbol.asyncIterator].forEach(methodName => {\n  // count is handled specially since we don't want to create a cursor.\n  // it is still included in ASYNC_CURSOR_METHODS because we still want an async version of it to exist.\n  if (methodName === 'count') {\n    return\n  }\n  Cursor.prototype[methodName] = function (...args) {\n    const cursor = setupSynchronousCursor(this, methodName);\n    return cursor[methodName](...args);\n  };\n\n  // These methods are handled separately.\n  if (methodName === Symbol.iterator || methodName === Symbol.asyncIterator) {\n    return;\n  }\n\n  const methodNameAsync = getAsyncMethodName(methodName);\n  Cursor.prototype[methodNameAsync] = function (...args) {\n    try {\n      return Promise.resolve(this[methodName](...args));\n    } catch (error) {\n      return Promise.reject(error);\n    }\n  };\n});\n\nCursor.prototype.getTransform = function () {\n  return this._cursorDescription.options.transform;\n};\n\n// When you call Meteor.publish() with a function that returns a Cursor, we need\n// to transmute it into the equivalent subscription.  This is the function that\n// does that.\nCursor.prototype._publishCursor = function (sub) {\n  var self = this;\n  var collection = self._cursorDescription.collectionName;\n  return Mongo.Collection._publishCursor(self, sub, collection);\n};\n\n// Used to guarantee that publish functions return at most one cursor per\n// collection. Private, because we might later have cursors that include\n// documents from multiple collections somehow.\nCursor.prototype._getCollectionName = function () {\n  var self = this;\n  return self._cursorDescription.collectionName;\n};\n\nCursor.prototype.observe = function (callbacks) {\n  var self = this;\n  return LocalCollection._observeFromObserveChanges(self, callbacks);\n};\n\nCursor.prototype.observeAsync = function (callbacks) {\n  return new Promise(resolve => resolve(this.observe(callbacks)));\n};\n\nCursor.prototype.observeChanges = function (callbacks, options = {}) {\n  var self = this;\n  var methods = [\n    'addedAt',\n    'added',\n    'changedAt',\n    'changed',\n    'removedAt',\n    'removed',\n    'movedTo'\n  ];\n  var ordered = LocalCollection._observeChangesCallbacksAreOrdered(callbacks);\n\n  let exceptionName = callbacks._fromObserve ? 'observe' : 'observeChanges';\n  exceptionName += ' callback';\n  methods.forEach(function (method) {\n    if (callbacks[method] && typeof callbacks[method] == \"function\") {\n      callbacks[method] = Meteor.bindEnvironment(callbacks[method], method + exceptionName);\n    }\n  });\n\n  return self._mongo._observeChanges(\n    self._cursorDescription, ordered, callbacks, options.nonMutatingCallbacks);\n};\n\nCursor.prototype.observeChangesAsync = async function (callbacks, options = {}) {\n  return this.observeChanges(callbacks, options);\n};\n\nMongoConnection.prototype._createSynchronousCursor = function(\n    cursorDescription, options = {}) {\n  var self = this;\n  const { selfForIteration, useTransform } = options; \n  options = { selfForIteration, useTransform };\n\n  var collection = self.rawCollection(cursorDescription.collectionName);\n  var cursorOptions = cursorDescription.options;\n  var mongoOptions = {\n    sort: cursorOptions.sort,\n    limit: cursorOptions.limit,\n    skip: cursorOptions.skip,\n    projection: cursorOptions.fields || cursorOptions.projection,\n    readPreference: cursorOptions.readPreference,\n  };\n\n  // Do we want a tailable cursor (which only works on capped collections)?\n  if (cursorOptions.tailable) {\n    mongoOptions.numberOfRetries = -1;\n  }\n\n  var dbCursor = collection.find(\n    replaceTypes(cursorDescription.selector, replaceMeteorAtomWithMongo),\n    mongoOptions);\n\n  // Do we want a tailable cursor (which only works on capped collections)?\n  if (cursorOptions.tailable) {\n    // We want a tailable cursor...\n    dbCursor.addCursorFlag(\"tailable\", true)\n    // ... and for the server to wait a bit if any getMore has no data (rather\n    // than making us put the relevant sleeps in the client)...\n    dbCursor.addCursorFlag(\"awaitData\", true)\n\n    // And if this is on the oplog collection and the cursor specifies a 'ts',\n    // then set the undocumented oplog replay flag, which does a special scan to\n    // find the first document (instead of creating an index on ts). This is a\n    // very hard-coded Mongo flag which only works on the oplog collection and\n    // only works with the ts field.\n    if (cursorDescription.collectionName === OPLOG_COLLECTION &&\n        cursorDescription.selector.ts) {\n      dbCursor.addCursorFlag(\"oplogReplay\", true)\n    }\n  }\n\n  if (typeof cursorOptions.maxTimeMs !== 'undefined') {\n    dbCursor = dbCursor.maxTimeMS(cursorOptions.maxTimeMs);\n  }\n  if (typeof cursorOptions.hint !== 'undefined') {\n    dbCursor = dbCursor.hint(cursorOptions.hint);\n  }\n\n  return new AsynchronousCursor(dbCursor, cursorDescription, options, collection);\n};\n\n/**\n * This is just a light wrapper for the cursor. The goal here is to ensure compatibility even if\n * there are breaking changes on the MongoDB driver.\n *\n * @constructor\n */\nclass AsynchronousCursor {\n  constructor(dbCursor, cursorDescription, options) {\n    this._dbCursor = dbCursor;\n    this._cursorDescription = cursorDescription;\n\n    this._selfForIteration = options.selfForIteration || this;\n    if (options.useTransform && cursorDescription.options.transform) {\n      this._transform = LocalCollection.wrapTransform(\n          cursorDescription.options.transform);\n    } else {\n      this._transform = null;\n    }\n\n    this._visitedIds = new LocalCollection._IdMap;\n  }\n\n  [Symbol.asyncIterator]() {\n    var cursor = this;\n    return {\n      async next() {\n        const value = await cursor._nextObjectPromise();\n        return { done: !value, value };\n      },\n    };\n  }\n\n  // Returns a Promise for the next object from the underlying cursor (before\n  // the Mongo->Meteor type replacement).\n  async _rawNextObjectPromise() {\n    try {\n      return this._dbCursor.next();\n    } catch (e) {\n      console.error(e);\n    }\n  }\n\n  // Returns a Promise for the next object from the cursor, skipping those whose\n  // IDs we've already seen and replacing Mongo atoms with Meteor atoms.\n  async _nextObjectPromise () {\n    while (true) {\n      var doc = await this._rawNextObjectPromise();\n\n      if (!doc) return null;\n      doc = replaceTypes(doc, replaceMongoAtomWithMeteor);\n\n      if (!this._cursorDescription.options.tailable && _.has(doc, '_id')) {\n        // Did Mongo give us duplicate documents in the same cursor? If so,\n        // ignore this one. (Do this before the transform, since transform might\n        // return some unrelated value.) We don't do this for tailable cursors,\n        // because we want to maintain O(1) memory usage. And if there isn't _id\n        // for some reason (maybe it's the oplog), then we don't do this either.\n        // (Be careful to do this for falsey but existing _id, though.)\n        if (this._visitedIds.has(doc._id)) continue;\n        this._visitedIds.set(doc._id, true);\n      }\n\n      if (this._transform)\n        doc = this._transform(doc);\n\n      return doc;\n    }\n  }\n\n  // Returns a promise which is resolved with the next object (like with\n  // _nextObjectPromise) or rejected if the cursor doesn't return within\n  // timeoutMS ms.\n  _nextObjectPromiseWithTimeout(timeoutMS) {\n    if (!timeoutMS) {\n      return this._nextObjectPromise();\n    }\n    const nextObjectPromise = this._nextObjectPromise();\n    const timeoutErr = new Error('Client-side timeout waiting for next object');\n    const timeoutPromise = new Promise((resolve, reject) => {\n      setTimeout(() => {\n        reject(timeoutErr);\n      }, timeoutMS);\n    });\n    return Promise.race([nextObjectPromise, timeoutPromise])\n        .catch((err) => {\n          if (err === timeoutErr) {\n            this.close();\n          }\n          throw err;\n        });\n  }\n\n  async forEach(callback, thisArg) {\n    // Get back to the beginning.\n    this._rewind();\n\n    let idx = 0;\n    while (true) {\n      const doc = await this._nextObjectPromise();\n      if (!doc) return;\n      await callback.call(thisArg, doc, idx++, this._selfForIteration);\n    }\n  }\n\n  async map(callback, thisArg) {\n    const results = [];\n    await this.forEach(async (doc, index) => {\n      results.push(await callback.call(thisArg, doc, index, this._selfForIteration));\n    });\n\n    return results;\n  }\n\n  _rewind() {\n    // known to be synchronous\n    this._dbCursor.rewind();\n\n    this._visitedIds = new LocalCollection._IdMap;\n  }\n\n  // Mostly usable for tailable cursors.\n  close() {\n    this._dbCursor.close();\n  }\n\n  fetch() {\n    return this.map(_.identity);\n  }\n\n  /**\n   * FIXME: (node:34680) [MONGODB DRIVER] Warning: cursor.count is deprecated and will be\n   *  removed in the next major version, please use `collection.estimatedDocumentCount` or\n   *  `collection.countDocuments` instead.\n   */\n  count() {\n    return this._dbCursor.count();\n  }\n\n  // This method is NOT wrapped in Cursor.\n  async getRawObjects(ordered) {\n    var self = this;\n    if (ordered) {\n      return self.fetch();\n    } else {\n      var results = new LocalCollection._IdMap;\n      await self.forEach(function (doc) {\n        results.set(doc._id, doc);\n      });\n      return results;\n    }\n  }\n}\n\nvar SynchronousCursor = function (dbCursor, cursorDescription, options, collection) {\n  var self = this;\n  const { selfForIteration, useTransform } = options; \n  options = { selfForIteration, useTransform };\n\n  self._dbCursor = dbCursor;\n  self._cursorDescription = cursorDescription;\n  // The \"self\" argument passed to forEach/map callbacks. If we're wrapped\n  // inside a user-visible Cursor, we want to provide the outer cursor!\n  self._selfForIteration = options.selfForIteration || self;\n  if (options.useTransform && cursorDescription.options.transform) {\n    self._transform = LocalCollection.wrapTransform(\n      cursorDescription.options.transform);\n  } else {\n    self._transform = null;\n  }\n\n  self._synchronousCount = Future.wrap(\n    collection.countDocuments.bind(\n      collection,\n      replaceTypes(cursorDescription.selector, replaceMeteorAtomWithMongo),\n      replaceTypes(cursorDescription.options, replaceMeteorAtomWithMongo),\n    )\n  );\n  self._visitedIds = new LocalCollection._IdMap;\n};\n\nObject.assign(SynchronousCursor.prototype, {\n  // Returns a Promise for the next object from the underlying cursor (before\n  // the Mongo->Meteor type replacement).\n  _rawNextObjectPromise: function () {\n    const self = this;\n    return new Promise((resolve, reject) => {\n      self._dbCursor.next((err, doc) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(doc);\n        }\n      });\n    });\n  },\n\n  // Returns a Promise for the next object from the cursor, skipping those whose\n  // IDs we've already seen and replacing Mongo atoms with Meteor atoms.\n  _nextObjectPromise: async function () {\n    var self = this;\n\n    while (true) {\n      var doc = await self._rawNextObjectPromise();\n\n      if (!doc) return null;\n      doc = replaceTypes(doc, replaceMongoAtomWithMeteor);\n\n      if (!self._cursorDescription.options.tailable && has(doc, '_id')) {\n        // Did Mongo give us duplicate documents in the same cursor? If so,\n        // ignore this one. (Do this before the transform, since transform might\n        // return some unrelated value.) We don't do this for tailable cursors,\n        // because we want to maintain O(1) memory usage. And if there isn't _id\n        // for some reason (maybe it's the oplog), then we don't do this either.\n        // (Be careful to do this for falsey but existing _id, though.)\n        if (self._visitedIds.has(doc._id)) continue;\n        self._visitedIds.set(doc._id, true);\n      }\n\n      if (self._transform)\n        doc = self._transform(doc);\n\n      return doc;\n    }\n  },\n\n  // Returns a promise which is resolved with the next object (like with\n  // _nextObjectPromise) or rejected if the cursor doesn't return within\n  // timeoutMS ms.\n  _nextObjectPromiseWithTimeout: function (timeoutMS) {\n    const self = this;\n    if (!timeoutMS) {\n      return self._nextObjectPromise();\n    }\n    const nextObjectPromise = self._nextObjectPromise();\n    const timeoutErr = new Error('Client-side timeout waiting for next object');\n    const timeoutPromise = new Promise((resolve, reject) => {\n      const timer = setTimeout(() => {\n        reject(timeoutErr);\n      }, timeoutMS);\n    });\n    return Promise.race([nextObjectPromise, timeoutPromise])\n      .catch((err) => {\n        if (err === timeoutErr) {\n          self.close();\n        }\n        throw err;\n      });\n  },\n\n  _nextObject: function () {\n    var self = this;\n    return self._nextObjectPromise().await();\n  },\n\n  forEach: function (callback, thisArg) {\n    var self = this;\n    const wrappedFn = Meteor.wrapFn(callback);\n\n    // Get back to the beginning.\n    self._rewind();\n\n    // We implement the loop ourself instead of using self._dbCursor.each,\n    // because \"each\" will call its callback outside of a fiber which makes it\n    // much more complex to make this function synchronous.\n    var index = 0;\n    while (true) {\n      var doc = self._nextObject();\n      if (!doc) return;\n      wrappedFn.call(thisArg, doc, index++, self._selfForIteration);\n    }\n  },\n\n  // XXX Allow overlapping callback executions if callback yields.\n  map: function (callback, thisArg) {\n    var self = this;\n    const wrappedFn = Meteor.wrapFn(callback);\n    var res = [];\n    self.forEach(function (doc, index) {\n      res.push(wrappedFn.call(thisArg, doc, index, self._selfForIteration));\n    });\n    return res;\n  },\n\n  _rewind: function () {\n    var self = this;\n\n    // known to be synchronous\n    self._dbCursor.rewind();\n\n    self._visitedIds = new LocalCollection._IdMap;\n  },\n\n  // Mostly usable for tailable cursors.\n  close: function () {\n    var self = this;\n\n    self._dbCursor.close();\n  },\n\n  fetch: function () {\n    var self = this;\n    return self.map(identity);\n  },\n\n  count: function () {\n    var self = this;\n    return self._synchronousCount().wait();\n  },\n\n  // This method is NOT wrapped in Cursor.\n  getRawObjects: function (ordered) {\n    var self = this;\n    if (ordered) {\n      return self.fetch();\n    } else {\n      var results = new LocalCollection._IdMap;\n      self.forEach(function (doc) {\n        results.set(doc._id, doc);\n      });\n      return results;\n    }\n  }\n});\n\nSynchronousCursor.prototype[Symbol.iterator] = function () {\n  var self = this;\n\n  // Get back to the beginning.\n  self._rewind();\n\n  return {\n    next() {\n      const doc = self._nextObject();\n      return doc ? {\n        value: doc\n      } : {\n        done: true\n      };\n    }\n  };\n};\n\nSynchronousCursor.prototype[Symbol.asyncIterator] = function () {\n  const syncResult = this[Symbol.iterator]();\n  return {\n    async next() {\n      return Promise.resolve(syncResult.next());\n    }\n  };\n}\n\n// Tails the cursor described by cursorDescription, most likely on the\n// oplog. Calls docCallback with each document found. Ignores errors and just\n// restarts the tail on error.\n//\n// If timeoutMS is set, then if we don't get a new document every timeoutMS,\n// kill and restart the cursor. This is primarily a workaround for #8598.\nMongoConnection.prototype.tail = function (cursorDescription, docCallback, timeoutMS) {\n  var self = this;\n  if (!cursorDescription.options.tailable)\n    throw new Error(\"Can only tail a tailable cursor\");\n\n  var cursor = self._createSynchronousCursor(cursorDescription);\n\n  var stopped = false;\n  var lastTS;\n\n  Meteor.defer(async function loop() {\n    var doc = null;\n    while (true) {\n      if (stopped)\n        return;\n      try {\n        doc = await cursor._nextObjectPromiseWithTimeout(timeoutMS);\n      } catch (err) {\n        // There's no good way to figure out if this was actually an error from\n        // Mongo, or just client-side (including our own timeout error). Ah\n        // well. But either way, we need to retry the cursor (unless the failure\n        // was because the observe got stopped).\n        doc = null;\n      }\n      // Since we awaited a promise above, we need to check again to see if\n      // we've been stopped before calling the callback.\n      if (stopped)\n        return;\n      if (doc) {\n        // If a tailable cursor contains a \"ts\" field, use it to recreate the\n        // cursor on error. (\"ts\" is a standard that Mongo uses internally for\n        // the oplog, and there's a special flag that lets you do binary search\n        // on it instead of needing to use an index.)\n        lastTS = doc.ts;\n        docCallback(doc);\n      } else {\n        var newSelector = Object.assign({}, cursorDescription.selector);\n        if (lastTS) {\n          newSelector.ts = {$gt: lastTS};\n        }\n        cursor = self._createSynchronousCursor(new CursorDescription(\n          cursorDescription.collectionName,\n          newSelector,\n          cursorDescription.options));\n        // Mongo failover takes many seconds.  Retry in a bit.  (Without this\n        // setTimeout, we peg the CPU at 100% and never notice the actual\n        // failover.\n        setTimeout(loop, 100);\n        break;\n      }\n    }\n  });\n\n  return {\n    stop: function () {\n      stopped = true;\n      cursor.close();\n    }\n  };\n};\n\nconst oplogCollectionWarnings = [];\n\nObject.assign(MongoConnection.prototype, {\n  _observeChanges: async function (\n      cursorDescription, ordered, callbacks, nonMutatingCallbacks) {\n    var self = this;\n    const collectionName = cursorDescription.collectionName;\n\n    if (cursorDescription.options.tailable) {\n      return self._observeChangesTailable(cursorDescription, ordered, callbacks);\n    }\n\n    // You may not filter out _id when observing changes, because the id is a core\n    // part of the observeChanges API.\n    const fieldsOptions = cursorDescription.options.projection || cursorDescription.options.fields;\n    if (fieldsOptions &&\n        (fieldsOptions._id === 0 ||\n            fieldsOptions._id === false)) {\n      throw Error(\"You may not observe a cursor with {fields: {_id: 0}}\");\n    }\n\n  var observeKey = EJSON.stringify(\n    Object.assign({ordered: ordered}, cursorDescription));\n\n    var multiplexer, observeDriver;\n    var firstHandle = false;\n\n    // Find a matching ObserveMultiplexer, or create a new one. This next block is\n    // guaranteed to not yield (and it doesn't call anything that can observe a\n    // new query), so no other calls to this function can interleave with it.\n    if (has(self._observeMultiplexers, observeKey)) {\n      multiplexer = self._observeMultiplexers[observeKey];\n    } else {\n      firstHandle = true;\n      // Create a new ObserveMultiplexer.\n      multiplexer = new ObserveMultiplexer({\n        ordered: ordered,\n        onStop: function () {\n          delete self._observeMultiplexers[observeKey];\n          return observeDriver.stop();\n        }\n      });\n    }\n\n    var observeHandle = new ObserveHandle(multiplexer,\n        callbacks,\n        nonMutatingCallbacks,\n    );\n\n    const oplogOptions = self?._oplogHandle?._oplogOptions || {};\n  const { includeCollections, excludeCollections } = oplogOptions;\n  if (firstHandle) {\n      var matcher, sorter;\n    var canUseOplog = [\n        function () {\n          // At a bare minimum, using the oplog requires us to have an oplog, to\n          // want unordered callbacks, and to not want a callback on the polls\n          // that won't happen.\n          return self._oplogHandle && !ordered &&\n            !callbacks._testOnlyPollCallback;\n  },\n      function () {\n        // We also need to check, if the collection of this Cursor is actually being \"watched\" by the Oplog handle\n        // if not, we have to fallback to long polling\n        if (excludeCollections?.length && excludeCollections.includes(collectionName)) {\n          if (!oplogCollectionWarnings.includes(collectionName)) {\n            console.warn(`Meteor.settings.packages.mongo.oplogExcludeCollections includes the collection ${collectionName} - your subscriptions will only use long polling!`);\n            oplogCollectionWarnings.push(collectionName); // we only want to show the warnings once per collection!\n          }\n          return false;\n        }\n        if (includeCollections?.length && !includeCollections.includes(collectionName)) {\n          if (!oplogCollectionWarnings.includes(collectionName)) {\n            console.warn(`Meteor.settings.packages.mongo.oplogIncludeCollections does not include the collection ${collectionName} - your subscriptions will only use long polling!`);\n            oplogCollectionWarnings.push(collectionName); // we only want to show the warnings once per collection!\n          }\n          return false;\n        }\n        return true;\n      },\n      function () {\n        // We need to be able to compile the selector. Fall back to polling for\n        // some newfangled $selector that minimongo doesn't support yet.\n        try {\n          matcher = new Minimongo.Matcher(cursorDescription.selector);\n          return true;\n        } catch (e) {\n          // XXX make all compilation errors MinimongoError or something\n          //     so that this doesn't ignore unrelated exceptions\n          return false;\n        }\n      },\n      function () {\n        // ... and the selector itself needs to support oplog.\n        return OplogObserveDriver.cursorSupported(cursorDescription, matcher);\n      },\n      function () {\n        // And we need to be able to compile the sort, if any.  eg, can't be\n        // {$natural: 1}.\n        if (!cursorDescription.options.sort)\n          return true;\n        try {\n          sorter = new Minimongo.Sorter(cursorDescription.options.sort);\n          return true;\n        } catch (e) {\n          // XXX make all compilation errors MinimongoError or something\n          //     so that this doesn't ignore unrelated exceptions\n          return false;\n        }\n      }\n    ].every(f => f());  // invoke each function and check if all return true\n\n    var driverClass = canUseOplog ? OplogObserveDriver : PollingObserveDriver;\n    observeDriver = new driverClass({\n      cursorDescription: cursorDescription,\n      mongoHandle: self,\n      multiplexer: multiplexer,\n      ordered: ordered,\n      matcher: matcher,  // ignored by polling\n      sorter: sorter,  // ignored by polling\n      _testOnlyPollCallback: callbacks._testOnlyPollCallback\n});\n\n    if (observeDriver._init) {\n      await observeDriver._init();\n    }\n\n    // This field is only set for use in tests.\n    multiplexer._observeDriver = observeDriver;\n  }\n  self._observeMultiplexers[observeKey] = multiplexer;\n  // Blocks until the initial adds have been sent.\n  await multiplexer.addHandleAndSendInitialAdds(observeHandle);\n\n  return observeHandle;\n},\n\n});\n\n\n// Listen for the invalidation messages that will trigger us to poll the\n// database for changes. If this selector specifies specific IDs, specify them\n// here, so that updates to different specific IDs don't cause us to poll.\n// listenCallback is the same kind of (notification, complete) callback passed\n// to InvalidationCrossbar.listen.\n\nlistenAll = async function (cursorDescription, listenCallback) {\n  const listeners = [];\n  await forEachTrigger(cursorDescription, function (trigger) {\n    listeners.push(DDPServer._InvalidationCrossbar.listen(\n      trigger, listenCallback));\n  });\n\n  return {\n    stop: function () {\n      listeners.forEach(function (listener) {\n        listener.stop();\n      });\n    }\n  };\n};\n\nforEachTrigger = async function (cursorDescription, triggerCallback) {\n  const key = {collection: cursorDescription.collectionName};\n  const specificIds = LocalCollection._idsMatchedBySelector(\n    cursorDescription.selector);\n  if (specificIds) {\n    for (const id of specificIds) {\n      await triggerCallback(_.extend({id: id}, key));\n    }\n    await triggerCallback(_.extend({dropCollection: true, id: null}, key));\n  } else {\n    await triggerCallback(key);\n  }\n  // Everyone cares about the database being dropped.\n  await triggerCallback({ dropDatabase: true });\n};\n\n// observeChanges for tailable cursors on capped collections.\n//\n// Some differences from normal cursors:\n//   - Will never produce anything other than 'added' or 'addedBefore'. If you\n//     do update a document that has already been produced, this will not notice\n//     it.\n//   - If you disconnect and reconnect from Mongo, it will essentially restart\n//     the query, which will lead to duplicate results. This is pretty bad,\n//     but if you include a field called 'ts' which is inserted as\n//     new MongoInternals.MongoTimestamp(0, 0) (which is initialized to the\n//     current Mongo-style timestamp), we'll be able to find the place to\n//     restart properly. (This field is specifically understood by Mongo with an\n//     optimization which allows it to find the right place to start without\n//     an index on ts. It's how the oplog works.)\n//   - No callbacks are triggered synchronously with the call (there's no\n//     differentiation between \"initial data\" and \"later changes\"; everything\n//     that matches the query gets sent asynchronously).\n//   - De-duplication is not implemented.\n//   - Does not yet interact with the write fence. Probably, this should work by\n//     ignoring removes (which don't work on capped collections) and updates\n//     (which don't affect tailable cursors), and just keeping track of the ID\n//     of the inserted object, and closing the write fence once you get to that\n//     ID (or timestamp?).  This doesn't work well if the document doesn't match\n//     the query, though.  On the other hand, the write fence can close\n//     immediately if it does not match the query. So if we trust minimongo\n//     enough to accurately evaluate the query against the write fence, we\n//     should be able to do this...  Of course, minimongo doesn't even support\n//     Mongo Timestamps yet.\nMongoConnection.prototype._observeChangesTailable = function (\n    cursorDescription, ordered, callbacks) {\n  var self = this;\n\n  // Tailable cursors only ever call added/addedBefore callbacks, so it's an\n  // error if you didn't provide them.\n  if ((ordered && !callbacks.addedBefore) ||\n      (!ordered && !callbacks.added)) {\n    throw new Error(\"Can't observe an \" + (ordered ? \"ordered\" : \"unordered\")\n                    + \" tailable cursor without a \"\n                    + (ordered ? \"addedBefore\" : \"added\") + \" callback\");\n  }\n\n  return self.tail(cursorDescription, function (doc) {\n    var id = doc._id;\n    delete doc._id;\n    // The ts is an implementation detail. Hide it.\n    delete doc.ts;\n    if (ordered) {\n      callbacks.addedBefore(id, doc, null);\n    } else {\n      callbacks.added(id, doc);\n    }\n  });\n};\n\n// XXX We probably need to find a better way to expose this. Right now\n// it's only used by tests, but in fact you need it in normal\n// operation to interact with capped collections.\nMongoInternals.MongoTimestamp = MongoDB.Timestamp;\n\nMongoInternals.Connection = MongoConnection;"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"0e983c87cef0c45ecd3a9fd63e42a2b8d8717bf9"}
