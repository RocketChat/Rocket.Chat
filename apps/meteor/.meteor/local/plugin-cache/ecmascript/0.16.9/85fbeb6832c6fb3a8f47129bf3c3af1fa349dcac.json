{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/ddp-server/crossbar.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.arm64"},"sourceFileName":"packages/ddp-server/crossbar.js","filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/ddp-server/crossbar.js","targets":{"android":"125.0.0","chrome":"125.0.0","edge":"125.0.0","firefox":"115.0.0","ie":"10.0.0","ios":"17.4.0","opera":"110.0.0","opera_mobile":"80.0.0","safari":"17.4.0","samsung":"24.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","root":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true,"topLevelAwait":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/ddp-server/crossbar.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/ddp-server/crossbar.js"}},"code":"// A \"crossbar\" is a class that provides structured notification registration.\n// See _match for the definition of how a notification matches a trigger.\n// All notifications and triggers must have a string key named 'collection'.\n\nDDPServer._Crossbar = function (options) {\n  var self = this;\n  options = options || {};\n  self.nextId = 1;\n  // map from collection name (string) -> listener id -> object. each object has\n  // keys 'trigger', 'callback'.  As a hack, the empty string means \"no\n  // collection\".\n  self.listenersByCollection = {};\n  self.listenersByCollectionCount = {};\n  self.factPackage = options.factPackage || \"livedata\";\n  self.factName = options.factName || null;\n};\n_.extend(DDPServer._Crossbar.prototype, {\n  // msg is a trigger or a notification\n  _collectionForMessage: function (msg) {\n    var self = this;\n    if (!_.has(msg, 'collection')) {\n      return '';\n    } else if (typeof msg.collection === 'string') {\n      if (msg.collection === '') throw Error(\"Message has empty collection!\");\n      return msg.collection;\n    } else {\n      throw Error(\"Message has non-string collection!\");\n    }\n  },\n  // Listen for notification that match 'trigger'. A notification\n  // matches if it has the key-value pairs in trigger as a\n  // subset. When a notification matches, call 'callback', passing\n  // the actual notification.\n  //\n  // Returns a listen handle, which is an object with a method\n  // stop(). Call stop() to stop listening.\n  //\n  // XXX It should be legal to call fire() from inside a listen()\n  // callback?\n  listen: function (trigger, callback) {\n    var self = this;\n    var id = self.nextId++;\n    var collection = self._collectionForMessage(trigger);\n    var record = {\n      trigger: EJSON.clone(trigger),\n      callback: callback\n    };\n    if (!_.has(self.listenersByCollection, collection)) {\n      self.listenersByCollection[collection] = {};\n      self.listenersByCollectionCount[collection] = 0;\n    }\n    self.listenersByCollection[collection][id] = record;\n    self.listenersByCollectionCount[collection]++;\n    if (self.factName && Package['facts-base']) {\n      Package['facts-base'].Facts.incrementServerFact(self.factPackage, self.factName, 1);\n    }\n    return {\n      stop: function () {\n        if (self.factName && Package['facts-base']) {\n          Package['facts-base'].Facts.incrementServerFact(self.factPackage, self.factName, -1);\n        }\n        delete self.listenersByCollection[collection][id];\n        self.listenersByCollectionCount[collection]--;\n        if (self.listenersByCollectionCount[collection] === 0) {\n          delete self.listenersByCollection[collection];\n          delete self.listenersByCollectionCount[collection];\n        }\n      }\n    };\n  },\n  // Fire the provided 'notification' (an object whose attribute\n  // values are all JSON-compatibile) -- inform all matching listeners\n  // (registered with listen()).\n  //\n  // If fire() is called inside a write fence, then each of the\n  // listener callbacks will be called inside the write fence as well.\n  //\n  // The listeners may be invoked in parallel, rather than serially.\n  fire: async function (notification) {\n    var self = this;\n    var collection = self._collectionForMessage(notification);\n    if (!_.has(self.listenersByCollection, collection)) {\n      return;\n    }\n    var listenersForCollection = self.listenersByCollection[collection];\n    var callbackIds = [];\n    _.each(listenersForCollection, function (l, id) {\n      if (self._matches(notification, l.trigger)) {\n        callbackIds.push(id);\n      }\n    });\n\n    // Listener callbacks can yield, so we need to first find all the ones that\n    // match in a single iteration over self.listenersByCollection (which can't\n    // be mutated during this iteration), and then invoke the matching\n    // callbacks, checking before each call to ensure they haven't stopped.\n    // Note that we don't have to check that\n    // self.listenersByCollection[collection] still === listenersForCollection,\n    // because the only way that stops being true is if listenersForCollection\n    // first gets reduced down to the empty object (and then never gets\n    // increased again).\n    for (const id of callbackIds) {\n      if (_.has(listenersForCollection, id)) {\n        await listenersForCollection[id].callback(notification);\n      }\n    }\n  },\n  // A notification matches a trigger if all keys that exist in both are equal.\n  //\n  // Examples:\n  //  N:{collection: \"C\"} matches T:{collection: \"C\"}\n  //    (a non-targeted write to a collection matches a\n  //     non-targeted query)\n  //  N:{collection: \"C\", id: \"X\"} matches T:{collection: \"C\"}\n  //    (a targeted write to a collection matches a non-targeted query)\n  //  N:{collection: \"C\"} matches T:{collection: \"C\", id: \"X\"}\n  //    (a non-targeted write to a collection matches a\n  //     targeted query)\n  //  N:{collection: \"C\", id: \"X\"} matches T:{collection: \"C\", id: \"X\"}\n  //    (a targeted write to a collection matches a targeted query targeted\n  //     at the same document)\n  //  N:{collection: \"C\", id: \"X\"} does not match T:{collection: \"C\", id: \"Y\"}\n  //    (a targeted write to a collection does not match a targeted query\n  //     targeted at a different document)\n  _matches: function (notification, trigger) {\n    // Most notifications that use the crossbar have a string `collection` and\n    // maybe an `id` that is a string or ObjectID. We're already dividing up\n    // triggers by collection, but let's fast-track \"nope, different ID\" (and\n    // avoid the overly generic EJSON.equals). This makes a noticeable\n    // performance difference; see https://github.com/meteor/meteor/pull/3697\n    if (typeof notification.id === 'string' && typeof trigger.id === 'string' && notification.id !== trigger.id) {\n      return false;\n    }\n    if (notification.id instanceof MongoID.ObjectID && trigger.id instanceof MongoID.ObjectID && !notification.id.equals(trigger.id)) {\n      return false;\n    }\n    return _.all(trigger, function (triggerValue, key) {\n      return !_.has(notification, key) || EJSON.equals(triggerValue, notification[key]);\n    });\n  }\n});\n\n// The \"invalidation crossbar\" is a specific instance used by the DDP server to\n// implement write fence notifications. Listener callbacks on this crossbar\n// should call beginWrite on the current write fence before they return, if they\n// want to delay the write fence from firing (ie, the DDP method-data-updated\n// message from being sent).\nDDPServer._InvalidationCrossbar = new DDPServer._Crossbar({\n  factName: \"invalidation-crossbar-listeners\"\n});","map":{"version":3,"names":["DDPServer","_Crossbar","options","self","nextId","listenersByCollection","listenersByCollectionCount","factPackage","factName","_","extend","prototype","_collectionForMessage","msg","has","collection","Error","listen","trigger","callback","id","record","EJSON","clone","Package","Facts","incrementServerFact","stop","fire","notification","listenersForCollection","callbackIds","each","l","_matches","push","MongoID","ObjectID","equals","all","triggerValue","key","_InvalidationCrossbar"],"sources":["packages/ddp-server/crossbar.js"],"sourcesContent":["// A \"crossbar\" is a class that provides structured notification registration.\n// See _match for the definition of how a notification matches a trigger.\n// All notifications and triggers must have a string key named 'collection'.\n\nDDPServer._Crossbar = function (options) {\n  var self = this;\n  options = options || {};\n\n  self.nextId = 1;\n  // map from collection name (string) -> listener id -> object. each object has\n  // keys 'trigger', 'callback'.  As a hack, the empty string means \"no\n  // collection\".\n  self.listenersByCollection = {};\n  self.listenersByCollectionCount = {};\n  self.factPackage = options.factPackage || \"livedata\";\n  self.factName = options.factName || null;\n};\n\n_.extend(DDPServer._Crossbar.prototype, {\n  // msg is a trigger or a notification\n  _collectionForMessage: function (msg) {\n    var self = this;\n    if (! _.has(msg, 'collection')) {\n      return '';\n    } else if (typeof(msg.collection) === 'string') {\n      if (msg.collection === '')\n        throw Error(\"Message has empty collection!\");\n      return msg.collection;\n    } else {\n      throw Error(\"Message has non-string collection!\");\n    }\n  },\n\n  // Listen for notification that match 'trigger'. A notification\n  // matches if it has the key-value pairs in trigger as a\n  // subset. When a notification matches, call 'callback', passing\n  // the actual notification.\n  //\n  // Returns a listen handle, which is an object with a method\n  // stop(). Call stop() to stop listening.\n  //\n  // XXX It should be legal to call fire() from inside a listen()\n  // callback?\n  listen: function (trigger, callback) {\n    var self = this;\n    var id = self.nextId++;\n\n    var collection = self._collectionForMessage(trigger);\n    var record = {trigger: EJSON.clone(trigger), callback: callback};\n    if (! _.has(self.listenersByCollection, collection)) {\n      self.listenersByCollection[collection] = {};\n      self.listenersByCollectionCount[collection] = 0;\n    }\n    self.listenersByCollection[collection][id] = record;\n    self.listenersByCollectionCount[collection]++;\n\n    if (self.factName && Package['facts-base']) {\n      Package['facts-base'].Facts.incrementServerFact(\n        self.factPackage, self.factName, 1);\n    }\n\n    return {\n      stop: function () {\n        if (self.factName && Package['facts-base']) {\n          Package['facts-base'].Facts.incrementServerFact(\n            self.factPackage, self.factName, -1);\n        }\n        delete self.listenersByCollection[collection][id];\n        self.listenersByCollectionCount[collection]--;\n        if (self.listenersByCollectionCount[collection] === 0) {\n          delete self.listenersByCollection[collection];\n          delete self.listenersByCollectionCount[collection];\n        }\n      }\n    };\n  },\n\n  // Fire the provided 'notification' (an object whose attribute\n  // values are all JSON-compatibile) -- inform all matching listeners\n  // (registered with listen()).\n  //\n  // If fire() is called inside a write fence, then each of the\n  // listener callbacks will be called inside the write fence as well.\n  //\n  // The listeners may be invoked in parallel, rather than serially.\n  fire: async function (notification) {\n    var self = this;\n\n    var collection = self._collectionForMessage(notification);\n\n    if (! _.has(self.listenersByCollection, collection)) {\n      return;\n    }\n\n    var listenersForCollection = self.listenersByCollection[collection];\n    var callbackIds = [];\n    _.each(listenersForCollection, function (l, id) {\n      if (self._matches(notification, l.trigger)) {\n        callbackIds.push(id);\n      }\n    });\n\n    // Listener callbacks can yield, so we need to first find all the ones that\n    // match in a single iteration over self.listenersByCollection (which can't\n    // be mutated during this iteration), and then invoke the matching\n    // callbacks, checking before each call to ensure they haven't stopped.\n    // Note that we don't have to check that\n    // self.listenersByCollection[collection] still === listenersForCollection,\n    // because the only way that stops being true is if listenersForCollection\n    // first gets reduced down to the empty object (and then never gets\n    // increased again).\n    for (const id of callbackIds) {\n      if (_.has(listenersForCollection, id)) {\n        await listenersForCollection[id].callback(notification);\n      }\n    }\n  },\n\n  // A notification matches a trigger if all keys that exist in both are equal.\n  //\n  // Examples:\n  //  N:{collection: \"C\"} matches T:{collection: \"C\"}\n  //    (a non-targeted write to a collection matches a\n  //     non-targeted query)\n  //  N:{collection: \"C\", id: \"X\"} matches T:{collection: \"C\"}\n  //    (a targeted write to a collection matches a non-targeted query)\n  //  N:{collection: \"C\"} matches T:{collection: \"C\", id: \"X\"}\n  //    (a non-targeted write to a collection matches a\n  //     targeted query)\n  //  N:{collection: \"C\", id: \"X\"} matches T:{collection: \"C\", id: \"X\"}\n  //    (a targeted write to a collection matches a targeted query targeted\n  //     at the same document)\n  //  N:{collection: \"C\", id: \"X\"} does not match T:{collection: \"C\", id: \"Y\"}\n  //    (a targeted write to a collection does not match a targeted query\n  //     targeted at a different document)\n  _matches: function (notification, trigger) {\n    // Most notifications that use the crossbar have a string `collection` and\n    // maybe an `id` that is a string or ObjectID. We're already dividing up\n    // triggers by collection, but let's fast-track \"nope, different ID\" (and\n    // avoid the overly generic EJSON.equals). This makes a noticeable\n    // performance difference; see https://github.com/meteor/meteor/pull/3697\n    if (typeof(notification.id) === 'string' &&\n        typeof(trigger.id) === 'string' &&\n        notification.id !== trigger.id) {\n      return false;\n    }\n    if (notification.id instanceof MongoID.ObjectID &&\n        trigger.id instanceof MongoID.ObjectID &&\n        ! notification.id.equals(trigger.id)) {\n      return false;\n    }\n\n    return _.all(trigger, function (triggerValue, key) {\n      return !_.has(notification, key) ||\n        EJSON.equals(triggerValue, notification[key]);\n    });\n  }\n});\n\n// The \"invalidation crossbar\" is a specific instance used by the DDP server to\n// implement write fence notifications. Listener callbacks on this crossbar\n// should call beginWrite on the current write fence before they return, if they\n// want to delay the write fence from firing (ie, the DDP method-data-updated\n// message from being sent).\nDDPServer._InvalidationCrossbar = new DDPServer._Crossbar({\n  factName: \"invalidation-crossbar-listeners\"\n});\n"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"85fbeb6832c6fb3a8f47129bf3c3af1fa349dcac"}
