{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/minimongo/cursor.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser.legacy"},"sourceFileName":"packages/minimongo/cursor.js","filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/minimongo/cursor.js","targets":{"android":"125.0.0","chrome":"125.0.0","edge":"125.0.0","firefox":"115.0.0","ie":"10.0.0","ios":"17.4.0","opera":"110.0.0","opera_mobile":"80.0.0","safari":"17.4.0","samsung":"24.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","root":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":true,"enforceStrictMode":false,"dynamicImport":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"base$0$3","visitor":{"FunctionExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$4","visitor":{"ForInStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-arrow-functions","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-block-scoped-functions","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-block-scoping","visitor":{"VariableDeclaration":{"enter":[null,null]},"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-classes","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-computed-properties","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-destructuring","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-object-super","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"DoWhileStatement":{"exit":[null]},"ForInStatement":{"exit":[null]},"ForStatement":{"exit":[null]},"WhileStatement":{"exit":[null]},"ForOfStatement":{"exit":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-shorthand-properties","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-spread","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-sticky-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-typeof-symbol","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"StaticBlock":{"enter":[null]},"TSModuleBlock":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectPattern":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-unicode-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-property-literals","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-regenerator","visitor":{"ObjectMethod":{"enter":[null],"exit":[null]},"ClassMethod":{"enter":[null],"exit":[null]},"ClassPrivateMethod":{"enter":[null],"exit":[null]},"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/minimongo/cursor.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/minimongo/cursor.js"}},"code":"var _createForOfIteratorHelperLoose;\nmodule.link(\"@babel/runtime/helpers/createForOfIteratorHelperLoose\", {\n  default: function (v) {\n    _createForOfIteratorHelperLoose = v;\n  }\n}, 0);\nvar _regeneratorRuntime;\nmodule.link(\"@babel/runtime/regenerator\", {\n  default: function (v) {\n    _regeneratorRuntime = v;\n  }\n}, 1);\nmodule.export({\n  \"default\": function () {\n    return Cursor;\n  }\n});\nvar LocalCollection;\nmodule.link(\"./local_collection.js\", {\n  \"default\": function (v) {\n    LocalCollection = v;\n  }\n}, 0);\nvar hasOwn;\nmodule.link(\"./common.js\", {\n  hasOwn: function (v) {\n    hasOwn = v;\n  }\n}, 1);\nvar ASYNC_CURSOR_METHODS, getAsyncMethodName;\nmodule.link(\"./constants\", {\n  ASYNC_CURSOR_METHODS: function (v) {\n    ASYNC_CURSOR_METHODS = v;\n  },\n  getAsyncMethodName: function (v) {\n    getAsyncMethodName = v;\n  }\n}, 2);\nvar Cursor = /*#__PURE__*/function () {\n  // don't call this ctor directly.  use LocalCollection.find().\n  function Cursor(collection, selector) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.collection = collection;\n    this.sorter = null;\n    this.matcher = new Minimongo.Matcher(selector);\n    if (LocalCollection._selectorIsIdPerhapsAsObject(selector)) {\n      // stash for fast _id and { _id }\n      this._selectorId = hasOwn.call(selector, '_id') ? selector._id : selector;\n    } else {\n      this._selectorId = undefined;\n      if (this.matcher.hasGeoQuery() || options.sort) {\n        this.sorter = new Minimongo.Sorter(options.sort || []);\n      }\n    }\n    this.skip = options.skip || 0;\n    this.limit = options.limit;\n    this.fields = options.projection || options.fields;\n    this._projectionFn = LocalCollection._compileProjection(this.fields || {});\n    this._transform = LocalCollection.wrapTransform(options.transform);\n\n    // by default, queries register w/ Tracker when it is available.\n    if (typeof Tracker !== 'undefined') {\n      this.reactive = options.reactive === undefined ? true : options.reactive;\n    }\n  }\n\n  /**\n   * @deprecated in 2.9\n   * @summary Returns the number of documents that match a query. This method is\n   *          [deprecated since MongoDB 4.0](https://www.mongodb.com/docs/v4.4/reference/command/count/);\n   *          see `Collection.countDocuments` and\n   *          `Collection.estimatedDocumentCount` for a replacement.\n   * @memberOf Mongo.Cursor\n   * @method  count\n   * @instance\n   * @locus Anywhere\n   * @returns {Number}\n   */\n  var _proto = Cursor.prototype;\n  _proto.count = function () {\n    function count() {\n      if (this.reactive) {\n        // allow the observe to be unordered\n        this._depend({\n          added: true,\n          removed: true\n        }, true);\n      }\n      return this._getRawObjects({\n        ordered: true\n      }).length;\n    }\n    return count;\n  }()\n  /**\n   * @summary Return all matching documents as an Array.\n   * @memberOf Mongo.Cursor\n   * @method  fetch\n   * @instance\n   * @locus Anywhere\n   * @returns {Object[]}\n   */\n  ;\n  _proto.fetch = function () {\n    function fetch() {\n      var result = [];\n      this.forEach(function (doc) {\n        result.push(doc);\n      });\n      return result;\n    }\n    return fetch;\n  }();\n  _proto[Symbol.iterator] = function () {\n    var _this = this;\n    if (this.reactive) {\n      this._depend({\n        addedBefore: true,\n        removed: true,\n        changed: true,\n        movedBefore: true\n      });\n    }\n    var index = 0;\n    var objects = this._getRawObjects({\n      ordered: true\n    });\n    return {\n      next: function () {\n        if (index < objects.length) {\n          // This doubles as a clone operation.\n          var element = _this._projectionFn(objects[index++]);\n          if (_this._transform) element = _this._transform(element);\n          return {\n            value: element\n          };\n        }\n        return {\n          done: true\n        };\n      }\n    };\n  };\n  _proto[Symbol.asyncIterator] = function () {\n    var syncResult = this[Symbol.iterator]();\n    return {\n      next: function () {\n        function _callee() {\n          return _regeneratorRuntime.async(function () {\n            function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  return _context.abrupt(\"return\", Promise.resolve(syncResult.next()));\n                case 1:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n            return _callee$;\n          }(), null, null, null, Promise);\n        }\n        return _callee;\n      }()\n    };\n  }\n\n  /**\n   * @callback IterationCallback\n   * @param {Object} doc\n   * @param {Number} index\n   */\n  /**\n   * @summary Call `callback` once for each matching document, sequentially and\n   *          synchronously.\n   * @locus Anywhere\n   * @method  forEach\n   * @instance\n   * @memberOf Mongo.Cursor\n   * @param {IterationCallback} callback Function to call. It will be called\n   *                                     with three arguments: the document, a\n   *                                     0-based index, and <em>cursor</em>\n   *                                     itself.\n   * @param {Any} [thisArg] An object which will be the value of `this` inside\n   *                        `callback`.\n   */;\n  _proto.forEach = function () {\n    function forEach(callback, thisArg) {\n      var _this2 = this;\n      if (this.reactive) {\n        this._depend({\n          addedBefore: true,\n          removed: true,\n          changed: true,\n          movedBefore: true\n        });\n      }\n      this._getRawObjects({\n        ordered: true\n      }).forEach(function (element, i) {\n        // This doubles as a clone operation.\n        element = _this2._projectionFn(element);\n        if (_this2._transform) {\n          element = _this2._transform(element);\n        }\n        callback.call(thisArg, element, i, _this2);\n      });\n    }\n    return forEach;\n  }();\n  _proto.getTransform = function () {\n    function getTransform() {\n      return this._transform;\n    }\n    return getTransform;\n  }()\n  /**\n   * @summary Map callback over all matching documents.  Returns an Array.\n   * @locus Anywhere\n   * @method map\n   * @instance\n   * @memberOf Mongo.Cursor\n   * @param {IterationCallback} callback Function to call. It will be called\n   *                                     with three arguments: the document, a\n   *                                     0-based index, and <em>cursor</em>\n   *                                     itself.\n   * @param {Any} [thisArg] An object which will be the value of `this` inside\n   *                        `callback`.\n   */\n  ;\n  _proto.map = function () {\n    function map(callback, thisArg) {\n      var _this3 = this;\n      var result = [];\n      this.forEach(function (doc, i) {\n        result.push(callback.call(thisArg, doc, i, _this3));\n      });\n      return result;\n    }\n    return map;\n  }() // options to contain:\n  //  * callbacks for observe():\n  //    - addedAt (document, atIndex)\n  //    - added (document)\n  //    - changedAt (newDocument, oldDocument, atIndex)\n  //    - changed (newDocument, oldDocument)\n  //    - removedAt (document, atIndex)\n  //    - removed (document)\n  //    - movedTo (document, oldIndex, newIndex)\n  //\n  // attributes available on returned query handle:\n  //  * stop(): end updates\n  //  * collection: the collection this query is querying\n  //\n  // iff x is a returned query handle, (x instanceof\n  // LocalCollection.ObserveHandle) is true\n  //\n  // initial results delivered through added callback\n  // XXX maybe callbacks should take a list of objects, to expose transactions?\n  // XXX maybe support field limiting (to limit what you're notified on)\n  /**\n   * @summary Watch a query.  Receive callbacks as the result set changes.\n   * @locus Anywhere\n   * @memberOf Mongo.Cursor\n   * @instance\n   * @param {Object} callbacks Functions to call to deliver the result set as it\n   *                           changes\n   */\n  ;\n  _proto.observe = function () {\n    function observe(options) {\n      return LocalCollection._observeFromObserveChanges(this, options);\n    }\n    return observe;\n  }()\n  /**\n   * @summary Watch a query.  Receive callbacks as the result set changes.\n   * @locus Anywhere\n   * @memberOf Mongo.Cursor\n   * @instance\n   */\n  ;\n  _proto.observeAsync = function () {\n    function observeAsync(options) {\n      var _this4 = this;\n      return new Promise(function (resolve) {\n        return resolve(_this4.observe(options));\n      });\n    }\n    return observeAsync;\n  }()\n  /**\n   * @summary Watch a query. Receive callbacks as the result set changes. Only\n   *          the differences between the old and new documents are passed to\n   *          the callbacks.\n   * @locus Anywhere\n   * @memberOf Mongo.Cursor\n   * @instance\n   * @param {Object} callbacks Functions to call to deliver the result set as it\n   *                           changes\n   */\n  ;\n  _proto.observeChanges = function () {\n    function observeChanges(options) {\n      var _this5 = this;\n      var ordered = LocalCollection._observeChangesCallbacksAreOrdered(options);\n\n      // there are several places that assume you aren't combining skip/limit with\n      // unordered observe.  eg, update's EJSON.clone, and the \"there are several\"\n      // comment in _modifyAndNotify\n      // XXX allow skip/limit with unordered observe\n      if (!options._allow_unordered && !ordered && (this.skip || this.limit)) {\n        throw new Error(\"Must use an ordered observe with skip or limit (i.e. 'addedBefore' \" + \"for observeChanges or 'addedAt' for observe, instead of 'added').\");\n      }\n      if (this.fields && (this.fields._id === 0 || this.fields._id === false)) {\n        throw Error(\"You may not observe a cursor with {fields: {_id: 0}}\");\n      }\n      var distances = this.matcher.hasGeoQuery() && ordered && new LocalCollection._IdMap();\n      var query = {\n        cursor: this,\n        dirty: false,\n        distances: distances,\n        matcher: this.matcher,\n        // not fast pathed\n        ordered: ordered,\n        projectionFn: this._projectionFn,\n        resultsSnapshot: null,\n        sorter: ordered && this.sorter\n      };\n      var qid;\n\n      // Non-reactive queries call added[Before] and then never call anything\n      // else.\n      if (this.reactive) {\n        qid = this.collection.next_qid++;\n        this.collection.queries[qid] = query;\n      }\n      query.results = this._getRawObjects({\n        ordered: ordered,\n        distances: query.distances\n      });\n      if (this.collection.paused) {\n        query.resultsSnapshot = ordered ? [] : new LocalCollection._IdMap();\n      }\n\n      // wrap callbacks we were passed. callbacks only fire when not paused and\n      // are never undefined\n      // Filters out blacklisted fields according to cursor's projection.\n      // XXX wrong place for this?\n\n      // furthermore, callbacks enqueue until the operation we're working on is\n      // done.\n      var wrapCallback = function (fn) {\n        if (!fn) {\n          return function () {};\n        }\n        var self = _this5;\n        return function /* args*/\n        () {\n          var _this6 = this;\n          if (self.collection.paused) {\n            return;\n          }\n          var args = arguments;\n          self.collection._observeQueue.queueTask(function () {\n            fn.apply(_this6, args);\n          });\n        };\n      };\n      query.added = wrapCallback(options.added);\n      query.changed = wrapCallback(options.changed);\n      query.removed = wrapCallback(options.removed);\n      if (ordered) {\n        query.addedBefore = wrapCallback(options.addedBefore);\n        query.movedBefore = wrapCallback(options.movedBefore);\n      }\n      if (!options._suppress_initial && !this.collection.paused) {\n        var _query$results, _query$results$size;\n        var handler = function (doc) {\n          var fields = EJSON.clone(doc);\n          delete fields._id;\n          if (ordered) {\n            query.addedBefore(doc._id, _this5._projectionFn(fields), null);\n          }\n          query.added(doc._id, _this5._projectionFn(fields));\n        };\n        // it means it's just an array\n        if (query.results.length) {\n          for (var _iterator = _createForOfIteratorHelperLoose(query.results), _step; !(_step = _iterator()).done;) {\n            var doc = _step.value;\n            handler(doc);\n          }\n        }\n        // it means it's an id map\n        if ((_query$results = query.results) !== null && _query$results !== void 0 && (_query$results$size = _query$results.size) !== null && _query$results$size !== void 0 && _query$results$size.call(_query$results)) {\n          query.results.forEach(handler);\n        }\n      }\n      var handle = Object.assign(new LocalCollection.ObserveHandle(), {\n        collection: this.collection,\n        stop: function () {\n          if (_this5.reactive) {\n            delete _this5.collection.queries[qid];\n          }\n        },\n        isReady: false,\n        isReadyPromise: null\n      });\n      if (this.reactive && Tracker.active) {\n        // XXX in many cases, the same observe will be recreated when\n        // the current autorun is rerun.  we could save work by\n        // letting it linger across rerun and potentially get\n        // repurposed if the same observe is performed, using logic\n        // similar to that of Meteor.subscribe.\n        Tracker.onInvalidate(function () {\n          handle.stop();\n        });\n      }\n\n      // run the observe callbacks resulting from the initial contents\n      // before we leave the observe.\n      var drainResult = this.collection._observeQueue.drain();\n      if (drainResult instanceof Promise) {\n        handle.isReadyPromise = drainResult;\n        drainResult.then(function () {\n          return handle.isReady = true;\n        });\n      } else {\n        handle.isReady = true;\n        handle.isReadyPromise = Promise.resolve();\n      }\n      return handle;\n    }\n    return observeChanges;\n  }()\n  /**\n   * @summary Watch a query. Receive callbacks as the result set changes. Only\n   *          the differences between the old and new documents are passed to\n   *          the callbacks.\n   * @locus Anywhere\n   * @memberOf Mongo.Cursor\n   * @instance\n   * @param {Object} callbacks Functions to call to deliver the result set as it\n   *                           changes\n   */\n  ;\n  _proto.observeChangesAsync = function () {\n    function observeChangesAsync(options) {\n      var _this7 = this;\n      return new Promise(function (resolve) {\n        var handle = _this7.observeChanges(options);\n        handle.isReadyPromise.then(function () {\n          return resolve(handle);\n        });\n      });\n    }\n    return observeChangesAsync;\n  }() // XXX Maybe we need a version of observe that just calls a callback if\n  // anything changed.\n  ;\n  _proto._depend = function () {\n    function _depend(changers, _allow_unordered) {\n      if (Tracker.active) {\n        var dependency = new Tracker.Dependency();\n        var notify = dependency.changed.bind(dependency);\n        dependency.depend();\n        var options = {\n          _allow_unordered: _allow_unordered,\n          _suppress_initial: true\n        };\n        ['added', 'addedBefore', 'changed', 'movedBefore', 'removed'].forEach(function (fn) {\n          if (changers[fn]) {\n            options[fn] = notify;\n          }\n        });\n\n        // observeChanges will stop() when this computation is invalidated\n        this.observeChanges(options);\n      }\n    }\n    return _depend;\n  }();\n  _proto._getCollectionName = function () {\n    function _getCollectionName() {\n      return this.collection.name;\n    }\n    return _getCollectionName;\n  }() // Returns a collection of matching objects, but doesn't deep copy them.\n  //\n  // If ordered is set, returns a sorted array, respecting sorter, skip, and\n  // limit properties of the query provided that options.applySkipLimit is\n  // not set to false (#1201). If sorter is falsey, no sort -- you get the\n  // natural order.\n  //\n  // If ordered is not set, returns an object mapping from ID to doc (sorter,\n  // skip and limit should not be set).\n  //\n  // If ordered is set and this cursor is a $near geoquery, then this function\n  // will use an _IdMap to track each distance from the $near argument point in\n  // order to use it as a sort key. If an _IdMap is passed in the 'distances'\n  // argument, this function will clear it and use it for this purpose\n  // (otherwise it will just create its own _IdMap). The observeChanges\n  // implementation uses this to remember the distances after this function\n  // returns.\n  ;\n  _proto._getRawObjects = function () {\n    function _getRawObjects() {\n      var _this8 = this;\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      // By default this method will respect skip and limit because .fetch(),\n      // .forEach() etc... expect this behaviour. It can be forced to ignore\n      // skip and limit by setting applySkipLimit to false (.count() does this,\n      // for example)\n      var applySkipLimit = options.applySkipLimit !== false;\n\n      // XXX use OrderedDict instead of array, and make IdMap and OrderedDict\n      // compatible\n      var results = options.ordered ? [] : new LocalCollection._IdMap();\n\n      // fast path for single ID value\n      if (this._selectorId !== undefined) {\n        // If you have non-zero skip and ask for a single id, you get nothing.\n        // This is so it matches the behavior of the '{_id: foo}' path.\n        if (applySkipLimit && this.skip) {\n          return results;\n        }\n        var selectedDoc = this.collection._docs.get(this._selectorId);\n        if (selectedDoc) {\n          if (options.ordered) {\n            results.push(selectedDoc);\n          } else {\n            results.set(this._selectorId, selectedDoc);\n          }\n        }\n        return results;\n      }\n\n      // slow path for arbitrary selector, sort, skip, limit\n\n      // in the observeChanges case, distances is actually part of the \"query\"\n      // (ie, live results set) object.  in other cases, distances is only used\n      // inside this function.\n      var distances;\n      if (this.matcher.hasGeoQuery() && options.ordered) {\n        if (options.distances) {\n          distances = options.distances;\n          distances.clear();\n        } else {\n          distances = new LocalCollection._IdMap();\n        }\n      }\n      this.collection._docs.forEach(function (doc, id) {\n        var matchResult = _this8.matcher.documentMatches(doc);\n        if (matchResult.result) {\n          if (options.ordered) {\n            results.push(doc);\n            if (distances && matchResult.distance !== undefined) {\n              distances.set(id, matchResult.distance);\n            }\n          } else {\n            results.set(id, doc);\n          }\n        }\n\n        // Override to ensure all docs are matched if ignoring skip & limit\n        if (!applySkipLimit) {\n          return true;\n        }\n\n        // Fast path for limited unsorted queries.\n        // XXX 'length' check here seems wrong for ordered\n        return !_this8.limit || _this8.skip || _this8.sorter || results.length !== _this8.limit;\n      });\n      if (!options.ordered) {\n        return results;\n      }\n      if (this.sorter) {\n        results.sort(this.sorter.getComparator({\n          distances: distances\n        }));\n      }\n\n      // Return the full set of results if there is no skip or limit or if we're\n      // ignoring them\n      if (!applySkipLimit || !this.limit && !this.skip) {\n        return results;\n      }\n      return results.slice(this.skip, this.limit ? this.limit + this.skip : results.length);\n    }\n    return _getRawObjects;\n  }();\n  _proto._publishCursor = function () {\n    function _publishCursor(subscription) {\n      // XXX minimongo should not depend on mongo-livedata!\n      if (!Package.mongo) {\n        throw new Error(\"Can't publish from Minimongo without the `mongo` package.\");\n      }\n      if (!this.collection.name) {\n        throw new Error(\"Can't publish a cursor from a collection without a name.\");\n      }\n      return Package.mongo.Mongo.Collection._publishCursor(this, subscription, this.collection.name);\n    }\n    return _publishCursor;\n  }();\n  return Cursor;\n}();\n// Implements async version of cursor methods to keep collections isomorphic\nASYNC_CURSOR_METHODS.forEach(function (method) {\n  var asyncName = getAsyncMethodName(method);\n  Cursor.prototype[asyncName] = function () {\n    try {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return Promise.resolve(this[method].apply(this, args));\n    } catch (error) {\n      return Promise.reject(error);\n    }\n  };\n});","map":{"version":3,"names":["_createForOfIteratorHelperLoose","module","link","default","v","_regeneratorRuntime","export","Cursor","LocalCollection","hasOwn","ASYNC_CURSOR_METHODS","getAsyncMethodName","collection","selector","options","arguments","length","undefined","sorter","matcher","Minimongo","Matcher","_selectorIsIdPerhapsAsObject","_selectorId","call","_id","hasGeoQuery","sort","Sorter","skip","limit","fields","projection","_projectionFn","_compileProjection","_transform","wrapTransform","transform","Tracker","reactive","_proto","prototype","count","_depend","added","removed","_getRawObjects","ordered","fetch","result","forEach","doc","push","Symbol","iterator","_this","addedBefore","changed","movedBefore","index","objects","next","element","value","done","asyncIterator","syncResult","_callee","async","_callee$","_context","prev","abrupt","Promise","resolve","stop","callback","thisArg","_this2","i","getTransform","map","_this3","observe","_observeFromObserveChanges","observeAsync","_this4","observeChanges","_this5","_observeChangesCallbacksAreOrdered","_allow_unordered","Error","distances","_IdMap","query","cursor","dirty","projectionFn","resultsSnapshot","qid","next_qid","queries","results","paused","wrapCallback","fn","self","_this6","args","_observeQueue","queueTask","apply","_suppress_initial","_query$results","_query$results$size","handler","EJSON","clone","_iterator","_step","size","handle","Object","assign","ObserveHandle","isReady","isReadyPromise","active","onInvalidate","drainResult","drain","then","observeChangesAsync","_this7","changers","dependency","Dependency","notify","bind","depend","_getCollectionName","name","_this8","applySkipLimit","selectedDoc","_docs","get","set","clear","id","matchResult","documentMatches","distance","getComparator","slice","_publishCursor","subscription","Package","mongo","Mongo","Collection","method","asyncName","_len","Array","_key","error","reject"],"sources":["packages/minimongo/cursor.js"],"sourcesContent":["import LocalCollection from './local_collection.js';\nimport { hasOwn } from './common.js';\nimport { ASYNC_CURSOR_METHODS, getAsyncMethodName } from './constants';\n\n// Cursor: a specification for a particular subset of documents, w/ a defined\n// order, limit, and offset.  creating a Cursor with LocalCollection.find(),\nexport default class Cursor {\n  // don't call this ctor directly.  use LocalCollection.find().\n  constructor(collection, selector, options = {}) {\n    this.collection = collection;\n    this.sorter = null;\n    this.matcher = new Minimongo.Matcher(selector);\n\n    if (LocalCollection._selectorIsIdPerhapsAsObject(selector)) {\n      // stash for fast _id and { _id }\n      this._selectorId = hasOwn.call(selector, '_id') ? selector._id : selector;\n    } else {\n      this._selectorId = undefined;\n\n      if (this.matcher.hasGeoQuery() || options.sort) {\n        this.sorter = new Minimongo.Sorter(options.sort || []);\n      }\n    }\n\n    this.skip = options.skip || 0;\n    this.limit = options.limit;\n    this.fields = options.projection || options.fields;\n\n    this._projectionFn = LocalCollection._compileProjection(this.fields || {});\n\n    this._transform = LocalCollection.wrapTransform(options.transform);\n\n    // by default, queries register w/ Tracker when it is available.\n    if (typeof Tracker !== 'undefined') {\n      this.reactive = options.reactive === undefined ? true : options.reactive;\n    }\n  }\n\n  /**\n   * @deprecated in 2.9\n   * @summary Returns the number of documents that match a query. This method is\n   *          [deprecated since MongoDB 4.0](https://www.mongodb.com/docs/v4.4/reference/command/count/);\n   *          see `Collection.countDocuments` and\n   *          `Collection.estimatedDocumentCount` for a replacement.\n   * @memberOf Mongo.Cursor\n   * @method  count\n   * @instance\n   * @locus Anywhere\n   * @returns {Number}\n   */\n  count() {\n    if (this.reactive) {\n      // allow the observe to be unordered\n      this._depend({ added: true, removed: true }, true);\n    }\n\n    return this._getRawObjects({\n      ordered: true,\n    }).length;\n  }\n\n  /**\n   * @summary Return all matching documents as an Array.\n   * @memberOf Mongo.Cursor\n   * @method  fetch\n   * @instance\n   * @locus Anywhere\n   * @returns {Object[]}\n   */\n  fetch() {\n    const result = [];\n\n    this.forEach(doc => {\n      result.push(doc);\n    });\n\n    return result;\n  }\n\n  [Symbol.iterator]() {\n    if (this.reactive) {\n      this._depend({\n        addedBefore: true,\n        removed: true,\n        changed: true,\n        movedBefore: true,\n      });\n    }\n\n    let index = 0;\n    const objects = this._getRawObjects({ ordered: true });\n\n    return {\n      next: () => {\n        if (index < objects.length) {\n          // This doubles as a clone operation.\n          let element = this._projectionFn(objects[index++]);\n\n          if (this._transform) element = this._transform(element);\n\n          return { value: element };\n        }\n\n        return { done: true };\n      },\n    };\n  }\n\n  [Symbol.asyncIterator]() {\n    const syncResult = this[Symbol.iterator]();\n    return {\n      async next() {\n        return Promise.resolve(syncResult.next());\n      },\n    };\n  }\n\n  /**\n   * @callback IterationCallback\n   * @param {Object} doc\n   * @param {Number} index\n   */\n  /**\n   * @summary Call `callback` once for each matching document, sequentially and\n   *          synchronously.\n   * @locus Anywhere\n   * @method  forEach\n   * @instance\n   * @memberOf Mongo.Cursor\n   * @param {IterationCallback} callback Function to call. It will be called\n   *                                     with three arguments: the document, a\n   *                                     0-based index, and <em>cursor</em>\n   *                                     itself.\n   * @param {Any} [thisArg] An object which will be the value of `this` inside\n   *                        `callback`.\n   */\n  forEach(callback, thisArg) {\n    if (this.reactive) {\n      this._depend({\n        addedBefore: true,\n        removed: true,\n        changed: true,\n        movedBefore: true,\n      });\n    }\n\n    this._getRawObjects({ ordered: true }).forEach((element, i) => {\n      // This doubles as a clone operation.\n      element = this._projectionFn(element);\n\n      if (this._transform) {\n        element = this._transform(element);\n      }\n\n      callback.call(thisArg, element, i, this);\n    });\n  }\n\n  getTransform() {\n    return this._transform;\n  }\n\n  /**\n   * @summary Map callback over all matching documents.  Returns an Array.\n   * @locus Anywhere\n   * @method map\n   * @instance\n   * @memberOf Mongo.Cursor\n   * @param {IterationCallback} callback Function to call. It will be called\n   *                                     with three arguments: the document, a\n   *                                     0-based index, and <em>cursor</em>\n   *                                     itself.\n   * @param {Any} [thisArg] An object which will be the value of `this` inside\n   *                        `callback`.\n   */\n  map(callback, thisArg) {\n    const result = [];\n\n    this.forEach((doc, i) => {\n      result.push(callback.call(thisArg, doc, i, this));\n    });\n\n    return result;\n  }\n\n  // options to contain:\n  //  * callbacks for observe():\n  //    - addedAt (document, atIndex)\n  //    - added (document)\n  //    - changedAt (newDocument, oldDocument, atIndex)\n  //    - changed (newDocument, oldDocument)\n  //    - removedAt (document, atIndex)\n  //    - removed (document)\n  //    - movedTo (document, oldIndex, newIndex)\n  //\n  // attributes available on returned query handle:\n  //  * stop(): end updates\n  //  * collection: the collection this query is querying\n  //\n  // iff x is a returned query handle, (x instanceof\n  // LocalCollection.ObserveHandle) is true\n  //\n  // initial results delivered through added callback\n  // XXX maybe callbacks should take a list of objects, to expose transactions?\n  // XXX maybe support field limiting (to limit what you're notified on)\n\n  /**\n   * @summary Watch a query.  Receive callbacks as the result set changes.\n   * @locus Anywhere\n   * @memberOf Mongo.Cursor\n   * @instance\n   * @param {Object} callbacks Functions to call to deliver the result set as it\n   *                           changes\n   */\n  observe(options) {\n    return LocalCollection._observeFromObserveChanges(this, options);\n  }\n\n  /**\n   * @summary Watch a query.  Receive callbacks as the result set changes.\n   * @locus Anywhere\n   * @memberOf Mongo.Cursor\n   * @instance\n   */\n  observeAsync(options) {\n    return new Promise(resolve => resolve(this.observe(options)));\n  }\n\n  /**\n   * @summary Watch a query. Receive callbacks as the result set changes. Only\n   *          the differences between the old and new documents are passed to\n   *          the callbacks.\n   * @locus Anywhere\n   * @memberOf Mongo.Cursor\n   * @instance\n   * @param {Object} callbacks Functions to call to deliver the result set as it\n   *                           changes\n   */\n  observeChanges(options) {\n    const ordered = LocalCollection._observeChangesCallbacksAreOrdered(options);\n\n    // there are several places that assume you aren't combining skip/limit with\n    // unordered observe.  eg, update's EJSON.clone, and the \"there are several\"\n    // comment in _modifyAndNotify\n    // XXX allow skip/limit with unordered observe\n    if (!options._allow_unordered && !ordered && (this.skip || this.limit)) {\n      throw new Error(\n        \"Must use an ordered observe with skip or limit (i.e. 'addedBefore' \" +\n          \"for observeChanges or 'addedAt' for observe, instead of 'added').\"\n      );\n    }\n\n    if (this.fields && (this.fields._id === 0 || this.fields._id === false)) {\n      throw Error(\"You may not observe a cursor with {fields: {_id: 0}}\");\n    }\n\n    const distances =\n      this.matcher.hasGeoQuery() && ordered && new LocalCollection._IdMap();\n\n    const query = {\n      cursor: this,\n      dirty: false,\n      distances,\n      matcher: this.matcher, // not fast pathed\n      ordered,\n      projectionFn: this._projectionFn,\n      resultsSnapshot: null,\n      sorter: ordered && this.sorter,\n    };\n\n    let qid;\n\n    // Non-reactive queries call added[Before] and then never call anything\n    // else.\n    if (this.reactive) {\n      qid = this.collection.next_qid++;\n      this.collection.queries[qid] = query;\n    }\n\n    query.results = this._getRawObjects({\n      ordered,\n      distances: query.distances,\n    });\n\n    if (this.collection.paused) {\n      query.resultsSnapshot = ordered ? [] : new LocalCollection._IdMap();\n    }\n\n    // wrap callbacks we were passed. callbacks only fire when not paused and\n    // are never undefined\n    // Filters out blacklisted fields according to cursor's projection.\n    // XXX wrong place for this?\n\n    // furthermore, callbacks enqueue until the operation we're working on is\n    // done.\n    const wrapCallback = (fn) => {\n      if (!fn) {\n        return () => {};\n      }\n\n      const self = this;\n\n      return function (/* args*/) {\n        if (self.collection.paused) {\n          return;\n        }\n\n        const args = arguments;\n\n        self.collection._observeQueue.queueTask(() => {\n          fn.apply(this, args);\n        });\n      };\n    };\n\n    query.added = wrapCallback(options.added);\n    query.changed = wrapCallback(options.changed);\n    query.removed = wrapCallback(options.removed);\n\n    if (ordered) {\n      query.addedBefore = wrapCallback(options.addedBefore);\n      query.movedBefore = wrapCallback(options.movedBefore);\n    }\n\n    if (!options._suppress_initial && !this.collection.paused) {\n      const handler = (doc) => {\n        const fields = EJSON.clone(doc);\n\n        delete fields._id;\n\n        if (ordered) {\n          query.addedBefore(doc._id, this._projectionFn(fields), null);\n        }\n\n        query.added(doc._id, this._projectionFn(fields));\n      };\n      // it means it's just an array\n      if (query.results.length) {\n        for (const doc of query.results) {\n          handler(doc);\n        }\n      }\n      // it means it's an id map\n      if (query.results?.size?.()) {\n        query.results.forEach(handler);\n      }\n    }\n\n    const handle = Object.assign(new LocalCollection.ObserveHandle(), {\n      collection: this.collection,\n      stop: () => {\n        if (this.reactive) {\n          delete this.collection.queries[qid];\n        }\n      },\n      isReady: false,\n      isReadyPromise: null,\n    });\n\n    if (this.reactive && Tracker.active) {\n      // XXX in many cases, the same observe will be recreated when\n      // the current autorun is rerun.  we could save work by\n      // letting it linger across rerun and potentially get\n      // repurposed if the same observe is performed, using logic\n      // similar to that of Meteor.subscribe.\n      Tracker.onInvalidate(() => {\n        handle.stop();\n      });\n    }\n\n    // run the observe callbacks resulting from the initial contents\n    // before we leave the observe.\n    const drainResult = this.collection._observeQueue.drain();\n\n    if (drainResult instanceof Promise) {\n      handle.isReadyPromise = drainResult;\n      drainResult.then(() => (handle.isReady = true));\n    } else {\n      handle.isReady = true;\n      handle.isReadyPromise = Promise.resolve();\n    }\n\n    return handle;\n  }\n\n  /**\n   * @summary Watch a query. Receive callbacks as the result set changes. Only\n   *          the differences between the old and new documents are passed to\n   *          the callbacks.\n   * @locus Anywhere\n   * @memberOf Mongo.Cursor\n   * @instance\n   * @param {Object} callbacks Functions to call to deliver the result set as it\n   *                           changes\n   */\n  observeChangesAsync(options) {\n    return new Promise((resolve) => {\n      const handle = this.observeChanges(options);\n      handle.isReadyPromise.then(() => resolve(handle));\n    });\n  }\n\n  // XXX Maybe we need a version of observe that just calls a callback if\n  // anything changed.\n  _depend(changers, _allow_unordered) {\n    if (Tracker.active) {\n      const dependency = new Tracker.Dependency();\n      const notify = dependency.changed.bind(dependency);\n\n      dependency.depend();\n\n      const options = { _allow_unordered, _suppress_initial: true };\n\n      ['added', 'addedBefore', 'changed', 'movedBefore', 'removed'].forEach(\n        fn => {\n          if (changers[fn]) {\n            options[fn] = notify;\n          }\n        }\n      );\n\n      // observeChanges will stop() when this computation is invalidated\n      this.observeChanges(options);\n    }\n  }\n\n  _getCollectionName() {\n    return this.collection.name;\n  }\n\n  // Returns a collection of matching objects, but doesn't deep copy them.\n  //\n  // If ordered is set, returns a sorted array, respecting sorter, skip, and\n  // limit properties of the query provided that options.applySkipLimit is\n  // not set to false (#1201). If sorter is falsey, no sort -- you get the\n  // natural order.\n  //\n  // If ordered is not set, returns an object mapping from ID to doc (sorter,\n  // skip and limit should not be set).\n  //\n  // If ordered is set and this cursor is a $near geoquery, then this function\n  // will use an _IdMap to track each distance from the $near argument point in\n  // order to use it as a sort key. If an _IdMap is passed in the 'distances'\n  // argument, this function will clear it and use it for this purpose\n  // (otherwise it will just create its own _IdMap). The observeChanges\n  // implementation uses this to remember the distances after this function\n  // returns.\n  _getRawObjects(options = {}) {\n    // By default this method will respect skip and limit because .fetch(),\n    // .forEach() etc... expect this behaviour. It can be forced to ignore\n    // skip and limit by setting applySkipLimit to false (.count() does this,\n    // for example)\n    const applySkipLimit = options.applySkipLimit !== false;\n\n    // XXX use OrderedDict instead of array, and make IdMap and OrderedDict\n    // compatible\n    const results = options.ordered ? [] : new LocalCollection._IdMap();\n\n    // fast path for single ID value\n    if (this._selectorId !== undefined) {\n      // If you have non-zero skip and ask for a single id, you get nothing.\n      // This is so it matches the behavior of the '{_id: foo}' path.\n      if (applySkipLimit && this.skip) {\n        return results;\n      }\n\n      const selectedDoc = this.collection._docs.get(this._selectorId);\n      if (selectedDoc) {\n        if (options.ordered) {\n          results.push(selectedDoc);\n        } else {\n          results.set(this._selectorId, selectedDoc);\n        }\n      }\n      return results;\n    }\n\n    // slow path for arbitrary selector, sort, skip, limit\n\n    // in the observeChanges case, distances is actually part of the \"query\"\n    // (ie, live results set) object.  in other cases, distances is only used\n    // inside this function.\n    let distances;\n    if (this.matcher.hasGeoQuery() && options.ordered) {\n      if (options.distances) {\n        distances = options.distances;\n        distances.clear();\n      } else {\n        distances = new LocalCollection._IdMap();\n      }\n    }\n    this.collection._docs.forEach((doc, id) => {\n      const matchResult = this.matcher.documentMatches(doc);\n      if (matchResult.result) {\n        if (options.ordered) {\n          results.push(doc);\n\n          if (distances && matchResult.distance !== undefined) {\n            distances.set(id, matchResult.distance);\n          }\n        } else {\n          results.set(id, doc);\n        }\n      }\n\n      // Override to ensure all docs are matched if ignoring skip & limit\n      if (!applySkipLimit) {\n        return true;\n      }\n\n      // Fast path for limited unsorted queries.\n      // XXX 'length' check here seems wrong for ordered\n      return (\n        !this.limit || this.skip || this.sorter || results.length !== this.limit\n      );\n    });\n\n    if (!options.ordered) {\n      return results;\n    }\n\n    if (this.sorter) {\n      results.sort(this.sorter.getComparator({ distances }));\n    }\n\n    // Return the full set of results if there is no skip or limit or if we're\n    // ignoring them\n    if (!applySkipLimit || (!this.limit && !this.skip)) {\n      return results;\n    }\n\n    return results.slice(\n      this.skip,\n      this.limit ? this.limit + this.skip : results.length\n    );\n  }\n\n  _publishCursor(subscription) {\n    // XXX minimongo should not depend on mongo-livedata!\n    if (!Package.mongo) {\n      throw new Error(\n        \"Can't publish from Minimongo without the `mongo` package.\"\n      );\n    }\n\n    if (!this.collection.name) {\n      throw new Error(\n        \"Can't publish a cursor from a collection without a name.\"\n      );\n    }\n\n    return Package.mongo.Mongo.Collection._publishCursor(\n      this,\n      subscription,\n      this.collection.name\n    );\n  }\n}\n\n// Implements async version of cursor methods to keep collections isomorphic\nASYNC_CURSOR_METHODS.forEach(method => {\n  const asyncName = getAsyncMethodName(method);\n  Cursor.prototype[asyncName] = function(...args) {\n    try {\n      return Promise.resolve(this[method].apply(this, args));\n    } catch (error) {\n      return Promise.reject(error);\n    }\n  };\n});\n"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"6694e78897ea80767d39f37a629744db2b58c546"}
