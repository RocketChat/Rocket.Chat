{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/minimongo/cursor.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.arm64"},"sourceFileName":"packages/minimongo/cursor.js","filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/minimongo/cursor.js","targets":{"android":"125.0.0","chrome":"125.0.0","edge":"125.0.0","firefox":"115.0.0","ie":"10.0.0","ios":"17.4.0","opera":"110.0.0","opera_mobile":"80.0.0","safari":"17.4.0","samsung":"24.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","root":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true,"topLevelAwait":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/minimongo/cursor.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/minimongo/cursor.js"}},"code":"!module.wrapAsync(async function (module, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    module.export({\n      default: () => Cursor\n    });\n    let LocalCollection;\n    module.link(\"./local_collection.js\", {\n      default(v) {\n        LocalCollection = v;\n      }\n    }, 0);\n    let hasOwn;\n    module.link(\"./common.js\", {\n      hasOwn(v) {\n        hasOwn = v;\n      }\n    }, 1);\n    let ASYNC_CURSOR_METHODS, getAsyncMethodName;\n    module.link(\"./constants\", {\n      ASYNC_CURSOR_METHODS(v) {\n        ASYNC_CURSOR_METHODS = v;\n      },\n      getAsyncMethodName(v) {\n        getAsyncMethodName = v;\n      }\n    }, 2);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    class Cursor {\n      // don't call this ctor directly.  use LocalCollection.find().\n      constructor(collection, selector) {\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        this.collection = collection;\n        this.sorter = null;\n        this.matcher = new Minimongo.Matcher(selector);\n        if (LocalCollection._selectorIsIdPerhapsAsObject(selector)) {\n          // stash for fast _id and { _id }\n          this._selectorId = hasOwn.call(selector, '_id') ? selector._id : selector;\n        } else {\n          this._selectorId = undefined;\n          if (this.matcher.hasGeoQuery() || options.sort) {\n            this.sorter = new Minimongo.Sorter(options.sort || []);\n          }\n        }\n        this.skip = options.skip || 0;\n        this.limit = options.limit;\n        this.fields = options.projection || options.fields;\n        this._projectionFn = LocalCollection._compileProjection(this.fields || {});\n        this._transform = LocalCollection.wrapTransform(options.transform);\n\n        // by default, queries register w/ Tracker when it is available.\n        if (typeof Tracker !== 'undefined') {\n          this.reactive = options.reactive === undefined ? true : options.reactive;\n        }\n      }\n\n      /**\n       * @deprecated in 2.9\n       * @summary Returns the number of documents that match a query. This method is\n       *          [deprecated since MongoDB 4.0](https://www.mongodb.com/docs/v4.4/reference/command/count/);\n       *          see `Collection.countDocuments` and\n       *          `Collection.estimatedDocumentCount` for a replacement.\n       * @memberOf Mongo.Cursor\n       * @method  count\n       * @instance\n       * @locus Anywhere\n       * @returns {Number}\n       */\n      count() {\n        if (this.reactive) {\n          // allow the observe to be unordered\n          this._depend({\n            added: true,\n            removed: true\n          }, true);\n        }\n        return this._getRawObjects({\n          ordered: true\n        }).length;\n      }\n\n      /**\n       * @summary Return all matching documents as an Array.\n       * @memberOf Mongo.Cursor\n       * @method  fetch\n       * @instance\n       * @locus Anywhere\n       * @returns {Object[]}\n       */\n      fetch() {\n        const result = [];\n        this.forEach(doc => {\n          result.push(doc);\n        });\n        return result;\n      }\n      [Symbol.iterator]() {\n        if (this.reactive) {\n          this._depend({\n            addedBefore: true,\n            removed: true,\n            changed: true,\n            movedBefore: true\n          });\n        }\n        let index = 0;\n        const objects = this._getRawObjects({\n          ordered: true\n        });\n        return {\n          next: () => {\n            if (index < objects.length) {\n              // This doubles as a clone operation.\n              let element = this._projectionFn(objects[index++]);\n              if (this._transform) element = this._transform(element);\n              return {\n                value: element\n              };\n            }\n            return {\n              done: true\n            };\n          }\n        };\n      }\n      [Symbol.asyncIterator]() {\n        const syncResult = this[Symbol.iterator]();\n        return {\n          async next() {\n            return Promise.resolve(syncResult.next());\n          }\n        };\n      }\n\n      /**\n       * @callback IterationCallback\n       * @param {Object} doc\n       * @param {Number} index\n       */\n      /**\n       * @summary Call `callback` once for each matching document, sequentially and\n       *          synchronously.\n       * @locus Anywhere\n       * @method  forEach\n       * @instance\n       * @memberOf Mongo.Cursor\n       * @param {IterationCallback} callback Function to call. It will be called\n       *                                     with three arguments: the document, a\n       *                                     0-based index, and <em>cursor</em>\n       *                                     itself.\n       * @param {Any} [thisArg] An object which will be the value of `this` inside\n       *                        `callback`.\n       */\n      forEach(callback, thisArg) {\n        if (this.reactive) {\n          this._depend({\n            addedBefore: true,\n            removed: true,\n            changed: true,\n            movedBefore: true\n          });\n        }\n        this._getRawObjects({\n          ordered: true\n        }).forEach((element, i) => {\n          // This doubles as a clone operation.\n          element = this._projectionFn(element);\n          if (this._transform) {\n            element = this._transform(element);\n          }\n          callback.call(thisArg, element, i, this);\n        });\n      }\n      getTransform() {\n        return this._transform;\n      }\n\n      /**\n       * @summary Map callback over all matching documents.  Returns an Array.\n       * @locus Anywhere\n       * @method map\n       * @instance\n       * @memberOf Mongo.Cursor\n       * @param {IterationCallback} callback Function to call. It will be called\n       *                                     with three arguments: the document, a\n       *                                     0-based index, and <em>cursor</em>\n       *                                     itself.\n       * @param {Any} [thisArg] An object which will be the value of `this` inside\n       *                        `callback`.\n       */\n      map(callback, thisArg) {\n        const result = [];\n        this.forEach((doc, i) => {\n          result.push(callback.call(thisArg, doc, i, this));\n        });\n        return result;\n      }\n\n      // options to contain:\n      //  * callbacks for observe():\n      //    - addedAt (document, atIndex)\n      //    - added (document)\n      //    - changedAt (newDocument, oldDocument, atIndex)\n      //    - changed (newDocument, oldDocument)\n      //    - removedAt (document, atIndex)\n      //    - removed (document)\n      //    - movedTo (document, oldIndex, newIndex)\n      //\n      // attributes available on returned query handle:\n      //  * stop(): end updates\n      //  * collection: the collection this query is querying\n      //\n      // iff x is a returned query handle, (x instanceof\n      // LocalCollection.ObserveHandle) is true\n      //\n      // initial results delivered through added callback\n      // XXX maybe callbacks should take a list of objects, to expose transactions?\n      // XXX maybe support field limiting (to limit what you're notified on)\n\n      /**\n       * @summary Watch a query.  Receive callbacks as the result set changes.\n       * @locus Anywhere\n       * @memberOf Mongo.Cursor\n       * @instance\n       * @param {Object} callbacks Functions to call to deliver the result set as it\n       *                           changes\n       */\n      observe(options) {\n        return LocalCollection._observeFromObserveChanges(this, options);\n      }\n\n      /**\n       * @summary Watch a query.  Receive callbacks as the result set changes.\n       * @locus Anywhere\n       * @memberOf Mongo.Cursor\n       * @instance\n       */\n      observeAsync(options) {\n        return new Promise(resolve => resolve(this.observe(options)));\n      }\n\n      /**\n       * @summary Watch a query. Receive callbacks as the result set changes. Only\n       *          the differences between the old and new documents are passed to\n       *          the callbacks.\n       * @locus Anywhere\n       * @memberOf Mongo.Cursor\n       * @instance\n       * @param {Object} callbacks Functions to call to deliver the result set as it\n       *                           changes\n       */\n      observeChanges(options) {\n        const ordered = LocalCollection._observeChangesCallbacksAreOrdered(options);\n\n        // there are several places that assume you aren't combining skip/limit with\n        // unordered observe.  eg, update's EJSON.clone, and the \"there are several\"\n        // comment in _modifyAndNotify\n        // XXX allow skip/limit with unordered observe\n        if (!options._allow_unordered && !ordered && (this.skip || this.limit)) {\n          throw new Error(\"Must use an ordered observe with skip or limit (i.e. 'addedBefore' \" + \"for observeChanges or 'addedAt' for observe, instead of 'added').\");\n        }\n        if (this.fields && (this.fields._id === 0 || this.fields._id === false)) {\n          throw Error(\"You may not observe a cursor with {fields: {_id: 0}}\");\n        }\n        const distances = this.matcher.hasGeoQuery() && ordered && new LocalCollection._IdMap();\n        const query = {\n          cursor: this,\n          dirty: false,\n          distances,\n          matcher: this.matcher,\n          // not fast pathed\n          ordered,\n          projectionFn: this._projectionFn,\n          resultsSnapshot: null,\n          sorter: ordered && this.sorter\n        };\n        let qid;\n\n        // Non-reactive queries call added[Before] and then never call anything\n        // else.\n        if (this.reactive) {\n          qid = this.collection.next_qid++;\n          this.collection.queries[qid] = query;\n        }\n        query.results = this._getRawObjects({\n          ordered,\n          distances: query.distances\n        });\n        if (this.collection.paused) {\n          query.resultsSnapshot = ordered ? [] : new LocalCollection._IdMap();\n        }\n\n        // wrap callbacks we were passed. callbacks only fire when not paused and\n        // are never undefined\n        // Filters out blacklisted fields according to cursor's projection.\n        // XXX wrong place for this?\n\n        // furthermore, callbacks enqueue until the operation we're working on is\n        // done.\n        const wrapCallback = fn => {\n          if (!fn) {\n            return () => {};\n          }\n          const self = this;\n          return function /* args*/\n          () {\n            if (self.collection.paused) {\n              return;\n            }\n            const args = arguments;\n            self.collection._observeQueue.queueTask(() => {\n              fn.apply(this, args);\n            });\n          };\n        };\n        query.added = wrapCallback(options.added);\n        query.changed = wrapCallback(options.changed);\n        query.removed = wrapCallback(options.removed);\n        if (ordered) {\n          query.addedBefore = wrapCallback(options.addedBefore);\n          query.movedBefore = wrapCallback(options.movedBefore);\n        }\n        if (!options._suppress_initial && !this.collection.paused) {\n          var _query$results, _query$results$size;\n          const handler = doc => {\n            const fields = EJSON.clone(doc);\n            delete fields._id;\n            if (ordered) {\n              query.addedBefore(doc._id, this._projectionFn(fields), null);\n            }\n            query.added(doc._id, this._projectionFn(fields));\n          };\n          // it means it's just an array\n          if (query.results.length) {\n            for (const doc of query.results) {\n              handler(doc);\n            }\n          }\n          // it means it's an id map\n          if ((_query$results = query.results) !== null && _query$results !== void 0 && (_query$results$size = _query$results.size) !== null && _query$results$size !== void 0 && _query$results$size.call(_query$results)) {\n            query.results.forEach(handler);\n          }\n        }\n        const handle = Object.assign(new LocalCollection.ObserveHandle(), {\n          collection: this.collection,\n          stop: () => {\n            if (this.reactive) {\n              delete this.collection.queries[qid];\n            }\n          },\n          isReady: false,\n          isReadyPromise: null\n        });\n        if (this.reactive && Tracker.active) {\n          // XXX in many cases, the same observe will be recreated when\n          // the current autorun is rerun.  we could save work by\n          // letting it linger across rerun and potentially get\n          // repurposed if the same observe is performed, using logic\n          // similar to that of Meteor.subscribe.\n          Tracker.onInvalidate(() => {\n            handle.stop();\n          });\n        }\n\n        // run the observe callbacks resulting from the initial contents\n        // before we leave the observe.\n        const drainResult = this.collection._observeQueue.drain();\n        if (drainResult instanceof Promise) {\n          handle.isReadyPromise = drainResult;\n          drainResult.then(() => handle.isReady = true);\n        } else {\n          handle.isReady = true;\n          handle.isReadyPromise = Promise.resolve();\n        }\n        return handle;\n      }\n\n      /**\n       * @summary Watch a query. Receive callbacks as the result set changes. Only\n       *          the differences between the old and new documents are passed to\n       *          the callbacks.\n       * @locus Anywhere\n       * @memberOf Mongo.Cursor\n       * @instance\n       * @param {Object} callbacks Functions to call to deliver the result set as it\n       *                           changes\n       */\n      observeChangesAsync(options) {\n        return new Promise(resolve => {\n          const handle = this.observeChanges(options);\n          handle.isReadyPromise.then(() => resolve(handle));\n        });\n      }\n\n      // XXX Maybe we need a version of observe that just calls a callback if\n      // anything changed.\n      _depend(changers, _allow_unordered) {\n        if (Tracker.active) {\n          const dependency = new Tracker.Dependency();\n          const notify = dependency.changed.bind(dependency);\n          dependency.depend();\n          const options = {\n            _allow_unordered,\n            _suppress_initial: true\n          };\n          ['added', 'addedBefore', 'changed', 'movedBefore', 'removed'].forEach(fn => {\n            if (changers[fn]) {\n              options[fn] = notify;\n            }\n          });\n\n          // observeChanges will stop() when this computation is invalidated\n          this.observeChanges(options);\n        }\n      }\n      _getCollectionName() {\n        return this.collection.name;\n      }\n\n      // Returns a collection of matching objects, but doesn't deep copy them.\n      //\n      // If ordered is set, returns a sorted array, respecting sorter, skip, and\n      // limit properties of the query provided that options.applySkipLimit is\n      // not set to false (#1201). If sorter is falsey, no sort -- you get the\n      // natural order.\n      //\n      // If ordered is not set, returns an object mapping from ID to doc (sorter,\n      // skip and limit should not be set).\n      //\n      // If ordered is set and this cursor is a $near geoquery, then this function\n      // will use an _IdMap to track each distance from the $near argument point in\n      // order to use it as a sort key. If an _IdMap is passed in the 'distances'\n      // argument, this function will clear it and use it for this purpose\n      // (otherwise it will just create its own _IdMap). The observeChanges\n      // implementation uses this to remember the distances after this function\n      // returns.\n      _getRawObjects() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        // By default this method will respect skip and limit because .fetch(),\n        // .forEach() etc... expect this behaviour. It can be forced to ignore\n        // skip and limit by setting applySkipLimit to false (.count() does this,\n        // for example)\n        const applySkipLimit = options.applySkipLimit !== false;\n\n        // XXX use OrderedDict instead of array, and make IdMap and OrderedDict\n        // compatible\n        const results = options.ordered ? [] : new LocalCollection._IdMap();\n\n        // fast path for single ID value\n        if (this._selectorId !== undefined) {\n          // If you have non-zero skip and ask for a single id, you get nothing.\n          // This is so it matches the behavior of the '{_id: foo}' path.\n          if (applySkipLimit && this.skip) {\n            return results;\n          }\n          const selectedDoc = this.collection._docs.get(this._selectorId);\n          if (selectedDoc) {\n            if (options.ordered) {\n              results.push(selectedDoc);\n            } else {\n              results.set(this._selectorId, selectedDoc);\n            }\n          }\n          return results;\n        }\n\n        // slow path for arbitrary selector, sort, skip, limit\n\n        // in the observeChanges case, distances is actually part of the \"query\"\n        // (ie, live results set) object.  in other cases, distances is only used\n        // inside this function.\n        let distances;\n        if (this.matcher.hasGeoQuery() && options.ordered) {\n          if (options.distances) {\n            distances = options.distances;\n            distances.clear();\n          } else {\n            distances = new LocalCollection._IdMap();\n          }\n        }\n        this.collection._docs.forEach((doc, id) => {\n          const matchResult = this.matcher.documentMatches(doc);\n          if (matchResult.result) {\n            if (options.ordered) {\n              results.push(doc);\n              if (distances && matchResult.distance !== undefined) {\n                distances.set(id, matchResult.distance);\n              }\n            } else {\n              results.set(id, doc);\n            }\n          }\n\n          // Override to ensure all docs are matched if ignoring skip & limit\n          if (!applySkipLimit) {\n            return true;\n          }\n\n          // Fast path for limited unsorted queries.\n          // XXX 'length' check here seems wrong for ordered\n          return !this.limit || this.skip || this.sorter || results.length !== this.limit;\n        });\n        if (!options.ordered) {\n          return results;\n        }\n        if (this.sorter) {\n          results.sort(this.sorter.getComparator({\n            distances\n          }));\n        }\n\n        // Return the full set of results if there is no skip or limit or if we're\n        // ignoring them\n        if (!applySkipLimit || !this.limit && !this.skip) {\n          return results;\n        }\n        return results.slice(this.skip, this.limit ? this.limit + this.skip : results.length);\n      }\n      _publishCursor(subscription) {\n        // XXX minimongo should not depend on mongo-livedata!\n        if (!Package.mongo) {\n          throw new Error(\"Can't publish from Minimongo without the `mongo` package.\");\n        }\n        if (!this.collection.name) {\n          throw new Error(\"Can't publish a cursor from a collection without a name.\");\n        }\n        return Package.mongo.Mongo.Collection._publishCursor(this, subscription, this.collection.name);\n      }\n    }\n    // Implements async version of cursor methods to keep collections isomorphic\n    ASYNC_CURSOR_METHODS.forEach(method => {\n      const asyncName = getAsyncMethodName(method);\n      Cursor.prototype[asyncName] = function () {\n        try {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n          return Promise.resolve(this[method].apply(this, args));\n        } catch (error) {\n          return Promise.reject(error);\n        }\n      };\n    });\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: false\n});","map":{"version":3,"names":["module","export","default","Cursor","LocalCollection","link","v","hasOwn","ASYNC_CURSOR_METHODS","getAsyncMethodName","__reifyWaitForDeps__","constructor","collection","selector","options","arguments","length","undefined","sorter","matcher","Minimongo","Matcher","_selectorIsIdPerhapsAsObject","_selectorId","call","_id","hasGeoQuery","sort","Sorter","skip","limit","fields","projection","_projectionFn","_compileProjection","_transform","wrapTransform","transform","Tracker","reactive","count","_depend","added","removed","_getRawObjects","ordered","fetch","result","forEach","doc","push","Symbol","iterator","addedBefore","changed","movedBefore","index","objects","next","element","value","done","asyncIterator","syncResult","Promise","resolve","callback","thisArg","i","getTransform","map","observe","_observeFromObserveChanges","observeAsync","observeChanges","_observeChangesCallbacksAreOrdered","_allow_unordered","Error","distances","_IdMap","query","cursor","dirty","projectionFn","resultsSnapshot","qid","next_qid","queries","results","paused","wrapCallback","fn","self","args","_observeQueue","queueTask","apply","_suppress_initial","_query$results","_query$results$size","handler","EJSON","clone","size","handle","Object","assign","ObserveHandle","stop","isReady","isReadyPromise","active","onInvalidate","drainResult","drain","then","observeChangesAsync","changers","dependency","Dependency","notify","bind","depend","_getCollectionName","name","applySkipLimit","selectedDoc","_docs","get","set","clear","id","matchResult","documentMatches","distance","getComparator","slice","_publishCursor","subscription","Package","mongo","Mongo","Collection","method","asyncName","prototype","_len","Array","_key","error","reject","__reify_async_result__","_reifyError","async"],"sources":["packages/minimongo/cursor.js"],"sourcesContent":["import LocalCollection from './local_collection.js';\nimport { hasOwn } from './common.js';\nimport { ASYNC_CURSOR_METHODS, getAsyncMethodName } from './constants';\n\n// Cursor: a specification for a particular subset of documents, w/ a defined\n// order, limit, and offset.  creating a Cursor with LocalCollection.find(),\nexport default class Cursor {\n  // don't call this ctor directly.  use LocalCollection.find().\n  constructor(collection, selector, options = {}) {\n    this.collection = collection;\n    this.sorter = null;\n    this.matcher = new Minimongo.Matcher(selector);\n\n    if (LocalCollection._selectorIsIdPerhapsAsObject(selector)) {\n      // stash for fast _id and { _id }\n      this._selectorId = hasOwn.call(selector, '_id') ? selector._id : selector;\n    } else {\n      this._selectorId = undefined;\n\n      if (this.matcher.hasGeoQuery() || options.sort) {\n        this.sorter = new Minimongo.Sorter(options.sort || []);\n      }\n    }\n\n    this.skip = options.skip || 0;\n    this.limit = options.limit;\n    this.fields = options.projection || options.fields;\n\n    this._projectionFn = LocalCollection._compileProjection(this.fields || {});\n\n    this._transform = LocalCollection.wrapTransform(options.transform);\n\n    // by default, queries register w/ Tracker when it is available.\n    if (typeof Tracker !== 'undefined') {\n      this.reactive = options.reactive === undefined ? true : options.reactive;\n    }\n  }\n\n  /**\n   * @deprecated in 2.9\n   * @summary Returns the number of documents that match a query. This method is\n   *          [deprecated since MongoDB 4.0](https://www.mongodb.com/docs/v4.4/reference/command/count/);\n   *          see `Collection.countDocuments` and\n   *          `Collection.estimatedDocumentCount` for a replacement.\n   * @memberOf Mongo.Cursor\n   * @method  count\n   * @instance\n   * @locus Anywhere\n   * @returns {Number}\n   */\n  count() {\n    if (this.reactive) {\n      // allow the observe to be unordered\n      this._depend({ added: true, removed: true }, true);\n    }\n\n    return this._getRawObjects({\n      ordered: true,\n    }).length;\n  }\n\n  /**\n   * @summary Return all matching documents as an Array.\n   * @memberOf Mongo.Cursor\n   * @method  fetch\n   * @instance\n   * @locus Anywhere\n   * @returns {Object[]}\n   */\n  fetch() {\n    const result = [];\n\n    this.forEach(doc => {\n      result.push(doc);\n    });\n\n    return result;\n  }\n\n  [Symbol.iterator]() {\n    if (this.reactive) {\n      this._depend({\n        addedBefore: true,\n        removed: true,\n        changed: true,\n        movedBefore: true,\n      });\n    }\n\n    let index = 0;\n    const objects = this._getRawObjects({ ordered: true });\n\n    return {\n      next: () => {\n        if (index < objects.length) {\n          // This doubles as a clone operation.\n          let element = this._projectionFn(objects[index++]);\n\n          if (this._transform) element = this._transform(element);\n\n          return { value: element };\n        }\n\n        return { done: true };\n      },\n    };\n  }\n\n  [Symbol.asyncIterator]() {\n    const syncResult = this[Symbol.iterator]();\n    return {\n      async next() {\n        return Promise.resolve(syncResult.next());\n      },\n    };\n  }\n\n  /**\n   * @callback IterationCallback\n   * @param {Object} doc\n   * @param {Number} index\n   */\n  /**\n   * @summary Call `callback` once for each matching document, sequentially and\n   *          synchronously.\n   * @locus Anywhere\n   * @method  forEach\n   * @instance\n   * @memberOf Mongo.Cursor\n   * @param {IterationCallback} callback Function to call. It will be called\n   *                                     with three arguments: the document, a\n   *                                     0-based index, and <em>cursor</em>\n   *                                     itself.\n   * @param {Any} [thisArg] An object which will be the value of `this` inside\n   *                        `callback`.\n   */\n  forEach(callback, thisArg) {\n    if (this.reactive) {\n      this._depend({\n        addedBefore: true,\n        removed: true,\n        changed: true,\n        movedBefore: true,\n      });\n    }\n\n    this._getRawObjects({ ordered: true }).forEach((element, i) => {\n      // This doubles as a clone operation.\n      element = this._projectionFn(element);\n\n      if (this._transform) {\n        element = this._transform(element);\n      }\n\n      callback.call(thisArg, element, i, this);\n    });\n  }\n\n  getTransform() {\n    return this._transform;\n  }\n\n  /**\n   * @summary Map callback over all matching documents.  Returns an Array.\n   * @locus Anywhere\n   * @method map\n   * @instance\n   * @memberOf Mongo.Cursor\n   * @param {IterationCallback} callback Function to call. It will be called\n   *                                     with three arguments: the document, a\n   *                                     0-based index, and <em>cursor</em>\n   *                                     itself.\n   * @param {Any} [thisArg] An object which will be the value of `this` inside\n   *                        `callback`.\n   */\n  map(callback, thisArg) {\n    const result = [];\n\n    this.forEach((doc, i) => {\n      result.push(callback.call(thisArg, doc, i, this));\n    });\n\n    return result;\n  }\n\n  // options to contain:\n  //  * callbacks for observe():\n  //    - addedAt (document, atIndex)\n  //    - added (document)\n  //    - changedAt (newDocument, oldDocument, atIndex)\n  //    - changed (newDocument, oldDocument)\n  //    - removedAt (document, atIndex)\n  //    - removed (document)\n  //    - movedTo (document, oldIndex, newIndex)\n  //\n  // attributes available on returned query handle:\n  //  * stop(): end updates\n  //  * collection: the collection this query is querying\n  //\n  // iff x is a returned query handle, (x instanceof\n  // LocalCollection.ObserveHandle) is true\n  //\n  // initial results delivered through added callback\n  // XXX maybe callbacks should take a list of objects, to expose transactions?\n  // XXX maybe support field limiting (to limit what you're notified on)\n\n  /**\n   * @summary Watch a query.  Receive callbacks as the result set changes.\n   * @locus Anywhere\n   * @memberOf Mongo.Cursor\n   * @instance\n   * @param {Object} callbacks Functions to call to deliver the result set as it\n   *                           changes\n   */\n  observe(options) {\n    return LocalCollection._observeFromObserveChanges(this, options);\n  }\n\n  /**\n   * @summary Watch a query.  Receive callbacks as the result set changes.\n   * @locus Anywhere\n   * @memberOf Mongo.Cursor\n   * @instance\n   */\n  observeAsync(options) {\n    return new Promise(resolve => resolve(this.observe(options)));\n  }\n\n  /**\n   * @summary Watch a query. Receive callbacks as the result set changes. Only\n   *          the differences between the old and new documents are passed to\n   *          the callbacks.\n   * @locus Anywhere\n   * @memberOf Mongo.Cursor\n   * @instance\n   * @param {Object} callbacks Functions to call to deliver the result set as it\n   *                           changes\n   */\n  observeChanges(options) {\n    const ordered = LocalCollection._observeChangesCallbacksAreOrdered(options);\n\n    // there are several places that assume you aren't combining skip/limit with\n    // unordered observe.  eg, update's EJSON.clone, and the \"there are several\"\n    // comment in _modifyAndNotify\n    // XXX allow skip/limit with unordered observe\n    if (!options._allow_unordered && !ordered && (this.skip || this.limit)) {\n      throw new Error(\n        \"Must use an ordered observe with skip or limit (i.e. 'addedBefore' \" +\n          \"for observeChanges or 'addedAt' for observe, instead of 'added').\"\n      );\n    }\n\n    if (this.fields && (this.fields._id === 0 || this.fields._id === false)) {\n      throw Error(\"You may not observe a cursor with {fields: {_id: 0}}\");\n    }\n\n    const distances =\n      this.matcher.hasGeoQuery() && ordered && new LocalCollection._IdMap();\n\n    const query = {\n      cursor: this,\n      dirty: false,\n      distances,\n      matcher: this.matcher, // not fast pathed\n      ordered,\n      projectionFn: this._projectionFn,\n      resultsSnapshot: null,\n      sorter: ordered && this.sorter,\n    };\n\n    let qid;\n\n    // Non-reactive queries call added[Before] and then never call anything\n    // else.\n    if (this.reactive) {\n      qid = this.collection.next_qid++;\n      this.collection.queries[qid] = query;\n    }\n\n    query.results = this._getRawObjects({\n      ordered,\n      distances: query.distances,\n    });\n\n    if (this.collection.paused) {\n      query.resultsSnapshot = ordered ? [] : new LocalCollection._IdMap();\n    }\n\n    // wrap callbacks we were passed. callbacks only fire when not paused and\n    // are never undefined\n    // Filters out blacklisted fields according to cursor's projection.\n    // XXX wrong place for this?\n\n    // furthermore, callbacks enqueue until the operation we're working on is\n    // done.\n    const wrapCallback = (fn) => {\n      if (!fn) {\n        return () => {};\n      }\n\n      const self = this;\n\n      return function (/* args*/) {\n        if (self.collection.paused) {\n          return;\n        }\n\n        const args = arguments;\n\n        self.collection._observeQueue.queueTask(() => {\n          fn.apply(this, args);\n        });\n      };\n    };\n\n    query.added = wrapCallback(options.added);\n    query.changed = wrapCallback(options.changed);\n    query.removed = wrapCallback(options.removed);\n\n    if (ordered) {\n      query.addedBefore = wrapCallback(options.addedBefore);\n      query.movedBefore = wrapCallback(options.movedBefore);\n    }\n\n    if (!options._suppress_initial && !this.collection.paused) {\n      const handler = (doc) => {\n        const fields = EJSON.clone(doc);\n\n        delete fields._id;\n\n        if (ordered) {\n          query.addedBefore(doc._id, this._projectionFn(fields), null);\n        }\n\n        query.added(doc._id, this._projectionFn(fields));\n      };\n      // it means it's just an array\n      if (query.results.length) {\n        for (const doc of query.results) {\n          handler(doc);\n        }\n      }\n      // it means it's an id map\n      if (query.results?.size?.()) {\n        query.results.forEach(handler);\n      }\n    }\n\n    const handle = Object.assign(new LocalCollection.ObserveHandle(), {\n      collection: this.collection,\n      stop: () => {\n        if (this.reactive) {\n          delete this.collection.queries[qid];\n        }\n      },\n      isReady: false,\n      isReadyPromise: null,\n    });\n\n    if (this.reactive && Tracker.active) {\n      // XXX in many cases, the same observe will be recreated when\n      // the current autorun is rerun.  we could save work by\n      // letting it linger across rerun and potentially get\n      // repurposed if the same observe is performed, using logic\n      // similar to that of Meteor.subscribe.\n      Tracker.onInvalidate(() => {\n        handle.stop();\n      });\n    }\n\n    // run the observe callbacks resulting from the initial contents\n    // before we leave the observe.\n    const drainResult = this.collection._observeQueue.drain();\n\n    if (drainResult instanceof Promise) {\n      handle.isReadyPromise = drainResult;\n      drainResult.then(() => (handle.isReady = true));\n    } else {\n      handle.isReady = true;\n      handle.isReadyPromise = Promise.resolve();\n    }\n\n    return handle;\n  }\n\n  /**\n   * @summary Watch a query. Receive callbacks as the result set changes. Only\n   *          the differences between the old and new documents are passed to\n   *          the callbacks.\n   * @locus Anywhere\n   * @memberOf Mongo.Cursor\n   * @instance\n   * @param {Object} callbacks Functions to call to deliver the result set as it\n   *                           changes\n   */\n  observeChangesAsync(options) {\n    return new Promise((resolve) => {\n      const handle = this.observeChanges(options);\n      handle.isReadyPromise.then(() => resolve(handle));\n    });\n  }\n\n  // XXX Maybe we need a version of observe that just calls a callback if\n  // anything changed.\n  _depend(changers, _allow_unordered) {\n    if (Tracker.active) {\n      const dependency = new Tracker.Dependency();\n      const notify = dependency.changed.bind(dependency);\n\n      dependency.depend();\n\n      const options = { _allow_unordered, _suppress_initial: true };\n\n      ['added', 'addedBefore', 'changed', 'movedBefore', 'removed'].forEach(\n        fn => {\n          if (changers[fn]) {\n            options[fn] = notify;\n          }\n        }\n      );\n\n      // observeChanges will stop() when this computation is invalidated\n      this.observeChanges(options);\n    }\n  }\n\n  _getCollectionName() {\n    return this.collection.name;\n  }\n\n  // Returns a collection of matching objects, but doesn't deep copy them.\n  //\n  // If ordered is set, returns a sorted array, respecting sorter, skip, and\n  // limit properties of the query provided that options.applySkipLimit is\n  // not set to false (#1201). If sorter is falsey, no sort -- you get the\n  // natural order.\n  //\n  // If ordered is not set, returns an object mapping from ID to doc (sorter,\n  // skip and limit should not be set).\n  //\n  // If ordered is set and this cursor is a $near geoquery, then this function\n  // will use an _IdMap to track each distance from the $near argument point in\n  // order to use it as a sort key. If an _IdMap is passed in the 'distances'\n  // argument, this function will clear it and use it for this purpose\n  // (otherwise it will just create its own _IdMap). The observeChanges\n  // implementation uses this to remember the distances after this function\n  // returns.\n  _getRawObjects(options = {}) {\n    // By default this method will respect skip and limit because .fetch(),\n    // .forEach() etc... expect this behaviour. It can be forced to ignore\n    // skip and limit by setting applySkipLimit to false (.count() does this,\n    // for example)\n    const applySkipLimit = options.applySkipLimit !== false;\n\n    // XXX use OrderedDict instead of array, and make IdMap and OrderedDict\n    // compatible\n    const results = options.ordered ? [] : new LocalCollection._IdMap();\n\n    // fast path for single ID value\n    if (this._selectorId !== undefined) {\n      // If you have non-zero skip and ask for a single id, you get nothing.\n      // This is so it matches the behavior of the '{_id: foo}' path.\n      if (applySkipLimit && this.skip) {\n        return results;\n      }\n\n      const selectedDoc = this.collection._docs.get(this._selectorId);\n      if (selectedDoc) {\n        if (options.ordered) {\n          results.push(selectedDoc);\n        } else {\n          results.set(this._selectorId, selectedDoc);\n        }\n      }\n      return results;\n    }\n\n    // slow path for arbitrary selector, sort, skip, limit\n\n    // in the observeChanges case, distances is actually part of the \"query\"\n    // (ie, live results set) object.  in other cases, distances is only used\n    // inside this function.\n    let distances;\n    if (this.matcher.hasGeoQuery() && options.ordered) {\n      if (options.distances) {\n        distances = options.distances;\n        distances.clear();\n      } else {\n        distances = new LocalCollection._IdMap();\n      }\n    }\n    this.collection._docs.forEach((doc, id) => {\n      const matchResult = this.matcher.documentMatches(doc);\n      if (matchResult.result) {\n        if (options.ordered) {\n          results.push(doc);\n\n          if (distances && matchResult.distance !== undefined) {\n            distances.set(id, matchResult.distance);\n          }\n        } else {\n          results.set(id, doc);\n        }\n      }\n\n      // Override to ensure all docs are matched if ignoring skip & limit\n      if (!applySkipLimit) {\n        return true;\n      }\n\n      // Fast path for limited unsorted queries.\n      // XXX 'length' check here seems wrong for ordered\n      return (\n        !this.limit || this.skip || this.sorter || results.length !== this.limit\n      );\n    });\n\n    if (!options.ordered) {\n      return results;\n    }\n\n    if (this.sorter) {\n      results.sort(this.sorter.getComparator({ distances }));\n    }\n\n    // Return the full set of results if there is no skip or limit or if we're\n    // ignoring them\n    if (!applySkipLimit || (!this.limit && !this.skip)) {\n      return results;\n    }\n\n    return results.slice(\n      this.skip,\n      this.limit ? this.limit + this.skip : results.length\n    );\n  }\n\n  _publishCursor(subscription) {\n    // XXX minimongo should not depend on mongo-livedata!\n    if (!Package.mongo) {\n      throw new Error(\n        \"Can't publish from Minimongo without the `mongo` package.\"\n      );\n    }\n\n    if (!this.collection.name) {\n      throw new Error(\n        \"Can't publish a cursor from a collection without a name.\"\n      );\n    }\n\n    return Package.mongo.Mongo.Collection._publishCursor(\n      this,\n      subscription,\n      this.collection.name\n    );\n  }\n}\n\n// Implements async version of cursor methods to keep collections isomorphic\nASYNC_CURSOR_METHODS.forEach(method => {\n  const asyncName = getAsyncMethodName(method);\n  Cursor.prototype[asyncName] = function(...args) {\n    try {\n      return Promise.resolve(this[method].apply(this, args));\n    } catch (error) {\n      return Promise.reject(error);\n    }\n  };\n});\n"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"f0fb1f126583c93215135bcb70349b312661f07a"}
