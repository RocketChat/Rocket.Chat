{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/minimongo/minimongo_server.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.arm64"},"sourceFileName":"packages/minimongo/minimongo_server.js","filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/minimongo/minimongo_server.js","targets":{"android":"125.0.0","chrome":"125.0.0","edge":"125.0.0","firefox":"115.0.0","ie":"10.0.0","ios":"17.4.0","opera":"110.0.0","opera_mobile":"80.0.0","safari":"17.4.0","samsung":"24.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","root":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true,"topLevelAwait":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/minimongo/minimongo_server.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/minimongo/minimongo_server.js"}},"code":"!module.wrapAsync(async function (module, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    module.link(\"./minimongo_common.js\");\n    let hasOwn, isNumericKey, isOperatorObject, pathsToTree, projectionDetails;\n    module.link(\"./common.js\", {\n      hasOwn(v) {\n        hasOwn = v;\n      },\n      isNumericKey(v) {\n        isNumericKey = v;\n      },\n      isOperatorObject(v) {\n        isOperatorObject = v;\n      },\n      pathsToTree(v) {\n        pathsToTree = v;\n      },\n      projectionDetails(v) {\n        projectionDetails = v;\n      }\n    }, 0);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    Minimongo._pathsElidingNumericKeys = paths => paths.map(path => path.split('.').filter(part => !isNumericKey(part)).join('.'));\n\n    // Returns true if the modifier applied to some document may change the result\n    // of matching the document by selector\n    // The modifier is always in a form of Object:\n    //  - $set\n    //    - 'a.b.22.z': value\n    //    - 'foo.bar': 42\n    //  - $unset\n    //    - 'abc.d': 1\n    Minimongo.Matcher.prototype.affectedByModifier = function (modifier) {\n      // safe check for $set/$unset being objects\n      modifier = Object.assign({\n        $set: {},\n        $unset: {}\n      }, modifier);\n      const meaningfulPaths = this._getPaths();\n      const modifiedPaths = [].concat(Object.keys(modifier.$set), Object.keys(modifier.$unset));\n      return modifiedPaths.some(path => {\n        const mod = path.split('.');\n        return meaningfulPaths.some(meaningfulPath => {\n          const sel = meaningfulPath.split('.');\n          let i = 0,\n            j = 0;\n          while (i < sel.length && j < mod.length) {\n            if (isNumericKey(sel[i]) && isNumericKey(mod[j])) {\n              // foo.4.bar selector affected by foo.4 modifier\n              // foo.3.bar selector unaffected by foo.4 modifier\n              if (sel[i] === mod[j]) {\n                i++;\n                j++;\n              } else {\n                return false;\n              }\n            } else if (isNumericKey(sel[i])) {\n              // foo.4.bar selector unaffected by foo.bar modifier\n              return false;\n            } else if (isNumericKey(mod[j])) {\n              j++;\n            } else if (sel[i] === mod[j]) {\n              i++;\n              j++;\n            } else {\n              return false;\n            }\n          }\n\n          // One is a prefix of another, taking numeric fields into account\n          return true;\n        });\n      });\n    };\n\n    // @param modifier - Object: MongoDB-styled modifier with `$set`s and `$unsets`\n    //                           only. (assumed to come from oplog)\n    // @returns - Boolean: if after applying the modifier, selector can start\n    //                     accepting the modified value.\n    // NOTE: assumes that document affected by modifier didn't match this Matcher\n    // before, so if modifier can't convince selector in a positive change it would\n    // stay 'false'.\n    // Currently doesn't support $-operators and numeric indices precisely.\n    Minimongo.Matcher.prototype.canBecomeTrueByModifier = function (modifier) {\n      if (!this.affectedByModifier(modifier)) {\n        return false;\n      }\n      if (!this.isSimple()) {\n        return true;\n      }\n      modifier = Object.assign({\n        $set: {},\n        $unset: {}\n      }, modifier);\n      const modifierPaths = [].concat(Object.keys(modifier.$set), Object.keys(modifier.$unset));\n      if (this._getPaths().some(pathHasNumericKeys) || modifierPaths.some(pathHasNumericKeys)) {\n        return true;\n      }\n\n      // check if there is a $set or $unset that indicates something is an\n      // object rather than a scalar in the actual object where we saw $-operator\n      // NOTE: it is correct since we allow only scalars in $-operators\n      // Example: for selector {'a.b': {$gt: 5}} the modifier {'a.b.c':7} would\n      // definitely set the result to false as 'a.b' appears to be an object.\n      const expectedScalarIsObject = Object.keys(this._selector).some(path => {\n        if (!isOperatorObject(this._selector[path])) {\n          return false;\n        }\n        return modifierPaths.some(modifierPath => modifierPath.startsWith(\"\".concat(path, \".\")));\n      });\n      if (expectedScalarIsObject) {\n        return false;\n      }\n\n      // See if we can apply the modifier on the ideally matching object. If it\n      // still matches the selector, then the modifier could have turned the real\n      // object in the database into something matching.\n      const matchingDocument = EJSON.clone(this.matchingDocument());\n\n      // The selector is too complex, anything can happen.\n      if (matchingDocument === null) {\n        return true;\n      }\n      try {\n        LocalCollection._modify(matchingDocument, modifier);\n      } catch (error) {\n        // Couldn't set a property on a field which is a scalar or null in the\n        // selector.\n        // Example:\n        // real document: { 'a.b': 3 }\n        // selector: { 'a': 12 }\n        // converted selector (ideal document): { 'a': 12 }\n        // modifier: { $set: { 'a.b': 4 } }\n        // We don't know what real document was like but from the error raised by\n        // $set on a scalar field we can reason that the structure of real document\n        // is completely different.\n        if (error.name === 'MinimongoError' && error.setPropertyError) {\n          return false;\n        }\n        throw error;\n      }\n      return this.documentMatches(matchingDocument).result;\n    };\n\n    // Knows how to combine a mongo selector and a fields projection to a new fields\n    // projection taking into account active fields from the passed selector.\n    // @returns Object - projection object (same as fields option of mongo cursor)\n    Minimongo.Matcher.prototype.combineIntoProjection = function (projection) {\n      const selectorPaths = Minimongo._pathsElidingNumericKeys(this._getPaths());\n\n      // Special case for $where operator in the selector - projection should depend\n      // on all fields of the document. getSelectorPaths returns a list of paths\n      // selector depends on. If one of the paths is '' (empty string) representing\n      // the root or the whole document, complete projection should be returned.\n      if (selectorPaths.includes('')) {\n        return {};\n      }\n      return combineImportantPathsIntoProjection(selectorPaths, projection);\n    };\n\n    // Returns an object that would match the selector if possible or null if the\n    // selector is too complex for us to analyze\n    // { 'a.b': { ans: 42 }, 'foo.bar': null, 'foo.baz': \"something\" }\n    // => { a: { b: { ans: 42 } }, foo: { bar: null, baz: \"something\" } }\n    Minimongo.Matcher.prototype.matchingDocument = function () {\n      // check if it was computed before\n      if (this._matchingDocument !== undefined) {\n        return this._matchingDocument;\n      }\n\n      // If the analysis of this selector is too hard for our implementation\n      // fallback to \"YES\"\n      let fallback = false;\n      this._matchingDocument = pathsToTree(this._getPaths(), path => {\n        const valueSelector = this._selector[path];\n        if (isOperatorObject(valueSelector)) {\n          // if there is a strict equality, there is a good\n          // chance we can use one of those as \"matching\"\n          // dummy value\n          if (valueSelector.$eq) {\n            return valueSelector.$eq;\n          }\n          if (valueSelector.$in) {\n            const matcher = new Minimongo.Matcher({\n              placeholder: valueSelector\n            });\n\n            // Return anything from $in that matches the whole selector for this\n            // path. If nothing matches, returns `undefined` as nothing can make\n            // this selector into `true`.\n            return valueSelector.$in.find(placeholder => matcher.documentMatches({\n              placeholder\n            }).result);\n          }\n          if (onlyContainsKeys(valueSelector, ['$gt', '$gte', '$lt', '$lte'])) {\n            let lowerBound = -Infinity;\n            let upperBound = Infinity;\n            ['$lte', '$lt'].forEach(op => {\n              if (hasOwn.call(valueSelector, op) && valueSelector[op] < upperBound) {\n                upperBound = valueSelector[op];\n              }\n            });\n            ['$gte', '$gt'].forEach(op => {\n              if (hasOwn.call(valueSelector, op) && valueSelector[op] > lowerBound) {\n                lowerBound = valueSelector[op];\n              }\n            });\n            const middle = (lowerBound + upperBound) / 2;\n            const matcher = new Minimongo.Matcher({\n              placeholder: valueSelector\n            });\n            if (!matcher.documentMatches({\n              placeholder: middle\n            }).result && (middle === lowerBound || middle === upperBound)) {\n              fallback = true;\n            }\n            return middle;\n          }\n          if (onlyContainsKeys(valueSelector, ['$nin', '$ne'])) {\n            // Since this._isSimple makes sure $nin and $ne are not combined with\n            // objects or arrays, we can confidently return an empty object as it\n            // never matches any scalar.\n            return {};\n          }\n          fallback = true;\n        }\n        return this._selector[path];\n      }, x => x);\n      if (fallback) {\n        this._matchingDocument = null;\n      }\n      return this._matchingDocument;\n    };\n\n    // Minimongo.Sorter gets a similar method, which delegates to a Matcher it made\n    // for this exact purpose.\n    Minimongo.Sorter.prototype.affectedByModifier = function (modifier) {\n      return this._selectorForAffectedByModifier.affectedByModifier(modifier);\n    };\n    Minimongo.Sorter.prototype.combineIntoProjection = function (projection) {\n      return combineImportantPathsIntoProjection(Minimongo._pathsElidingNumericKeys(this._getPaths()), projection);\n    };\n    function combineImportantPathsIntoProjection(paths, projection) {\n      const details = projectionDetails(projection);\n\n      // merge the paths to include\n      const tree = pathsToTree(paths, path => true, (node, path, fullPath) => true, details.tree);\n      const mergedProjection = treeToPaths(tree);\n      if (details.including) {\n        // both selector and projection are pointing on fields to include\n        // so we can just return the merged tree\n        return mergedProjection;\n      }\n\n      // selector is pointing at fields to include\n      // projection is pointing at fields to exclude\n      // make sure we don't exclude important paths\n      const mergedExclProjection = {};\n      Object.keys(mergedProjection).forEach(path => {\n        if (!mergedProjection[path]) {\n          mergedExclProjection[path] = false;\n        }\n      });\n      return mergedExclProjection;\n    }\n    function getPaths(selector) {\n      return Object.keys(new Minimongo.Matcher(selector)._paths);\n\n      // XXX remove it?\n      // return Object.keys(selector).map(k => {\n      //   // we don't know how to handle $where because it can be anything\n      //   if (k === '$where') {\n      //     return ''; // matches everything\n      //   }\n\n      //   // we branch from $or/$and/$nor operator\n      //   if (['$or', '$and', '$nor'].includes(k)) {\n      //     return selector[k].map(getPaths);\n      //   }\n\n      //   // the value is a literal or some comparison operator\n      //   return k;\n      // })\n      //   .reduce((a, b) => a.concat(b), [])\n      //   .filter((a, b, c) => c.indexOf(a) === b);\n    }\n\n    // A helper to ensure object has only certain keys\n    function onlyContainsKeys(obj, keys) {\n      return Object.keys(obj).every(k => keys.includes(k));\n    }\n    function pathHasNumericKeys(path) {\n      return path.split('.').some(isNumericKey);\n    }\n\n    // Returns a set of key paths similar to\n    // { 'foo.bar': 1, 'a.b.c': 1 }\n    function treeToPaths(tree) {\n      let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      const result = {};\n      Object.keys(tree).forEach(key => {\n        const value = tree[key];\n        if (value === Object(value)) {\n          Object.assign(result, treeToPaths(value, \"\".concat(prefix + key, \".\")));\n        } else {\n          result[prefix + key] = value;\n        }\n      });\n      return result;\n    }\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: false\n});","map":{"version":3,"names":["module","link","hasOwn","isNumericKey","isOperatorObject","pathsToTree","projectionDetails","v","__reifyWaitForDeps__","Minimongo","_pathsElidingNumericKeys","paths","map","path","split","filter","part","join","Matcher","prototype","affectedByModifier","modifier","Object","assign","$set","$unset","meaningfulPaths","_getPaths","modifiedPaths","concat","keys","some","mod","meaningfulPath","sel","i","j","length","canBecomeTrueByModifier","isSimple","modifierPaths","pathHasNumericKeys","expectedScalarIsObject","_selector","modifierPath","startsWith","matchingDocument","EJSON","clone","LocalCollection","_modify","error","name","setPropertyError","documentMatches","result","combineIntoProjection","projection","selectorPaths","includes","combineImportantPathsIntoProjection","_matchingDocument","undefined","fallback","valueSelector","$eq","$in","matcher","placeholder","find","onlyContainsKeys","lowerBound","Infinity","upperBound","forEach","op","call","middle","x","Sorter","_selectorForAffectedByModifier","details","tree","node","fullPath","mergedProjection","treeToPaths","including","mergedExclProjection","getPaths","selector","_paths","obj","every","k","prefix","arguments","key","value","__reify_async_result__","_reifyError","self","async"],"sources":["packages/minimongo/minimongo_server.js"],"sourcesContent":["import './minimongo_common.js';\nimport {\n  hasOwn,\n  isNumericKey,\n  isOperatorObject,\n  pathsToTree,\n  projectionDetails,\n} from './common.js';\n\nMinimongo._pathsElidingNumericKeys = paths => paths.map(path =>\n  path.split('.').filter(part => !isNumericKey(part)).join('.')\n);\n\n// Returns true if the modifier applied to some document may change the result\n// of matching the document by selector\n// The modifier is always in a form of Object:\n//  - $set\n//    - 'a.b.22.z': value\n//    - 'foo.bar': 42\n//  - $unset\n//    - 'abc.d': 1\nMinimongo.Matcher.prototype.affectedByModifier = function(modifier) {\n  // safe check for $set/$unset being objects\n  modifier = Object.assign({$set: {}, $unset: {}}, modifier);\n\n  const meaningfulPaths = this._getPaths();\n  const modifiedPaths = [].concat(\n    Object.keys(modifier.$set),\n    Object.keys(modifier.$unset)\n  );\n\n  return modifiedPaths.some(path => {\n    const mod = path.split('.');\n\n    return meaningfulPaths.some(meaningfulPath => {\n      const sel = meaningfulPath.split('.');\n\n      let i = 0, j = 0;\n\n      while (i < sel.length && j < mod.length) {\n        if (isNumericKey(sel[i]) && isNumericKey(mod[j])) {\n          // foo.4.bar selector affected by foo.4 modifier\n          // foo.3.bar selector unaffected by foo.4 modifier\n          if (sel[i] === mod[j]) {\n            i++;\n            j++;\n          } else {\n            return false;\n          }\n        } else if (isNumericKey(sel[i])) {\n          // foo.4.bar selector unaffected by foo.bar modifier\n          return false;\n        } else if (isNumericKey(mod[j])) {\n          j++;\n        } else if (sel[i] === mod[j]) {\n          i++;\n          j++;\n        } else {\n          return false;\n        }\n      }\n\n      // One is a prefix of another, taking numeric fields into account\n      return true;\n    });\n  });\n};\n\n// @param modifier - Object: MongoDB-styled modifier with `$set`s and `$unsets`\n//                           only. (assumed to come from oplog)\n// @returns - Boolean: if after applying the modifier, selector can start\n//                     accepting the modified value.\n// NOTE: assumes that document affected by modifier didn't match this Matcher\n// before, so if modifier can't convince selector in a positive change it would\n// stay 'false'.\n// Currently doesn't support $-operators and numeric indices precisely.\nMinimongo.Matcher.prototype.canBecomeTrueByModifier = function(modifier) {\n  if (!this.affectedByModifier(modifier)) {\n    return false;\n  }\n\n  if (!this.isSimple()) {\n    return true;\n  }\n\n  modifier = Object.assign({$set: {}, $unset: {}}, modifier);\n\n  const modifierPaths = [].concat(\n    Object.keys(modifier.$set),\n    Object.keys(modifier.$unset)\n  );\n\n  if (this._getPaths().some(pathHasNumericKeys) ||\n      modifierPaths.some(pathHasNumericKeys)) {\n    return true;\n  }\n\n  // check if there is a $set or $unset that indicates something is an\n  // object rather than a scalar in the actual object where we saw $-operator\n  // NOTE: it is correct since we allow only scalars in $-operators\n  // Example: for selector {'a.b': {$gt: 5}} the modifier {'a.b.c':7} would\n  // definitely set the result to false as 'a.b' appears to be an object.\n  const expectedScalarIsObject = Object.keys(this._selector).some(path => {\n    if (!isOperatorObject(this._selector[path])) {\n      return false;\n    }\n\n    return modifierPaths.some(modifierPath =>\n      modifierPath.startsWith(`${path}.`)\n    );\n  });\n\n  if (expectedScalarIsObject) {\n    return false;\n  }\n\n  // See if we can apply the modifier on the ideally matching object. If it\n  // still matches the selector, then the modifier could have turned the real\n  // object in the database into something matching.\n  const matchingDocument = EJSON.clone(this.matchingDocument());\n\n  // The selector is too complex, anything can happen.\n  if (matchingDocument === null) {\n    return true;\n  }\n\n  try {\n    LocalCollection._modify(matchingDocument, modifier);\n  } catch (error) {\n    // Couldn't set a property on a field which is a scalar or null in the\n    // selector.\n    // Example:\n    // real document: { 'a.b': 3 }\n    // selector: { 'a': 12 }\n    // converted selector (ideal document): { 'a': 12 }\n    // modifier: { $set: { 'a.b': 4 } }\n    // We don't know what real document was like but from the error raised by\n    // $set on a scalar field we can reason that the structure of real document\n    // is completely different.\n    if (error.name === 'MinimongoError' && error.setPropertyError) {\n      return false;\n    }\n\n    throw error;\n  }\n\n  return this.documentMatches(matchingDocument).result;\n};\n\n// Knows how to combine a mongo selector and a fields projection to a new fields\n// projection taking into account active fields from the passed selector.\n// @returns Object - projection object (same as fields option of mongo cursor)\nMinimongo.Matcher.prototype.combineIntoProjection = function(projection) {\n  const selectorPaths = Minimongo._pathsElidingNumericKeys(this._getPaths());\n\n  // Special case for $where operator in the selector - projection should depend\n  // on all fields of the document. getSelectorPaths returns a list of paths\n  // selector depends on. If one of the paths is '' (empty string) representing\n  // the root or the whole document, complete projection should be returned.\n  if (selectorPaths.includes('')) {\n    return {};\n  }\n\n  return combineImportantPathsIntoProjection(selectorPaths, projection);\n};\n\n// Returns an object that would match the selector if possible or null if the\n// selector is too complex for us to analyze\n// { 'a.b': { ans: 42 }, 'foo.bar': null, 'foo.baz': \"something\" }\n// => { a: { b: { ans: 42 } }, foo: { bar: null, baz: \"something\" } }\nMinimongo.Matcher.prototype.matchingDocument = function() {\n  // check if it was computed before\n  if (this._matchingDocument !== undefined) {\n    return this._matchingDocument;\n  }\n\n  // If the analysis of this selector is too hard for our implementation\n  // fallback to \"YES\"\n  let fallback = false;\n\n  this._matchingDocument = pathsToTree(\n    this._getPaths(),\n    path => {\n      const valueSelector = this._selector[path];\n\n      if (isOperatorObject(valueSelector)) {\n        // if there is a strict equality, there is a good\n        // chance we can use one of those as \"matching\"\n        // dummy value\n        if (valueSelector.$eq) {\n          return valueSelector.$eq;\n        }\n\n        if (valueSelector.$in) {\n          const matcher = new Minimongo.Matcher({placeholder: valueSelector});\n\n          // Return anything from $in that matches the whole selector for this\n          // path. If nothing matches, returns `undefined` as nothing can make\n          // this selector into `true`.\n          return valueSelector.$in.find(placeholder =>\n            matcher.documentMatches({placeholder}).result\n          );\n        }\n\n        if (onlyContainsKeys(valueSelector, ['$gt', '$gte', '$lt', '$lte'])) {\n          let lowerBound = -Infinity;\n          let upperBound = Infinity;\n\n          ['$lte', '$lt'].forEach(op => {\n            if (hasOwn.call(valueSelector, op) &&\n                valueSelector[op] < upperBound) {\n              upperBound = valueSelector[op];\n            }\n          });\n\n          ['$gte', '$gt'].forEach(op => {\n            if (hasOwn.call(valueSelector, op) &&\n                valueSelector[op] > lowerBound) {\n              lowerBound = valueSelector[op];\n            }\n          });\n\n          const middle = (lowerBound + upperBound) / 2;\n          const matcher = new Minimongo.Matcher({placeholder: valueSelector});\n\n          if (!matcher.documentMatches({placeholder: middle}).result &&\n              (middle === lowerBound || middle === upperBound)) {\n            fallback = true;\n          }\n\n          return middle;\n        }\n\n        if (onlyContainsKeys(valueSelector, ['$nin', '$ne'])) {\n          // Since this._isSimple makes sure $nin and $ne are not combined with\n          // objects or arrays, we can confidently return an empty object as it\n          // never matches any scalar.\n          return {};\n        }\n\n        fallback = true;\n      }\n\n      return this._selector[path];\n    },\n    x => x);\n\n  if (fallback) {\n    this._matchingDocument = null;\n  }\n\n  return this._matchingDocument;\n};\n\n// Minimongo.Sorter gets a similar method, which delegates to a Matcher it made\n// for this exact purpose.\nMinimongo.Sorter.prototype.affectedByModifier = function(modifier) {\n  return this._selectorForAffectedByModifier.affectedByModifier(modifier);\n};\n\nMinimongo.Sorter.prototype.combineIntoProjection = function(projection) {\n  return combineImportantPathsIntoProjection(\n    Minimongo._pathsElidingNumericKeys(this._getPaths()),\n    projection\n  );\n};\n\nfunction combineImportantPathsIntoProjection(paths, projection) {\n  const details = projectionDetails(projection);\n\n  // merge the paths to include\n  const tree = pathsToTree(\n    paths,\n    path => true,\n    (node, path, fullPath) => true,\n    details.tree\n  );\n  const mergedProjection = treeToPaths(tree);\n\n  if (details.including) {\n    // both selector and projection are pointing on fields to include\n    // so we can just return the merged tree\n    return mergedProjection;\n  }\n\n  // selector is pointing at fields to include\n  // projection is pointing at fields to exclude\n  // make sure we don't exclude important paths\n  const mergedExclProjection = {};\n\n  Object.keys(mergedProjection).forEach(path => {\n    if (!mergedProjection[path]) {\n      mergedExclProjection[path] = false;\n    }\n  });\n\n  return mergedExclProjection;\n}\n\nfunction getPaths(selector) {\n  return Object.keys(new Minimongo.Matcher(selector)._paths);\n\n  // XXX remove it?\n  // return Object.keys(selector).map(k => {\n  //   // we don't know how to handle $where because it can be anything\n  //   if (k === '$where') {\n  //     return ''; // matches everything\n  //   }\n\n  //   // we branch from $or/$and/$nor operator\n  //   if (['$or', '$and', '$nor'].includes(k)) {\n  //     return selector[k].map(getPaths);\n  //   }\n\n  //   // the value is a literal or some comparison operator\n  //   return k;\n  // })\n  //   .reduce((a, b) => a.concat(b), [])\n  //   .filter((a, b, c) => c.indexOf(a) === b);\n}\n\n// A helper to ensure object has only certain keys\nfunction onlyContainsKeys(obj, keys) {\n  return Object.keys(obj).every(k => keys.includes(k));\n}\n\nfunction pathHasNumericKeys(path) {\n  return path.split('.').some(isNumericKey);\n}\n\n// Returns a set of key paths similar to\n// { 'foo.bar': 1, 'a.b.c': 1 }\nfunction treeToPaths(tree, prefix = '') {\n  const result = {};\n\n  Object.keys(tree).forEach(key => {\n    const value = tree[key];\n    if (value === Object(value)) {\n      Object.assign(result, treeToPaths(value, `${prefix + key}.`));\n    } else {\n      result[prefix + key] = value;\n    }\n  });\n\n  return result;\n}\n"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"4003d34f487a9b1a2989f5c2806d59c9b3bed6d2"}
