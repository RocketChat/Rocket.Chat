{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/minimongo/common.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser.legacy"},"sourceFileName":"packages/minimongo/common.js","filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/minimongo/common.js","targets":{"android":"125.0.0","chrome":"125.0.0","edge":"125.0.0","firefox":"115.0.0","ie":"10.0.0","ios":"17.4.0","opera":"110.0.0","opera_mobile":"80.0.0","safari":"17.4.0","samsung":"24.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","root":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":true,"enforceStrictMode":false,"dynamicImport":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"base$0$3","visitor":{"FunctionExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$4","visitor":{"ForInStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-arrow-functions","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-block-scoped-functions","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-block-scoping","visitor":{"VariableDeclaration":{"enter":[null,null]},"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-classes","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-computed-properties","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-destructuring","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-object-super","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"DoWhileStatement":{"exit":[null]},"ForInStatement":{"exit":[null]},"ForStatement":{"exit":[null]},"WhileStatement":{"exit":[null]},"ForOfStatement":{"exit":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-shorthand-properties","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-spread","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-sticky-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-typeof-symbol","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"StaticBlock":{"enter":[null]},"TSModuleBlock":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectPattern":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-unicode-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-property-literals","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-regenerator","visitor":{"ObjectMethod":{"enter":[null],"exit":[null]},"ClassMethod":{"enter":[null],"exit":[null]},"ClassPrivateMethod":{"enter":[null],"exit":[null]},"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/minimongo/common.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/minimongo/common.js"}},"code":"var _toConsumableArray;\nmodule.link(\"@babel/runtime/helpers/toConsumableArray\", {\n  default: function (v) {\n    _toConsumableArray = v;\n  }\n}, 0);\nvar _typeof;\nmodule.link(\"@babel/runtime/helpers/typeof\", {\n  default: function (v) {\n    _typeof = v;\n  }\n}, 1);\nmodule.export({\n  hasOwn: function () {\n    return hasOwn;\n  },\n  ELEMENT_OPERATORS: function () {\n    return ELEMENT_OPERATORS;\n  },\n  compileDocumentSelector: function () {\n    return compileDocumentSelector;\n  },\n  equalityElementMatcher: function () {\n    return equalityElementMatcher;\n  },\n  expandArraysInBranches: function () {\n    return expandArraysInBranches;\n  },\n  isIndexable: function () {\n    return isIndexable;\n  },\n  isNumericKey: function () {\n    return isNumericKey;\n  },\n  isOperatorObject: function () {\n    return isOperatorObject;\n  },\n  makeLookupFunction: function () {\n    return makeLookupFunction;\n  },\n  nothingMatcher: function () {\n    return nothingMatcher;\n  },\n  pathsToTree: function () {\n    return pathsToTree;\n  },\n  populateDocumentWithQueryFields: function () {\n    return populateDocumentWithQueryFields;\n  },\n  projectionDetails: function () {\n    return projectionDetails;\n  },\n  regexpElementMatcher: function () {\n    return regexpElementMatcher;\n  }\n});\nvar LocalCollection;\nmodule.link(\"./local_collection.js\", {\n  \"default\": function (v) {\n    LocalCollection = v;\n  }\n}, 0);\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar ELEMENT_OPERATORS = {\n  $lt: makeInequality(function (cmpValue) {\n    return cmpValue < 0;\n  }),\n  $gt: makeInequality(function (cmpValue) {\n    return cmpValue > 0;\n  }),\n  $lte: makeInequality(function (cmpValue) {\n    return cmpValue <= 0;\n  }),\n  $gte: makeInequality(function (cmpValue) {\n    return cmpValue >= 0;\n  }),\n  $mod: {\n    compileElementSelector: function (operand) {\n      if (!(Array.isArray(operand) && operand.length === 2 && typeof operand[0] === 'number' && typeof operand[1] === 'number')) {\n        throw Error('argument to $mod must be an array of two numbers');\n      }\n\n      // XXX could require to be ints or round or something\n      var divisor = operand[0];\n      var remainder = operand[1];\n      return function (value) {\n        return typeof value === 'number' && value % divisor === remainder;\n      };\n    }\n  },\n  $in: {\n    compileElementSelector: function (operand) {\n      if (!Array.isArray(operand)) {\n        throw Error('$in needs an array');\n      }\n      var elementMatchers = operand.map(function (option) {\n        if (option instanceof RegExp) {\n          return regexpElementMatcher(option);\n        }\n        if (isOperatorObject(option)) {\n          throw Error('cannot nest $ under $in');\n        }\n        return equalityElementMatcher(option);\n      });\n      return function (value) {\n        // Allow {a: {$in: [null]}} to match when 'a' does not exist.\n        if (value === undefined) {\n          value = null;\n        }\n        return elementMatchers.some(function (matcher) {\n          return matcher(value);\n        });\n      };\n    }\n  },\n  $size: {\n    // {a: [[5, 5]]} must match {a: {$size: 1}} but not {a: {$size: 2}}, so we\n    // don't want to consider the element [5,5] in the leaf array [[5,5]] as a\n    // possible value.\n    dontExpandLeafArrays: true,\n    compileElementSelector: function (operand) {\n      if (typeof operand === 'string') {\n        // Don't ask me why, but by experimentation, this seems to be what Mongo\n        // does.\n        operand = 0;\n      } else if (typeof operand !== 'number') {\n        throw Error('$size needs a number');\n      }\n      return function (value) {\n        return Array.isArray(value) && value.length === operand;\n      };\n    }\n  },\n  $type: {\n    // {a: [5]} must not match {a: {$type: 4}} (4 means array), but it should\n    // match {a: {$type: 1}} (1 means number), and {a: [[5]]} must match {$a:\n    // {$type: 4}}. Thus, when we see a leaf array, we *should* expand it but\n    // should *not* include it itself.\n    dontIncludeLeafArrays: true,\n    compileElementSelector: function (operand) {\n      if (typeof operand === 'string') {\n        var operandAliasMap = {\n          'double': 1,\n          'string': 2,\n          'object': 3,\n          'array': 4,\n          'binData': 5,\n          'undefined': 6,\n          'objectId': 7,\n          'bool': 8,\n          'date': 9,\n          'null': 10,\n          'regex': 11,\n          'dbPointer': 12,\n          'javascript': 13,\n          'symbol': 14,\n          'javascriptWithScope': 15,\n          'int': 16,\n          'timestamp': 17,\n          'long': 18,\n          'decimal': 19,\n          'minKey': -1,\n          'maxKey': 127\n        };\n        if (!hasOwn.call(operandAliasMap, operand)) {\n          throw Error(\"unknown string alias for $type: \" + operand);\n        }\n        operand = operandAliasMap[operand];\n      } else if (typeof operand === 'number') {\n        if (operand === 0 || operand < -1 || operand > 19 && operand !== 127) {\n          throw Error(\"Invalid numerical $type code: \" + operand);\n        }\n      } else {\n        throw Error('argument to $type is not a number or a string');\n      }\n      return function (value) {\n        return value !== undefined && LocalCollection._f._type(value) === operand;\n      };\n    }\n  },\n  $bitsAllSet: {\n    compileElementSelector: function (operand) {\n      var mask = getOperandBitmask(operand, '$bitsAllSet');\n      return function (value) {\n        var bitmask = getValueBitmask(value, mask.length);\n        return bitmask && mask.every(function (byte, i) {\n          return (bitmask[i] & byte) === byte;\n        });\n      };\n    }\n  },\n  $bitsAnySet: {\n    compileElementSelector: function (operand) {\n      var mask = getOperandBitmask(operand, '$bitsAnySet');\n      return function (value) {\n        var bitmask = getValueBitmask(value, mask.length);\n        return bitmask && mask.some(function (byte, i) {\n          return (~bitmask[i] & byte) !== byte;\n        });\n      };\n    }\n  },\n  $bitsAllClear: {\n    compileElementSelector: function (operand) {\n      var mask = getOperandBitmask(operand, '$bitsAllClear');\n      return function (value) {\n        var bitmask = getValueBitmask(value, mask.length);\n        return bitmask && mask.every(function (byte, i) {\n          return !(bitmask[i] & byte);\n        });\n      };\n    }\n  },\n  $bitsAnyClear: {\n    compileElementSelector: function (operand) {\n      var mask = getOperandBitmask(operand, '$bitsAnyClear');\n      return function (value) {\n        var bitmask = getValueBitmask(value, mask.length);\n        return bitmask && mask.some(function (byte, i) {\n          return (bitmask[i] & byte) !== byte;\n        });\n      };\n    }\n  },\n  $regex: {\n    compileElementSelector: function (operand, valueSelector) {\n      if (!(typeof operand === 'string' || operand instanceof RegExp)) {\n        throw Error('$regex has to be a string or RegExp');\n      }\n      var regexp;\n      if (valueSelector.$options !== undefined) {\n        // Options passed in $options (even the empty string) always overrides\n        // options in the RegExp object itself.\n\n        // Be clear that we only support the JS-supported options, not extended\n        // ones (eg, Mongo supports x and s). Ideally we would implement x and s\n        // by transforming the regexp, but not today...\n        if (/[^gim]/.test(valueSelector.$options)) {\n          throw new Error('Only the i, m, and g regexp options are supported');\n        }\n        var source = operand instanceof RegExp ? operand.source : operand;\n        regexp = new RegExp(source, valueSelector.$options);\n      } else if (operand instanceof RegExp) {\n        regexp = operand;\n      } else {\n        regexp = new RegExp(operand);\n      }\n      return regexpElementMatcher(regexp);\n    }\n  },\n  $elemMatch: {\n    dontExpandLeafArrays: true,\n    compileElementSelector: function (operand, valueSelector, matcher) {\n      if (!LocalCollection._isPlainObject(operand)) {\n        throw Error('$elemMatch need an object');\n      }\n      var isDocMatcher = !isOperatorObject(Object.keys(operand).filter(function (key) {\n        return !hasOwn.call(LOGICAL_OPERATORS, key);\n      }).reduce(function (a, b) {\n        var _Object$assign;\n        return Object.assign(a, (_Object$assign = {}, _Object$assign[b] = operand[b], _Object$assign));\n      }, {}), true);\n      var subMatcher;\n      if (isDocMatcher) {\n        // This is NOT the same as compileValueSelector(operand), and not just\n        // because of the slightly different calling convention.\n        // {$elemMatch: {x: 3}} means \"an element has a field x:3\", not\n        // \"consists only of a field x:3\". Also, regexps and sub-$ are allowed.\n        subMatcher = compileDocumentSelector(operand, matcher, {\n          inElemMatch: true\n        });\n      } else {\n        subMatcher = compileValueSelector(operand, matcher);\n      }\n      return function (value) {\n        if (!Array.isArray(value)) {\n          return false;\n        }\n        for (var i = 0; i < value.length; ++i) {\n          var arrayElement = value[i];\n          var arg = void 0;\n          if (isDocMatcher) {\n            // We can only match {$elemMatch: {b: 3}} against objects.\n            // (We can also match against arrays, if there's numeric indices,\n            // eg {$elemMatch: {'0.b': 3}} or {$elemMatch: {0: 3}}.)\n            if (!isIndexable(arrayElement)) {\n              return false;\n            }\n            arg = arrayElement;\n          } else {\n            // dontIterate ensures that {a: {$elemMatch: {$gt: 5}}} matches\n            // {a: [8]} but not {a: [[8]]}\n            arg = [{\n              value: arrayElement,\n              dontIterate: true\n            }];\n          }\n          // XXX support $near in $elemMatch by propagating $distance?\n          if (subMatcher(arg).result) {\n            return i; // specially understood to mean \"use as arrayIndices\"\n          }\n        }\n        return false;\n      };\n    }\n  }\n};\n// Operators that appear at the top level of a document selector.\nvar LOGICAL_OPERATORS = {\n  $and: function (subSelector, matcher, inElemMatch) {\n    return andDocumentMatchers(compileArrayOfDocumentSelectors(subSelector, matcher, inElemMatch));\n  },\n  $or: function (subSelector, matcher, inElemMatch) {\n    var matchers = compileArrayOfDocumentSelectors(subSelector, matcher, inElemMatch);\n\n    // Special case: if there is only one matcher, use it directly, *preserving*\n    // any arrayIndices it returns.\n    if (matchers.length === 1) {\n      return matchers[0];\n    }\n    return function (doc) {\n      var result = matchers.some(function (fn) {\n        return fn(doc).result;\n      });\n      // $or does NOT set arrayIndices when it has multiple\n      // sub-expressions. (Tested against MongoDB.)\n      return {\n        result: result\n      };\n    };\n  },\n  $nor: function (subSelector, matcher, inElemMatch) {\n    var matchers = compileArrayOfDocumentSelectors(subSelector, matcher, inElemMatch);\n    return function (doc) {\n      var result = matchers.every(function (fn) {\n        return !fn(doc).result;\n      });\n      // Never set arrayIndices, because we only match if nothing in particular\n      // 'matched' (and because this is consistent with MongoDB).\n      return {\n        result: result\n      };\n    };\n  },\n  $where: function (selectorValue, matcher) {\n    // Record that *any* path may be used.\n    matcher._recordPathUsed('');\n    matcher._hasWhere = true;\n    if (!(selectorValue instanceof Function)) {\n      // XXX MongoDB seems to have more complex logic to decide where or or not\n      // to add 'return'; not sure exactly what it is.\n      selectorValue = Function('obj', \"return \" + selectorValue);\n    }\n\n    // We make the document available as both `this` and `obj`.\n    // // XXX not sure what we should do if this throws\n    return function (doc) {\n      return {\n        result: selectorValue.call(doc, doc)\n      };\n    };\n  },\n  // This is just used as a comment in the query (in MongoDB, it also ends up in\n  // query logs); it has no effect on the actual selection.\n  $comment: function () {\n    return function () {\n      return {\n        result: true\n      };\n    };\n  }\n};\n\n// Operators that (unlike LOGICAL_OPERATORS) pertain to individual paths in a\n// document, but (unlike ELEMENT_OPERATORS) do not have a simple definition as\n// \"match each branched value independently and combine with\n// convertElementMatcherToBranchedMatcher\".\nvar VALUE_OPERATORS = {\n  $eq: function (operand) {\n    return convertElementMatcherToBranchedMatcher(equalityElementMatcher(operand));\n  },\n  $not: function (operand, valueSelector, matcher) {\n    return invertBranchedMatcher(compileValueSelector(operand, matcher));\n  },\n  $ne: function (operand) {\n    return invertBranchedMatcher(convertElementMatcherToBranchedMatcher(equalityElementMatcher(operand)));\n  },\n  $nin: function (operand) {\n    return invertBranchedMatcher(convertElementMatcherToBranchedMatcher(ELEMENT_OPERATORS.$in.compileElementSelector(operand)));\n  },\n  $exists: function (operand) {\n    var exists = convertElementMatcherToBranchedMatcher(function (value) {\n      return value !== undefined;\n    });\n    return operand ? exists : invertBranchedMatcher(exists);\n  },\n  // $options just provides options for $regex; its logic is inside $regex\n  $options: function (operand, valueSelector) {\n    if (!hasOwn.call(valueSelector, '$regex')) {\n      throw Error('$options needs a $regex');\n    }\n    return everythingMatcher;\n  },\n  // $maxDistance is basically an argument to $near\n  $maxDistance: function (operand, valueSelector) {\n    if (!valueSelector.$near) {\n      throw Error('$maxDistance needs a $near');\n    }\n    return everythingMatcher;\n  },\n  $all: function (operand, valueSelector, matcher) {\n    if (!Array.isArray(operand)) {\n      throw Error('$all requires array');\n    }\n\n    // Not sure why, but this seems to be what MongoDB does.\n    if (operand.length === 0) {\n      return nothingMatcher;\n    }\n    var branchedMatchers = operand.map(function (criterion) {\n      // XXX handle $all/$elemMatch combination\n      if (isOperatorObject(criterion)) {\n        throw Error('no $ expressions in $all');\n      }\n\n      // This is always a regexp or equality selector.\n      return compileValueSelector(criterion, matcher);\n    });\n\n    // andBranchedMatchers does NOT require all selectors to return true on the\n    // SAME branch.\n    return andBranchedMatchers(branchedMatchers);\n  },\n  $near: function (operand, valueSelector, matcher, isRoot) {\n    if (!isRoot) {\n      throw Error('$near can\\'t be inside another $ operator');\n    }\n    matcher._hasGeoQuery = true;\n\n    // There are two kinds of geodata in MongoDB: legacy coordinate pairs and\n    // GeoJSON. They use different distance metrics, too. GeoJSON queries are\n    // marked with a $geometry property, though legacy coordinates can be\n    // matched using $geometry.\n    var maxDistance, point, distance;\n    if (LocalCollection._isPlainObject(operand) && hasOwn.call(operand, '$geometry')) {\n      // GeoJSON \"2dsphere\" mode.\n      maxDistance = operand.$maxDistance;\n      point = operand.$geometry;\n      distance = function (value) {\n        // XXX: for now, we don't calculate the actual distance between, say,\n        // polygon and circle. If people care about this use-case it will get\n        // a priority.\n        if (!value) {\n          return null;\n        }\n        if (!value.type) {\n          return GeoJSON.pointDistance(point, {\n            type: 'Point',\n            coordinates: pointToArray(value)\n          });\n        }\n        if (value.type === 'Point') {\n          return GeoJSON.pointDistance(point, value);\n        }\n        return GeoJSON.geometryWithinRadius(value, point, maxDistance) ? 0 : maxDistance + 1;\n      };\n    } else {\n      maxDistance = valueSelector.$maxDistance;\n      if (!isIndexable(operand)) {\n        throw Error('$near argument must be coordinate pair or GeoJSON');\n      }\n      point = pointToArray(operand);\n      distance = function (value) {\n        if (!isIndexable(value)) {\n          return null;\n        }\n        return distanceCoordinatePairs(point, value);\n      };\n    }\n    return function (branchedValues) {\n      // There might be multiple points in the document that match the given\n      // field. Only one of them needs to be within $maxDistance, but we need to\n      // evaluate all of them and use the nearest one for the implicit sort\n      // specifier. (That's why we can't just use ELEMENT_OPERATORS here.)\n      //\n      // Note: This differs from MongoDB's implementation, where a document will\n      // actually show up *multiple times* in the result set, with one entry for\n      // each within-$maxDistance branching point.\n      var result = {\n        result: false\n      };\n      expandArraysInBranches(branchedValues).every(function (branch) {\n        // if operation is an update, don't skip branches, just return the first\n        // one (#3599)\n        var curDistance;\n        if (!matcher._isUpdate) {\n          if (!(_typeof(branch.value) === 'object')) {\n            return true;\n          }\n          curDistance = distance(branch.value);\n\n          // Skip branches that aren't real points or are too far away.\n          if (curDistance === null || curDistance > maxDistance) {\n            return true;\n          }\n\n          // Skip anything that's a tie.\n          if (result.distance !== undefined && result.distance <= curDistance) {\n            return true;\n          }\n        }\n        result.result = true;\n        result.distance = curDistance;\n        if (branch.arrayIndices) {\n          result.arrayIndices = branch.arrayIndices;\n        } else {\n          delete result.arrayIndices;\n        }\n        return !matcher._isUpdate;\n      });\n      return result;\n    };\n  }\n};\n\n// NB: We are cheating and using this function to implement 'AND' for both\n// 'document matchers' and 'branched matchers'. They both return result objects\n// but the argument is different: for the former it's a whole doc, whereas for\n// the latter it's an array of 'branched values'.\nfunction andSomeMatchers(subMatchers) {\n  if (subMatchers.length === 0) {\n    return everythingMatcher;\n  }\n  if (subMatchers.length === 1) {\n    return subMatchers[0];\n  }\n  return function (docOrBranches) {\n    var match = {};\n    match.result = subMatchers.every(function (fn) {\n      var subResult = fn(docOrBranches);\n\n      // Copy a 'distance' number out of the first sub-matcher that has\n      // one. Yes, this means that if there are multiple $near fields in a\n      // query, something arbitrary happens; this appears to be consistent with\n      // Mongo.\n      if (subResult.result && subResult.distance !== undefined && match.distance === undefined) {\n        match.distance = subResult.distance;\n      }\n\n      // Similarly, propagate arrayIndices from sub-matchers... but to match\n      // MongoDB behavior, this time the *last* sub-matcher with arrayIndices\n      // wins.\n      if (subResult.result && subResult.arrayIndices) {\n        match.arrayIndices = subResult.arrayIndices;\n      }\n      return subResult.result;\n    });\n\n    // If we didn't actually match, forget any extra metadata we came up with.\n    if (!match.result) {\n      delete match.distance;\n      delete match.arrayIndices;\n    }\n    return match;\n  };\n}\nvar andDocumentMatchers = andSomeMatchers;\nvar andBranchedMatchers = andSomeMatchers;\nfunction compileArrayOfDocumentSelectors(selectors, matcher, inElemMatch) {\n  if (!Array.isArray(selectors) || selectors.length === 0) {\n    throw Error('$and/$or/$nor must be nonempty array');\n  }\n  return selectors.map(function (subSelector) {\n    if (!LocalCollection._isPlainObject(subSelector)) {\n      throw Error('$or/$and/$nor entries need to be full objects');\n    }\n    return compileDocumentSelector(subSelector, matcher, {\n      inElemMatch: inElemMatch\n    });\n  });\n}\n\n// Takes in a selector that could match a full document (eg, the original\n// selector). Returns a function mapping document->result object.\n//\n// matcher is the Matcher object we are compiling.\n//\n// If this is the root document selector (ie, not wrapped in $and or the like),\n// then isRoot is true. (This is used by $near.)\nfunction compileDocumentSelector(docSelector, matcher) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var docMatchers = Object.keys(docSelector).map(function (key) {\n    var subSelector = docSelector[key];\n    if (key.substr(0, 1) === '$') {\n      // Outer operators are either logical operators (they recurse back into\n      // this function), or $where.\n      if (!hasOwn.call(LOGICAL_OPERATORS, key)) {\n        throw new Error(\"Unrecognized logical operator: \" + key);\n      }\n      matcher._isSimple = false;\n      return LOGICAL_OPERATORS[key](subSelector, matcher, options.inElemMatch);\n    }\n\n    // Record this path, but only if we aren't in an elemMatcher, since in an\n    // elemMatch this is a path inside an object in an array, not in the doc\n    // root.\n    if (!options.inElemMatch) {\n      matcher._recordPathUsed(key);\n    }\n\n    // Don't add a matcher if subSelector is a function -- this is to match\n    // the behavior of Meteor on the server (inherited from the node mongodb\n    // driver), which is to ignore any part of a selector which is a function.\n    if (typeof subSelector === 'function') {\n      return undefined;\n    }\n    var lookUpByIndex = makeLookupFunction(key);\n    var valueMatcher = compileValueSelector(subSelector, matcher, options.isRoot);\n    return function (doc) {\n      return valueMatcher(lookUpByIndex(doc));\n    };\n  }).filter(Boolean);\n  return andDocumentMatchers(docMatchers);\n}\n// Takes in a selector that could match a key-indexed value in a document; eg,\n// {$gt: 5, $lt: 9}, or a regular expression, or any non-expression object (to\n// indicate equality).  Returns a branched matcher: a function mapping\n// [branched value]->result object.\nfunction compileValueSelector(valueSelector, matcher, isRoot) {\n  if (valueSelector instanceof RegExp) {\n    matcher._isSimple = false;\n    return convertElementMatcherToBranchedMatcher(regexpElementMatcher(valueSelector));\n  }\n  if (isOperatorObject(valueSelector)) {\n    return operatorBranchedMatcher(valueSelector, matcher, isRoot);\n  }\n  return convertElementMatcherToBranchedMatcher(equalityElementMatcher(valueSelector));\n}\n\n// Given an element matcher (which evaluates a single value), returns a branched\n// value (which evaluates the element matcher on all the branches and returns a\n// more structured return value possibly including arrayIndices).\nfunction convertElementMatcherToBranchedMatcher(elementMatcher) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function (branches) {\n    var expanded = options.dontExpandLeafArrays ? branches : expandArraysInBranches(branches, options.dontIncludeLeafArrays);\n    var match = {};\n    match.result = expanded.some(function (element) {\n      var matched = elementMatcher(element.value);\n\n      // Special case for $elemMatch: it means \"true, and use this as an array\n      // index if I didn't already have one\".\n      if (typeof matched === 'number') {\n        // XXX This code dates from when we only stored a single array index\n        // (for the outermost array). Should we be also including deeper array\n        // indices from the $elemMatch match?\n        if (!element.arrayIndices) {\n          element.arrayIndices = [matched];\n        }\n        matched = true;\n      }\n\n      // If some element matched, and it's tagged with array indices, include\n      // those indices in our result object.\n      if (matched && element.arrayIndices) {\n        match.arrayIndices = element.arrayIndices;\n      }\n      return matched;\n    });\n    return match;\n  };\n}\n\n// Helpers for $near.\nfunction distanceCoordinatePairs(a, b) {\n  var pointA = pointToArray(a);\n  var pointB = pointToArray(b);\n  return Math.hypot(pointA[0] - pointB[0], pointA[1] - pointB[1]);\n}\n\n// Takes something that is not an operator object and returns an element matcher\n// for equality with that thing.\nfunction equalityElementMatcher(elementSelector) {\n  if (isOperatorObject(elementSelector)) {\n    throw Error('Can\\'t create equalityValueSelector for operator object');\n  }\n\n  // Special-case: null and undefined are equal (if you got undefined in there\n  // somewhere, or if you got it due to some branch being non-existent in the\n  // weird special case), even though they aren't with EJSON.equals.\n  // undefined or null\n  if (elementSelector == null) {\n    return function (value) {\n      return value == null;\n    };\n  }\n  return function (value) {\n    return LocalCollection._f._equal(elementSelector, value);\n  };\n}\nfunction everythingMatcher(docOrBranchedValues) {\n  return {\n    result: true\n  };\n}\nfunction expandArraysInBranches(branches, skipTheArrays) {\n  var branchesOut = [];\n  branches.forEach(function (branch) {\n    var thisIsArray = Array.isArray(branch.value);\n\n    // We include the branch itself, *UNLESS* we it's an array that we're going\n    // to iterate and we're told to skip arrays.  (That's right, we include some\n    // arrays even skipTheArrays is true: these are arrays that were found via\n    // explicit numerical indices.)\n    if (!(skipTheArrays && thisIsArray && !branch.dontIterate)) {\n      branchesOut.push({\n        arrayIndices: branch.arrayIndices,\n        value: branch.value\n      });\n    }\n    if (thisIsArray && !branch.dontIterate) {\n      branch.value.forEach(function (value, i) {\n        branchesOut.push({\n          arrayIndices: (branch.arrayIndices || []).concat(i),\n          value: value\n        });\n      });\n    }\n  });\n  return branchesOut;\n}\n// Helpers for $bitsAllSet/$bitsAnySet/$bitsAllClear/$bitsAnyClear.\nfunction getOperandBitmask(operand, selector) {\n  // numeric bitmask\n  // You can provide a numeric bitmask to be matched against the operand field.\n  // It must be representable as a non-negative 32-bit signed integer.\n  // Otherwise, $bitsAllSet will return an error.\n  if (Number.isInteger(operand) && operand >= 0) {\n    return new Uint8Array(new Int32Array([operand]).buffer);\n  }\n\n  // bindata bitmask\n  // You can also use an arbitrarily large BinData instance as a bitmask.\n  if (EJSON.isBinary(operand)) {\n    return new Uint8Array(operand.buffer);\n  }\n\n  // position list\n  // If querying a list of bit positions, each <position> must be a non-negative\n  // integer. Bit positions start at 0 from the least significant bit.\n  if (Array.isArray(operand) && operand.every(function (x) {\n    return Number.isInteger(x) && x >= 0;\n  })) {\n    var buffer = new ArrayBuffer((Math.max.apply(Math, _toConsumableArray(operand)) >> 3) + 1);\n    var view = new Uint8Array(buffer);\n    operand.forEach(function (x) {\n      view[x >> 3] |= 1 << (x & 0x7);\n    });\n    return view;\n  }\n\n  // bad operand\n  throw Error(\"operand to \" + selector + \" must be a numeric bitmask (representable as a \" + 'non-negative 32-bit signed integer), a bindata bitmask or an array with ' + 'bit positions (non-negative integers)');\n}\nfunction getValueBitmask(value, length) {\n  // The field value must be either numerical or a BinData instance. Otherwise,\n  // $bits... will not match the current document.\n\n  // numerical\n  if (Number.isSafeInteger(value)) {\n    // $bits... will not match numerical values that cannot be represented as a\n    // signed 64-bit integer. This can be the case if a value is either too\n    // large or small to fit in a signed 64-bit integer, or if it has a\n    // fractional component.\n    var buffer = new ArrayBuffer(Math.max(length, 2 * Uint32Array.BYTES_PER_ELEMENT));\n    var view = new Uint32Array(buffer, 0, 2);\n    view[0] = value % ((1 << 16) * (1 << 16)) | 0;\n    view[1] = value / ((1 << 16) * (1 << 16)) | 0;\n\n    // sign extension\n    if (value < 0) {\n      view = new Uint8Array(buffer, 2);\n      view.forEach(function (byte, i) {\n        view[i] = 0xff;\n      });\n    }\n    return new Uint8Array(buffer);\n  }\n\n  // bindata\n  if (EJSON.isBinary(value)) {\n    return new Uint8Array(value.buffer);\n  }\n\n  // no match\n  return false;\n}\n\n// Actually inserts a key value into the selector document\n// However, this checks there is no ambiguity in setting\n// the value for the given key, throws otherwise\nfunction insertIntoDocument(document, key, value) {\n  Object.keys(document).forEach(function (existingKey) {\n    if (existingKey.length > key.length && existingKey.indexOf(key + \".\") === 0 || key.length > existingKey.length && key.indexOf(existingKey + \".\") === 0) {\n      throw new Error(\"cannot infer query fields to set, both paths '\" + existingKey + \"' and \" + (\"'\" + key + \"' are matched\"));\n    } else if (existingKey === key) {\n      throw new Error(\"cannot infer query fields to set, path '\" + key + \"' is matched twice\");\n    }\n  });\n  document[key] = value;\n}\n\n// Returns a branched matcher that matches iff the given matcher does not.\n// Note that this implicitly \"deMorganizes\" the wrapped function.  ie, it\n// means that ALL branch values need to fail to match innerBranchedMatcher.\nfunction invertBranchedMatcher(branchedMatcher) {\n  return function (branchValues) {\n    // We explicitly choose to strip arrayIndices here: it doesn't make sense to\n    // say \"update the array element that does not match something\", at least\n    // in mongo-land.\n    return {\n      result: !branchedMatcher(branchValues).result\n    };\n  };\n}\nfunction isIndexable(obj) {\n  return Array.isArray(obj) || LocalCollection._isPlainObject(obj);\n}\nfunction isNumericKey(s) {\n  return /^[0-9]+$/.test(s);\n}\nfunction isOperatorObject(valueSelector, inconsistentOK) {\n  if (!LocalCollection._isPlainObject(valueSelector)) {\n    return false;\n  }\n  var theseAreOperators = undefined;\n  Object.keys(valueSelector).forEach(function (selKey) {\n    var thisIsOperator = selKey.substr(0, 1) === '$' || selKey === 'diff';\n    if (theseAreOperators === undefined) {\n      theseAreOperators = thisIsOperator;\n    } else if (theseAreOperators !== thisIsOperator) {\n      if (!inconsistentOK) {\n        throw new Error(\"Inconsistent operator: \" + JSON.stringify(valueSelector));\n      }\n      theseAreOperators = false;\n    }\n  });\n  return !!theseAreOperators; // {} has no operators\n}\n// Helper for $lt/$gt/$lte/$gte.\nfunction makeInequality(cmpValueComparator) {\n  return {\n    compileElementSelector: function (operand) {\n      // Arrays never compare false with non-arrays for any inequality.\n      // XXX This was behavior we observed in pre-release MongoDB 2.5, but\n      //     it seems to have been reverted.\n      //     See https://jira.mongodb.org/browse/SERVER-11444\n      if (Array.isArray(operand)) {\n        return function () {\n          return false;\n        };\n      }\n\n      // Special case: consider undefined and null the same (so true with\n      // $gte/$lte).\n      if (operand === undefined) {\n        operand = null;\n      }\n      var operandType = LocalCollection._f._type(operand);\n      return function (value) {\n        if (value === undefined) {\n          value = null;\n        }\n\n        // Comparisons are never true among things of different type (except\n        // null vs undefined).\n        if (LocalCollection._f._type(value) !== operandType) {\n          return false;\n        }\n        return cmpValueComparator(LocalCollection._f._cmp(value, operand));\n      };\n    }\n  };\n}\n\n// makeLookupFunction(key) returns a lookup function.\n//\n// A lookup function takes in a document and returns an array of matching\n// branches.  If no arrays are found while looking up the key, this array will\n// have exactly one branches (possibly 'undefined', if some segment of the key\n// was not found).\n//\n// If arrays are found in the middle, this can have more than one element, since\n// we 'branch'. When we 'branch', if there are more key segments to look up,\n// then we only pursue branches that are plain objects (not arrays or scalars).\n// This means we can actually end up with no branches!\n//\n// We do *NOT* branch on arrays that are found at the end (ie, at the last\n// dotted member of the key). We just return that array; if you want to\n// effectively 'branch' over the array's values, post-process the lookup\n// function with expandArraysInBranches.\n//\n// Each branch is an object with keys:\n//  - value: the value at the branch\n//  - dontIterate: an optional bool; if true, it means that 'value' is an array\n//    that expandArraysInBranches should NOT expand. This specifically happens\n//    when there is a numeric index in the key, and ensures the\n//    perhaps-surprising MongoDB behavior where {'a.0': 5} does NOT\n//    match {a: [[5]]}.\n//  - arrayIndices: if any array indexing was done during lookup (either due to\n//    explicit numeric indices or implicit branching), this will be an array of\n//    the array indices used, from outermost to innermost; it is falsey or\n//    absent if no array index is used. If an explicit numeric index is used,\n//    the index will be followed in arrayIndices by the string 'x'.\n//\n//    Note: arrayIndices is used for two purposes. First, it is used to\n//    implement the '$' modifier feature, which only ever looks at its first\n//    element.\n//\n//    Second, it is used for sort key generation, which needs to be able to tell\n//    the difference between different paths. Moreover, it needs to\n//    differentiate between explicit and implicit branching, which is why\n//    there's the somewhat hacky 'x' entry: this means that explicit and\n//    implicit array lookups will have different full arrayIndices paths. (That\n//    code only requires that different paths have different arrayIndices; it\n//    doesn't actually 'parse' arrayIndices. As an alternative, arrayIndices\n//    could contain objects with flags like 'implicit', but I think that only\n//    makes the code surrounding them more complex.)\n//\n//    (By the way, this field ends up getting passed around a lot without\n//    cloning, so never mutate any arrayIndices field/var in this package!)\n//\n//\n// At the top level, you may only pass in a plain object or array.\n//\n// See the test 'minimongo - lookup' for some examples of what lookup functions\n// return.\nfunction makeLookupFunction(key) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var parts = key.split('.');\n  var firstPart = parts.length ? parts[0] : '';\n  var lookupRest = parts.length > 1 && makeLookupFunction(parts.slice(1).join('.'), options);\n  function buildResult(arrayIndices, dontIterate, value) {\n    return arrayIndices && arrayIndices.length ? dontIterate ? [{\n      arrayIndices: arrayIndices,\n      dontIterate: dontIterate,\n      value: value\n    }] : [{\n      arrayIndices: arrayIndices,\n      value: value\n    }] : dontIterate ? [{\n      dontIterate: dontIterate,\n      value: value\n    }] : [{\n      value: value\n    }];\n  }\n\n  // Doc will always be a plain object or an array.\n  // apply an explicit numeric index, an array.\n  return function (doc, arrayIndices) {\n    if (Array.isArray(doc)) {\n      // If we're being asked to do an invalid lookup into an array (non-integer\n      // or out-of-bounds), return no results (which is different from returning\n      // a single undefined result, in that `null` equality checks won't match).\n      if (!(isNumericKey(firstPart) && firstPart < doc.length)) {\n        return [];\n      }\n\n      // Remember that we used this array index. Include an 'x' to indicate that\n      // the previous index came from being considered as an explicit array\n      // index (not branching).\n      arrayIndices = arrayIndices ? arrayIndices.concat(+firstPart, 'x') : [+firstPart, 'x'];\n    }\n\n    // Do our first lookup.\n    var firstLevel = doc[firstPart];\n\n    // If there is no deeper to dig, return what we found.\n    //\n    // If what we found is an array, most value selectors will choose to treat\n    // the elements of the array as matchable values in their own right, but\n    // that's done outside of the lookup function. (Exceptions to this are $size\n    // and stuff relating to $elemMatch.  eg, {a: {$size: 2}} does not match {a:\n    // [[1, 2]]}.)\n    //\n    // That said, if we just did an *explicit* array lookup (on doc) to find\n    // firstLevel, and firstLevel is an array too, we do NOT want value\n    // selectors to iterate over it.  eg, {'a.0': 5} does not match {a: [[5]]}.\n    // So in that case, we mark the return value as 'don't iterate'.\n    if (!lookupRest) {\n      return buildResult(arrayIndices, Array.isArray(doc) && Array.isArray(firstLevel), firstLevel);\n    }\n\n    // We need to dig deeper.  But if we can't, because what we've found is not\n    // an array or plain object, we're done. If we just did a numeric index into\n    // an array, we return nothing here (this is a change in Mongo 2.5 from\n    // Mongo 2.4, where {'a.0.b': null} stopped matching {a: [5]}). Otherwise,\n    // return a single `undefined` (which can, for example, match via equality\n    // with `null`).\n    if (!isIndexable(firstLevel)) {\n      if (Array.isArray(doc)) {\n        return [];\n      }\n      return buildResult(arrayIndices, false, undefined);\n    }\n    var result = [];\n    var appendToResult = function (more) {\n      result.push.apply(result, _toConsumableArray(more));\n    };\n\n    // Dig deeper: look up the rest of the parts on whatever we've found.\n    // (lookupRest is smart enough to not try to do invalid lookups into\n    // firstLevel if it's an array.)\n    appendToResult(lookupRest(firstLevel, arrayIndices));\n\n    // If we found an array, then in *addition* to potentially treating the next\n    // part as a literal integer lookup, we should also 'branch': try to look up\n    // the rest of the parts on each array element in parallel.\n    //\n    // In this case, we *only* dig deeper into array elements that are plain\n    // objects. (Recall that we only got this far if we have further to dig.)\n    // This makes sense: we certainly don't dig deeper into non-indexable\n    // objects. And it would be weird to dig into an array: it's simpler to have\n    // a rule that explicit integer indexes only apply to an outer array, not to\n    // an array you find after a branching search.\n    //\n    // In the special case of a numeric part in a *sort selector* (not a query\n    // selector), we skip the branching: we ONLY allow the numeric part to mean\n    // 'look up this index' in that case, not 'also look up this index in all\n    // the elements of the array'.\n    if (Array.isArray(firstLevel) && !(isNumericKey(parts[1]) && options.forSort)) {\n      firstLevel.forEach(function (branch, arrayIndex) {\n        if (LocalCollection._isPlainObject(branch)) {\n          appendToResult(lookupRest(branch, arrayIndices ? arrayIndices.concat(arrayIndex) : [arrayIndex]));\n        }\n      });\n    }\n    return result;\n  };\n}\n// Object exported only for unit testing.\n// Use it to export private functions to test in Tinytest.\nMinimongoTest = {\n  makeLookupFunction: makeLookupFunction\n};\nMinimongoError = function (message) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (typeof message === 'string' && options.field) {\n    message += \" for field '\" + options.field + \"'\";\n  }\n  var error = new Error(message);\n  error.name = 'MinimongoError';\n  return error;\n};\nfunction nothingMatcher(docOrBranchedValues) {\n  return {\n    result: false\n  };\n}\n// Takes an operator object (an object with $ keys) and returns a branched\n// matcher for it.\nfunction operatorBranchedMatcher(valueSelector, matcher, isRoot) {\n  // Each valueSelector works separately on the various branches.  So one\n  // operator can match one branch and another can match another branch.  This\n  // is OK.\n  var operatorMatchers = Object.keys(valueSelector).map(function (operator) {\n    var operand = valueSelector[operator];\n    var simpleRange = ['$lt', '$lte', '$gt', '$gte'].includes(operator) && typeof operand === 'number';\n    var simpleEquality = ['$ne', '$eq'].includes(operator) && operand !== Object(operand);\n    var simpleInclusion = ['$in', '$nin'].includes(operator) && Array.isArray(operand) && !operand.some(function (x) {\n      return x === Object(x);\n    });\n    if (!(simpleRange || simpleInclusion || simpleEquality)) {\n      matcher._isSimple = false;\n    }\n    if (hasOwn.call(VALUE_OPERATORS, operator)) {\n      return VALUE_OPERATORS[operator](operand, valueSelector, matcher, isRoot);\n    }\n    if (hasOwn.call(ELEMENT_OPERATORS, operator)) {\n      var options = ELEMENT_OPERATORS[operator];\n      return convertElementMatcherToBranchedMatcher(options.compileElementSelector(operand, valueSelector, matcher), options);\n    }\n    throw new Error(\"Unrecognized operator: \" + operator);\n  });\n  return andBranchedMatchers(operatorMatchers);\n}\n\n// paths - Array: list of mongo style paths\n// newLeafFn - Function: of form function(path) should return a scalar value to\n//                       put into list created for that path\n// conflictFn - Function: of form function(node, path, fullPath) is called\n//                        when building a tree path for 'fullPath' node on\n//                        'path' was already a leaf with a value. Must return a\n//                        conflict resolution.\n// initial tree - Optional Object: starting tree.\n// @returns - Object: tree represented as a set of nested objects\nfunction pathsToTree(paths, newLeafFn, conflictFn) {\n  var root = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  paths.forEach(function (path) {\n    var pathArray = path.split('.');\n    var tree = root;\n\n    // use .every just for iteration with break\n    var success = pathArray.slice(0, -1).every(function (key, i) {\n      if (!hasOwn.call(tree, key)) {\n        tree[key] = {};\n      } else if (tree[key] !== Object(tree[key])) {\n        tree[key] = conflictFn(tree[key], pathArray.slice(0, i + 1).join('.'), path);\n\n        // break out of loop if we are failing for this path\n        if (tree[key] !== Object(tree[key])) {\n          return false;\n        }\n      }\n      tree = tree[key];\n      return true;\n    });\n    if (success) {\n      var lastKey = pathArray[pathArray.length - 1];\n      if (hasOwn.call(tree, lastKey)) {\n        tree[lastKey] = conflictFn(tree[lastKey], path, path);\n      } else {\n        tree[lastKey] = newLeafFn(path);\n      }\n    }\n  });\n  return root;\n}\n// Makes sure we get 2 elements array and assume the first one to be x and\n// the second one to y no matter what user passes.\n// In case user passes { lon: x, lat: y } returns [x, y]\nfunction pointToArray(point) {\n  return Array.isArray(point) ? point.slice() : [point.x, point.y];\n}\n\n// Creating a document from an upsert is quite tricky.\n// E.g. this selector: {\"$or\": [{\"b.foo\": {\"$all\": [\"bar\"]}}]}, should result\n// in: {\"b.foo\": \"bar\"}\n// But this selector: {\"$or\": [{\"b\": {\"foo\": {\"$all\": [\"bar\"]}}}]} should throw\n// an error\n\n// Some rules (found mainly with trial & error, so there might be more):\n// - handle all childs of $and (or implicit $and)\n// - handle $or nodes with exactly 1 child\n// - ignore $or nodes with more than 1 child\n// - ignore $nor and $not nodes\n// - throw when a value can not be set unambiguously\n// - every value for $all should be dealt with as separate $eq-s\n// - threat all children of $all as $eq setters (=> set if $all.length === 1,\n//   otherwise throw error)\n// - you can not mix '$'-prefixed keys and non-'$'-prefixed keys\n// - you can only have dotted keys on a root-level\n// - you can not have '$'-prefixed keys more than one-level deep in an object\n\n// Handles one key/value pair to put in the selector document\nfunction populateDocumentWithKeyValue(document, key, value) {\n  if (value && Object.getPrototypeOf(value) === Object.prototype) {\n    populateDocumentWithObject(document, key, value);\n  } else if (!(value instanceof RegExp)) {\n    insertIntoDocument(document, key, value);\n  }\n}\n\n// Handles a key, value pair to put in the selector document\n// if the value is an object\nfunction populateDocumentWithObject(document, key, value) {\n  var keys = Object.keys(value);\n  var unprefixedKeys = keys.filter(function (op) {\n    return op[0] !== '$';\n  });\n  if (unprefixedKeys.length > 0 || !keys.length) {\n    // Literal (possibly empty) object ( or empty object )\n    // Don't allow mixing '$'-prefixed with non-'$'-prefixed fields\n    if (keys.length !== unprefixedKeys.length) {\n      throw new Error(\"unknown operator: \" + unprefixedKeys[0]);\n    }\n    validateObject(value, key);\n    insertIntoDocument(document, key, value);\n  } else {\n    Object.keys(value).forEach(function (op) {\n      var object = value[op];\n      if (op === '$eq') {\n        populateDocumentWithKeyValue(document, key, object);\n      } else if (op === '$all') {\n        // every value for $all should be dealt with as separate $eq-s\n        object.forEach(function (element) {\n          return populateDocumentWithKeyValue(document, key, element);\n        });\n      }\n    });\n  }\n}\n\n// Fills a document with certain fields from an upsert selector\nfunction populateDocumentWithQueryFields(query) {\n  var document = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (Object.getPrototypeOf(query) === Object.prototype) {\n    // handle implicit $and\n    Object.keys(query).forEach(function (key) {\n      var value = query[key];\n      if (key === '$and') {\n        // handle explicit $and\n        value.forEach(function (element) {\n          return populateDocumentWithQueryFields(element, document);\n        });\n      } else if (key === '$or') {\n        // handle $or nodes with exactly 1 child\n        if (value.length === 1) {\n          populateDocumentWithQueryFields(value[0], document);\n        }\n      } else if (key[0] !== '$') {\n        // Ignore other '$'-prefixed logical selectors\n        populateDocumentWithKeyValue(document, key, value);\n      }\n    });\n  } else {\n    // Handle meteor-specific shortcut for selecting _id\n    if (LocalCollection._selectorIsId(query)) {\n      insertIntoDocument(document, '_id', query);\n    }\n  }\n  return document;\n}\nfunction projectionDetails(fields) {\n  // Find the non-_id keys (_id is handled specially because it is included\n  // unless explicitly excluded). Sort the keys, so that our code to detect\n  // overlaps like 'foo' and 'foo.bar' can assume that 'foo' comes first.\n  var fieldsKeys = Object.keys(fields).sort();\n\n  // If _id is the only field in the projection, do not remove it, since it is\n  // required to determine if this is an exclusion or exclusion. Also keep an\n  // inclusive _id, since inclusive _id follows the normal rules about mixing\n  // inclusive and exclusive fields. If _id is not the only field in the\n  // projection and is exclusive, remove it so it can be handled later by a\n  // special case, since exclusive _id is always allowed.\n  if (!(fieldsKeys.length === 1 && fieldsKeys[0] === '_id') && !(fieldsKeys.includes('_id') && fields._id)) {\n    fieldsKeys = fieldsKeys.filter(function (key) {\n      return key !== '_id';\n    });\n  }\n  var including = null; // Unknown\n\n  fieldsKeys.forEach(function (keyPath) {\n    var rule = !!fields[keyPath];\n    if (including === null) {\n      including = rule;\n    }\n\n    // This error message is copied from MongoDB shell\n    if (including !== rule) {\n      throw MinimongoError('You cannot currently mix including and excluding fields.');\n    }\n  });\n  var projectionRulesTree = pathsToTree(fieldsKeys, function (path) {\n    return including;\n  }, function (node, path, fullPath) {\n    // Check passed projection fields' keys: If you have two rules such as\n    // 'foo.bar' and 'foo.bar.baz', then the result becomes ambiguous. If\n    // that happens, there is a probability you are doing something wrong,\n    // framework should notify you about such mistake earlier on cursor\n    // compilation step than later during runtime.  Note, that real mongo\n    // doesn't do anything about it and the later rule appears in projection\n    // project, more priority it takes.\n    //\n    // Example, assume following in mongo shell:\n    // > db.coll.insert({ a: { b: 23, c: 44 } })\n    // > db.coll.find({}, { 'a': 1, 'a.b': 1 })\n    // {\"_id\": ObjectId(\"520bfe456024608e8ef24af3\"), \"a\": {\"b\": 23}}\n    // > db.coll.find({}, { 'a.b': 1, 'a': 1 })\n    // {\"_id\": ObjectId(\"520bfe456024608e8ef24af3\"), \"a\": {\"b\": 23, \"c\": 44}}\n    //\n    // Note, how second time the return set of keys is different.\n    var currentPath = fullPath;\n    var anotherPath = path;\n    throw MinimongoError(\"both \" + currentPath + \" and \" + anotherPath + \" found in fields option, \" + 'using both of them may trigger unexpected behavior. Did you mean to ' + 'use only one of them?');\n  });\n  return {\n    including: including,\n    tree: projectionRulesTree\n  };\n}\nfunction regexpElementMatcher(regexp) {\n  return function (value) {\n    if (value instanceof RegExp) {\n      return value.toString() === regexp.toString();\n    }\n\n    // Regexps only work against strings.\n    if (typeof value !== 'string') {\n      return false;\n    }\n\n    // Reset regexp's state to avoid inconsistent matching for objects with the\n    // same value on consecutive calls of regexp.test. This happens only if the\n    // regexp has the 'g' flag. Also note that ES6 introduces a new flag 'y' for\n    // which we should *not* change the lastIndex but MongoDB doesn't support\n    // either of these flags.\n    regexp.lastIndex = 0;\n    return regexp.test(value);\n  };\n}\n// Validates the key in a path.\n// Objects that are nested more then 1 level cannot have dotted fields\n// or fields starting with '$'\nfunction validateKeyInPath(key, path) {\n  if (key.includes('.')) {\n    throw new Error(\"The dotted field '\" + key + \"' in '\" + path + \".\" + key + \" is not valid for storage.\");\n  }\n  if (key[0] === '$') {\n    throw new Error(\"The dollar ($) prefixed field  '\" + path + \".\" + key + \" is not valid for storage.\");\n  }\n}\n\n// Recursively validates an object that is nested more than one level deep\nfunction validateObject(object, path) {\n  if (object && Object.getPrototypeOf(object) === Object.prototype) {\n    Object.keys(object).forEach(function (key) {\n      validateKeyInPath(key, path);\n      validateObject(object[key], path + '.' + key);\n    });\n  }\n}","map":{"version":3,"names":["_toConsumableArray","module","link","default","v","_typeof","export","hasOwn","ELEMENT_OPERATORS","compileDocumentSelector","equalityElementMatcher","expandArraysInBranches","isIndexable","isNumericKey","isOperatorObject","makeLookupFunction","nothingMatcher","pathsToTree","populateDocumentWithQueryFields","projectionDetails","regexpElementMatcher","LocalCollection","Object","prototype","hasOwnProperty","$lt","makeInequality","cmpValue","$gt","$lte","$gte","$mod","compileElementSelector","operand","Array","isArray","length","Error","divisor","remainder","value","$in","elementMatchers","map","option","RegExp","undefined","some","matcher","$size","dontExpandLeafArrays","$type","dontIncludeLeafArrays","operandAliasMap","call","_f","_type","$bitsAllSet","mask","getOperandBitmask","bitmask","getValueBitmask","every","byte","i","$bitsAnySet","$bitsAllClear","$bitsAnyClear","$regex","valueSelector","regexp","$options","test","source","$elemMatch","_isPlainObject","isDocMatcher","keys","filter","key","LOGICAL_OPERATORS","reduce","a","b","_Object$assign","assign","subMatcher","inElemMatch","compileValueSelector","arrayElement","arg","dontIterate","result","$and","subSelector","andDocumentMatchers","compileArrayOfDocumentSelectors","$or","matchers","doc","fn","$nor","$where","selectorValue","_recordPathUsed","_hasWhere","Function","$comment","VALUE_OPERATORS","$eq","convertElementMatcherToBranchedMatcher","$not","invertBranchedMatcher","$ne","$nin","$exists","exists","everythingMatcher","$maxDistance","$near","$all","branchedMatchers","criterion","andBranchedMatchers","isRoot","_hasGeoQuery","maxDistance","point","distance","$geometry","type","GeoJSON","pointDistance","coordinates","pointToArray","geometryWithinRadius","distanceCoordinatePairs","branchedValues","branch","curDistance","_isUpdate","arrayIndices","andSomeMatchers","subMatchers","docOrBranches","match","subResult","selectors","docSelector","options","arguments","docMatchers","substr","_isSimple","lookUpByIndex","valueMatcher","Boolean","operatorBranchedMatcher","elementMatcher","branches","expanded","element","matched","pointA","pointB","Math","hypot","elementSelector","_equal","docOrBranchedValues","skipTheArrays","branchesOut","forEach","thisIsArray","push","concat","selector","Number","isInteger","Uint8Array","Int32Array","buffer","EJSON","isBinary","x","ArrayBuffer","max","apply","view","isSafeInteger","Uint32Array","BYTES_PER_ELEMENT","insertIntoDocument","document","existingKey","indexOf","branchedMatcher","branchValues","obj","s","inconsistentOK","theseAreOperators","selKey","thisIsOperator","JSON","stringify","cmpValueComparator","operandType","_cmp","parts","split","firstPart","lookupRest","slice","join","buildResult","firstLevel","appendToResult","more","forSort","arrayIndex","MinimongoTest","MinimongoError","message","field","error","name","operatorMatchers","operator","simpleRange","includes","simpleEquality","simpleInclusion","paths","newLeafFn","conflictFn","root","path","pathArray","tree","success","lastKey","y","populateDocumentWithKeyValue","getPrototypeOf","populateDocumentWithObject","unprefixedKeys","op","validateObject","object","query","_selectorIsId","fields","fieldsKeys","sort","_id","including","keyPath","rule","projectionRulesTree","node","fullPath","currentPath","anotherPath","toString","lastIndex","validateKeyInPath"],"sources":["packages/minimongo/common.js"],"sourcesContent":["import LocalCollection from './local_collection.js';\n\nexport const hasOwn = Object.prototype.hasOwnProperty;\n\n// Each element selector contains:\n//  - compileElementSelector, a function with args:\n//    - operand - the \"right hand side\" of the operator\n//    - valueSelector - the \"context\" for the operator (so that $regex can find\n//      $options)\n//    - matcher - the Matcher this is going into (so that $elemMatch can compile\n//      more things)\n//    returning a function mapping a single value to bool.\n//  - dontExpandLeafArrays, a bool which prevents expandArraysInBranches from\n//    being called\n//  - dontIncludeLeafArrays, a bool which causes an argument to be passed to\n//    expandArraysInBranches if it is called\nexport const ELEMENT_OPERATORS = {\n  $lt: makeInequality(cmpValue => cmpValue < 0),\n  $gt: makeInequality(cmpValue => cmpValue > 0),\n  $lte: makeInequality(cmpValue => cmpValue <= 0),\n  $gte: makeInequality(cmpValue => cmpValue >= 0),\n  $mod: {\n    compileElementSelector(operand) {\n      if (!(Array.isArray(operand) && operand.length === 2\n            && typeof operand[0] === 'number'\n            && typeof operand[1] === 'number')) {\n        throw Error('argument to $mod must be an array of two numbers');\n      }\n\n      // XXX could require to be ints or round or something\n      const divisor = operand[0];\n      const remainder = operand[1];\n      return value => (\n        typeof value === 'number' && value % divisor === remainder\n      );\n    },\n  },\n  $in: {\n    compileElementSelector(operand) {\n      if (!Array.isArray(operand)) {\n        throw Error('$in needs an array');\n      }\n\n      const elementMatchers = operand.map(option => {\n        if (option instanceof RegExp) {\n          return regexpElementMatcher(option);\n        }\n\n        if (isOperatorObject(option)) {\n          throw Error('cannot nest $ under $in');\n        }\n\n        return equalityElementMatcher(option);\n      });\n\n      return value => {\n        // Allow {a: {$in: [null]}} to match when 'a' does not exist.\n        if (value === undefined) {\n          value = null;\n        }\n\n        return elementMatchers.some(matcher => matcher(value));\n      };\n    },\n  },\n  $size: {\n    // {a: [[5, 5]]} must match {a: {$size: 1}} but not {a: {$size: 2}}, so we\n    // don't want to consider the element [5,5] in the leaf array [[5,5]] as a\n    // possible value.\n    dontExpandLeafArrays: true,\n    compileElementSelector(operand) {\n      if (typeof operand === 'string') {\n        // Don't ask me why, but by experimentation, this seems to be what Mongo\n        // does.\n        operand = 0;\n      } else if (typeof operand !== 'number') {\n        throw Error('$size needs a number');\n      }\n\n      return value => Array.isArray(value) && value.length === operand;\n    },\n  },\n  $type: {\n    // {a: [5]} must not match {a: {$type: 4}} (4 means array), but it should\n    // match {a: {$type: 1}} (1 means number), and {a: [[5]]} must match {$a:\n    // {$type: 4}}. Thus, when we see a leaf array, we *should* expand it but\n    // should *not* include it itself.\n    dontIncludeLeafArrays: true,\n    compileElementSelector(operand) {\n      if (typeof operand === 'string') {\n        const operandAliasMap = {\n          'double': 1,\n          'string': 2,\n          'object': 3,\n          'array': 4,\n          'binData': 5,\n          'undefined': 6,\n          'objectId': 7,\n          'bool': 8,\n          'date': 9,\n          'null': 10,\n          'regex': 11,\n          'dbPointer': 12,\n          'javascript': 13,\n          'symbol': 14,\n          'javascriptWithScope': 15,\n          'int': 16,\n          'timestamp': 17,\n          'long': 18,\n          'decimal': 19,\n          'minKey': -1,\n          'maxKey': 127,\n        };\n        if (!hasOwn.call(operandAliasMap, operand)) {\n          throw Error(`unknown string alias for $type: ${operand}`);\n        }\n        operand = operandAliasMap[operand];\n      } else if (typeof operand === 'number') {\n        if (operand === 0 || operand < -1\n          || (operand > 19 && operand !== 127)) {\n          throw Error(`Invalid numerical $type code: ${operand}`);\n        }\n      } else {\n        throw Error('argument to $type is not a number or a string');\n      }\n\n      return value => (\n        value !== undefined && LocalCollection._f._type(value) === operand\n      );\n    },\n  },\n  $bitsAllSet: {\n    compileElementSelector(operand) {\n      const mask = getOperandBitmask(operand, '$bitsAllSet');\n      return value => {\n        const bitmask = getValueBitmask(value, mask.length);\n        return bitmask && mask.every((byte, i) => (bitmask[i] & byte) === byte);\n      };\n    },\n  },\n  $bitsAnySet: {\n    compileElementSelector(operand) {\n      const mask = getOperandBitmask(operand, '$bitsAnySet');\n      return value => {\n        const bitmask = getValueBitmask(value, mask.length);\n        return bitmask && mask.some((byte, i) => (~bitmask[i] & byte) !== byte);\n      };\n    },\n  },\n  $bitsAllClear: {\n    compileElementSelector(operand) {\n      const mask = getOperandBitmask(operand, '$bitsAllClear');\n      return value => {\n        const bitmask = getValueBitmask(value, mask.length);\n        return bitmask && mask.every((byte, i) => !(bitmask[i] & byte));\n      };\n    },\n  },\n  $bitsAnyClear: {\n    compileElementSelector(operand) {\n      const mask = getOperandBitmask(operand, '$bitsAnyClear');\n      return value => {\n        const bitmask = getValueBitmask(value, mask.length);\n        return bitmask && mask.some((byte, i) => (bitmask[i] & byte) !== byte);\n      };\n    },\n  },\n  $regex: {\n    compileElementSelector(operand, valueSelector) {\n      if (!(typeof operand === 'string' || operand instanceof RegExp)) {\n        throw Error('$regex has to be a string or RegExp');\n      }\n\n      let regexp;\n      if (valueSelector.$options !== undefined) {\n        // Options passed in $options (even the empty string) always overrides\n        // options in the RegExp object itself.\n\n        // Be clear that we only support the JS-supported options, not extended\n        // ones (eg, Mongo supports x and s). Ideally we would implement x and s\n        // by transforming the regexp, but not today...\n        if (/[^gim]/.test(valueSelector.$options)) {\n          throw new Error('Only the i, m, and g regexp options are supported');\n        }\n\n        const source = operand instanceof RegExp ? operand.source : operand;\n        regexp = new RegExp(source, valueSelector.$options);\n      } else if (operand instanceof RegExp) {\n        regexp = operand;\n      } else {\n        regexp = new RegExp(operand);\n      }\n\n      return regexpElementMatcher(regexp);\n    },\n  },\n  $elemMatch: {\n    dontExpandLeafArrays: true,\n    compileElementSelector(operand, valueSelector, matcher) {\n      if (!LocalCollection._isPlainObject(operand)) {\n        throw Error('$elemMatch need an object');\n      }\n\n      const isDocMatcher = !isOperatorObject(\n        Object.keys(operand)\n          .filter(key => !hasOwn.call(LOGICAL_OPERATORS, key))\n          .reduce((a, b) => Object.assign(a, {[b]: operand[b]}), {}),\n        true);\n\n      let subMatcher;\n      if (isDocMatcher) {\n        // This is NOT the same as compileValueSelector(operand), and not just\n        // because of the slightly different calling convention.\n        // {$elemMatch: {x: 3}} means \"an element has a field x:3\", not\n        // \"consists only of a field x:3\". Also, regexps and sub-$ are allowed.\n        subMatcher =\n          compileDocumentSelector(operand, matcher, {inElemMatch: true});\n      } else {\n        subMatcher = compileValueSelector(operand, matcher);\n      }\n\n      return value => {\n        if (!Array.isArray(value)) {\n          return false;\n        }\n\n        for (let i = 0; i < value.length; ++i) {\n          const arrayElement = value[i];\n          let arg;\n          if (isDocMatcher) {\n            // We can only match {$elemMatch: {b: 3}} against objects.\n            // (We can also match against arrays, if there's numeric indices,\n            // eg {$elemMatch: {'0.b': 3}} or {$elemMatch: {0: 3}}.)\n            if (!isIndexable(arrayElement)) {\n              return false;\n            }\n\n            arg = arrayElement;\n          } else {\n            // dontIterate ensures that {a: {$elemMatch: {$gt: 5}}} matches\n            // {a: [8]} but not {a: [[8]]}\n            arg = [{value: arrayElement, dontIterate: true}];\n          }\n          // XXX support $near in $elemMatch by propagating $distance?\n          if (subMatcher(arg).result) {\n            return i; // specially understood to mean \"use as arrayIndices\"\n          }\n        }\n\n        return false;\n      };\n    },\n  },\n};\n\n// Operators that appear at the top level of a document selector.\nconst LOGICAL_OPERATORS = {\n  $and(subSelector, matcher, inElemMatch) {\n    return andDocumentMatchers(\n      compileArrayOfDocumentSelectors(subSelector, matcher, inElemMatch)\n    );\n  },\n\n  $or(subSelector, matcher, inElemMatch) {\n    const matchers = compileArrayOfDocumentSelectors(\n      subSelector,\n      matcher,\n      inElemMatch\n    );\n\n    // Special case: if there is only one matcher, use it directly, *preserving*\n    // any arrayIndices it returns.\n    if (matchers.length === 1) {\n      return matchers[0];\n    }\n\n    return doc => {\n      const result = matchers.some(fn => fn(doc).result);\n      // $or does NOT set arrayIndices when it has multiple\n      // sub-expressions. (Tested against MongoDB.)\n      return {result};\n    };\n  },\n\n  $nor(subSelector, matcher, inElemMatch) {\n    const matchers = compileArrayOfDocumentSelectors(\n      subSelector,\n      matcher,\n      inElemMatch\n    );\n    return doc => {\n      const result = matchers.every(fn => !fn(doc).result);\n      // Never set arrayIndices, because we only match if nothing in particular\n      // 'matched' (and because this is consistent with MongoDB).\n      return {result};\n    };\n  },\n\n  $where(selectorValue, matcher) {\n    // Record that *any* path may be used.\n    matcher._recordPathUsed('');\n    matcher._hasWhere = true;\n\n    if (!(selectorValue instanceof Function)) {\n      // XXX MongoDB seems to have more complex logic to decide where or or not\n      // to add 'return'; not sure exactly what it is.\n      selectorValue = Function('obj', `return ${selectorValue}`);\n    }\n\n    // We make the document available as both `this` and `obj`.\n    // // XXX not sure what we should do if this throws\n    return doc => ({result: selectorValue.call(doc, doc)});\n  },\n\n  // This is just used as a comment in the query (in MongoDB, it also ends up in\n  // query logs); it has no effect on the actual selection.\n  $comment() {\n    return () => ({result: true});\n  },\n};\n\n// Operators that (unlike LOGICAL_OPERATORS) pertain to individual paths in a\n// document, but (unlike ELEMENT_OPERATORS) do not have a simple definition as\n// \"match each branched value independently and combine with\n// convertElementMatcherToBranchedMatcher\".\nconst VALUE_OPERATORS = {\n  $eq(operand) {\n    return convertElementMatcherToBranchedMatcher(\n      equalityElementMatcher(operand)\n    );\n  },\n  $not(operand, valueSelector, matcher) {\n    return invertBranchedMatcher(compileValueSelector(operand, matcher));\n  },\n  $ne(operand) {\n    return invertBranchedMatcher(\n      convertElementMatcherToBranchedMatcher(equalityElementMatcher(operand))\n    );\n  },\n  $nin(operand) {\n    return invertBranchedMatcher(\n      convertElementMatcherToBranchedMatcher(\n        ELEMENT_OPERATORS.$in.compileElementSelector(operand)\n      )\n    );\n  },\n  $exists(operand) {\n    const exists = convertElementMatcherToBranchedMatcher(\n      value => value !== undefined\n    );\n    return operand ? exists : invertBranchedMatcher(exists);\n  },\n  // $options just provides options for $regex; its logic is inside $regex\n  $options(operand, valueSelector) {\n    if (!hasOwn.call(valueSelector, '$regex')) {\n      throw Error('$options needs a $regex');\n    }\n\n    return everythingMatcher;\n  },\n  // $maxDistance is basically an argument to $near\n  $maxDistance(operand, valueSelector) {\n    if (!valueSelector.$near) {\n      throw Error('$maxDistance needs a $near');\n    }\n\n    return everythingMatcher;\n  },\n  $all(operand, valueSelector, matcher) {\n    if (!Array.isArray(operand)) {\n      throw Error('$all requires array');\n    }\n\n    // Not sure why, but this seems to be what MongoDB does.\n    if (operand.length === 0) {\n      return nothingMatcher;\n    }\n\n    const branchedMatchers = operand.map(criterion => {\n      // XXX handle $all/$elemMatch combination\n      if (isOperatorObject(criterion)) {\n        throw Error('no $ expressions in $all');\n      }\n\n      // This is always a regexp or equality selector.\n      return compileValueSelector(criterion, matcher);\n    });\n\n    // andBranchedMatchers does NOT require all selectors to return true on the\n    // SAME branch.\n    return andBranchedMatchers(branchedMatchers);\n  },\n  $near(operand, valueSelector, matcher, isRoot) {\n    if (!isRoot) {\n      throw Error('$near can\\'t be inside another $ operator');\n    }\n\n    matcher._hasGeoQuery = true;\n\n    // There are two kinds of geodata in MongoDB: legacy coordinate pairs and\n    // GeoJSON. They use different distance metrics, too. GeoJSON queries are\n    // marked with a $geometry property, though legacy coordinates can be\n    // matched using $geometry.\n    let maxDistance, point, distance;\n    if (LocalCollection._isPlainObject(operand) && hasOwn.call(operand, '$geometry')) {\n      // GeoJSON \"2dsphere\" mode.\n      maxDistance = operand.$maxDistance;\n      point = operand.$geometry;\n      distance = value => {\n        // XXX: for now, we don't calculate the actual distance between, say,\n        // polygon and circle. If people care about this use-case it will get\n        // a priority.\n        if (!value) {\n          return null;\n        }\n\n        if (!value.type) {\n          return GeoJSON.pointDistance(\n            point,\n            {type: 'Point', coordinates: pointToArray(value)}\n          );\n        }\n\n        if (value.type === 'Point') {\n          return GeoJSON.pointDistance(point, value);\n        }\n\n        return GeoJSON.geometryWithinRadius(value, point, maxDistance)\n          ? 0\n          : maxDistance + 1;\n      };\n    } else {\n      maxDistance = valueSelector.$maxDistance;\n\n      if (!isIndexable(operand)) {\n        throw Error('$near argument must be coordinate pair or GeoJSON');\n      }\n\n      point = pointToArray(operand);\n\n      distance = value => {\n        if (!isIndexable(value)) {\n          return null;\n        }\n\n        return distanceCoordinatePairs(point, value);\n      };\n    }\n\n    return branchedValues => {\n      // There might be multiple points in the document that match the given\n      // field. Only one of them needs to be within $maxDistance, but we need to\n      // evaluate all of them and use the nearest one for the implicit sort\n      // specifier. (That's why we can't just use ELEMENT_OPERATORS here.)\n      //\n      // Note: This differs from MongoDB's implementation, where a document will\n      // actually show up *multiple times* in the result set, with one entry for\n      // each within-$maxDistance branching point.\n      const result = {result: false};\n      expandArraysInBranches(branchedValues).every(branch => {\n        // if operation is an update, don't skip branches, just return the first\n        // one (#3599)\n        let curDistance;\n        if (!matcher._isUpdate) {\n          if (!(typeof branch.value === 'object')) {\n            return true;\n          }\n\n          curDistance = distance(branch.value);\n\n          // Skip branches that aren't real points or are too far away.\n          if (curDistance === null || curDistance > maxDistance) {\n            return true;\n          }\n\n          // Skip anything that's a tie.\n          if (result.distance !== undefined && result.distance <= curDistance) {\n            return true;\n          }\n        }\n\n        result.result = true;\n        result.distance = curDistance;\n\n        if (branch.arrayIndices) {\n          result.arrayIndices = branch.arrayIndices;\n        } else {\n          delete result.arrayIndices;\n        }\n\n        return !matcher._isUpdate;\n      });\n\n      return result;\n    };\n  },\n};\n\n// NB: We are cheating and using this function to implement 'AND' for both\n// 'document matchers' and 'branched matchers'. They both return result objects\n// but the argument is different: for the former it's a whole doc, whereas for\n// the latter it's an array of 'branched values'.\nfunction andSomeMatchers(subMatchers) {\n  if (subMatchers.length === 0) {\n    return everythingMatcher;\n  }\n\n  if (subMatchers.length === 1) {\n    return subMatchers[0];\n  }\n\n  return docOrBranches => {\n    const match = {};\n    match.result = subMatchers.every(fn => {\n      const subResult = fn(docOrBranches);\n\n      // Copy a 'distance' number out of the first sub-matcher that has\n      // one. Yes, this means that if there are multiple $near fields in a\n      // query, something arbitrary happens; this appears to be consistent with\n      // Mongo.\n      if (subResult.result &&\n          subResult.distance !== undefined &&\n          match.distance === undefined) {\n        match.distance = subResult.distance;\n      }\n\n      // Similarly, propagate arrayIndices from sub-matchers... but to match\n      // MongoDB behavior, this time the *last* sub-matcher with arrayIndices\n      // wins.\n      if (subResult.result && subResult.arrayIndices) {\n        match.arrayIndices = subResult.arrayIndices;\n      }\n\n      return subResult.result;\n    });\n\n    // If we didn't actually match, forget any extra metadata we came up with.\n    if (!match.result) {\n      delete match.distance;\n      delete match.arrayIndices;\n    }\n\n    return match;\n  };\n}\n\nconst andDocumentMatchers = andSomeMatchers;\nconst andBranchedMatchers = andSomeMatchers;\n\nfunction compileArrayOfDocumentSelectors(selectors, matcher, inElemMatch) {\n  if (!Array.isArray(selectors) || selectors.length === 0) {\n    throw Error('$and/$or/$nor must be nonempty array');\n  }\n\n  return selectors.map(subSelector => {\n    if (!LocalCollection._isPlainObject(subSelector)) {\n      throw Error('$or/$and/$nor entries need to be full objects');\n    }\n\n    return compileDocumentSelector(subSelector, matcher, {inElemMatch});\n  });\n}\n\n// Takes in a selector that could match a full document (eg, the original\n// selector). Returns a function mapping document->result object.\n//\n// matcher is the Matcher object we are compiling.\n//\n// If this is the root document selector (ie, not wrapped in $and or the like),\n// then isRoot is true. (This is used by $near.)\nexport function compileDocumentSelector(docSelector, matcher, options = {}) {\n  const docMatchers = Object.keys(docSelector).map(key => {\n    const subSelector = docSelector[key];\n\n    if (key.substr(0, 1) === '$') {\n      // Outer operators are either logical operators (they recurse back into\n      // this function), or $where.\n      if (!hasOwn.call(LOGICAL_OPERATORS, key)) {\n        throw new Error(`Unrecognized logical operator: ${key}`);\n      }\n\n      matcher._isSimple = false;\n      return LOGICAL_OPERATORS[key](subSelector, matcher, options.inElemMatch);\n    }\n\n    // Record this path, but only if we aren't in an elemMatcher, since in an\n    // elemMatch this is a path inside an object in an array, not in the doc\n    // root.\n    if (!options.inElemMatch) {\n      matcher._recordPathUsed(key);\n    }\n\n    // Don't add a matcher if subSelector is a function -- this is to match\n    // the behavior of Meteor on the server (inherited from the node mongodb\n    // driver), which is to ignore any part of a selector which is a function.\n    if (typeof subSelector === 'function') {\n      return undefined;\n    }\n\n    const lookUpByIndex = makeLookupFunction(key);\n    const valueMatcher = compileValueSelector(\n      subSelector,\n      matcher,\n      options.isRoot\n    );\n\n    return doc => valueMatcher(lookUpByIndex(doc));\n  }).filter(Boolean);\n\n  return andDocumentMatchers(docMatchers);\n}\n\n// Takes in a selector that could match a key-indexed value in a document; eg,\n// {$gt: 5, $lt: 9}, or a regular expression, or any non-expression object (to\n// indicate equality).  Returns a branched matcher: a function mapping\n// [branched value]->result object.\nfunction compileValueSelector(valueSelector, matcher, isRoot) {\n  if (valueSelector instanceof RegExp) {\n    matcher._isSimple = false;\n    return convertElementMatcherToBranchedMatcher(\n      regexpElementMatcher(valueSelector)\n    );\n  }\n\n  if (isOperatorObject(valueSelector)) {\n    return operatorBranchedMatcher(valueSelector, matcher, isRoot);\n  }\n\n  return convertElementMatcherToBranchedMatcher(\n    equalityElementMatcher(valueSelector)\n  );\n}\n\n// Given an element matcher (which evaluates a single value), returns a branched\n// value (which evaluates the element matcher on all the branches and returns a\n// more structured return value possibly including arrayIndices).\nfunction convertElementMatcherToBranchedMatcher(elementMatcher, options = {}) {\n  return branches => {\n    const expanded = options.dontExpandLeafArrays\n      ? branches\n      : expandArraysInBranches(branches, options.dontIncludeLeafArrays);\n\n    const match = {};\n    match.result = expanded.some(element => {\n      let matched = elementMatcher(element.value);\n\n      // Special case for $elemMatch: it means \"true, and use this as an array\n      // index if I didn't already have one\".\n      if (typeof matched === 'number') {\n        // XXX This code dates from when we only stored a single array index\n        // (for the outermost array). Should we be also including deeper array\n        // indices from the $elemMatch match?\n        if (!element.arrayIndices) {\n          element.arrayIndices = [matched];\n        }\n\n        matched = true;\n      }\n\n      // If some element matched, and it's tagged with array indices, include\n      // those indices in our result object.\n      if (matched && element.arrayIndices) {\n        match.arrayIndices = element.arrayIndices;\n      }\n\n      return matched;\n    });\n\n    return match;\n  };\n}\n\n// Helpers for $near.\nfunction distanceCoordinatePairs(a, b) {\n  const pointA = pointToArray(a);\n  const pointB = pointToArray(b);\n\n  return Math.hypot(pointA[0] - pointB[0], pointA[1] - pointB[1]);\n}\n\n// Takes something that is not an operator object and returns an element matcher\n// for equality with that thing.\nexport function equalityElementMatcher(elementSelector) {\n  if (isOperatorObject(elementSelector)) {\n    throw Error('Can\\'t create equalityValueSelector for operator object');\n  }\n\n  // Special-case: null and undefined are equal (if you got undefined in there\n  // somewhere, or if you got it due to some branch being non-existent in the\n  // weird special case), even though they aren't with EJSON.equals.\n  // undefined or null\n  if (elementSelector == null) {\n    return value => value == null;\n  }\n\n  return value => LocalCollection._f._equal(elementSelector, value);\n}\n\nfunction everythingMatcher(docOrBranchedValues) {\n  return {result: true};\n}\n\nexport function expandArraysInBranches(branches, skipTheArrays) {\n  const branchesOut = [];\n\n  branches.forEach(branch => {\n    const thisIsArray = Array.isArray(branch.value);\n\n    // We include the branch itself, *UNLESS* we it's an array that we're going\n    // to iterate and we're told to skip arrays.  (That's right, we include some\n    // arrays even skipTheArrays is true: these are arrays that were found via\n    // explicit numerical indices.)\n    if (!(skipTheArrays && thisIsArray && !branch.dontIterate)) {\n      branchesOut.push({arrayIndices: branch.arrayIndices, value: branch.value});\n    }\n\n    if (thisIsArray && !branch.dontIterate) {\n      branch.value.forEach((value, i) => {\n        branchesOut.push({\n          arrayIndices: (branch.arrayIndices || []).concat(i),\n          value\n        });\n      });\n    }\n  });\n\n  return branchesOut;\n}\n\n// Helpers for $bitsAllSet/$bitsAnySet/$bitsAllClear/$bitsAnyClear.\nfunction getOperandBitmask(operand, selector) {\n  // numeric bitmask\n  // You can provide a numeric bitmask to be matched against the operand field.\n  // It must be representable as a non-negative 32-bit signed integer.\n  // Otherwise, $bitsAllSet will return an error.\n  if (Number.isInteger(operand) && operand >= 0) {\n    return new Uint8Array(new Int32Array([operand]).buffer);\n  }\n\n  // bindata bitmask\n  // You can also use an arbitrarily large BinData instance as a bitmask.\n  if (EJSON.isBinary(operand)) {\n    return new Uint8Array(operand.buffer);\n  }\n\n  // position list\n  // If querying a list of bit positions, each <position> must be a non-negative\n  // integer. Bit positions start at 0 from the least significant bit.\n  if (Array.isArray(operand) &&\n      operand.every(x => Number.isInteger(x) && x >= 0)) {\n    const buffer = new ArrayBuffer((Math.max(...operand) >> 3) + 1);\n    const view = new Uint8Array(buffer);\n\n    operand.forEach(x => {\n      view[x >> 3] |= 1 << (x & 0x7);\n    });\n\n    return view;\n  }\n\n  // bad operand\n  throw Error(\n    `operand to ${selector} must be a numeric bitmask (representable as a ` +\n    'non-negative 32-bit signed integer), a bindata bitmask or an array with ' +\n    'bit positions (non-negative integers)'\n  );\n}\n\nfunction getValueBitmask(value, length) {\n  // The field value must be either numerical or a BinData instance. Otherwise,\n  // $bits... will not match the current document.\n\n  // numerical\n  if (Number.isSafeInteger(value)) {\n    // $bits... will not match numerical values that cannot be represented as a\n    // signed 64-bit integer. This can be the case if a value is either too\n    // large or small to fit in a signed 64-bit integer, or if it has a\n    // fractional component.\n    const buffer = new ArrayBuffer(\n      Math.max(length, 2 * Uint32Array.BYTES_PER_ELEMENT)\n    );\n\n    let view = new Uint32Array(buffer, 0, 2);\n    view[0] = value % ((1 << 16) * (1 << 16)) | 0;\n    view[1] = value / ((1 << 16) * (1 << 16)) | 0;\n\n    // sign extension\n    if (value < 0) {\n      view = new Uint8Array(buffer, 2);\n      view.forEach((byte, i) => {\n        view[i] = 0xff;\n      });\n    }\n\n    return new Uint8Array(buffer);\n  }\n\n  // bindata\n  if (EJSON.isBinary(value)) {\n    return new Uint8Array(value.buffer);\n  }\n\n  // no match\n  return false;\n}\n\n// Actually inserts a key value into the selector document\n// However, this checks there is no ambiguity in setting\n// the value for the given key, throws otherwise\nfunction insertIntoDocument(document, key, value) {\n  Object.keys(document).forEach(existingKey => {\n    if (\n      (existingKey.length > key.length && existingKey.indexOf(`${key}.`) === 0) ||\n      (key.length > existingKey.length && key.indexOf(`${existingKey}.`) === 0)\n    ) {\n      throw new Error(\n        `cannot infer query fields to set, both paths '${existingKey}' and ` +\n        `'${key}' are matched`\n      );\n    } else if (existingKey === key) {\n      throw new Error(\n        `cannot infer query fields to set, path '${key}' is matched twice`\n      );\n    }\n  });\n\n  document[key] = value;\n}\n\n// Returns a branched matcher that matches iff the given matcher does not.\n// Note that this implicitly \"deMorganizes\" the wrapped function.  ie, it\n// means that ALL branch values need to fail to match innerBranchedMatcher.\nfunction invertBranchedMatcher(branchedMatcher) {\n  return branchValues => {\n    // We explicitly choose to strip arrayIndices here: it doesn't make sense to\n    // say \"update the array element that does not match something\", at least\n    // in mongo-land.\n    return {result: !branchedMatcher(branchValues).result};\n  };\n}\n\nexport function isIndexable(obj) {\n  return Array.isArray(obj) || LocalCollection._isPlainObject(obj);\n}\n\nexport function isNumericKey(s) {\n  return /^[0-9]+$/.test(s);\n}\n\n// Returns true if this is an object with at least one key and all keys begin\n// with $.  Unless inconsistentOK is set, throws if some keys begin with $ and\n// others don't.\nexport function isOperatorObject(valueSelector, inconsistentOK) {\n  if (!LocalCollection._isPlainObject(valueSelector)) {\n    return false;\n  }\n\n  let theseAreOperators = undefined;\n  Object.keys(valueSelector).forEach(selKey => {\n    const thisIsOperator = selKey.substr(0, 1) === '$' || selKey === 'diff';\n\n    if (theseAreOperators === undefined) {\n      theseAreOperators = thisIsOperator;\n    } else if (theseAreOperators !== thisIsOperator) {\n      if (!inconsistentOK) {\n        throw new Error(\n          `Inconsistent operator: ${JSON.stringify(valueSelector)}`\n        );\n      }\n\n      theseAreOperators = false;\n    }\n  });\n\n  return !!theseAreOperators; // {} has no operators\n}\n\n// Helper for $lt/$gt/$lte/$gte.\nfunction makeInequality(cmpValueComparator) {\n  return {\n    compileElementSelector(operand) {\n      // Arrays never compare false with non-arrays for any inequality.\n      // XXX This was behavior we observed in pre-release MongoDB 2.5, but\n      //     it seems to have been reverted.\n      //     See https://jira.mongodb.org/browse/SERVER-11444\n      if (Array.isArray(operand)) {\n        return () => false;\n      }\n\n      // Special case: consider undefined and null the same (so true with\n      // $gte/$lte).\n      if (operand === undefined) {\n        operand = null;\n      }\n\n      const operandType = LocalCollection._f._type(operand);\n\n      return value => {\n        if (value === undefined) {\n          value = null;\n        }\n\n        // Comparisons are never true among things of different type (except\n        // null vs undefined).\n        if (LocalCollection._f._type(value) !== operandType) {\n          return false;\n        }\n\n        return cmpValueComparator(LocalCollection._f._cmp(value, operand));\n      };\n    },\n  };\n}\n\n// makeLookupFunction(key) returns a lookup function.\n//\n// A lookup function takes in a document and returns an array of matching\n// branches.  If no arrays are found while looking up the key, this array will\n// have exactly one branches (possibly 'undefined', if some segment of the key\n// was not found).\n//\n// If arrays are found in the middle, this can have more than one element, since\n// we 'branch'. When we 'branch', if there are more key segments to look up,\n// then we only pursue branches that are plain objects (not arrays or scalars).\n// This means we can actually end up with no branches!\n//\n// We do *NOT* branch on arrays that are found at the end (ie, at the last\n// dotted member of the key). We just return that array; if you want to\n// effectively 'branch' over the array's values, post-process the lookup\n// function with expandArraysInBranches.\n//\n// Each branch is an object with keys:\n//  - value: the value at the branch\n//  - dontIterate: an optional bool; if true, it means that 'value' is an array\n//    that expandArraysInBranches should NOT expand. This specifically happens\n//    when there is a numeric index in the key, and ensures the\n//    perhaps-surprising MongoDB behavior where {'a.0': 5} does NOT\n//    match {a: [[5]]}.\n//  - arrayIndices: if any array indexing was done during lookup (either due to\n//    explicit numeric indices or implicit branching), this will be an array of\n//    the array indices used, from outermost to innermost; it is falsey or\n//    absent if no array index is used. If an explicit numeric index is used,\n//    the index will be followed in arrayIndices by the string 'x'.\n//\n//    Note: arrayIndices is used for two purposes. First, it is used to\n//    implement the '$' modifier feature, which only ever looks at its first\n//    element.\n//\n//    Second, it is used for sort key generation, which needs to be able to tell\n//    the difference between different paths. Moreover, it needs to\n//    differentiate between explicit and implicit branching, which is why\n//    there's the somewhat hacky 'x' entry: this means that explicit and\n//    implicit array lookups will have different full arrayIndices paths. (That\n//    code only requires that different paths have different arrayIndices; it\n//    doesn't actually 'parse' arrayIndices. As an alternative, arrayIndices\n//    could contain objects with flags like 'implicit', but I think that only\n//    makes the code surrounding them more complex.)\n//\n//    (By the way, this field ends up getting passed around a lot without\n//    cloning, so never mutate any arrayIndices field/var in this package!)\n//\n//\n// At the top level, you may only pass in a plain object or array.\n//\n// See the test 'minimongo - lookup' for some examples of what lookup functions\n// return.\nexport function makeLookupFunction(key, options = {}) {\n  const parts = key.split('.');\n  const firstPart = parts.length ? parts[0] : '';\n  const lookupRest = (\n    parts.length > 1 &&\n    makeLookupFunction(parts.slice(1).join('.'), options)\n  );\n\n  function buildResult(arrayIndices, dontIterate, value) {\n    return arrayIndices && arrayIndices.length\n      ? dontIterate\n        ? [{ arrayIndices, dontIterate, value }]\n        : [{ arrayIndices, value }]\n      : dontIterate\n        ? [{ dontIterate, value }]\n        : [{ value }];\n  }\n\n  // Doc will always be a plain object or an array.\n  // apply an explicit numeric index, an array.\n  return (doc, arrayIndices) => {\n    if (Array.isArray(doc)) {\n      // If we're being asked to do an invalid lookup into an array (non-integer\n      // or out-of-bounds), return no results (which is different from returning\n      // a single undefined result, in that `null` equality checks won't match).\n      if (!(isNumericKey(firstPart) && firstPart < doc.length)) {\n        return [];\n      }\n\n      // Remember that we used this array index. Include an 'x' to indicate that\n      // the previous index came from being considered as an explicit array\n      // index (not branching).\n      arrayIndices = arrayIndices ? arrayIndices.concat(+firstPart, 'x') : [+firstPart, 'x'];\n    }\n\n    // Do our first lookup.\n    const firstLevel = doc[firstPart];\n\n    // If there is no deeper to dig, return what we found.\n    //\n    // If what we found is an array, most value selectors will choose to treat\n    // the elements of the array as matchable values in their own right, but\n    // that's done outside of the lookup function. (Exceptions to this are $size\n    // and stuff relating to $elemMatch.  eg, {a: {$size: 2}} does not match {a:\n    // [[1, 2]]}.)\n    //\n    // That said, if we just did an *explicit* array lookup (on doc) to find\n    // firstLevel, and firstLevel is an array too, we do NOT want value\n    // selectors to iterate over it.  eg, {'a.0': 5} does not match {a: [[5]]}.\n    // So in that case, we mark the return value as 'don't iterate'.\n    if (!lookupRest) {\n      return buildResult(\n        arrayIndices,\n        Array.isArray(doc) && Array.isArray(firstLevel),\n        firstLevel,\n      );\n    }\n\n    // We need to dig deeper.  But if we can't, because what we've found is not\n    // an array or plain object, we're done. If we just did a numeric index into\n    // an array, we return nothing here (this is a change in Mongo 2.5 from\n    // Mongo 2.4, where {'a.0.b': null} stopped matching {a: [5]}). Otherwise,\n    // return a single `undefined` (which can, for example, match via equality\n    // with `null`).\n    if (!isIndexable(firstLevel)) {\n      if (Array.isArray(doc)) {\n        return [];\n      }\n\n      return buildResult(arrayIndices, false, undefined);\n    }\n\n    const result = [];\n    const appendToResult = more => {\n      result.push(...more);\n    };\n\n    // Dig deeper: look up the rest of the parts on whatever we've found.\n    // (lookupRest is smart enough to not try to do invalid lookups into\n    // firstLevel if it's an array.)\n    appendToResult(lookupRest(firstLevel, arrayIndices));\n\n    // If we found an array, then in *addition* to potentially treating the next\n    // part as a literal integer lookup, we should also 'branch': try to look up\n    // the rest of the parts on each array element in parallel.\n    //\n    // In this case, we *only* dig deeper into array elements that are plain\n    // objects. (Recall that we only got this far if we have further to dig.)\n    // This makes sense: we certainly don't dig deeper into non-indexable\n    // objects. And it would be weird to dig into an array: it's simpler to have\n    // a rule that explicit integer indexes only apply to an outer array, not to\n    // an array you find after a branching search.\n    //\n    // In the special case of a numeric part in a *sort selector* (not a query\n    // selector), we skip the branching: we ONLY allow the numeric part to mean\n    // 'look up this index' in that case, not 'also look up this index in all\n    // the elements of the array'.\n    if (Array.isArray(firstLevel) &&\n        !(isNumericKey(parts[1]) && options.forSort)) {\n      firstLevel.forEach((branch, arrayIndex) => {\n        if (LocalCollection._isPlainObject(branch)) {\n          appendToResult(lookupRest(branch, arrayIndices ? arrayIndices.concat(arrayIndex) : [arrayIndex]));\n        }\n      });\n    }\n\n    return result;\n  };\n}\n\n// Object exported only for unit testing.\n// Use it to export private functions to test in Tinytest.\nMinimongoTest = {makeLookupFunction};\nMinimongoError = (message, options = {}) => {\n  if (typeof message === 'string' && options.field) {\n    message += ` for field '${options.field}'`;\n  }\n\n  const error = new Error(message);\n  error.name = 'MinimongoError';\n  return error;\n};\n\nexport function nothingMatcher(docOrBranchedValues) {\n  return {result: false};\n}\n\n// Takes an operator object (an object with $ keys) and returns a branched\n// matcher for it.\nfunction operatorBranchedMatcher(valueSelector, matcher, isRoot) {\n  // Each valueSelector works separately on the various branches.  So one\n  // operator can match one branch and another can match another branch.  This\n  // is OK.\n  const operatorMatchers = Object.keys(valueSelector).map(operator => {\n    const operand = valueSelector[operator];\n\n    const simpleRange = (\n      ['$lt', '$lte', '$gt', '$gte'].includes(operator) &&\n      typeof operand === 'number'\n    );\n\n    const simpleEquality = (\n      ['$ne', '$eq'].includes(operator) &&\n      operand !== Object(operand)\n    );\n\n    const simpleInclusion = (\n      ['$in', '$nin'].includes(operator)\n      && Array.isArray(operand)\n      && !operand.some(x => x === Object(x))\n    );\n\n    if (!(simpleRange || simpleInclusion || simpleEquality)) {\n      matcher._isSimple = false;\n    }\n\n    if (hasOwn.call(VALUE_OPERATORS, operator)) {\n      return VALUE_OPERATORS[operator](operand, valueSelector, matcher, isRoot);\n    }\n\n    if (hasOwn.call(ELEMENT_OPERATORS, operator)) {\n      const options = ELEMENT_OPERATORS[operator];\n      return convertElementMatcherToBranchedMatcher(\n        options.compileElementSelector(operand, valueSelector, matcher),\n        options\n      );\n    }\n\n    throw new Error(`Unrecognized operator: ${operator}`);\n  });\n\n  return andBranchedMatchers(operatorMatchers);\n}\n\n// paths - Array: list of mongo style paths\n// newLeafFn - Function: of form function(path) should return a scalar value to\n//                       put into list created for that path\n// conflictFn - Function: of form function(node, path, fullPath) is called\n//                        when building a tree path for 'fullPath' node on\n//                        'path' was already a leaf with a value. Must return a\n//                        conflict resolution.\n// initial tree - Optional Object: starting tree.\n// @returns - Object: tree represented as a set of nested objects\nexport function pathsToTree(paths, newLeafFn, conflictFn, root = {}) {\n  paths.forEach(path => {\n    const pathArray = path.split('.');\n    let tree = root;\n\n    // use .every just for iteration with break\n    const success = pathArray.slice(0, -1).every((key, i) => {\n      if (!hasOwn.call(tree, key)) {\n        tree[key] = {};\n      } else if (tree[key] !== Object(tree[key])) {\n        tree[key] = conflictFn(\n          tree[key],\n          pathArray.slice(0, i + 1).join('.'),\n          path\n        );\n\n        // break out of loop if we are failing for this path\n        if (tree[key] !== Object(tree[key])) {\n          return false;\n        }\n      }\n\n      tree = tree[key];\n\n      return true;\n    });\n\n    if (success) {\n      const lastKey = pathArray[pathArray.length - 1];\n      if (hasOwn.call(tree, lastKey)) {\n        tree[lastKey] = conflictFn(tree[lastKey], path, path);\n      } else {\n        tree[lastKey] = newLeafFn(path);\n      }\n    }\n  });\n\n  return root;\n}\n\n// Makes sure we get 2 elements array and assume the first one to be x and\n// the second one to y no matter what user passes.\n// In case user passes { lon: x, lat: y } returns [x, y]\nfunction pointToArray(point) {\n  return Array.isArray(point) ? point.slice() : [point.x, point.y];\n}\n\n// Creating a document from an upsert is quite tricky.\n// E.g. this selector: {\"$or\": [{\"b.foo\": {\"$all\": [\"bar\"]}}]}, should result\n// in: {\"b.foo\": \"bar\"}\n// But this selector: {\"$or\": [{\"b\": {\"foo\": {\"$all\": [\"bar\"]}}}]} should throw\n// an error\n\n// Some rules (found mainly with trial & error, so there might be more):\n// - handle all childs of $and (or implicit $and)\n// - handle $or nodes with exactly 1 child\n// - ignore $or nodes with more than 1 child\n// - ignore $nor and $not nodes\n// - throw when a value can not be set unambiguously\n// - every value for $all should be dealt with as separate $eq-s\n// - threat all children of $all as $eq setters (=> set if $all.length === 1,\n//   otherwise throw error)\n// - you can not mix '$'-prefixed keys and non-'$'-prefixed keys\n// - you can only have dotted keys on a root-level\n// - you can not have '$'-prefixed keys more than one-level deep in an object\n\n// Handles one key/value pair to put in the selector document\nfunction populateDocumentWithKeyValue(document, key, value) {\n  if (value && Object.getPrototypeOf(value) === Object.prototype) {\n    populateDocumentWithObject(document, key, value);\n  } else if (!(value instanceof RegExp)) {\n    insertIntoDocument(document, key, value);\n  }\n}\n\n// Handles a key, value pair to put in the selector document\n// if the value is an object\nfunction populateDocumentWithObject(document, key, value) {\n  const keys = Object.keys(value);\n  const unprefixedKeys = keys.filter(op => op[0] !== '$');\n\n  if (unprefixedKeys.length > 0 || !keys.length) {\n    // Literal (possibly empty) object ( or empty object )\n    // Don't allow mixing '$'-prefixed with non-'$'-prefixed fields\n    if (keys.length !== unprefixedKeys.length) {\n      throw new Error(`unknown operator: ${unprefixedKeys[0]}`);\n    }\n\n    validateObject(value, key);\n    insertIntoDocument(document, key, value);\n  } else {\n    Object.keys(value).forEach(op => {\n      const object = value[op];\n\n      if (op === '$eq') {\n        populateDocumentWithKeyValue(document, key, object);\n      } else if (op === '$all') {\n        // every value for $all should be dealt with as separate $eq-s\n        object.forEach(element =>\n          populateDocumentWithKeyValue(document, key, element)\n        );\n      }\n    });\n  }\n}\n\n// Fills a document with certain fields from an upsert selector\nexport function populateDocumentWithQueryFields(query, document = {}) {\n  if (Object.getPrototypeOf(query) === Object.prototype) {\n    // handle implicit $and\n    Object.keys(query).forEach(key => {\n      const value = query[key];\n\n      if (key === '$and') {\n        // handle explicit $and\n        value.forEach(element =>\n          populateDocumentWithQueryFields(element, document)\n        );\n      } else if (key === '$or') {\n        // handle $or nodes with exactly 1 child\n        if (value.length === 1) {\n          populateDocumentWithQueryFields(value[0], document);\n        }\n      } else if (key[0] !== '$') {\n        // Ignore other '$'-prefixed logical selectors\n        populateDocumentWithKeyValue(document, key, value);\n      }\n    });\n  } else {\n    // Handle meteor-specific shortcut for selecting _id\n    if (LocalCollection._selectorIsId(query)) {\n      insertIntoDocument(document, '_id', query);\n    }\n  }\n\n  return document;\n}\n\n// Traverses the keys of passed projection and constructs a tree where all\n// leaves are either all True or all False\n// @returns Object:\n//  - tree - Object - tree representation of keys involved in projection\n//  (exception for '_id' as it is a special case handled separately)\n//  - including - Boolean - \"take only certain fields\" type of projection\nexport function projectionDetails(fields) {\n  // Find the non-_id keys (_id is handled specially because it is included\n  // unless explicitly excluded). Sort the keys, so that our code to detect\n  // overlaps like 'foo' and 'foo.bar' can assume that 'foo' comes first.\n  let fieldsKeys = Object.keys(fields).sort();\n\n  // If _id is the only field in the projection, do not remove it, since it is\n  // required to determine if this is an exclusion or exclusion. Also keep an\n  // inclusive _id, since inclusive _id follows the normal rules about mixing\n  // inclusive and exclusive fields. If _id is not the only field in the\n  // projection and is exclusive, remove it so it can be handled later by a\n  // special case, since exclusive _id is always allowed.\n  if (!(fieldsKeys.length === 1 && fieldsKeys[0] === '_id') &&\n      !(fieldsKeys.includes('_id') && fields._id)) {\n    fieldsKeys = fieldsKeys.filter(key => key !== '_id');\n  }\n\n  let including = null; // Unknown\n\n  fieldsKeys.forEach(keyPath => {\n    const rule = !!fields[keyPath];\n\n    if (including === null) {\n      including = rule;\n    }\n\n    // This error message is copied from MongoDB shell\n    if (including !== rule) {\n      throw MinimongoError(\n        'You cannot currently mix including and excluding fields.'\n      );\n    }\n  });\n\n  const projectionRulesTree = pathsToTree(\n    fieldsKeys,\n    path => including,\n    (node, path, fullPath) => {\n      // Check passed projection fields' keys: If you have two rules such as\n      // 'foo.bar' and 'foo.bar.baz', then the result becomes ambiguous. If\n      // that happens, there is a probability you are doing something wrong,\n      // framework should notify you about such mistake earlier on cursor\n      // compilation step than later during runtime.  Note, that real mongo\n      // doesn't do anything about it and the later rule appears in projection\n      // project, more priority it takes.\n      //\n      // Example, assume following in mongo shell:\n      // > db.coll.insert({ a: { b: 23, c: 44 } })\n      // > db.coll.find({}, { 'a': 1, 'a.b': 1 })\n      // {\"_id\": ObjectId(\"520bfe456024608e8ef24af3\"), \"a\": {\"b\": 23}}\n      // > db.coll.find({}, { 'a.b': 1, 'a': 1 })\n      // {\"_id\": ObjectId(\"520bfe456024608e8ef24af3\"), \"a\": {\"b\": 23, \"c\": 44}}\n      //\n      // Note, how second time the return set of keys is different.\n      const currentPath = fullPath;\n      const anotherPath = path;\n      throw MinimongoError(\n        `both ${currentPath} and ${anotherPath} found in fields option, ` +\n        'using both of them may trigger unexpected behavior. Did you mean to ' +\n        'use only one of them?'\n      );\n    });\n\n  return {including, tree: projectionRulesTree};\n}\n\n// Takes a RegExp object and returns an element matcher.\nexport function regexpElementMatcher(regexp) {\n  return value => {\n    if (value instanceof RegExp) {\n      return value.toString() === regexp.toString();\n    }\n\n    // Regexps only work against strings.\n    if (typeof value !== 'string') {\n      return false;\n    }\n\n    // Reset regexp's state to avoid inconsistent matching for objects with the\n    // same value on consecutive calls of regexp.test. This happens only if the\n    // regexp has the 'g' flag. Also note that ES6 introduces a new flag 'y' for\n    // which we should *not* change the lastIndex but MongoDB doesn't support\n    // either of these flags.\n    regexp.lastIndex = 0;\n\n    return regexp.test(value);\n  };\n}\n\n// Validates the key in a path.\n// Objects that are nested more then 1 level cannot have dotted fields\n// or fields starting with '$'\nfunction validateKeyInPath(key, path) {\n  if (key.includes('.')) {\n    throw new Error(\n      `The dotted field '${key}' in '${path}.${key} is not valid for storage.`\n    );\n  }\n\n  if (key[0] === '$') {\n    throw new Error(\n      `The dollar ($) prefixed field  '${path}.${key} is not valid for storage.`\n    );\n  }\n}\n\n// Recursively validates an object that is nested more than one level deep\nfunction validateObject(object, path) {\n  if (object && Object.getPrototypeOf(object) === Object.prototype) {\n    Object.keys(object).forEach(key => {\n      validateKeyInPath(key, path);\n      validateObject(object[key], path + '.' + key);\n    });\n  }\n}\n"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"18cfae828f2d055e3044b3d95c143ba6cc4077d7"}
