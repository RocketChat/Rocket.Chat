{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/mongo/polling_observe_driver.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.arm64"},"sourceFileName":"packages/mongo/polling_observe_driver.js","filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/mongo/polling_observe_driver.js","targets":{"android":"125.0.0","chrome":"125.0.0","edge":"125.0.0","firefox":"115.0.0","ie":"10.0.0","ios":"17.4.0","opera":"110.0.0","opera_mobile":"80.0.0","safari":"17.4.0","samsung":"24.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","root":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true,"topLevelAwait":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/mongo/polling_observe_driver.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/mongo/polling_observe_driver.js"}},"code":"!module.wrapAsync(async function (module, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    let throttle;\n    module.link(\"lodash.throttle\", {\n      default(v) {\n        throttle = v;\n      }\n    }, 0);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    var POLLING_THROTTLE_MS = +process.env.METEOR_POLLING_THROTTLE_MS || 50;\n    var POLLING_INTERVAL_MS = +process.env.METEOR_POLLING_INTERVAL_MS || 10 * 1000;\n    PollingObserveDriver = function (options) {\n      const self = this;\n      self._options = options;\n      self._cursorDescription = options.cursorDescription;\n      self._mongoHandle = options.mongoHandle;\n      self._ordered = options.ordered;\n      self._multiplexer = options.multiplexer;\n      self._stopCallbacks = [];\n      self._stopped = false;\n      self._cursor = self._mongoHandle._createSynchronousCursor(self._cursorDescription);\n\n      // previous results snapshot.  on each poll cycle, diffs against\n      // results drives the callbacks.\n      self._results = null;\n\n      // The number of _pollMongo calls that have been added to self._taskQueue but\n      // have not started running. Used to make sure we never schedule more than one\n      // _pollMongo (other than possibly the one that is currently running). It's\n      // also used by _suspendPolling to pretend there's a poll scheduled. Usually,\n      // it's either 0 (for \"no polls scheduled other than maybe one currently\n      // running\") or 1 (for \"a poll scheduled that isn't running yet\"), but it can\n      // also be 2 if incremented by _suspendPolling.\n      self._pollsScheduledButNotStarted = 0;\n      self._pendingWrites = []; // people to notify when polling completes\n\n      // Make sure to create a separately throttled function for each\n      // PollingObserveDriver object.\n      self._ensurePollIsScheduled = throttle(self._unthrottledEnsurePollIsScheduled, self._cursorDescription.options.pollingThrottleMs || POLLING_THROTTLE_MS /* ms */);\n\n      // XXX figure out if we still need a queue\n      self._taskQueue = new Meteor._AsynchronousQueue();\n    };\n    _.extend(PollingObserveDriver.prototype, {\n      _init: async function () {\n        const self = this;\n        const options = self._options;\n        const listenersHandle = await listenAll(self._cursorDescription, function (notification) {\n          // When someone does a transaction that might affect us, schedule a poll\n          // of the database. If that transaction happens inside of a write fence,\n          // block the fence until we've polled and notified observers.\n          const fence = DDPServer._getCurrentFence();\n          if (fence) self._pendingWrites.push(fence.beginWrite());\n          // Ensure a poll is scheduled... but if we already know that one is,\n          // don't hit the throttled _ensurePollIsScheduled function (which might\n          // lead to us calling it unnecessarily in <pollingThrottleMs> ms).\n          if (self._pollsScheduledButNotStarted === 0) self._ensurePollIsScheduled();\n        });\n        self._stopCallbacks.push(async function () {\n          await listenersHandle.stop();\n        });\n\n        // every once and a while, poll even if we don't think we're dirty, for\n        // eventual consistency with database writes from outside the Meteor\n        // universe.\n        //\n        // For testing, there's an undocumented callback argument to observeChanges\n        // which disables time-based polling and gets called at the beginning of each\n        // poll.\n        if (options._testOnlyPollCallback) {\n          self._testOnlyPollCallback = options._testOnlyPollCallback;\n        } else {\n          const pollingInterval = self._cursorDescription.options.pollingIntervalMs || self._cursorDescription.options._pollingInterval ||\n          // COMPAT with 1.2\n          POLLING_INTERVAL_MS;\n          const intervalHandle = Meteor.setInterval(self._ensurePollIsScheduled.bind(self), pollingInterval);\n          self._stopCallbacks.push(function () {\n            Meteor.clearInterval(intervalHandle);\n          });\n        }\n\n        // Make sure we actually poll soon!\n        await this._unthrottledEnsurePollIsScheduled();\n        Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"mongo-livedata\", \"observe-drivers-polling\", 1);\n      },\n      // This is always called through _.throttle (except once at startup).\n      _unthrottledEnsurePollIsScheduled: async function () {\n        var self = this;\n        if (self._pollsScheduledButNotStarted > 0) return;\n        ++self._pollsScheduledButNotStarted;\n        await self._taskQueue.runTask(async function () {\n          await self._pollMongo();\n        });\n      },\n      // test-only interface for controlling polling.\n      //\n      // _suspendPolling blocks until any currently running and scheduled polls are\n      // done, and prevents any further polls from being scheduled. (new\n      // ObserveHandles can be added and receive their initial added callbacks,\n      // though.)\n      //\n      // _resumePolling immediately polls, and allows further polls to occur.\n      _suspendPolling: function () {\n        var self = this;\n        // Pretend that there's another poll scheduled (which will prevent\n        // _ensurePollIsScheduled from queueing any more polls).\n        ++self._pollsScheduledButNotStarted;\n        // Now block until all currently running or scheduled polls are done.\n        self._taskQueue.runTask(function () {});\n\n        // Confirm that there is only one \"poll\" (the fake one we're pretending to\n        // have) scheduled.\n        if (self._pollsScheduledButNotStarted !== 1) throw new Error(\"_pollsScheduledButNotStarted is \" + self._pollsScheduledButNotStarted);\n      },\n      _resumePolling: async function () {\n        var self = this;\n        // We should be in the same state as in the end of _suspendPolling.\n        if (self._pollsScheduledButNotStarted !== 1) throw new Error(\"_pollsScheduledButNotStarted is \" + self._pollsScheduledButNotStarted);\n        // Run a poll synchronously (which will counteract the\n        // ++_pollsScheduledButNotStarted from _suspendPolling).\n        await self._taskQueue.runTask(async function () {\n          await self._pollMongo();\n        });\n      },\n      async _pollMongo() {\n        var self = this;\n        --self._pollsScheduledButNotStarted;\n        if (self._stopped) return;\n        var first = false;\n        var newResults;\n        var oldResults = self._results;\n        if (!oldResults) {\n          first = true;\n          // XXX maybe use OrderedDict instead?\n          oldResults = self._ordered ? [] : new LocalCollection._IdMap();\n        }\n        self._testOnlyPollCallback && self._testOnlyPollCallback();\n\n        // Save the list of pending writes which this round will commit.\n        var writesForCycle = self._pendingWrites;\n        self._pendingWrites = [];\n\n        // Get the new query results. (This yields.)\n        try {\n          newResults = await self._cursor.getRawObjects(self._ordered);\n        } catch (e) {\n          if (first && typeof e.code === 'number') {\n            // This is an error document sent to us by mongod, not a connection\n            // error generated by the client. And we've never seen this query work\n            // successfully. Probably it's a bad selector or something, so we should\n            // NOT retry. Instead, we should halt the observe (which ends up calling\n            // `stop` on us).\n            await self._multiplexer.queryError(new Error(\"Exception while polling query \" + JSON.stringify(self._cursorDescription) + \": \" + e.message));\n          }\n\n          // getRawObjects can throw if we're having trouble talking to the\n          // database.  That's fine --- we will repoll later anyway. But we should\n          // make sure not to lose track of this cycle's writes.\n          // (It also can throw if there's just something invalid about this query;\n          // unfortunately the ObserveDriver API doesn't provide a good way to\n          // \"cancel\" the observe from the inside in this case.\n          Array.prototype.push.apply(self._pendingWrites, writesForCycle);\n          Meteor._debug(\"Exception while polling query \" + JSON.stringify(self._cursorDescription), e);\n          return;\n        }\n\n        // Run diffs.\n        if (!self._stopped) {\n          LocalCollection._diffQueryChanges(self._ordered, oldResults, newResults, self._multiplexer);\n        }\n\n        // Signals the multiplexer to allow all observeChanges calls that share this\n        // multiplexer to return. (This happens asynchronously, via the\n        // multiplexer's queue.)\n        if (first) self._multiplexer.ready();\n\n        // Replace self._results atomically.  (This assignment is what makes `first`\n        // stay through on the next cycle, so we've waited until after we've\n        // committed to ready-ing the multiplexer.)\n        self._results = newResults;\n\n        // Once the ObserveMultiplexer has processed everything we've done in this\n        // round, mark all the writes which existed before this call as\n        // commmitted. (If new writes have shown up in the meantime, there'll\n        // already be another _pollMongo task scheduled.)\n        await self._multiplexer.onFlush(async function () {\n          for (const w of writesForCycle) {\n            await w.committed();\n          }\n        });\n      },\n      stop: function () {\n        var self = this;\n        self._stopped = true;\n        const stopCallbacksCaller = async function (c) {\n          await c();\n        };\n        self._stopCallbacks.forEach(stopCallbacksCaller);\n        // Release any write fences that are waiting on us.\n        self._pendingWrites.forEach(async function (w) {\n          await w.committed();\n        });\n        Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"mongo-livedata\", \"observe-drivers-polling\", -1);\n      }\n    });\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: false\n});","map":{"version":3,"names":["throttle","module","link","default","v","__reifyWaitForDeps__","POLLING_THROTTLE_MS","process","env","METEOR_POLLING_THROTTLE_MS","POLLING_INTERVAL_MS","METEOR_POLLING_INTERVAL_MS","PollingObserveDriver","options","self","_options","_cursorDescription","cursorDescription","_mongoHandle","mongoHandle","_ordered","ordered","_multiplexer","multiplexer","_stopCallbacks","_stopped","_cursor","_createSynchronousCursor","_results","_pollsScheduledButNotStarted","_pendingWrites","_ensurePollIsScheduled","_unthrottledEnsurePollIsScheduled","pollingThrottleMs","_taskQueue","Meteor","_AsynchronousQueue","_","extend","prototype","_init","listenersHandle","listenAll","notification","fence","DDPServer","_getCurrentFence","push","beginWrite","stop","_testOnlyPollCallback","pollingInterval","pollingIntervalMs","_pollingInterval","intervalHandle","setInterval","bind","clearInterval","Package","Facts","incrementServerFact","runTask","_pollMongo","_suspendPolling","Error","_resumePolling","first","newResults","oldResults","LocalCollection","_IdMap","writesForCycle","getRawObjects","e","code","queryError","JSON","stringify","message","Array","apply","_debug","_diffQueryChanges","ready","onFlush","w","committed","stopCallbacksCaller","c","forEach","__reify_async_result__","_reifyError","async"],"sources":["packages/mongo/polling_observe_driver.js"],"sourcesContent":["import throttle from 'lodash.throttle';\n\nvar POLLING_THROTTLE_MS = +process.env.METEOR_POLLING_THROTTLE_MS || 50;\nvar POLLING_INTERVAL_MS = +process.env.METEOR_POLLING_INTERVAL_MS || 10 * 1000;\n\nPollingObserveDriver = function (options) {\n  const self = this;\n  self._options = options;\n\n  self._cursorDescription = options.cursorDescription;\n  self._mongoHandle = options.mongoHandle;\n  self._ordered = options.ordered;\n  self._multiplexer = options.multiplexer;\n  self._stopCallbacks = [];\n  self._stopped = false;\n\n  self._cursor = self._mongoHandle._createSynchronousCursor(\n    self._cursorDescription);\n\n  // previous results snapshot.  on each poll cycle, diffs against\n  // results drives the callbacks.\n  self._results = null;\n\n  // The number of _pollMongo calls that have been added to self._taskQueue but\n  // have not started running. Used to make sure we never schedule more than one\n  // _pollMongo (other than possibly the one that is currently running). It's\n  // also used by _suspendPolling to pretend there's a poll scheduled. Usually,\n  // it's either 0 (for \"no polls scheduled other than maybe one currently\n  // running\") or 1 (for \"a poll scheduled that isn't running yet\"), but it can\n  // also be 2 if incremented by _suspendPolling.\n  self._pollsScheduledButNotStarted = 0;\n  self._pendingWrites = []; // people to notify when polling completes\n\n  // Make sure to create a separately throttled function for each\n  // PollingObserveDriver object.\n  self._ensurePollIsScheduled = throttle(\n    self._unthrottledEnsurePollIsScheduled,\n    self._cursorDescription.options.pollingThrottleMs || POLLING_THROTTLE_MS /* ms */);\n\n  // XXX figure out if we still need a queue\n  self._taskQueue = new Meteor._AsynchronousQueue();\n\n  \n};\n\n_.extend(PollingObserveDriver.prototype, {\n  _init: async function () {\n    const self = this;\n    const options = self._options;\n    const listenersHandle = await listenAll(\n      self._cursorDescription, function (notification) {\n        // When someone does a transaction that might affect us, schedule a poll\n        // of the database. If that transaction happens inside of a write fence,\n        // block the fence until we've polled and notified observers.\n        const fence = DDPServer._getCurrentFence();\n        if (fence)\n          self._pendingWrites.push(fence.beginWrite());\n        // Ensure a poll is scheduled... but if we already know that one is,\n        // don't hit the throttled _ensurePollIsScheduled function (which might\n        // lead to us calling it unnecessarily in <pollingThrottleMs> ms).\n        if (self._pollsScheduledButNotStarted === 0)\n          self._ensurePollIsScheduled();\n      }\n    );\n    self._stopCallbacks.push(async function () { await listenersHandle.stop(); });\n  \n    // every once and a while, poll even if we don't think we're dirty, for\n    // eventual consistency with database writes from outside the Meteor\n    // universe.\n    //\n    // For testing, there's an undocumented callback argument to observeChanges\n    // which disables time-based polling and gets called at the beginning of each\n    // poll.\n    if (options._testOnlyPollCallback) {\n      self._testOnlyPollCallback = options._testOnlyPollCallback;\n    } else {\n      const pollingInterval =\n            self._cursorDescription.options.pollingIntervalMs ||\n            self._cursorDescription.options._pollingInterval || // COMPAT with 1.2\n            POLLING_INTERVAL_MS;\n      const intervalHandle = Meteor.setInterval(\n        self._ensurePollIsScheduled.bind(self), pollingInterval);\n      self._stopCallbacks.push(function () {\n        Meteor.clearInterval(intervalHandle);\n      });\n    }\n    \n    // Make sure we actually poll soon!\n    await this._unthrottledEnsurePollIsScheduled();\n\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n      \"mongo-livedata\", \"observe-drivers-polling\", 1);\n},\n// This is always called through _.throttle (except once at startup).\n_unthrottledEnsurePollIsScheduled: async function () {\n    var self = this;\n    if (self._pollsScheduledButNotStarted > 0)\n      return;\n    ++self._pollsScheduledButNotStarted;\n    await self._taskQueue.runTask(async function () {\n      await self._pollMongo();\n    });\n  },\n\n  // test-only interface for controlling polling.\n  //\n  // _suspendPolling blocks until any currently running and scheduled polls are\n  // done, and prevents any further polls from being scheduled. (new\n  // ObserveHandles can be added and receive their initial added callbacks,\n  // though.)\n  //\n  // _resumePolling immediately polls, and allows further polls to occur.\n  _suspendPolling: function() {\n    var self = this;\n    // Pretend that there's another poll scheduled (which will prevent\n    // _ensurePollIsScheduled from queueing any more polls).\n    ++self._pollsScheduledButNotStarted;\n    // Now block until all currently running or scheduled polls are done.\n    self._taskQueue.runTask(function() {});\n\n    // Confirm that there is only one \"poll\" (the fake one we're pretending to\n    // have) scheduled.\n    if (self._pollsScheduledButNotStarted !== 1)\n      throw new Error(\"_pollsScheduledButNotStarted is \" +\n                      self._pollsScheduledButNotStarted);\n  },\n  _resumePolling: async function() {\n    var self = this;\n    // We should be in the same state as in the end of _suspendPolling.\n    if (self._pollsScheduledButNotStarted !== 1)\n      throw new Error(\"_pollsScheduledButNotStarted is \" +\n                      self._pollsScheduledButNotStarted);\n    // Run a poll synchronously (which will counteract the\n    // ++_pollsScheduledButNotStarted from _suspendPolling).\n    await self._taskQueue.runTask(async function () {\n      await self._pollMongo();\n    });\n  },\n\n  async _pollMongo() {\n    var self = this;\n    --self._pollsScheduledButNotStarted;\n\n    if (self._stopped)\n      return;\n\n    var first = false;\n    var newResults;\n    var oldResults = self._results;\n    if (!oldResults) {\n      first = true;\n      // XXX maybe use OrderedDict instead?\n      oldResults = self._ordered ? [] : new LocalCollection._IdMap;\n    }\n\n    self._testOnlyPollCallback && self._testOnlyPollCallback();\n\n    // Save the list of pending writes which this round will commit.\n    var writesForCycle = self._pendingWrites;\n    self._pendingWrites = [];\n\n    // Get the new query results. (This yields.)\n    try {\n      newResults = await self._cursor.getRawObjects(self._ordered);\n    } catch (e) {\n      if (first && typeof(e.code) === 'number') {\n        // This is an error document sent to us by mongod, not a connection\n        // error generated by the client. And we've never seen this query work\n        // successfully. Probably it's a bad selector or something, so we should\n        // NOT retry. Instead, we should halt the observe (which ends up calling\n        // `stop` on us).\n        await self._multiplexer.queryError(\n            new Error(\n                \"Exception while polling query \" +\n                JSON.stringify(self._cursorDescription) + \": \" + e.message));\n      }\n\n      // getRawObjects can throw if we're having trouble talking to the\n      // database.  That's fine --- we will repoll later anyway. But we should\n      // make sure not to lose track of this cycle's writes.\n      // (It also can throw if there's just something invalid about this query;\n      // unfortunately the ObserveDriver API doesn't provide a good way to\n      // \"cancel\" the observe from the inside in this case.\n      Array.prototype.push.apply(self._pendingWrites, writesForCycle);\n      Meteor._debug(\"Exception while polling query \" +\n          JSON.stringify(self._cursorDescription), e);\n      return;\n    }\n\n    // Run diffs.\n    if (!self._stopped) {\n      LocalCollection._diffQueryChanges(\n          self._ordered, oldResults, newResults, self._multiplexer);\n    }\n\n    // Signals the multiplexer to allow all observeChanges calls that share this\n    // multiplexer to return. (This happens asynchronously, via the\n    // multiplexer's queue.)\n    if (first)\n      self._multiplexer.ready();\n\n    // Replace self._results atomically.  (This assignment is what makes `first`\n    // stay through on the next cycle, so we've waited until after we've\n    // committed to ready-ing the multiplexer.)\n    self._results = newResults;\n\n    // Once the ObserveMultiplexer has processed everything we've done in this\n    // round, mark all the writes which existed before this call as\n    // commmitted. (If new writes have shown up in the meantime, there'll\n    // already be another _pollMongo task scheduled.)\n    await self._multiplexer.onFlush(async function () {\n      for (const w of writesForCycle) {\n        await w.committed();\n      }\n    });\n  },\n\n  stop: function () {\n    var self = this;\n    self._stopped = true;\n    const stopCallbacksCaller = async function(c) {\n      await c();\n    };\n\n    self._stopCallbacks.forEach(stopCallbacksCaller);\n    // Release any write fences that are waiting on us.\n    self._pendingWrites.forEach(async function (w) {\n      await w.committed();\n    });\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n      \"mongo-livedata\", \"observe-drivers-polling\", -1);\n  }\n});"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"34048f177b752562c647d96545dd91acfba31117"}
