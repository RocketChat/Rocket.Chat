{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/minimongo/sorter.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.arm64"},"sourceFileName":"packages/minimongo/sorter.js","filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/minimongo/sorter.js","targets":{"android":"125.0.0","chrome":"125.0.0","edge":"125.0.0","firefox":"115.0.0","ie":"10.0.0","ios":"17.4.0","opera":"110.0.0","opera_mobile":"80.0.0","safari":"17.4.0","samsung":"24.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","root":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true,"topLevelAwait":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/minimongo/sorter.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/minimongo/sorter.js"}},"code":"!module.wrapAsync(async function (module, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    module.export({\n      default: () => Sorter\n    });\n    let ELEMENT_OPERATORS, equalityElementMatcher, expandArraysInBranches, hasOwn, isOperatorObject, makeLookupFunction, regexpElementMatcher;\n    module.link(\"./common.js\", {\n      ELEMENT_OPERATORS(v) {\n        ELEMENT_OPERATORS = v;\n      },\n      equalityElementMatcher(v) {\n        equalityElementMatcher = v;\n      },\n      expandArraysInBranches(v) {\n        expandArraysInBranches = v;\n      },\n      hasOwn(v) {\n        hasOwn = v;\n      },\n      isOperatorObject(v) {\n        isOperatorObject = v;\n      },\n      makeLookupFunction(v) {\n        makeLookupFunction = v;\n      },\n      regexpElementMatcher(v) {\n        regexpElementMatcher = v;\n      }\n    }, 0);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    class Sorter {\n      constructor(spec) {\n        this._sortSpecParts = [];\n        this._sortFunction = null;\n        const addSpecPart = (path, ascending) => {\n          if (!path) {\n            throw Error('sort keys must be non-empty');\n          }\n          if (path.charAt(0) === '$') {\n            throw Error(\"unsupported sort key: \".concat(path));\n          }\n          this._sortSpecParts.push({\n            ascending,\n            lookup: makeLookupFunction(path, {\n              forSort: true\n            }),\n            path\n          });\n        };\n        if (spec instanceof Array) {\n          spec.forEach(element => {\n            if (typeof element === 'string') {\n              addSpecPart(element, true);\n            } else {\n              addSpecPart(element[0], element[1] !== 'desc');\n            }\n          });\n        } else if (typeof spec === 'object') {\n          Object.keys(spec).forEach(key => {\n            addSpecPart(key, spec[key] >= 0);\n          });\n        } else if (typeof spec === 'function') {\n          this._sortFunction = spec;\n        } else {\n          throw Error(\"Bad sort specification: \".concat(JSON.stringify(spec)));\n        }\n\n        // If a function is specified for sorting, we skip the rest.\n        if (this._sortFunction) {\n          return;\n        }\n\n        // To implement affectedByModifier, we piggy-back on top of Matcher's\n        // affectedByModifier code; we create a selector that is affected by the\n        // same modifiers as this sort order. This is only implemented on the\n        // server.\n        if (this.affectedByModifier) {\n          const selector = {};\n          this._sortSpecParts.forEach(spec => {\n            selector[spec.path] = 1;\n          });\n          this._selectorForAffectedByModifier = new Minimongo.Matcher(selector);\n        }\n        this._keyComparator = composeComparators(this._sortSpecParts.map((spec, i) => this._keyFieldComparator(i)));\n      }\n      getComparator(options) {\n        // If sort is specified or have no distances, just use the comparator from\n        // the source specification (which defaults to \"everything is equal\".\n        // issue #3599\n        // https://docs.mongodb.com/manual/reference/operator/query/near/#sort-operation\n        // sort effectively overrides $near\n        if (this._sortSpecParts.length || !options || !options.distances) {\n          return this._getBaseComparator();\n        }\n        const distances = options.distances;\n\n        // Return a comparator which compares using $near distances.\n        return (a, b) => {\n          if (!distances.has(a._id)) {\n            throw Error(\"Missing distance for \".concat(a._id));\n          }\n          if (!distances.has(b._id)) {\n            throw Error(\"Missing distance for \".concat(b._id));\n          }\n          return distances.get(a._id) - distances.get(b._id);\n        };\n      }\n\n      // Takes in two keys: arrays whose lengths match the number of spec\n      // parts. Returns negative, 0, or positive based on using the sort spec to\n      // compare fields.\n      _compareKeys(key1, key2) {\n        if (key1.length !== this._sortSpecParts.length || key2.length !== this._sortSpecParts.length) {\n          throw Error('Key has wrong length');\n        }\n        return this._keyComparator(key1, key2);\n      }\n\n      // Iterates over each possible \"key\" from doc (ie, over each branch), calling\n      // 'cb' with the key.\n      _generateKeysFromDoc(doc, cb) {\n        if (this._sortSpecParts.length === 0) {\n          throw new Error('can\\'t generate keys without a spec');\n        }\n        const pathFromIndices = indices => \"\".concat(indices.join(','), \",\");\n        let knownPaths = null;\n\n        // maps index -> ({'' -> value} or {path -> value})\n        const valuesByIndexAndPath = this._sortSpecParts.map(spec => {\n          // Expand any leaf arrays that we find, and ignore those arrays\n          // themselves.  (We never sort based on an array itself.)\n          let branches = expandArraysInBranches(spec.lookup(doc), true);\n\n          // If there are no values for a key (eg, key goes to an empty array),\n          // pretend we found one undefined value.\n          if (!branches.length) {\n            branches = [{\n              value: void 0\n            }];\n          }\n          const element = Object.create(null);\n          let usedPaths = false;\n          branches.forEach(branch => {\n            if (!branch.arrayIndices) {\n              // If there are no array indices for a branch, then it must be the\n              // only branch, because the only thing that produces multiple branches\n              // is the use of arrays.\n              if (branches.length > 1) {\n                throw Error('multiple branches but no array used?');\n              }\n              element[''] = branch.value;\n              return;\n            }\n            usedPaths = true;\n            const path = pathFromIndices(branch.arrayIndices);\n            if (hasOwn.call(element, path)) {\n              throw Error(\"duplicate path: \".concat(path));\n            }\n            element[path] = branch.value;\n\n            // If two sort fields both go into arrays, they have to go into the\n            // exact same arrays and we have to find the same paths.  This is\n            // roughly the same condition that makes MongoDB throw this strange\n            // error message.  eg, the main thing is that if sort spec is {a: 1,\n            // b:1} then a and b cannot both be arrays.\n            //\n            // (In MongoDB it seems to be OK to have {a: 1, 'a.x.y': 1} where 'a'\n            // and 'a.x.y' are both arrays, but we don't allow this for now.\n            // #NestedArraySort\n            // XXX achieve full compatibility here\n            if (knownPaths && !hasOwn.call(knownPaths, path)) {\n              throw Error('cannot index parallel arrays');\n            }\n          });\n          if (knownPaths) {\n            // Similarly to above, paths must match everywhere, unless this is a\n            // non-array field.\n            if (!hasOwn.call(element, '') && Object.keys(knownPaths).length !== Object.keys(element).length) {\n              throw Error('cannot index parallel arrays!');\n            }\n          } else if (usedPaths) {\n            knownPaths = {};\n            Object.keys(element).forEach(path => {\n              knownPaths[path] = true;\n            });\n          }\n          return element;\n        });\n        if (!knownPaths) {\n          // Easy case: no use of arrays.\n          const soleKey = valuesByIndexAndPath.map(values => {\n            if (!hasOwn.call(values, '')) {\n              throw Error('no value in sole key case?');\n            }\n            return values[''];\n          });\n          cb(soleKey);\n          return;\n        }\n        Object.keys(knownPaths).forEach(path => {\n          const key = valuesByIndexAndPath.map(values => {\n            if (hasOwn.call(values, '')) {\n              return values[''];\n            }\n            if (!hasOwn.call(values, path)) {\n              throw Error('missing path?');\n            }\n            return values[path];\n          });\n          cb(key);\n        });\n      }\n\n      // Returns a comparator that represents the sort specification (but not\n      // including a possible geoquery distance tie-breaker).\n      _getBaseComparator() {\n        if (this._sortFunction) {\n          return this._sortFunction;\n        }\n\n        // If we're only sorting on geoquery distance and no specs, just say\n        // everything is equal.\n        if (!this._sortSpecParts.length) {\n          return (doc1, doc2) => 0;\n        }\n        return (doc1, doc2) => {\n          const key1 = this._getMinKeyFromDoc(doc1);\n          const key2 = this._getMinKeyFromDoc(doc2);\n          return this._compareKeys(key1, key2);\n        };\n      }\n\n      // Finds the minimum key from the doc, according to the sort specs.  (We say\n      // \"minimum\" here but this is with respect to the sort spec, so \"descending\"\n      // sort fields mean we're finding the max for that field.)\n      //\n      // Note that this is NOT \"find the minimum value of the first field, the\n      // minimum value of the second field, etc\"... it's \"choose the\n      // lexicographically minimum value of the key vector, allowing only keys which\n      // you can find along the same paths\".  ie, for a doc {a: [{x: 0, y: 5}, {x:\n      // 1, y: 3}]} with sort spec {'a.x': 1, 'a.y': 1}, the only keys are [0,5] and\n      // [1,3], and the minimum key is [0,5]; notably, [0,3] is NOT a key.\n      _getMinKeyFromDoc(doc) {\n        let minKey = null;\n        this._generateKeysFromDoc(doc, key => {\n          if (minKey === null) {\n            minKey = key;\n            return;\n          }\n          if (this._compareKeys(key, minKey) < 0) {\n            minKey = key;\n          }\n        });\n        return minKey;\n      }\n      _getPaths() {\n        return this._sortSpecParts.map(part => part.path);\n      }\n\n      // Given an index 'i', returns a comparator that compares two key arrays based\n      // on field 'i'.\n      _keyFieldComparator(i) {\n        const invert = !this._sortSpecParts[i].ascending;\n        return (key1, key2) => {\n          const compare = LocalCollection._f._cmp(key1[i], key2[i]);\n          return invert ? -compare : compare;\n        };\n      }\n    }\n    // Given an array of comparators\n    // (functions (a,b)->(negative or positive or zero)), returns a single\n    // comparator which uses each comparator in order and returns the first\n    // non-zero value.\n    function composeComparators(comparatorArray) {\n      return (a, b) => {\n        for (let i = 0; i < comparatorArray.length; ++i) {\n          const compare = comparatorArray[i](a, b);\n          if (compare !== 0) {\n            return compare;\n          }\n        }\n        return 0;\n      };\n    }\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: false\n});","map":{"version":3,"names":["module","export","default","Sorter","ELEMENT_OPERATORS","equalityElementMatcher","expandArraysInBranches","hasOwn","isOperatorObject","makeLookupFunction","regexpElementMatcher","link","v","__reifyWaitForDeps__","constructor","spec","_sortSpecParts","_sortFunction","addSpecPart","path","ascending","Error","charAt","concat","push","lookup","forSort","Array","forEach","element","Object","keys","key","JSON","stringify","affectedByModifier","selector","_selectorForAffectedByModifier","Minimongo","Matcher","_keyComparator","composeComparators","map","i","_keyFieldComparator","getComparator","options","length","distances","_getBaseComparator","a","b","has","_id","get","_compareKeys","key1","key2","_generateKeysFromDoc","doc","cb","pathFromIndices","indices","join","knownPaths","valuesByIndexAndPath","branches","value","create","usedPaths","branch","arrayIndices","call","soleKey","values","doc1","doc2","_getMinKeyFromDoc","minKey","_getPaths","part","invert","compare","LocalCollection","_f","_cmp","comparatorArray","__reify_async_result__","_reifyError","self","async"],"sources":["packages/minimongo/sorter.js"],"sourcesContent":["import {\n  ELEMENT_OPERATORS,\n  equalityElementMatcher,\n  expandArraysInBranches,\n  hasOwn,\n  isOperatorObject,\n  makeLookupFunction,\n  regexpElementMatcher,\n} from './common.js';\n\n// Give a sort spec, which can be in any of these forms:\n//   {\"key1\": 1, \"key2\": -1}\n//   [[\"key1\", \"asc\"], [\"key2\", \"desc\"]]\n//   [\"key1\", [\"key2\", \"desc\"]]\n//\n// (.. with the first form being dependent on the key enumeration\n// behavior of your javascript VM, which usually does what you mean in\n// this case if the key names don't look like integers ..)\n//\n// return a function that takes two objects, and returns -1 if the\n// first object comes first in order, 1 if the second object comes\n// first, or 0 if neither object comes before the other.\n\nexport default class Sorter {\n  constructor(spec) {\n    this._sortSpecParts = [];\n    this._sortFunction = null;\n\n    const addSpecPart = (path, ascending) => {\n      if (!path) {\n        throw Error('sort keys must be non-empty');\n      }\n\n      if (path.charAt(0) === '$') {\n        throw Error(`unsupported sort key: ${path}`);\n      }\n\n      this._sortSpecParts.push({\n        ascending,\n        lookup: makeLookupFunction(path, {forSort: true}),\n        path\n      });\n    };\n\n    if (spec instanceof Array) {\n      spec.forEach(element => {\n        if (typeof element === 'string') {\n          addSpecPart(element, true);\n        } else {\n          addSpecPart(element[0], element[1] !== 'desc');\n        }\n      });\n    } else if (typeof spec === 'object') {\n      Object.keys(spec).forEach(key => {\n        addSpecPart(key, spec[key] >= 0);\n      });\n    } else if (typeof spec === 'function') {\n      this._sortFunction = spec;\n    } else {\n      throw Error(`Bad sort specification: ${JSON.stringify(spec)}`);\n    }\n\n    // If a function is specified for sorting, we skip the rest.\n    if (this._sortFunction) {\n      return;\n    }\n\n    // To implement affectedByModifier, we piggy-back on top of Matcher's\n    // affectedByModifier code; we create a selector that is affected by the\n    // same modifiers as this sort order. This is only implemented on the\n    // server.\n    if (this.affectedByModifier) {\n      const selector = {};\n\n      this._sortSpecParts.forEach(spec => {\n        selector[spec.path] = 1;\n      });\n\n      this._selectorForAffectedByModifier = new Minimongo.Matcher(selector);\n    }\n\n    this._keyComparator = composeComparators(\n      this._sortSpecParts.map((spec, i) => this._keyFieldComparator(i))\n    );\n  }\n\n  getComparator(options) {\n    // If sort is specified or have no distances, just use the comparator from\n    // the source specification (which defaults to \"everything is equal\".\n    // issue #3599\n    // https://docs.mongodb.com/manual/reference/operator/query/near/#sort-operation\n    // sort effectively overrides $near\n    if (this._sortSpecParts.length || !options || !options.distances) {\n      return this._getBaseComparator();\n    }\n\n    const distances = options.distances;\n\n    // Return a comparator which compares using $near distances.\n    return (a, b) => {\n      if (!distances.has(a._id)) {\n        throw Error(`Missing distance for ${a._id}`);\n      }\n\n      if (!distances.has(b._id)) {\n        throw Error(`Missing distance for ${b._id}`);\n      }\n\n      return distances.get(a._id) - distances.get(b._id);\n    };\n  }\n\n  // Takes in two keys: arrays whose lengths match the number of spec\n  // parts. Returns negative, 0, or positive based on using the sort spec to\n  // compare fields.\n  _compareKeys(key1, key2) {\n    if (key1.length !== this._sortSpecParts.length ||\n        key2.length !== this._sortSpecParts.length) {\n      throw Error('Key has wrong length');\n    }\n\n    return this._keyComparator(key1, key2);\n  }\n\n  // Iterates over each possible \"key\" from doc (ie, over each branch), calling\n  // 'cb' with the key.\n  _generateKeysFromDoc(doc, cb) {\n    if (this._sortSpecParts.length === 0) {\n      throw new Error('can\\'t generate keys without a spec');\n    }\n\n    const pathFromIndices = indices => `${indices.join(',')},`;\n\n    let knownPaths = null;\n\n    // maps index -> ({'' -> value} or {path -> value})\n    const valuesByIndexAndPath = this._sortSpecParts.map(spec => {\n      // Expand any leaf arrays that we find, and ignore those arrays\n      // themselves.  (We never sort based on an array itself.)\n      let branches = expandArraysInBranches(spec.lookup(doc), true);\n\n      // If there are no values for a key (eg, key goes to an empty array),\n      // pretend we found one undefined value.\n      if (!branches.length) {\n        branches = [{ value: void 0 }];\n      }\n\n      const element = Object.create(null);\n      let usedPaths = false;\n\n      branches.forEach(branch => {\n        if (!branch.arrayIndices) {\n          // If there are no array indices for a branch, then it must be the\n          // only branch, because the only thing that produces multiple branches\n          // is the use of arrays.\n          if (branches.length > 1) {\n            throw Error('multiple branches but no array used?');\n          }\n\n          element[''] = branch.value;\n          return;\n        }\n\n        usedPaths = true;\n\n        const path = pathFromIndices(branch.arrayIndices);\n\n        if (hasOwn.call(element, path)) {\n          throw Error(`duplicate path: ${path}`);\n        }\n\n        element[path] = branch.value;\n\n        // If two sort fields both go into arrays, they have to go into the\n        // exact same arrays and we have to find the same paths.  This is\n        // roughly the same condition that makes MongoDB throw this strange\n        // error message.  eg, the main thing is that if sort spec is {a: 1,\n        // b:1} then a and b cannot both be arrays.\n        //\n        // (In MongoDB it seems to be OK to have {a: 1, 'a.x.y': 1} where 'a'\n        // and 'a.x.y' are both arrays, but we don't allow this for now.\n        // #NestedArraySort\n        // XXX achieve full compatibility here\n        if (knownPaths && !hasOwn.call(knownPaths, path)) {\n          throw Error('cannot index parallel arrays');\n        }\n      });\n\n      if (knownPaths) {\n        // Similarly to above, paths must match everywhere, unless this is a\n        // non-array field.\n        if (!hasOwn.call(element, '') &&\n            Object.keys(knownPaths).length !== Object.keys(element).length) {\n          throw Error('cannot index parallel arrays!');\n        }\n      } else if (usedPaths) {\n        knownPaths = {};\n\n        Object.keys(element).forEach(path => {\n          knownPaths[path] = true;\n        });\n      }\n\n      return element;\n    });\n\n    if (!knownPaths) {\n      // Easy case: no use of arrays.\n      const soleKey = valuesByIndexAndPath.map(values => {\n        if (!hasOwn.call(values, '')) {\n          throw Error('no value in sole key case?');\n        }\n\n        return values[''];\n      });\n\n      cb(soleKey);\n\n      return;\n    }\n\n    Object.keys(knownPaths).forEach(path => {\n      const key = valuesByIndexAndPath.map(values => {\n        if (hasOwn.call(values, '')) {\n          return values[''];\n        }\n\n        if (!hasOwn.call(values, path)) {\n          throw Error('missing path?');\n        }\n\n        return values[path];\n      });\n\n      cb(key);\n    });\n  }\n\n  // Returns a comparator that represents the sort specification (but not\n  // including a possible geoquery distance tie-breaker).\n  _getBaseComparator() {\n    if (this._sortFunction) {\n      return this._sortFunction;\n    }\n\n    // If we're only sorting on geoquery distance and no specs, just say\n    // everything is equal.\n    if (!this._sortSpecParts.length) {\n      return (doc1, doc2) => 0;\n    }\n\n    return (doc1, doc2) => {\n      const key1 = this._getMinKeyFromDoc(doc1);\n      const key2 = this._getMinKeyFromDoc(doc2);\n      return this._compareKeys(key1, key2);\n    };\n  }\n\n  // Finds the minimum key from the doc, according to the sort specs.  (We say\n  // \"minimum\" here but this is with respect to the sort spec, so \"descending\"\n  // sort fields mean we're finding the max for that field.)\n  //\n  // Note that this is NOT \"find the minimum value of the first field, the\n  // minimum value of the second field, etc\"... it's \"choose the\n  // lexicographically minimum value of the key vector, allowing only keys which\n  // you can find along the same paths\".  ie, for a doc {a: [{x: 0, y: 5}, {x:\n  // 1, y: 3}]} with sort spec {'a.x': 1, 'a.y': 1}, the only keys are [0,5] and\n  // [1,3], and the minimum key is [0,5]; notably, [0,3] is NOT a key.\n  _getMinKeyFromDoc(doc) {\n    let minKey = null;\n\n    this._generateKeysFromDoc(doc, key => {\n      if (minKey === null) {\n        minKey = key;\n        return;\n      }\n\n      if (this._compareKeys(key, minKey) < 0) {\n        minKey = key;\n      }\n    });\n\n    return minKey;\n  }\n\n  _getPaths() {\n    return this._sortSpecParts.map(part => part.path);\n  }\n\n  // Given an index 'i', returns a comparator that compares two key arrays based\n  // on field 'i'.\n  _keyFieldComparator(i) {\n    const invert = !this._sortSpecParts[i].ascending;\n\n    return (key1, key2) => {\n      const compare = LocalCollection._f._cmp(key1[i], key2[i]);\n      return invert ? -compare : compare;\n    };\n  }\n}\n\n// Given an array of comparators\n// (functions (a,b)->(negative or positive or zero)), returns a single\n// comparator which uses each comparator in order and returns the first\n// non-zero value.\nfunction composeComparators(comparatorArray) {\n  return (a, b) => {\n    for (let i = 0; i < comparatorArray.length; ++i) {\n      const compare = comparatorArray[i](a, b);\n      if (compare !== 0) {\n        return compare;\n      }\n    }\n\n    return 0;\n  };\n}\n"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"2f48b620ab256b6d2eab601cbcee53c92aceec73"}
