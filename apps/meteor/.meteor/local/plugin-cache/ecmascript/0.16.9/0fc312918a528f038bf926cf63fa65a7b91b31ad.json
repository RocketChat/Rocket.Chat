{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/accounts-password/password_server.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.arm64"},"sourceFileName":"packages/accounts-password/password_server.js","filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/accounts-password/password_server.js","targets":{"android":"125.0.0","chrome":"125.0.0","edge":"125.0.0","firefox":"115.0.0","ie":"10.0.0","ios":"17.4.0","opera":"110.0.0","opera_mobile":"80.0.0","safari":"17.4.0","samsung":"24.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","root":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true,"topLevelAwait":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/accounts-password/password_server.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/accounts-password/password_server.js"}},"code":"!module.wrapAsync(async function (module, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    let _objectSpread;\n    module.link(\"@babel/runtime/helpers/objectSpread2\", {\n      default(v) {\n        _objectSpread = v;\n      }\n    }, 0);\n    let bcryptHash, bcryptCompare;\n    module.link(\"bcrypt\", {\n      hash(v) {\n        bcryptHash = v;\n      },\n      compare(v) {\n        bcryptCompare = v;\n      }\n    }, 0);\n    let Accounts;\n    module.link(\"meteor/accounts-base\", {\n      Accounts(v) {\n        Accounts = v;\n      }\n    }, 1);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    // Utility for grabbing user\n    const getUserById = async (id, options) => await Meteor.users.findOneAsync(id, Accounts._addDefaultFieldSelector(options));\n\n    // User records have a 'services.password.bcrypt' field on them to hold\n    // their hashed passwords.\n    //\n    // When the client sends a password to the server, it can either be a\n    // string (the plaintext password) or an object with keys 'digest' and\n    // 'algorithm' (must be \"sha-256\" for now). The Meteor client always sends\n    // password objects { digest: *, algorithm: \"sha-256\" }, but DDP clients\n    // that don't have access to SHA can just send plaintext passwords as\n    // strings.\n    //\n    // When the server receives a plaintext password as a string, it always\n    // hashes it with SHA256 before passing it into bcrypt. When the server\n    // receives a password as an object, it asserts that the algorithm is\n    // \"sha-256\" and then passes the digest to bcrypt.\n\n    Accounts._bcryptRounds = () => Accounts._options.bcryptRounds || 10;\n\n    // Given a 'password' from the client, extract the string that we should\n    // bcrypt. 'password' can be one of:\n    //  - String (the plaintext password)\n    //  - Object with 'digest' and 'algorithm' keys. 'algorithm' must be \"sha-256\".\n    //\n    const getPasswordString = password => {\n      if (typeof password === \"string\") {\n        password = SHA256(password);\n      } else {\n        // 'password' is an object\n        if (password.algorithm !== \"sha-256\") {\n          throw new Error(\"Invalid password hash algorithm. \" + \"Only 'sha-256' is allowed.\");\n        }\n        password = password.digest;\n      }\n      return password;\n    };\n\n    // Use bcrypt to hash the password for storage in the database.\n    // `password` can be a string (in which case it will be run through\n    // SHA256 before bcrypt) or an object with properties `digest` and\n    // `algorithm` (in which case we bcrypt `password.digest`).\n    //\n    const hashPassword = async password => {\n      password = getPasswordString(password);\n      return await bcryptHash(password, Accounts._bcryptRounds());\n    };\n\n    // Extract the number of rounds used in the specified bcrypt hash.\n    const getRoundsFromBcryptHash = hash => {\n      let rounds;\n      if (hash) {\n        const hashSegments = hash.split('$');\n        if (hashSegments.length > 2) {\n          rounds = parseInt(hashSegments[2], 10);\n        }\n      }\n      return rounds;\n    };\n\n    // Check whether the provided password matches the bcrypt'ed password in\n    // the database user record. `password` can be a string (in which case\n    // it will be run through SHA256 before bcrypt) or an object with\n    // properties `digest` and `algorithm` (in which case we bcrypt\n    // `password.digest`).\n    //\n    // The user parameter needs at least user._id and user.services\n    Accounts._checkPasswordUserFields = {\n      _id: 1,\n      services: 1\n    };\n    //\n    const checkPasswordAsync = async (user, password) => {\n      const result = {\n        userId: user._id\n      };\n      const formattedPassword = getPasswordString(password);\n      const hash = user.services.password.bcrypt;\n      const hashRounds = getRoundsFromBcryptHash(hash);\n      if (!(await bcryptCompare(formattedPassword, hash))) {\n        result.error = Accounts._handleError(\"Incorrect password\", false);\n      } else if (hash && Accounts._bcryptRounds() != hashRounds) {\n        // The password checks out, but the user's bcrypt hash needs to be updated.\n\n        Meteor.defer(async () => {\n          await Meteor.users.updateAsync({\n            _id: user._id\n          }, {\n            $set: {\n              'services.password.bcrypt': await bcryptHash(formattedPassword, Accounts._bcryptRounds())\n            }\n          });\n        });\n      }\n      return result;\n    };\n    Accounts._checkPasswordAsync = checkPasswordAsync;\n\n    ///\n    /// LOGIN\n    ///\n\n    /**\n     * @summary Finds the user asynchronously with the specified username.\n     * First tries to match username case sensitively; if that fails, it\n     * tries case insensitively; but if more than one user matches the case\n     * insensitive search, it returns null.\n     * @locus Server\n     * @param {String} username The username to look for\n     * @param {Object} [options]\n     * @param {MongoFieldSpecifier} options.fields Dictionary of fields to return or exclude.\n     * @returns {Promise<Object>} A user if found, else null\n     * @importFromPackage accounts-base\n     */\n    Accounts.findUserByUsername = async (username, options) => await Accounts._findUserByQuery({\n      username\n    }, options);\n\n    /**\n     * @summary Finds the user asynchronously with the specified email.\n     * First tries to match email case sensitively; if that fails, it\n     * tries case insensitively; but if more than one user matches the case\n     * insensitive search, it returns null.\n     * @locus Server\n     * @param {String} email The email address to look for\n     * @param {Object} [options]\n     * @param {MongoFieldSpecifier} options.fields Dictionary of fields to return or exclude.\n     * @returns {Promise<Object>} A user if found, else null\n     * @importFromPackage accounts-base\n     */\n    Accounts.findUserByEmail = async (email, options) => await Accounts._findUserByQuery({\n      email\n    }, options);\n\n    // XXX maybe this belongs in the check package\n    const NonEmptyString = Match.Where(x => {\n      check(x, String);\n      return x.length > 0;\n    });\n    const passwordValidator = Match.OneOf(Match.Where(str => {\n      var _Meteor$settings, _Meteor$settings$pack, _Meteor$settings$pack2;\n      return Match.test(str, String) && str.length <= ((_Meteor$settings = Meteor.settings) === null || _Meteor$settings === void 0 ? void 0 : (_Meteor$settings$pack = _Meteor$settings.packages) === null || _Meteor$settings$pack === void 0 ? void 0 : (_Meteor$settings$pack2 = _Meteor$settings$pack.accounts) === null || _Meteor$settings$pack2 === void 0 ? void 0 : _Meteor$settings$pack2.passwordMaxLength) || 256;\n    }), {\n      digest: Match.Where(str => Match.test(str, String) && str.length === 64),\n      algorithm: Match.OneOf('sha-256')\n    });\n\n    // Handler to login with a password.\n    //\n    // The Meteor client sets options.password to an object with keys\n    // 'digest' (set to SHA256(password)) and 'algorithm' (\"sha-256\").\n    //\n    // For other DDP clients which don't have access to SHA, the handler\n    // also accepts the plaintext password in options.password as a string.\n    //\n    // (It might be nice if servers could turn the plaintext password\n    // option off. Or maybe it should be opt-in, not opt-out?\n    // Accounts.config option?)\n    //\n    // Note that neither password option is secure without SSL.\n    //\n    Accounts.registerLoginHandler(\"password\", async options => {\n      var _Accounts$_check2faEn, _Accounts;\n      if (!options.password) return undefined; // don't handle\n\n      check(options, {\n        user: Accounts._userQueryValidator,\n        password: passwordValidator,\n        code: Match.Optional(NonEmptyString)\n      });\n      const user = await Accounts._findUserByQuery(options.user, {\n        fields: _objectSpread({\n          services: 1\n        }, Accounts._checkPasswordUserFields)\n      });\n      if (!user) {\n        Accounts._handleError(\"User not found\");\n      }\n      if (!user.services || !user.services.password || !user.services.password.bcrypt) {\n        Accounts._handleError(\"User has no password set\");\n      }\n      const result = await checkPasswordAsync(user, options.password);\n      // This method is added by the package accounts-2fa\n      // First the login is validated, then the code situation is checked\n      if (!result.error && (_Accounts$_check2faEn = (_Accounts = Accounts)._check2faEnabled) !== null && _Accounts$_check2faEn !== void 0 && _Accounts$_check2faEn.call(_Accounts, user)) {\n        if (!options.code) {\n          Accounts._handleError('2FA code must be informed', true, 'no-2fa-code');\n        }\n        if (!Accounts._isTokenValid(user.services.twoFactorAuthentication.secret, options.code)) {\n          Accounts._handleError('Invalid 2FA code', true, 'invalid-2fa-code');\n        }\n      }\n      return result;\n    });\n\n    ///\n    /// CHANGING\n    ///\n\n    /**\n     * @summary Change a user's username asynchronously. Use this instead of updating the\n     * database directly. The operation will fail if there is an existing user\n     * with a username only differing in case.\n     * @locus Server\n     * @param {String} userId The ID of the user to update.\n     * @param {String} newUsername A new username for the user.\n     * @importFromPackage accounts-base\n     */\n    Accounts.setUsername = async (userId, newUsername) => {\n      check(userId, NonEmptyString);\n      check(newUsername, NonEmptyString);\n      const user = await getUserById(userId, {\n        fields: {\n          username: 1\n        }\n      });\n      if (!user) {\n        Accounts._handleError(\"User not found\");\n      }\n      const oldUsername = user.username;\n\n      // Perform a case insensitive check for duplicates before update\n      await Accounts._checkForCaseInsensitiveDuplicates('username', 'Username', newUsername, user._id);\n      await Meteor.users.updateAsync({\n        _id: user._id\n      }, {\n        $set: {\n          username: newUsername\n        }\n      });\n\n      // Perform another check after update, in case a matching user has been\n      // inserted in the meantime\n      try {\n        await Accounts._checkForCaseInsensitiveDuplicates('username', 'Username', newUsername, user._id);\n      } catch (ex) {\n        // Undo update if the check fails\n        await Meteor.users.updateAsync({\n          _id: user._id\n        }, {\n          $set: {\n            username: oldUsername\n          }\n        });\n        throw ex;\n      }\n    };\n\n    // Let the user change their own password if they know the old\n    // password. `oldPassword` and `newPassword` should be objects with keys\n    // `digest` and `algorithm` (representing the SHA256 of the password).\n    Meteor.methods({\n      changePassword: async function (oldPassword, newPassword) {\n        check(oldPassword, passwordValidator);\n        check(newPassword, passwordValidator);\n        if (!this.userId) {\n          throw new Meteor.Error(401, \"Must be logged in\");\n        }\n        const user = await getUserById(this.userId, {\n          fields: _objectSpread({\n            services: 1\n          }, Accounts._checkPasswordUserFields)\n        });\n        if (!user) {\n          Accounts._handleError(\"User not found\");\n        }\n        if (!user.services || !user.services.password || !user.services.password.bcrypt) {\n          Accounts._handleError(\"User has no password set\");\n        }\n        const result = await checkPasswordAsync(user, oldPassword);\n        if (result.error) {\n          throw result.error;\n        }\n        const hashed = await hashPassword(newPassword);\n\n        // It would be better if this removed ALL existing tokens and replaced\n        // the token for the current connection with a new one, but that would\n        // be tricky, so we'll settle for just replacing all tokens other than\n        // the one for the current connection.\n        const currentToken = Accounts._getLoginToken(this.connection.id);\n        await Meteor.users.updateAsync({\n          _id: this.userId\n        }, {\n          $set: {\n            'services.password.bcrypt': hashed\n          },\n          $pull: {\n            'services.resume.loginTokens': {\n              hashedToken: {\n                $ne: currentToken\n              }\n            }\n          },\n          $unset: {\n            'services.password.reset': 1\n          }\n        });\n        return {\n          passwordChanged: true\n        };\n      }\n    });\n\n    // Force change the users password.\n\n    /**\n     * @summary Forcibly change the password for a user.\n     * @locus Server\n     * @param {String} userId The id of the user to update.\n     * @param {String} newPassword A new password for the user.\n     * @param {Object} [options]\n     * @param {Object} options.logout Logout all current connections with this userId (default: true)\n     * @importFromPackage accounts-base\n     */\n    Accounts.setPasswordAsync = async (userId, newPlaintextPassword, options) => {\n      check(userId, String);\n      check(newPlaintextPassword, Match.Where(str => {\n        var _Meteor$settings2, _Meteor$settings2$pac, _Meteor$settings2$pac2;\n        return Match.test(str, String) && str.length <= ((_Meteor$settings2 = Meteor.settings) === null || _Meteor$settings2 === void 0 ? void 0 : (_Meteor$settings2$pac = _Meteor$settings2.packages) === null || _Meteor$settings2$pac === void 0 ? void 0 : (_Meteor$settings2$pac2 = _Meteor$settings2$pac.accounts) === null || _Meteor$settings2$pac2 === void 0 ? void 0 : _Meteor$settings2$pac2.passwordMaxLength) || 256;\n      }));\n      check(options, Match.Maybe({\n        logout: Boolean\n      }));\n      options = _objectSpread({\n        logout: true\n      }, options);\n      const user = await getUserById(userId, {\n        fields: {\n          _id: 1\n        }\n      });\n      if (!user) {\n        throw new Meteor.Error(403, \"User not found\");\n      }\n      const update = {\n        $unset: {\n          'services.password.reset': 1\n        },\n        $set: {\n          'services.password.bcrypt': await hashPassword(newPlaintextPassword)\n        }\n      };\n      if (options.logout) {\n        update.$unset['services.resume.loginTokens'] = 1;\n      }\n      await Meteor.users.updateAsync({\n        _id: user._id\n      }, update);\n    };\n\n    ///\n    /// RESETTING VIA EMAIL\n    ///\n\n    // Utility for plucking addresses from emails\n    const pluckAddresses = function () {\n      let emails = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      return emails.map(email => email.address);\n    };\n\n    // Method called by a user to request a password reset email. This is\n    // the start of the reset process.\n    Meteor.methods({\n      forgotPassword: async options => {\n        check(options, {\n          email: String\n        });\n        const user = await Accounts.findUserByEmail(options.email, {\n          fields: {\n            emails: 1\n          }\n        });\n        if (!user) {\n          Accounts._handleError(\"User not found\");\n        }\n        const emails = pluckAddresses(user.emails);\n        const caseSensitiveEmail = emails.find(email => email.toLowerCase() === options.email.toLowerCase());\n        await Accounts.sendResetPasswordEmail(user._id, caseSensitiveEmail);\n      }\n    });\n\n    /**\n     * @summary Asynchronously generates a reset token and saves it into the database.\n     * @locus Server\n     * @param {String} userId The id of the user to generate the reset token for.\n     * @param {String} email Which address of the user to generate the reset token for. This address must be in the user's `emails` list. If `null`, defaults to the first email in the list.\n     * @param {String} reason `resetPassword` or `enrollAccount`.\n     * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n     * @returns {Promise<Object>} Promise of an object with {email, user, token} values.\n     * @importFromPackage accounts-base\n     */\n    Accounts.generateResetToken = async (userId, email, reason, extraTokenData) => {\n      // Make sure the user exists, and email is one of their addresses.\n      // Don't limit the fields in the user object since the user is returned\n      // by the function and some other fields might be used elsewhere.\n      const user = await getUserById(userId);\n      if (!user) {\n        Accounts._handleError(\"Can't find user\");\n      }\n\n      // pick the first email if we weren't passed an email.\n      if (!email && user.emails && user.emails[0]) {\n        email = user.emails[0].address;\n      }\n\n      // make sure we have a valid email\n      if (!email || !pluckAddresses(user.emails).includes(email)) {\n        Accounts._handleError(\"No such email for user.\");\n      }\n      const token = Random.secret();\n      const tokenRecord = {\n        token,\n        email,\n        when: new Date()\n      };\n      if (reason === 'resetPassword') {\n        tokenRecord.reason = 'reset';\n      } else if (reason === 'enrollAccount') {\n        tokenRecord.reason = 'enroll';\n      } else if (reason) {\n        // fallback so that this function can be used for unknown reasons as well\n        tokenRecord.reason = reason;\n      }\n      if (extraTokenData) {\n        Object.assign(tokenRecord, extraTokenData);\n      }\n      // if this method is called from the enroll account work-flow then\n      // store the token record in 'services.password.enroll' db field\n      // else store the token record in in 'services.password.reset' db field\n      if (reason === 'enrollAccount') {\n        await Meteor.users.updateAsync({\n          _id: user._id\n        }, {\n          $set: {\n            'services.password.enroll': tokenRecord\n          }\n        });\n        // before passing to template, update user object with new token\n        Meteor._ensure(user, 'services', 'password').enroll = tokenRecord;\n      } else {\n        await Meteor.users.updateAsync({\n          _id: user._id\n        }, {\n          $set: {\n            'services.password.reset': tokenRecord\n          }\n        });\n        // before passing to template, update user object with new token\n        Meteor._ensure(user, 'services', 'password').reset = tokenRecord;\n      }\n      return {\n        email,\n        user,\n        token\n      };\n    };\n\n    /**\n     * @summary Generates asynchronously an e-mail verification token and saves it into the database.\n     * @locus Server\n     * @param {String} userId The id of the user to generate the  e-mail verification token for.\n     * @param {String} email Which address of the user to generate the e-mail verification token for. This address must be in the user's `emails` list. If `null`, defaults to the first unverified email in the list.\n     * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n     * @returns {Promise<Object>} Promise of an object with {email, user, token} values.\n     * @importFromPackage accounts-base\n     */\n    Accounts.generateVerificationToken = async (userId, email, extraTokenData) => {\n      // Make sure the user exists, and email is one of their addresses.\n      // Don't limit the fields in the user object since the user is returned\n      // by the function and some other fields might be used elsewhere.\n      const user = await getUserById(userId);\n      if (!user) {\n        Accounts._handleError(\"Can't find user\");\n      }\n\n      // pick the first unverified email if we weren't passed an email.\n      if (!email) {\n        const emailRecord = (user.emails || []).find(e => !e.verified);\n        email = (emailRecord || {}).address;\n        if (!email) {\n          Accounts._handleError(\"That user has no unverified email addresses.\");\n        }\n      }\n\n      // make sure we have a valid email\n      if (!email || !pluckAddresses(user.emails).includes(email)) {\n        Accounts._handleError(\"No such email for user.\");\n      }\n      const token = Random.secret();\n      const tokenRecord = {\n        token,\n        // TODO: This should probably be renamed to \"email\" to match reset token record.\n        address: email,\n        when: new Date()\n      };\n      if (extraTokenData) {\n        Object.assign(tokenRecord, extraTokenData);\n      }\n      await Meteor.users.updateAsync({\n        _id: user._id\n      }, {\n        $push: {\n          'services.email.verificationTokens': tokenRecord\n        }\n      });\n\n      // before passing to template, update user object with new token\n      Meteor._ensure(user, 'services', 'email');\n      if (!user.services.email.verificationTokens) {\n        user.services.email.verificationTokens = [];\n      }\n      user.services.email.verificationTokens.push(tokenRecord);\n      return {\n        email,\n        user,\n        token\n      };\n    };\n\n    // send the user an email with a link that when opened allows the user\n    // to set a new password, without the old password.\n\n    /**\n     * @summary Send an email asynchronously with a link the user can use to reset their password.\n     * @locus Server\n     * @param {String} userId The id of the user to send email to.\n     * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first email in the list.\n     * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n     * @param {Object} [extraParams] Optional additional params to be added to the reset url.\n     * @returns {Promise<Object>} Promise of an object with {email, user, token, url, options} values.\n     * @importFromPackage accounts-base\n     */\n    Accounts.sendResetPasswordEmail = async (userId, email, extraTokenData, extraParams) => {\n      const {\n        email: realEmail,\n        user,\n        token\n      } = await Accounts.generateResetToken(userId, email, 'resetPassword', extraTokenData);\n      const url = Accounts.urls.resetPassword(token, extraParams);\n      const options = await Accounts.generateOptionsForEmail(realEmail, user, url, 'resetPassword');\n      await Email.sendAsync(options);\n      if (Meteor.isDevelopment) {\n        console.log(\"\\nReset password URL: \".concat(url));\n      }\n      return {\n        email: realEmail,\n        user,\n        token,\n        url,\n        options\n      };\n    };\n\n    // send the user an email informing them that their account was created, with\n    // a link that when opened both marks their email as verified and forces them\n    // to choose their password. The email must be one of the addresses in the\n    // user's emails field, or undefined to pick the first email automatically.\n    //\n    // This is not called automatically. It must be called manually if you\n    // want to use enrollment emails.\n\n    /**\n     * @summary Send an email asynchronously with a link the user can use to set their initial password.\n     * @locus Server\n     * @param {String} userId The id of the user to send email to.\n     * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first email in the list.\n     * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n     * @param {Object} [extraParams] Optional additional params to be added to the enrollment url.\n     * @returns {Promise<Object>} Promise of an object {email, user, token, url, options} values.\n     * @importFromPackage accounts-base\n     */\n    Accounts.sendEnrollmentEmail = async (userId, email, extraTokenData, extraParams) => {\n      const {\n        email: realEmail,\n        user,\n        token\n      } = await Accounts.generateResetToken(userId, email, 'enrollAccount', extraTokenData);\n      const url = Accounts.urls.enrollAccount(token, extraParams);\n      const options = await Accounts.generateOptionsForEmail(realEmail, user, url, 'enrollAccount');\n      await Email.sendAsync(options);\n      if (Meteor.isDevelopment) {\n        console.log(\"\\nEnrollment email URL: \".concat(url));\n      }\n      return {\n        email: realEmail,\n        user,\n        token,\n        url,\n        options\n      };\n    };\n\n    // Take token from sendResetPasswordEmail or sendEnrollmentEmail, change\n    // the users password, and log them in.\n    Meteor.methods({\n      resetPassword: async function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        const token = args[0];\n        const newPassword = args[1];\n        return await Accounts._loginMethod(this, \"resetPassword\", args, \"password\", async () => {\n          var _Accounts$_check2faEn2, _Accounts2;\n          check(token, String);\n          check(newPassword, passwordValidator);\n          let user = await Meteor.users.findOneAsync({\n            \"services.password.reset.token\": token\n          }, {\n            fields: {\n              services: 1,\n              emails: 1\n            }\n          });\n          let isEnroll = false;\n          // if token is in services.password.reset db field implies\n          // this method is was not called from enroll account workflow\n          // else this method is called from enroll account workflow\n          if (!user) {\n            user = await Meteor.users.findOneAsync({\n              \"services.password.enroll.token\": token\n            }, {\n              fields: {\n                services: 1,\n                emails: 1\n              }\n            });\n            isEnroll = true;\n          }\n          if (!user) {\n            throw new Meteor.Error(403, \"Token expired\");\n          }\n          let tokenRecord = {};\n          if (isEnroll) {\n            tokenRecord = user.services.password.enroll;\n          } else {\n            tokenRecord = user.services.password.reset;\n          }\n          const {\n            when,\n            email\n          } = tokenRecord;\n          let tokenLifetimeMs = Accounts._getPasswordResetTokenLifetimeMs();\n          if (isEnroll) {\n            tokenLifetimeMs = Accounts._getPasswordEnrollTokenLifetimeMs();\n          }\n          const currentTimeMs = Date.now();\n          if (currentTimeMs - when > tokenLifetimeMs) throw new Meteor.Error(403, \"Token expired\");\n          if (!pluckAddresses(user.emails).includes(email)) return {\n            userId: user._id,\n            error: new Meteor.Error(403, \"Token has invalid email address\")\n          };\n          const hashed = await hashPassword(newPassword);\n\n          // NOTE: We're about to invalidate tokens on the user, who we might be\n          // logged in as. Make sure to avoid logging ourselves out if this\n          // happens. But also make sure not to leave the connection in a state\n          // of having a bad token set if things fail.\n          const oldToken = Accounts._getLoginToken(this.connection.id);\n          Accounts._setLoginToken(user._id, this.connection, null);\n          const resetToOldToken = () => Accounts._setLoginToken(user._id, this.connection, oldToken);\n          try {\n            // Update the user record by:\n            // - Changing the password to the new one\n            // - Forgetting about the reset token or enroll token that was just used\n            // - Verifying their email, since they got the password reset via email.\n            let affectedRecords = {};\n            // if reason is enroll then check services.password.enroll.token field for affected records\n            if (isEnroll) {\n              affectedRecords = await Meteor.users.updateAsync({\n                _id: user._id,\n                'emails.address': email,\n                'services.password.enroll.token': token\n              }, {\n                $set: {\n                  'services.password.bcrypt': hashed,\n                  'emails.$.verified': true\n                },\n                $unset: {\n                  'services.password.enroll': 1\n                }\n              });\n            } else {\n              affectedRecords = await Meteor.users.updateAsync({\n                _id: user._id,\n                'emails.address': email,\n                'services.password.reset.token': token\n              }, {\n                $set: {\n                  'services.password.bcrypt': hashed,\n                  'emails.$.verified': true\n                },\n                $unset: {\n                  'services.password.reset': 1\n                }\n              });\n            }\n            if (affectedRecords !== 1) return {\n              userId: user._id,\n              error: new Meteor.Error(403, \"Invalid email\")\n            };\n          } catch (err) {\n            resetToOldToken();\n            throw err;\n          }\n\n          // Replace all valid login tokens with new ones (changing\n          // password should invalidate existing sessions).\n          await Accounts._clearAllLoginTokens(user._id);\n          if ((_Accounts$_check2faEn2 = (_Accounts2 = Accounts)._check2faEnabled) !== null && _Accounts$_check2faEn2 !== void 0 && _Accounts$_check2faEn2.call(_Accounts2, user)) {\n            return {\n              userId: user._id,\n              error: Accounts._handleError('Changed password, but user not logged in because 2FA is enabled', false, '2fa-enabled')\n            };\n          }\n          return {\n            userId: user._id\n          };\n        });\n      }\n    });\n\n    ///\n    /// EMAIL VERIFICATION\n    ///\n\n    // send the user an email with a link that when opened marks that\n    // address as verified\n\n    /**\n     * @summary Send an email asynchronously with a link the user can use verify their email address.\n     * @locus Server\n     * @param {String} userId The id of the user to send email to.\n     * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first unverified email in the list.\n     * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n     * @param {Object} [extraParams] Optional additional params to be added to the verification url.\n     * @returns {Promise<Object>} Promise of an object with {email, user, token, url, options} values.\n     * @importFromPackage accounts-base\n     */\n    Accounts.sendVerificationEmail = async (userId, email, extraTokenData, extraParams) => {\n      // XXX Also generate a link using which someone can delete this\n      // account if they own said address but weren't those who created\n      // this account.\n\n      const {\n        email: realEmail,\n        user,\n        token\n      } = await Accounts.generateVerificationToken(userId, email, extraTokenData);\n      const url = Accounts.urls.verifyEmail(token, extraParams);\n      const options = await Accounts.generateOptionsForEmail(realEmail, user, url, 'verifyEmail');\n      await Email.sendAsync(options);\n      if (Meteor.isDevelopment) {\n        console.log(\"\\nVerification email URL: \".concat(url));\n      }\n      return {\n        email: realEmail,\n        user,\n        token,\n        url,\n        options\n      };\n    };\n\n    // Take token from sendVerificationEmail, mark the email as verified,\n    // and log them in.\n    Meteor.methods({\n      verifyEmail: async function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n        const token = args[0];\n        return await Accounts._loginMethod(this, \"verifyEmail\", args, \"password\", async () => {\n          var _Accounts$_check2faEn3, _Accounts3;\n          check(token, String);\n          const user = await Meteor.users.findOneAsync({\n            'services.email.verificationTokens.token': token\n          }, {\n            fields: {\n              services: 1,\n              emails: 1\n            }\n          });\n          if (!user) throw new Meteor.Error(403, \"Verify email link expired\");\n          const tokenRecord = await user.services.email.verificationTokens.find(t => t.token == token);\n          if (!tokenRecord) return {\n            userId: user._id,\n            error: new Meteor.Error(403, \"Verify email link expired\")\n          };\n          const emailsRecord = user.emails.find(e => e.address == tokenRecord.address);\n          if (!emailsRecord) return {\n            userId: user._id,\n            error: new Meteor.Error(403, \"Verify email link is for unknown address\")\n          };\n\n          // By including the address in the query, we can use 'emails.$' in the\n          // modifier to get a reference to the specific object in the emails\n          // array. See\n          // http://www.mongodb.org/display/DOCS/Updating/#Updating-The%24positionaloperator)\n          // http://www.mongodb.org/display/DOCS/Updating#Updating-%24pull\n          await Meteor.users.updateAsync({\n            _id: user._id,\n            'emails.address': tokenRecord.address\n          }, {\n            $set: {\n              'emails.$.verified': true\n            },\n            $pull: {\n              'services.email.verificationTokens': {\n                address: tokenRecord.address\n              }\n            }\n          });\n          if ((_Accounts$_check2faEn3 = (_Accounts3 = Accounts)._check2faEnabled) !== null && _Accounts$_check2faEn3 !== void 0 && _Accounts$_check2faEn3.call(_Accounts3, user)) {\n            return {\n              userId: user._id,\n              error: Accounts._handleError('Email verified, but user not logged in because 2FA is enabled', false, '2fa-enabled')\n            };\n          }\n          return {\n            userId: user._id\n          };\n        });\n      }\n    });\n\n    /**\n     * @summary Asynchronously add an email address for a user. Use this instead of directly\n     * updating the database. The operation will fail if there is a different user\n     * with an email only differing in case. If the specified user has an existing\n     * email only differing in case however, we replace it.\n     * @locus Server\n     * @param {String} userId The ID of the user to update.\n     * @param {String} newEmail A new email address for the user.\n     * @param {Boolean} [verified] Optional - whether the new email address should\n     * be marked as verified. Defaults to false.\n     * @importFromPackage accounts-base\n     */\n    Accounts.addEmailAsync = async (userId, newEmail, verified) => {\n      check(userId, NonEmptyString);\n      check(newEmail, NonEmptyString);\n      check(verified, Match.Optional(Boolean));\n      if (verified === void 0) {\n        verified = false;\n      }\n      const user = await getUserById(userId, {\n        fields: {\n          emails: 1\n        }\n      });\n      if (!user) throw new Meteor.Error(403, \"User not found\");\n\n      // Allow users to change their own email to a version with a different case\n\n      // We don't have to call checkForCaseInsensitiveDuplicates to do a case\n      // insensitive check across all emails in the database here because: (1) if\n      // there is no case-insensitive duplicate between this user and other users,\n      // then we are OK and (2) if this would create a conflict with other users\n      // then there would already be a case-insensitive duplicate and we can't fix\n      // that in this code anyway.\n      const caseInsensitiveRegExp = new RegExp(\"^\".concat(Meteor._escapeRegExp(newEmail), \"$\"), \"i\");\n\n      // TODO: This is a linear search. If we have a lot of emails.\n      //  we should consider using a different data structure.\n      const updatedEmail = async function () {\n        let emails = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        let _id = arguments.length > 1 ? arguments[1] : undefined;\n        let updated = false;\n        for (const email of emails) {\n          if (caseInsensitiveRegExp.test(email.address)) {\n            await Meteor.users.updateAsync({\n              _id: _id,\n              \"emails.address\": email.address\n            }, {\n              $set: {\n                \"emails.$.address\": newEmail,\n                \"emails.$.verified\": verified\n              }\n            });\n            updated = true;\n          }\n        }\n        return updated;\n      };\n      const didUpdateOwnEmail = await updatedEmail(user.emails, user._id);\n\n      // In the other updates below, we have to do another call to\n      // checkForCaseInsensitiveDuplicates to make sure that no conflicting values\n      // were added to the database in the meantime. We don't have to do this for\n      // the case where the user is updating their email address to one that is the\n      // same as before, but only different because of capitalization. Read the\n      // big comment above to understand why.\n\n      if (didUpdateOwnEmail) {\n        return;\n      }\n\n      // Perform a case insensitive check for duplicates before update\n      await Accounts._checkForCaseInsensitiveDuplicates(\"emails.address\", \"Email\", newEmail, user._id);\n      await Meteor.users.updateAsync({\n        _id: user._id\n      }, {\n        $addToSet: {\n          emails: {\n            address: newEmail,\n            verified: verified\n          }\n        }\n      });\n\n      // Perform another check after update, in case a matching user has been\n      // inserted in the meantime\n      try {\n        await Accounts._checkForCaseInsensitiveDuplicates(\"emails.address\", \"Email\", newEmail, user._id);\n      } catch (ex) {\n        // Undo update if the check fails\n        await Meteor.users.updateAsync({\n          _id: user._id\n        }, {\n          $pull: {\n            emails: {\n              address: newEmail\n            }\n          }\n        });\n        throw ex;\n      }\n    };\n\n    /**\n     * @summary Remove an email address asynchronously for a user. Use this instead of updating\n     * the database directly.\n     * @locus Server\n     * @param {String} userId The ID of the user to update.\n     * @param {String} email The email address to remove.\n     * @importFromPackage accounts-base\n     */\n    Accounts.removeEmail = async (userId, email) => {\n      check(userId, NonEmptyString);\n      check(email, NonEmptyString);\n      const user = await getUserById(userId, {\n        fields: {\n          _id: 1\n        }\n      });\n      if (!user) throw new Meteor.Error(403, \"User not found\");\n      await Meteor.users.updateAsync({\n        _id: user._id\n      }, {\n        $pull: {\n          emails: {\n            address: email\n          }\n        }\n      });\n    };\n\n    ///\n    /// CREATING USERS\n    ///\n\n    // Shared createUser function called from the createUser method, both\n    // if originates in client or server code. Calls user provided hooks,\n    // does the actual user insertion.\n    //\n    // returns the user id\n    const createUser = async options => {\n      // Unknown keys allowed, because a onCreateUserHook can take arbitrary\n      // options.\n      check(options, Match.ObjectIncluding({\n        username: Match.Optional(String),\n        email: Match.Optional(String),\n        password: Match.Optional(passwordValidator)\n      }));\n      const {\n        username,\n        email,\n        password\n      } = options;\n      if (!username && !email) throw new Meteor.Error(400, \"Need to set a username or email\");\n      const user = {\n        services: {}\n      };\n      if (password) {\n        const hashed = await hashPassword(password);\n        user.services.password = {\n          bcrypt: hashed\n        };\n      }\n      return await Accounts._createUserCheckingDuplicates({\n        user,\n        email,\n        username,\n        options\n      });\n    };\n\n    // method for create user. Requests come from the client.\n    Meteor.methods({\n      createUser: async function () {\n        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          args[_key3] = arguments[_key3];\n        }\n        const options = args[0];\n        return await Accounts._loginMethod(this, \"createUser\", args, \"password\", async () => {\n          // createUser() above does more checking.\n          check(options, Object);\n          if (Accounts._options.forbidClientAccountCreation) return {\n            error: new Meteor.Error(403, \"Signups forbidden\")\n          };\n          const userId = await Accounts.createUserVerifyingEmail(options);\n\n          // client gets logged in as the new user afterwards.\n          return {\n            userId: userId\n          };\n        });\n      }\n    });\n\n    /**\n     * @summary Creates an user asynchronously and sends an email if `options.email` is informed.\n     * Then if the `sendVerificationEmail` option from the `Accounts` package is\n     * enabled, you'll send a verification email if `options.password` is informed,\n     * otherwise you'll send an enrollment email.\n     * @locus Server\n     * @param {Object} options The options object to be passed down when creating\n     * the user\n     * @param {String} options.username A unique name for this user.\n     * @param {String} options.email The user's email address.\n     * @param {String} options.password The user's password. This is __not__ sent in plain text over the wire.\n     * @param {Object} options.profile The user's profile, typically including the `name` field.\n     * @importFromPackage accounts-base\n     * */\n    Accounts.createUserVerifyingEmail = async options => {\n      options = _objectSpread({}, options);\n      // Create user. result contains id and token.\n      const userId = await createUser(options);\n      // safety belt. createUser is supposed to throw on error. send 500 error\n      // instead of sending a verification email with empty userid.\n      if (!userId) throw new Error(\"createUser failed to insert new user\");\n\n      // If `Accounts._options.sendVerificationEmail` is set, register\n      // a token to verify the user's primary email, and send it to\n      // that address.\n      if (options.email && Accounts._options.sendVerificationEmail) {\n        if (options.password) {\n          await Accounts.sendVerificationEmail(userId, options.email);\n        } else {\n          await Accounts.sendEnrollmentEmail(userId, options.email);\n        }\n      }\n      return userId;\n    };\n\n    // Create user directly on the server.\n    //\n    // Unlike the client version, this does not log you in as this user\n    // after creation.\n    //\n    // returns Promise<userId> or throws an error if it can't create\n    //\n    // XXX add another argument (\"server options\") that gets sent to onCreateUser,\n    // which is always empty when called from the createUser method? eg, \"admin:\n    // true\", which we want to prevent the client from setting, but which a custom\n    // method calling Accounts.createUser could set?\n    //\n\n    Accounts.createUserAsync = async (options, callback) => {\n      options = _objectSpread({}, options);\n\n      // XXX allow an optional callback?\n      if (callback) {\n        throw new Error(\"Accounts.createUser with callback not supported on the server yet.\");\n      }\n      return createUser(options);\n    };\n\n    // Create user directly on the server.\n    //\n    // Unlike the client version, this does not log you in as this user\n    // after creation.\n    //\n    // returns userId or throws an error if it can't create\n    //\n    // XXX add another argument (\"server options\") that gets sent to onCreateUser,\n    // which is always empty when called from the createUser method? eg, \"admin:\n    // true\", which we want to prevent the client from setting, but which a custom\n    // method calling Accounts.createUser could set?\n    //\n\n    Accounts.createUser = Accounts.createUserAsync;\n\n    ///\n    /// PASSWORD-SPECIFIC INDEXES ON USERS\n    ///\n    await Meteor.users.createIndexAsync('services.email.verificationTokens.token', {\n      unique: true,\n      sparse: true\n    });\n    await Meteor.users.createIndexAsync('services.password.reset.token', {\n      unique: true,\n      sparse: true\n    });\n    await Meteor.users.createIndexAsync('services.password.enroll.token', {\n      unique: true,\n      sparse: true\n    });\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: true\n});","map":{"version":3,"names":["_objectSpread","module","link","default","v","bcryptHash","bcryptCompare","hash","compare","Accounts","__reifyWaitForDeps__","getUserById","id","options","Meteor","users","findOneAsync","_addDefaultFieldSelector","_bcryptRounds","_options","bcryptRounds","getPasswordString","password","SHA256","algorithm","Error","digest","hashPassword","getRoundsFromBcryptHash","rounds","hashSegments","split","length","parseInt","_checkPasswordUserFields","_id","services","checkPasswordAsync","user","result","userId","formattedPassword","bcrypt","hashRounds","error","_handleError","defer","updateAsync","$set","_checkPasswordAsync","findUserByUsername","username","_findUserByQuery","findUserByEmail","email","NonEmptyString","Match","Where","x","check","String","passwordValidator","OneOf","str","_Meteor$settings","_Meteor$settings$pack","_Meteor$settings$pack2","test","settings","packages","accounts","passwordMaxLength","registerLoginHandler","_Accounts$_check2faEn","_Accounts","undefined","_userQueryValidator","code","Optional","fields","_check2faEnabled","call","_isTokenValid","twoFactorAuthentication","secret","setUsername","newUsername","oldUsername","_checkForCaseInsensitiveDuplicates","ex","methods","changePassword","oldPassword","newPassword","hashed","currentToken","_getLoginToken","connection","$pull","hashedToken","$ne","$unset","passwordChanged","setPasswordAsync","newPlaintextPassword","_Meteor$settings2","_Meteor$settings2$pac","_Meteor$settings2$pac2","Maybe","logout","Boolean","update","pluckAddresses","emails","arguments","map","address","forgotPassword","caseSensitiveEmail","find","toLowerCase","sendResetPasswordEmail","generateResetToken","reason","extraTokenData","includes","token","Random","tokenRecord","when","Date","Object","assign","_ensure","enroll","reset","generateVerificationToken","emailRecord","e","verified","$push","verificationTokens","push","extraParams","realEmail","url","urls","resetPassword","generateOptionsForEmail","Email","sendAsync","isDevelopment","console","log","concat","sendEnrollmentEmail","enrollAccount","_len","args","Array","_key","_loginMethod","_Accounts$_check2faEn2","_Accounts2","isEnroll","tokenLifetimeMs","_getPasswordResetTokenLifetimeMs","_getPasswordEnrollTokenLifetimeMs","currentTimeMs","now","oldToken","_setLoginToken","resetToOldToken","affectedRecords","err","_clearAllLoginTokens","sendVerificationEmail","verifyEmail","_len2","_key2","_Accounts$_check2faEn3","_Accounts3","t","emailsRecord","addEmailAsync","newEmail","caseInsensitiveRegExp","RegExp","_escapeRegExp","updatedEmail","updated","didUpdateOwnEmail","$addToSet","removeEmail","createUser","ObjectIncluding","_createUserCheckingDuplicates","_len3","_key3","forbidClientAccountCreation","createUserVerifyingEmail","createUserAsync","callback","createIndexAsync","unique","sparse","__reify_async_result__","_reifyError","self","async"],"sources":["packages/accounts-password/password_server.js"],"sourcesContent":["import { hash as bcryptHash, compare as bcryptCompare } from 'bcrypt';\nimport { Accounts } from \"meteor/accounts-base\";\n\n// Utility for grabbing user\nconst getUserById =\n  async (id, options) =>\n    await Meteor.users.findOneAsync(id, Accounts._addDefaultFieldSelector(options));\n\n// User records have a 'services.password.bcrypt' field on them to hold\n// their hashed passwords.\n//\n// When the client sends a password to the server, it can either be a\n// string (the plaintext password) or an object with keys 'digest' and\n// 'algorithm' (must be \"sha-256\" for now). The Meteor client always sends\n// password objects { digest: *, algorithm: \"sha-256\" }, but DDP clients\n// that don't have access to SHA can just send plaintext passwords as\n// strings.\n//\n// When the server receives a plaintext password as a string, it always\n// hashes it with SHA256 before passing it into bcrypt. When the server\n// receives a password as an object, it asserts that the algorithm is\n// \"sha-256\" and then passes the digest to bcrypt.\n\n\nAccounts._bcryptRounds = () => Accounts._options.bcryptRounds || 10;\n\n// Given a 'password' from the client, extract the string that we should\n// bcrypt. 'password' can be one of:\n//  - String (the plaintext password)\n//  - Object with 'digest' and 'algorithm' keys. 'algorithm' must be \"sha-256\".\n//\nconst getPasswordString = password => {\n  if (typeof password === \"string\") {\n    password = SHA256(password);\n  } else { // 'password' is an object\n    if (password.algorithm !== \"sha-256\") {\n      throw new Error(\"Invalid password hash algorithm. \" +\n                      \"Only 'sha-256' is allowed.\");\n    }\n    password = password.digest;\n  }\n  return password;\n};\n\n// Use bcrypt to hash the password for storage in the database.\n// `password` can be a string (in which case it will be run through\n// SHA256 before bcrypt) or an object with properties `digest` and\n// `algorithm` (in which case we bcrypt `password.digest`).\n//\nconst hashPassword = async password => {\n  password = getPasswordString(password);\n  return await bcryptHash(password, Accounts._bcryptRounds());\n};\n\n// Extract the number of rounds used in the specified bcrypt hash.\nconst getRoundsFromBcryptHash = hash => {\n  let rounds;\n  if (hash) {\n    const hashSegments = hash.split('$');\n    if (hashSegments.length > 2) {\n      rounds = parseInt(hashSegments[2], 10);\n    }\n  }\n  return rounds;\n};\n\n// Check whether the provided password matches the bcrypt'ed password in\n// the database user record. `password` can be a string (in which case\n// it will be run through SHA256 before bcrypt) or an object with\n// properties `digest` and `algorithm` (in which case we bcrypt\n// `password.digest`).\n//\n// The user parameter needs at least user._id and user.services\nAccounts._checkPasswordUserFields = {_id: 1, services: 1};\n//\nconst checkPasswordAsync = async (user, password) => {\n  const result = {\n    userId: user._id\n  };\n\n  const formattedPassword = getPasswordString(password);\n  const hash = user.services.password.bcrypt;\n  const hashRounds = getRoundsFromBcryptHash(hash);\n\n  if (! await bcryptCompare(formattedPassword, hash)) {\n    result.error = Accounts._handleError(\"Incorrect password\", false);\n  } else if (hash && Accounts._bcryptRounds() != hashRounds) {\n    // The password checks out, but the user's bcrypt hash needs to be updated.\n\n    Meteor.defer(async () => {\n      await Meteor.users.updateAsync({ _id: user._id }, {\n        $set: {\n          'services.password.bcrypt':\n            await bcryptHash(formattedPassword, Accounts._bcryptRounds())\n        }\n      });\n    });\n  }\n\n  return result;\n};\n\nAccounts._checkPasswordAsync =  checkPasswordAsync;\n\n///\n/// LOGIN\n///\n\n\n/**\n * @summary Finds the user asynchronously with the specified username.\n * First tries to match username case sensitively; if that fails, it\n * tries case insensitively; but if more than one user matches the case\n * insensitive search, it returns null.\n * @locus Server\n * @param {String} username The username to look for\n * @param {Object} [options]\n * @param {MongoFieldSpecifier} options.fields Dictionary of fields to return or exclude.\n * @returns {Promise<Object>} A user if found, else null\n * @importFromPackage accounts-base\n */\nAccounts.findUserByUsername =\n  async (username, options) =>\n    await Accounts._findUserByQuery({ username }, options);\n\n/**\n * @summary Finds the user asynchronously with the specified email.\n * First tries to match email case sensitively; if that fails, it\n * tries case insensitively; but if more than one user matches the case\n * insensitive search, it returns null.\n * @locus Server\n * @param {String} email The email address to look for\n * @param {Object} [options]\n * @param {MongoFieldSpecifier} options.fields Dictionary of fields to return or exclude.\n * @returns {Promise<Object>} A user if found, else null\n * @importFromPackage accounts-base\n */\nAccounts.findUserByEmail =\n  async (email, options) =>\n    await Accounts._findUserByQuery({ email }, options);\n\n// XXX maybe this belongs in the check package\nconst NonEmptyString = Match.Where(x => {\n  check(x, String);\n  return x.length > 0;\n});\n\nconst passwordValidator = Match.OneOf(\n  Match.Where(str => Match.test(str, String) && str.length <= Meteor.settings?.packages?.accounts?.passwordMaxLength || 256), {\n    digest: Match.Where(str => Match.test(str, String) && str.length === 64),\n    algorithm: Match.OneOf('sha-256')\n  }\n);\n\n// Handler to login with a password.\n//\n// The Meteor client sets options.password to an object with keys\n// 'digest' (set to SHA256(password)) and 'algorithm' (\"sha-256\").\n//\n// For other DDP clients which don't have access to SHA, the handler\n// also accepts the plaintext password in options.password as a string.\n//\n// (It might be nice if servers could turn the plaintext password\n// option off. Or maybe it should be opt-in, not opt-out?\n// Accounts.config option?)\n//\n// Note that neither password option is secure without SSL.\n//\nAccounts.registerLoginHandler(\"password\", async options => {\n  if (!options.password)\n    return undefined; // don't handle\n\n  check(options, {\n    user: Accounts._userQueryValidator,\n    password: passwordValidator,\n    code: Match.Optional(NonEmptyString),\n  });\n\n\n  const user = await Accounts._findUserByQuery(options.user, {fields: {\n    services: 1,\n    ...Accounts._checkPasswordUserFields,\n  }});\n  if (!user) {\n    Accounts._handleError(\"User not found\");\n  }\n\n\n  if (!user.services || !user.services.password ||\n      !user.services.password.bcrypt) {\n    Accounts._handleError(\"User has no password set\");\n  }\n\n  const result = await checkPasswordAsync(user, options.password);\n  // This method is added by the package accounts-2fa\n  // First the login is validated, then the code situation is checked\n  if (\n    !result.error &&\n    Accounts._check2faEnabled?.(user)\n  ) {\n    if (!options.code) {\n      Accounts._handleError('2FA code must be informed', true, 'no-2fa-code');\n    }\n    if (\n      !Accounts._isTokenValid(\n        user.services.twoFactorAuthentication.secret,\n        options.code\n      )\n    ) {\n      Accounts._handleError('Invalid 2FA code', true, 'invalid-2fa-code');\n    }\n  }\n\n  return result;\n});\n\n///\n/// CHANGING\n///\n\n/**\n * @summary Change a user's username asynchronously. Use this instead of updating the\n * database directly. The operation will fail if there is an existing user\n * with a username only differing in case.\n * @locus Server\n * @param {String} userId The ID of the user to update.\n * @param {String} newUsername A new username for the user.\n * @importFromPackage accounts-base\n */\nAccounts.setUsername =\n  async (userId, newUsername) => {\n    check(userId, NonEmptyString);\n    check(newUsername, NonEmptyString);\n\n    const user = await getUserById(userId, {\n      fields: {\n        username: 1,\n      }\n    });\n\n    if (!user) {\n      Accounts._handleError(\"User not found\");\n    }\n\n    const oldUsername = user.username;\n\n    // Perform a case insensitive check for duplicates before update\n    await Accounts._checkForCaseInsensitiveDuplicates('username',\n      'Username', newUsername, user._id);\n\n    await Meteor.users.updateAsync({ _id: user._id }, { $set: { username: newUsername } });\n\n    // Perform another check after update, in case a matching user has been\n    // inserted in the meantime\n    try {\n      await Accounts._checkForCaseInsensitiveDuplicates('username',\n        'Username', newUsername, user._id);\n    } catch (ex) {\n      // Undo update if the check fails\n      await Meteor.users.updateAsync({ _id: user._id }, { $set: { username: oldUsername } });\n      throw ex;\n    }\n  };\n\n// Let the user change their own password if they know the old\n// password. `oldPassword` and `newPassword` should be objects with keys\n// `digest` and `algorithm` (representing the SHA256 of the password).\nMeteor.methods(\n  {\n    changePassword: async function (oldPassword, newPassword) {\n  check(oldPassword, passwordValidator);\n  check(newPassword, passwordValidator);\n\n  if (!this.userId) {\n    throw new Meteor.Error(401, \"Must be logged in\");\n  }\n\n  const user = await getUserById(this.userId, {fields: {\n    services: 1,\n    ...Accounts._checkPasswordUserFields,\n  }});\n  if (!user) {\n    Accounts._handleError(\"User not found\");\n  }\n\n  if (!user.services || !user.services.password || !user.services.password.bcrypt) {\n    Accounts._handleError(\"User has no password set\");\n  }\n\n  const result = await checkPasswordAsync(user, oldPassword);\n  if (result.error) {\n    throw result.error;\n  }\n\n  const hashed = await hashPassword(newPassword);\n\n  // It would be better if this removed ALL existing tokens and replaced\n  // the token for the current connection with a new one, but that would\n  // be tricky, so we'll settle for just replacing all tokens other than\n  // the one for the current connection.\n  const currentToken = Accounts._getLoginToken(this.connection.id);\n  await Meteor.users.updateAsync(\n    { _id: this.userId },\n    {\n      $set: { 'services.password.bcrypt': hashed },\n      $pull: {\n        'services.resume.loginTokens': { hashedToken: { $ne: currentToken } }\n      },\n      $unset: { 'services.password.reset': 1 }\n    }\n  );\n\n  return {passwordChanged: true};\n}});\n\n\n// Force change the users password.\n\n/**\n * @summary Forcibly change the password for a user.\n * @locus Server\n * @param {String} userId The id of the user to update.\n * @param {String} newPassword A new password for the user.\n * @param {Object} [options]\n * @param {Object} options.logout Logout all current connections with this userId (default: true)\n * @importFromPackage accounts-base\n */\nAccounts.setPasswordAsync =\n  async (userId, newPlaintextPassword, options) => {\n  check(userId, String);\n  check(newPlaintextPassword, Match.Where(str => Match.test(str, String) && str.length <= Meteor.settings?.packages?.accounts?.passwordMaxLength || 256));\n  check(options, Match.Maybe({ logout: Boolean }));\n  options = { logout: true , ...options };\n\n  const user = await getUserById(userId, { fields: { _id: 1 } });\n  if (!user) {\n    throw new Meteor.Error(403, \"User not found\");\n  }\n\n  const update = {\n    $unset: {\n      'services.password.reset': 1\n    },\n    $set: {'services.password.bcrypt': await hashPassword(newPlaintextPassword)}\n  };\n\n  if (options.logout) {\n    update.$unset['services.resume.loginTokens'] = 1;\n  }\n\n  await Meteor.users.updateAsync({_id: user._id}, update);\n};\n\n///\n/// RESETTING VIA EMAIL\n///\n\n// Utility for plucking addresses from emails\nconst pluckAddresses = (emails = []) => emails.map(email => email.address);\n\n// Method called by a user to request a password reset email. This is\n// the start of the reset process.\nMeteor.methods({forgotPassword: async options => {\n  check(options, {email: String})\n\n  const user = await Accounts.findUserByEmail(options.email, { fields: { emails: 1 } });\n\n  if (!user) {\n    Accounts._handleError(\"User not found\");\n  }\n\n  const emails = pluckAddresses(user.emails);\n  const caseSensitiveEmail = emails.find(\n    email => email.toLowerCase() === options.email.toLowerCase()\n  );\n\n  await Accounts.sendResetPasswordEmail(user._id, caseSensitiveEmail);\n}});\n\n/**\n * @summary Asynchronously generates a reset token and saves it into the database.\n * @locus Server\n * @param {String} userId The id of the user to generate the reset token for.\n * @param {String} email Which address of the user to generate the reset token for. This address must be in the user's `emails` list. If `null`, defaults to the first email in the list.\n * @param {String} reason `resetPassword` or `enrollAccount`.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @returns {Promise<Object>} Promise of an object with {email, user, token} values.\n * @importFromPackage accounts-base\n */\nAccounts.generateResetToken =\n  async (userId, email, reason, extraTokenData) => {\n  // Make sure the user exists, and email is one of their addresses.\n  // Don't limit the fields in the user object since the user is returned\n  // by the function and some other fields might be used elsewhere.\n  const user = await getUserById(userId);\n  if (!user) {\n    Accounts._handleError(\"Can't find user\");\n  }\n\n  // pick the first email if we weren't passed an email.\n  if (!email && user.emails && user.emails[0]) {\n    email = user.emails[0].address;\n  }\n\n  // make sure we have a valid email\n  if (!email ||\n    !(pluckAddresses(user.emails).includes(email))) {\n    Accounts._handleError(\"No such email for user.\");\n  }\n\n  const token = Random.secret();\n  const tokenRecord = {\n    token,\n    email,\n    when: new Date()\n  };\n\n  if (reason === 'resetPassword') {\n    tokenRecord.reason = 'reset';\n  } else if (reason === 'enrollAccount') {\n    tokenRecord.reason = 'enroll';\n  } else if (reason) {\n    // fallback so that this function can be used for unknown reasons as well\n    tokenRecord.reason = reason;\n  }\n\n  if (extraTokenData) {\n    Object.assign(tokenRecord, extraTokenData);\n  }\n  // if this method is called from the enroll account work-flow then\n  // store the token record in 'services.password.enroll' db field\n  // else store the token record in in 'services.password.reset' db field\n  if(reason === 'enrollAccount') {\n    await Meteor.users.updateAsync({_id: user._id}, {\n      $set : {\n        'services.password.enroll': tokenRecord\n      }\n    });\n    // before passing to template, update user object with new token\n     Meteor._ensure(user, 'services', 'password').enroll = tokenRecord;\n  } else {\n    await Meteor.users.updateAsync({_id: user._id}, {\n      $set : {\n        'services.password.reset': tokenRecord\n      }\n    });\n    // before passing to template, update user object with new token\n     Meteor._ensure(user, 'services', 'password').reset = tokenRecord;\n  }\n\n  return {email, user, token};\n};\n\n/**\n * @summary Generates asynchronously an e-mail verification token and saves it into the database.\n * @locus Server\n * @param {String} userId The id of the user to generate the  e-mail verification token for.\n * @param {String} email Which address of the user to generate the e-mail verification token for. This address must be in the user's `emails` list. If `null`, defaults to the first unverified email in the list.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @returns {Promise<Object>} Promise of an object with {email, user, token} values.\n * @importFromPackage accounts-base\n */\nAccounts.generateVerificationToken =\n  async (userId, email, extraTokenData) => {\n  // Make sure the user exists, and email is one of their addresses.\n  // Don't limit the fields in the user object since the user is returned\n  // by the function and some other fields might be used elsewhere.\n  const user = await getUserById(userId);\n  if (!user) {\n    Accounts._handleError(\"Can't find user\");\n  }\n\n  // pick the first unverified email if we weren't passed an email.\n  if (!email) {\n    const emailRecord = (user.emails || []).find(e => !e.verified);\n    email = (emailRecord || {}).address;\n\n    if (!email) {\n      Accounts._handleError(\"That user has no unverified email addresses.\");\n    }\n  }\n\n  // make sure we have a valid email\n  if (!email ||\n    !(pluckAddresses(user.emails).includes(email))) {\n    Accounts._handleError(\"No such email for user.\");\n  }\n\n  const token = Random.secret();\n  const tokenRecord = {\n    token,\n    // TODO: This should probably be renamed to \"email\" to match reset token record.\n    address: email,\n    when: new Date()\n  };\n\n  if (extraTokenData) {\n    Object.assign(tokenRecord, extraTokenData);\n  }\n\n  await Meteor.users.updateAsync({_id: user._id}, {$push: {\n    'services.email.verificationTokens': tokenRecord\n  }});\n\n  // before passing to template, update user object with new token\n  Meteor._ensure(user, 'services', 'email');\n  if (!user.services.email.verificationTokens) {\n    user.services.email.verificationTokens = [];\n  }\n  user.services.email.verificationTokens.push(tokenRecord);\n\n  return {email, user, token};\n};\n\n\n// send the user an email with a link that when opened allows the user\n// to set a new password, without the old password.\n\n/**\n * @summary Send an email asynchronously with a link the user can use to reset their password.\n * @locus Server\n * @param {String} userId The id of the user to send email to.\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first email in the list.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @param {Object} [extraParams] Optional additional params to be added to the reset url.\n * @returns {Promise<Object>} Promise of an object with {email, user, token, url, options} values.\n * @importFromPackage accounts-base\n */\nAccounts.sendResetPasswordEmail =\n  async (userId, email, extraTokenData, extraParams) => {\n    const { email: realEmail, user, token } =\n      await Accounts.generateResetToken(userId, email, 'resetPassword', extraTokenData);\n    const url = Accounts.urls.resetPassword(token, extraParams);\n    const options = await Accounts.generateOptionsForEmail(realEmail, user, url, 'resetPassword');\n    await Email.sendAsync(options);\n\n    if (Meteor.isDevelopment) {\n      console.log(`\\nReset password URL: ${ url }`);\n    }\n    return { email: realEmail, user, token, url, options };\n  };\n\n// send the user an email informing them that their account was created, with\n// a link that when opened both marks their email as verified and forces them\n// to choose their password. The email must be one of the addresses in the\n// user's emails field, or undefined to pick the first email automatically.\n//\n// This is not called automatically. It must be called manually if you\n// want to use enrollment emails.\n\n/**\n * @summary Send an email asynchronously with a link the user can use to set their initial password.\n * @locus Server\n * @param {String} userId The id of the user to send email to.\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first email in the list.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @param {Object} [extraParams] Optional additional params to be added to the enrollment url.\n * @returns {Promise<Object>} Promise of an object {email, user, token, url, options} values.\n * @importFromPackage accounts-base\n */\nAccounts.sendEnrollmentEmail =\n  async (userId, email, extraTokenData, extraParams) => {\n\n    const { email: realEmail, user, token } =\n      await Accounts.generateResetToken(userId, email, 'enrollAccount', extraTokenData);\n\n    const url = Accounts.urls.enrollAccount(token, extraParams);\n\n    const options =\n      await Accounts.generateOptionsForEmail(realEmail, user, url, 'enrollAccount');\n\n    await Email.sendAsync(options);\n    if (Meteor.isDevelopment) {\n      console.log(`\\nEnrollment email URL: ${ url }`);\n    }\n    return { email: realEmail, user, token, url, options };\n  };\n\n\n// Take token from sendResetPasswordEmail or sendEnrollmentEmail, change\n// the users password, and log them in.\nMeteor.methods(\n  {\n    resetPassword:\n      async function (...args) {\n        const token = args[0];\n        const newPassword = args[1];\n        return await Accounts._loginMethod(\n          this,\n          \"resetPassword\",\n          args,\n          \"password\",\n          async () => {\n            check(token, String);\n            check(newPassword, passwordValidator);\n            let user = await Meteor.users.findOneAsync(\n              { \"services.password.reset.token\": token },\n              {\n                fields: {\n                  services: 1,\n                  emails: 1,\n                }\n              }\n            );\n\n            let isEnroll = false;\n            // if token is in services.password.reset db field implies\n            // this method is was not called from enroll account workflow\n            // else this method is called from enroll account workflow\n            if (!user) {\n              user = await Meteor.users.findOneAsync(\n                { \"services.password.enroll.token\": token },\n                {\n                  fields: {\n                    services: 1,\n                    emails: 1,\n                  }\n                }\n              );\n              isEnroll = true;\n            }\n            if (!user) {\n              throw new Meteor.Error(403, \"Token expired\");\n            }\n            let tokenRecord = {};\n            if (isEnroll) {\n              tokenRecord = user.services.password.enroll;\n            } else {\n              tokenRecord = user.services.password.reset;\n            }\n            const { when, email } = tokenRecord;\n            let tokenLifetimeMs = Accounts._getPasswordResetTokenLifetimeMs();\n            if (isEnroll) {\n              tokenLifetimeMs = Accounts._getPasswordEnrollTokenLifetimeMs();\n            }\n            const currentTimeMs = Date.now();\n            if ((currentTimeMs - when) > tokenLifetimeMs)\n              throw new Meteor.Error(403, \"Token expired\");\n            if (!(pluckAddresses(user.emails).includes(email)))\n              return {\n                userId: user._id,\n                error: new Meteor.Error(403, \"Token has invalid email address\")\n              };\n\n            const hashed = await hashPassword(newPassword);\n\n            // NOTE: We're about to invalidate tokens on the user, who we might be\n            // logged in as. Make sure to avoid logging ourselves out if this\n            // happens. But also make sure not to leave the connection in a state\n            // of having a bad token set if things fail.\n            const oldToken = Accounts._getLoginToken(this.connection.id);\n            Accounts._setLoginToken(user._id, this.connection, null);\n            const resetToOldToken = () =>\n              Accounts._setLoginToken(user._id, this.connection, oldToken);\n\n            try {\n              // Update the user record by:\n              // - Changing the password to the new one\n              // - Forgetting about the reset token or enroll token that was just used\n              // - Verifying their email, since they got the password reset via email.\n              let affectedRecords = {};\n              // if reason is enroll then check services.password.enroll.token field for affected records\n              if (isEnroll) {\n                affectedRecords = await Meteor.users.updateAsync(\n                  {\n                    _id: user._id,\n                    'emails.address': email,\n                    'services.password.enroll.token': token\n                  },\n                  {\n                    $set: {\n                      'services.password.bcrypt': hashed,\n                      'emails.$.verified': true\n                    },\n                    $unset: { 'services.password.enroll': 1 }\n                  });\n              } else {\n                affectedRecords = await Meteor.users.updateAsync(\n                  {\n                    _id: user._id,\n                    'emails.address': email,\n                    'services.password.reset.token': token\n                  },\n                  {\n                    $set: {\n                      'services.password.bcrypt': hashed,\n                      'emails.$.verified': true\n                    },\n                    $unset: { 'services.password.reset': 1 }\n                  });\n              }\n              if (affectedRecords !== 1)\n                return {\n                  userId: user._id,\n                  error: new Meteor.Error(403, \"Invalid email\")\n                };\n            } catch (err) {\n              resetToOldToken();\n              throw err;\n            }\n\n            // Replace all valid login tokens with new ones (changing\n            // password should invalidate existing sessions).\n            await Accounts._clearAllLoginTokens(user._id);\n\n            if (Accounts._check2faEnabled?.(user)) {\n        return {\n          userId: user._id,\n          error: Accounts._handleError(\n            'Changed password, but user not logged in because 2FA is enabled',\n            false,\n            '2fa-enabled'\n          ),\n        };\n      }return { userId: user._id };\n          }\n        );\n      }\n  }\n);\n\n///\n/// EMAIL VERIFICATION\n///\n\n\n// send the user an email with a link that when opened marks that\n// address as verified\n\n/**\n * @summary Send an email asynchronously with a link the user can use verify their email address.\n * @locus Server\n * @param {String} userId The id of the user to send email to.\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first unverified email in the list.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @param {Object} [extraParams] Optional additional params to be added to the verification url.\n * @returns {Promise<Object>} Promise of an object with {email, user, token, url, options} values.\n * @importFromPackage accounts-base\n */\nAccounts.sendVerificationEmail =\n  async (userId, email, extraTokenData, extraParams) => {\n    // XXX Also generate a link using which someone can delete this\n    // account if they own said address but weren't those who created\n    // this account.\n\n    const { email: realEmail, user, token } =\n      await Accounts.generateVerificationToken(userId, email, extraTokenData);\n    const url = Accounts.urls.verifyEmail(token, extraParams);\n    const options = await Accounts.generateOptionsForEmail(realEmail, user, url, 'verifyEmail');\n    await Email.sendAsync(options);\n    if (Meteor.isDevelopment) {\n      console.log(`\\nVerification email URL: ${ url }`);\n    }\n    return { email: realEmail, user, token, url, options };\n  };\n\n// Take token from sendVerificationEmail, mark the email as verified,\n// and log them in.\nMeteor.methods(\n  {\n    verifyEmail: async function (...args) {\n      const token = args[0];\n      return await Accounts._loginMethod(\n        this,\n        \"verifyEmail\",\n        args,\n        \"password\",\n        async () => {\n          check(token, String);\n\n          const user = await Meteor.users.findOneAsync(\n            { 'services.email.verificationTokens.token': token },\n            {\n              fields: {\n                services: 1,\n                emails: 1,\n              }\n            }\n          );\n          if (!user)\n            throw new Meteor.Error(403, \"Verify email link expired\");\n\n          const tokenRecord =\n            await user\n              .services.email.verificationTokens.find(t => t.token == token);\n\n          if (!tokenRecord)\n            return {\n              userId: user._id,\n              error: new Meteor.Error(403, \"Verify email link expired\")\n            };\n\n          const emailsRecord =\n            user.emails.find(e => e.address == tokenRecord.address);\n\n          if (!emailsRecord)\n            return {\n              userId: user._id,\n              error: new Meteor.Error(403, \"Verify email link is for unknown address\")\n            };\n\n          // By including the address in the query, we can use 'emails.$' in the\n          // modifier to get a reference to the specific object in the emails\n          // array. See\n          // http://www.mongodb.org/display/DOCS/Updating/#Updating-The%24positionaloperator)\n          // http://www.mongodb.org/display/DOCS/Updating#Updating-%24pull\n          await Meteor.users.updateAsync(\n            {\n              _id: user._id,\n              'emails.address': tokenRecord.address\n            },\n            {\n              $set: { 'emails.$.verified': true },\n              $pull: { 'services.email.verificationTokens': { address: tokenRecord.address } }\n            });\n\n          if (Accounts._check2faEnabled?.(user)) {\n        return {\n          userId: user._id,\n          error: Accounts._handleError(\n            'Email verified, but user not logged in because 2FA is enabled',\n            false,\n            '2fa-enabled'\n          ),\n        };\n      }return { userId: user._id };\n        }\n      );\n    }\n  });\n\n/**\n * @summary Asynchronously add an email address for a user. Use this instead of directly\n * updating the database. The operation will fail if there is a different user\n * with an email only differing in case. If the specified user has an existing\n * email only differing in case however, we replace it.\n * @locus Server\n * @param {String} userId The ID of the user to update.\n * @param {String} newEmail A new email address for the user.\n * @param {Boolean} [verified] Optional - whether the new email address should\n * be marked as verified. Defaults to false.\n * @importFromPackage accounts-base\n */\nAccounts.addEmailAsync = async (userId, newEmail, verified) => {\n  check(userId, NonEmptyString);\n  check(newEmail, NonEmptyString);\n  check(verified, Match.Optional(Boolean));\n\n  if (verified === void 0) {\n    verified = false;\n  }\n\n  const user = await getUserById(userId, { fields: { emails: 1 } });\n  if (!user) throw new Meteor.Error(403, \"User not found\");\n\n  // Allow users to change their own email to a version with a different case\n\n  // We don't have to call checkForCaseInsensitiveDuplicates to do a case\n  // insensitive check across all emails in the database here because: (1) if\n  // there is no case-insensitive duplicate between this user and other users,\n  // then we are OK and (2) if this would create a conflict with other users\n  // then there would already be a case-insensitive duplicate and we can't fix\n  // that in this code anyway.\n  const caseInsensitiveRegExp = new RegExp(\n    `^${Meteor._escapeRegExp(newEmail)}$`,\n    \"i\"\n  );\n\n  // TODO: This is a linear search. If we have a lot of emails.\n  //  we should consider using a different data structure.\n  const updatedEmail = async (emails = [], _id) => {\n    let updated = false;\n    for (const email of emails) {\n      if (caseInsensitiveRegExp.test(email.address)) {\n        await Meteor.users.updateAsync(\n          {\n            _id: _id,\n            \"emails.address\": email.address,\n          },\n          {\n            $set: {\n              \"emails.$.address\": newEmail,\n              \"emails.$.verified\": verified,\n            },\n          }\n        );\n        updated = true;\n      }\n    }\n    return updated;\n  };\n  const didUpdateOwnEmail = await updatedEmail(user.emails, user._id);\n\n  // In the other updates below, we have to do another call to\n  // checkForCaseInsensitiveDuplicates to make sure that no conflicting values\n  // were added to the database in the meantime. We don't have to do this for\n  // the case where the user is updating their email address to one that is the\n  // same as before, but only different because of capitalization. Read the\n  // big comment above to understand why.\n\n  if (didUpdateOwnEmail) {\n    return;\n  }\n\n  // Perform a case insensitive check for duplicates before update\n  await Accounts._checkForCaseInsensitiveDuplicates(\n    \"emails.address\",\n    \"Email\",\n    newEmail,\n    user._id\n  );\n\n  await Meteor.users.updateAsync(\n    {\n      _id: user._id,\n    },\n    {\n      $addToSet: {\n        emails: {\n          address: newEmail,\n          verified: verified,\n        },\n      },\n    }\n  );\n\n  // Perform another check after update, in case a matching user has been\n  // inserted in the meantime\n  try {\n    await Accounts._checkForCaseInsensitiveDuplicates(\n      \"emails.address\",\n      \"Email\",\n      newEmail,\n      user._id\n    );\n  } catch (ex) {\n    // Undo update if the check fails\n    await Meteor.users.updateAsync(\n      { _id: user._id },\n      { $pull: { emails: { address: newEmail } } }\n    );\n    throw ex;\n  }\n};\n\n/**\n * @summary Remove an email address asynchronously for a user. Use this instead of updating\n * the database directly.\n * @locus Server\n * @param {String} userId The ID of the user to update.\n * @param {String} email The email address to remove.\n * @importFromPackage accounts-base\n */\nAccounts.removeEmail =\n  async (userId, email) => {\n    check(userId, NonEmptyString);\n    check(email, NonEmptyString);\n\n    const user = await getUserById(userId, { fields: { _id: 1 } });\n    if (!user)\n      throw new Meteor.Error(403, \"User not found\");\n\n    await Meteor.users.updateAsync({ _id: user._id },\n      { $pull: { emails: { address: email } } });\n  }\n\n///\n/// CREATING USERS\n///\n\n// Shared createUser function called from the createUser method, both\n// if originates in client or server code. Calls user provided hooks,\n// does the actual user insertion.\n//\n// returns the user id\nconst createUser =\n  async options => {\n    // Unknown keys allowed, because a onCreateUserHook can take arbitrary\n    // options.\n    check(options, Match.ObjectIncluding({\n      username: Match.Optional(String),\n      email: Match.Optional(String),\n      password: Match.Optional(passwordValidator)\n    }));\n\n    const { username, email, password } = options;\n    if (!username && !email)\n      throw new Meteor.Error(400, \"Need to set a username or email\");\n\n    const user = { services: {} };\n    if (password) {\n      const hashed = await hashPassword(password);\n      user.services.password = { bcrypt: hashed };\n    }\n\n    return await Accounts._createUserCheckingDuplicates({ user, email, username, options });\n  };\n\n// method for create user. Requests come from the client.\nMeteor.methods(\n  {\n    createUser: async function (...args) {\n      const options = args[0];\n      return await Accounts._loginMethod(\n        this,\n        \"createUser\",\n        args,\n        \"password\",\n        async () => {\n          // createUser() above does more checking.\n          check(options, Object);\n          if (Accounts._options.forbidClientAccountCreation)\n            return {\n              error: new Meteor.Error(403, \"Signups forbidden\")\n            };\n\n          const userId = await Accounts.createUserVerifyingEmail(options);\n\n          // client gets logged in as the new user afterwards.\n          return { userId: userId };\n        }\n      );\n    }\n  });\n\n/**\n * @summary Creates an user asynchronously and sends an email if `options.email` is informed.\n * Then if the `sendVerificationEmail` option from the `Accounts` package is\n * enabled, you'll send a verification email if `options.password` is informed,\n * otherwise you'll send an enrollment email.\n * @locus Server\n * @param {Object} options The options object to be passed down when creating\n * the user\n * @param {String} options.username A unique name for this user.\n * @param {String} options.email The user's email address.\n * @param {String} options.password The user's password. This is __not__ sent in plain text over the wire.\n * @param {Object} options.profile The user's profile, typically including the `name` field.\n * @importFromPackage accounts-base\n * */\nAccounts.createUserVerifyingEmail =\n  async (options) => {\n    options = { ...options };\n    // Create user. result contains id and token.\n    const userId = await createUser(options);\n    // safety belt. createUser is supposed to throw on error. send 500 error\n    // instead of sending a verification email with empty userid.\n    if (!userId)\n      throw new Error(\"createUser failed to insert new user\");\n\n    // If `Accounts._options.sendVerificationEmail` is set, register\n    // a token to verify the user's primary email, and send it to\n    // that address.\n    if (options.email && Accounts._options.sendVerificationEmail) {\n      if (options.password) {\n        await Accounts.sendVerificationEmail(userId, options.email);\n      } else {\n        await Accounts.sendEnrollmentEmail(userId, options.email);\n      }\n    }\n\n    return userId;\n  };\n\n// Create user directly on the server.\n//\n// Unlike the client version, this does not log you in as this user\n// after creation.\n//\n// returns Promise<userId> or throws an error if it can't create\n//\n// XXX add another argument (\"server options\") that gets sent to onCreateUser,\n// which is always empty when called from the createUser method? eg, \"admin:\n// true\", which we want to prevent the client from setting, but which a custom\n// method calling Accounts.createUser could set?\n//\n\nAccounts.createUserAsync =\n  async (options, callback) => {\n    options = { ...options };\n\n    // XXX allow an optional callback?\n    if (callback) {\n      throw new Error(\"Accounts.createUser with callback not supported on the server yet.\");\n    }\n\n    return createUser(options);\n  };\n\n// Create user directly on the server.\n//\n// Unlike the client version, this does not log you in as this user\n// after creation.\n//\n// returns userId or throws an error if it can't create\n//\n// XXX add another argument (\"server options\") that gets sent to onCreateUser,\n// which is always empty when called from the createUser method? eg, \"admin:\n// true\", which we want to prevent the client from setting, but which a custom\n// method calling Accounts.createUser could set?\n//\n\nAccounts.createUser = Accounts.createUserAsync;\n\n///\n/// PASSWORD-SPECIFIC INDEXES ON USERS\n///\nawait Meteor.users.createIndexAsync('services.email.verificationTokens.token',\n  { unique: true, sparse: true });\nawait Meteor.users.createIndexAsync('services.password.reset.token',\n  { unique: true, sparse: true });\nawait Meteor.users.createIndexAsync('services.password.enroll.token',\n  { unique: true, sparse: true });\n\n"],"mappings":";;;IAAA,IAAIA,aAAa;IAACC,MAAM,CAACC,IAAI,CAAC,sCAAsC,EAAC;MAACC,OAAOA,CAACC,CAAC,EAAC;QAACJ,aAAa,GAACI,CAAC;MAAA;IAAC,CAAC,EAAC,CAAC,CAAC;IAArG,IAAIC,UAAU,EAACC,aAAa;IAACL,MAAM,CAACC,IAAI,CAAC,QAAQ,EAAC;MAACK,IAAIA,CAACH,CAAC,EAAC;QAACC,UAAU,GAACD,CAAC;MAAA,CAAC;MAACI,OAAOA,CAACJ,CAAC,EAAC;QAACE,aAAa,GAACF,CAAC;MAAA;IAAC,CAAC,EAAC,CAAC,CAAC;IAAC,IAAIK,QAAQ;IAACR,MAAM,CAACC,IAAI,CAAC,sBAAsB,EAAC;MAACO,QAAQA,CAACL,CAAC,EAAC;QAACK,QAAQ,GAACL,CAAC;MAAA;IAAC,CAAC,EAAC,CAAC,CAAC;IAAC,IAAIM,oBAAoB,CAAC,CAAC,EAAE,CAAC,MAAMA,oBAAoB,CAAC,CAAC,EAAE,CAAC;IAGlP;IACA,MAAMC,WAAW,GACf,MAAAA,CAAOC,EAAE,EAAEC,OAAO,KAChB,MAAMC,MAAM,CAACC,KAAK,CAACC,YAAY,CAACJ,EAAE,EAAEH,QAAQ,CAACQ,wBAAwB,CAACJ,OAAO,CAAC,CAAC;;IAEnF;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAGAJ,QAAQ,CAACS,aAAa,GAAG,MAAMT,QAAQ,CAACU,QAAQ,CAACC,YAAY,IAAI,EAAE;;IAEnE;IACA;IACA;IACA;IACA;IACA,MAAMC,iBAAiB,GAAGC,QAAQ,IAAI;MACpC,IAAI,OAAOA,QAAQ,KAAK,QAAQ,EAAE;QAChCA,QAAQ,GAAGC,MAAM,CAACD,QAAQ,CAAC;MAC7B,CAAC,MAAM;QAAE;QACP,IAAIA,QAAQ,CAACE,SAAS,KAAK,SAAS,EAAE;UACpC,MAAM,IAAIC,KAAK,CAAC,mCAAmC,GACnC,4BAA4B,CAAC;QAC/C;QACAH,QAAQ,GAAGA,QAAQ,CAACI,MAAM;MAC5B;MACA,OAAOJ,QAAQ;IACjB,CAAC;;IAED;IACA;IACA;IACA;IACA;IACA,MAAMK,YAAY,GAAG,MAAML,QAAQ,IAAI;MACrCA,QAAQ,GAAGD,iBAAiB,CAACC,QAAQ,CAAC;MACtC,OAAO,MAAMjB,UAAU,CAACiB,QAAQ,EAAEb,QAAQ,CAACS,aAAa,CAAC,CAAC,CAAC;IAC7D,CAAC;;IAED;IACA,MAAMU,uBAAuB,GAAGrB,IAAI,IAAI;MACtC,IAAIsB,MAAM;MACV,IAAItB,IAAI,EAAE;QACR,MAAMuB,YAAY,GAAGvB,IAAI,CAACwB,KAAK,CAAC,GAAG,CAAC;QACpC,IAAID,YAAY,CAACE,MAAM,GAAG,CAAC,EAAE;UAC3BH,MAAM,GAAGI,QAAQ,CAACH,YAAY,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;QACxC;MACF;MACA,OAAOD,MAAM;IACf,CAAC;;IAED;IACA;IACA;IACA;IACA;IACA;IACA;IACApB,QAAQ,CAACyB,wBAAwB,GAAG;MAACC,GAAG,EAAE,CAAC;MAAEC,QAAQ,EAAE;IAAC,CAAC;IACzD;IACA,MAAMC,kBAAkB,GAAG,MAAAA,CAAOC,IAAI,EAAEhB,QAAQ,KAAK;MACnD,MAAMiB,MAAM,GAAG;QACbC,MAAM,EAAEF,IAAI,CAACH;MACf,CAAC;MAED,MAAMM,iBAAiB,GAAGpB,iBAAiB,CAACC,QAAQ,CAAC;MACrD,MAAMf,IAAI,GAAG+B,IAAI,CAACF,QAAQ,CAACd,QAAQ,CAACoB,MAAM;MAC1C,MAAMC,UAAU,GAAGf,uBAAuB,CAACrB,IAAI,CAAC;MAEhD,IAAI,EAAE,MAAMD,aAAa,CAACmC,iBAAiB,EAAElC,IAAI,CAAC,GAAE;QAClDgC,MAAM,CAACK,KAAK,GAAGnC,QAAQ,CAACoC,YAAY,CAAC,oBAAoB,EAAE,KAAK,CAAC;MACnE,CAAC,MAAM,IAAItC,IAAI,IAAIE,QAAQ,CAACS,aAAa,CAAC,CAAC,IAAIyB,UAAU,EAAE;QACzD;;QAEA7B,MAAM,CAACgC,KAAK,CAAC,YAAY;UACvB,MAAMhC,MAAM,CAACC,KAAK,CAACgC,WAAW,CAAC;YAAEZ,GAAG,EAAEG,IAAI,CAACH;UAAI,CAAC,EAAE;YAChDa,IAAI,EAAE;cACJ,0BAA0B,EACxB,MAAM3C,UAAU,CAACoC,iBAAiB,EAAEhC,QAAQ,CAACS,aAAa,CAAC,CAAC;YAChE;UACF,CAAC,CAAC;QACJ,CAAC,CAAC;MACJ;MAEA,OAAOqB,MAAM;IACf,CAAC;IAED9B,QAAQ,CAACwC,mBAAmB,GAAIZ,kBAAkB;;IAElD;IACA;IACA;;IAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACA5B,QAAQ,CAACyC,kBAAkB,GACzB,OAAOC,QAAQ,EAAEtC,OAAO,KACtB,MAAMJ,QAAQ,CAAC2C,gBAAgB,CAAC;MAAED;IAAS,CAAC,EAAEtC,OAAO,CAAC;;IAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACAJ,QAAQ,CAAC4C,eAAe,GACtB,OAAOC,KAAK,EAAEzC,OAAO,KACnB,MAAMJ,QAAQ,CAAC2C,gBAAgB,CAAC;MAAEE;IAAM,CAAC,EAAEzC,OAAO,CAAC;;IAEvD;IACA,MAAM0C,cAAc,GAAGC,KAAK,CAACC,KAAK,CAACC,CAAC,IAAI;MACtCC,KAAK,CAACD,CAAC,EAAEE,MAAM,CAAC;MAChB,OAAOF,CAAC,CAAC1B,MAAM,GAAG,CAAC;IACrB,CAAC,CAAC;IAEF,MAAM6B,iBAAiB,GAAGL,KAAK,CAACM,KAAK,CACnCN,KAAK,CAACC,KAAK,CAACM,GAAG;MAAA,IAAAC,gBAAA,EAAAC,qBAAA,EAAAC,sBAAA;MAAA,OAAIV,KAAK,CAACW,IAAI,CAACJ,GAAG,EAAEH,MAAM,CAAC,IAAIG,GAAG,CAAC/B,MAAM,MAAAgC,gBAAA,GAAIlD,MAAM,CAACsD,QAAQ,cAAAJ,gBAAA,wBAAAC,qBAAA,GAAfD,gBAAA,CAAiBK,QAAQ,cAAAJ,qBAAA,wBAAAC,sBAAA,GAAzBD,qBAAA,CAA2BK,QAAQ,cAAAJ,sBAAA,uBAAnCA,sBAAA,CAAqCK,iBAAiB,KAAI,GAAG;IAAA,EAAC,EAAE;MAC1H7C,MAAM,EAAE8B,KAAK,CAACC,KAAK,CAACM,GAAG,IAAIP,KAAK,CAACW,IAAI,CAACJ,GAAG,EAAEH,MAAM,CAAC,IAAIG,GAAG,CAAC/B,MAAM,KAAK,EAAE,CAAC;MACxER,SAAS,EAAEgC,KAAK,CAACM,KAAK,CAAC,SAAS;IAClC,CACF,CAAC;;IAED;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACArD,QAAQ,CAAC+D,oBAAoB,CAAC,UAAU,EAAE,MAAM3D,OAAO,IAAI;MAAA,IAAA4D,qBAAA,EAAAC,SAAA;MACzD,IAAI,CAAC7D,OAAO,CAACS,QAAQ,EACnB,OAAOqD,SAAS,CAAC,CAAC;;MAEpBhB,KAAK,CAAC9C,OAAO,EAAE;QACbyB,IAAI,EAAE7B,QAAQ,CAACmE,mBAAmB;QAClCtD,QAAQ,EAAEuC,iBAAiB;QAC3BgB,IAAI,EAAErB,KAAK,CAACsB,QAAQ,CAACvB,cAAc;MACrC,CAAC,CAAC;MAGF,MAAMjB,IAAI,GAAG,MAAM7B,QAAQ,CAAC2C,gBAAgB,CAACvC,OAAO,CAACyB,IAAI,EAAE;QAACyC,MAAM,EAAA/E,aAAA;UAChEoC,QAAQ,EAAE;QAAC,GACR3B,QAAQ,CAACyB,wBAAwB;MACrC,CAAC,CAAC;MACH,IAAI,CAACI,IAAI,EAAE;QACT7B,QAAQ,CAACoC,YAAY,CAAC,gBAAgB,CAAC;MACzC;MAGA,IAAI,CAACP,IAAI,CAACF,QAAQ,IAAI,CAACE,IAAI,CAACF,QAAQ,CAACd,QAAQ,IACzC,CAACgB,IAAI,CAACF,QAAQ,CAACd,QAAQ,CAACoB,MAAM,EAAE;QAClCjC,QAAQ,CAACoC,YAAY,CAAC,0BAA0B,CAAC;MACnD;MAEA,MAAMN,MAAM,GAAG,MAAMF,kBAAkB,CAACC,IAAI,EAAEzB,OAAO,CAACS,QAAQ,CAAC;MAC/D;MACA;MACA,IACE,CAACiB,MAAM,CAACK,KAAK,KAAA6B,qBAAA,GACb,CAAAC,SAAA,GAAAjE,QAAQ,EAACuE,gBAAgB,cAAAP,qBAAA,eAAzBA,qBAAA,CAAAQ,IAAA,CAAAP,SAAA,EAA4BpC,IAAI,CAAC,EACjC;QACA,IAAI,CAACzB,OAAO,CAACgE,IAAI,EAAE;UACjBpE,QAAQ,CAACoC,YAAY,CAAC,2BAA2B,EAAE,IAAI,EAAE,aAAa,CAAC;QACzE;QACA,IACE,CAACpC,QAAQ,CAACyE,aAAa,CACrB5C,IAAI,CAACF,QAAQ,CAAC+C,uBAAuB,CAACC,MAAM,EAC5CvE,OAAO,CAACgE,IACV,CAAC,EACD;UACApE,QAAQ,CAACoC,YAAY,CAAC,kBAAkB,EAAE,IAAI,EAAE,kBAAkB,CAAC;QACrE;MACF;MAEA,OAAON,MAAM;IACf,CAAC,CAAC;;IAEF;IACA;IACA;;IAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACA9B,QAAQ,CAAC4E,WAAW,GAClB,OAAO7C,MAAM,EAAE8C,WAAW,KAAK;MAC7B3B,KAAK,CAACnB,MAAM,EAAEe,cAAc,CAAC;MAC7BI,KAAK,CAAC2B,WAAW,EAAE/B,cAAc,CAAC;MAElC,MAAMjB,IAAI,GAAG,MAAM3B,WAAW,CAAC6B,MAAM,EAAE;QACrCuC,MAAM,EAAE;UACN5B,QAAQ,EAAE;QACZ;MACF,CAAC,CAAC;MAEF,IAAI,CAACb,IAAI,EAAE;QACT7B,QAAQ,CAACoC,YAAY,CAAC,gBAAgB,CAAC;MACzC;MAEA,MAAM0C,WAAW,GAAGjD,IAAI,CAACa,QAAQ;;MAEjC;MACA,MAAM1C,QAAQ,CAAC+E,kCAAkC,CAAC,UAAU,EAC1D,UAAU,EAAEF,WAAW,EAAEhD,IAAI,CAACH,GAAG,CAAC;MAEpC,MAAMrB,MAAM,CAACC,KAAK,CAACgC,WAAW,CAAC;QAAEZ,GAAG,EAAEG,IAAI,CAACH;MAAI,CAAC,EAAE;QAAEa,IAAI,EAAE;UAAEG,QAAQ,EAAEmC;QAAY;MAAE,CAAC,CAAC;;MAEtF;MACA;MACA,IAAI;QACF,MAAM7E,QAAQ,CAAC+E,kCAAkC,CAAC,UAAU,EAC1D,UAAU,EAAEF,WAAW,EAAEhD,IAAI,CAACH,GAAG,CAAC;MACtC,CAAC,CAAC,OAAOsD,EAAE,EAAE;QACX;QACA,MAAM3E,MAAM,CAACC,KAAK,CAACgC,WAAW,CAAC;UAAEZ,GAAG,EAAEG,IAAI,CAACH;QAAI,CAAC,EAAE;UAAEa,IAAI,EAAE;YAAEG,QAAQ,EAAEoC;UAAY;QAAE,CAAC,CAAC;QACtF,MAAME,EAAE;MACV;IACF,CAAC;;IAEH;IACA;IACA;IACA3E,MAAM,CAAC4E,OAAO,CACZ;MACEC,cAAc,EAAE,eAAAA,CAAgBC,WAAW,EAAEC,WAAW,EAAE;QAC5DlC,KAAK,CAACiC,WAAW,EAAE/B,iBAAiB,CAAC;QACrCF,KAAK,CAACkC,WAAW,EAAEhC,iBAAiB,CAAC;QAErC,IAAI,CAAC,IAAI,CAACrB,MAAM,EAAE;UAChB,MAAM,IAAI1B,MAAM,CAACW,KAAK,CAAC,GAAG,EAAE,mBAAmB,CAAC;QAClD;QAEA,MAAMa,IAAI,GAAG,MAAM3B,WAAW,CAAC,IAAI,CAAC6B,MAAM,EAAE;UAACuC,MAAM,EAAA/E,aAAA;YACjDoC,QAAQ,EAAE;UAAC,GACR3B,QAAQ,CAACyB,wBAAwB;QACrC,CAAC,CAAC;QACH,IAAI,CAACI,IAAI,EAAE;UACT7B,QAAQ,CAACoC,YAAY,CAAC,gBAAgB,CAAC;QACzC;QAEA,IAAI,CAACP,IAAI,CAACF,QAAQ,IAAI,CAACE,IAAI,CAACF,QAAQ,CAACd,QAAQ,IAAI,CAACgB,IAAI,CAACF,QAAQ,CAACd,QAAQ,CAACoB,MAAM,EAAE;UAC/EjC,QAAQ,CAACoC,YAAY,CAAC,0BAA0B,CAAC;QACnD;QAEA,MAAMN,MAAM,GAAG,MAAMF,kBAAkB,CAACC,IAAI,EAAEsD,WAAW,CAAC;QAC1D,IAAIrD,MAAM,CAACK,KAAK,EAAE;UAChB,MAAML,MAAM,CAACK,KAAK;QACpB;QAEA,MAAMkD,MAAM,GAAG,MAAMnE,YAAY,CAACkE,WAAW,CAAC;;QAE9C;QACA;QACA;QACA;QACA,MAAME,YAAY,GAAGtF,QAAQ,CAACuF,cAAc,CAAC,IAAI,CAACC,UAAU,CAACrF,EAAE,CAAC;QAChE,MAAME,MAAM,CAACC,KAAK,CAACgC,WAAW,CAC5B;UAAEZ,GAAG,EAAE,IAAI,CAACK;QAAO,CAAC,EACpB;UACEQ,IAAI,EAAE;YAAE,0BAA0B,EAAE8C;UAAO,CAAC;UAC5CI,KAAK,EAAE;YACL,6BAA6B,EAAE;cAAEC,WAAW,EAAE;gBAAEC,GAAG,EAAEL;cAAa;YAAE;UACtE,CAAC;UACDM,MAAM,EAAE;YAAE,yBAAyB,EAAE;UAAE;QACzC,CACF,CAAC;QAED,OAAO;UAACC,eAAe,EAAE;QAAI,CAAC;MAChC;IAAC,CAAC,CAAC;;IAGH;;IAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACA7F,QAAQ,CAAC8F,gBAAgB,GACvB,OAAO/D,MAAM,EAAEgE,oBAAoB,EAAE3F,OAAO,KAAK;MACjD8C,KAAK,CAACnB,MAAM,EAAEoB,MAAM,CAAC;MACrBD,KAAK,CAAC6C,oBAAoB,EAAEhD,KAAK,CAACC,KAAK,CAACM,GAAG;QAAA,IAAA0C,iBAAA,EAAAC,qBAAA,EAAAC,sBAAA;QAAA,OAAInD,KAAK,CAACW,IAAI,CAACJ,GAAG,EAAEH,MAAM,CAAC,IAAIG,GAAG,CAAC/B,MAAM,MAAAyE,iBAAA,GAAI3F,MAAM,CAACsD,QAAQ,cAAAqC,iBAAA,wBAAAC,qBAAA,GAAfD,iBAAA,CAAiBpC,QAAQ,cAAAqC,qBAAA,wBAAAC,sBAAA,GAAzBD,qBAAA,CAA2BpC,QAAQ,cAAAqC,sBAAA,uBAAnCA,sBAAA,CAAqCpC,iBAAiB,KAAI,GAAG;MAAA,EAAC,CAAC;MACvJZ,KAAK,CAAC9C,OAAO,EAAE2C,KAAK,CAACoD,KAAK,CAAC;QAAEC,MAAM,EAAEC;MAAQ,CAAC,CAAC,CAAC;MAChDjG,OAAO,GAAAb,aAAA;QAAK6G,MAAM,EAAE;MAAI,GAAMhG,OAAO,CAAE;MAEvC,MAAMyB,IAAI,GAAG,MAAM3B,WAAW,CAAC6B,MAAM,EAAE;QAAEuC,MAAM,EAAE;UAAE5C,GAAG,EAAE;QAAE;MAAE,CAAC,CAAC;MAC9D,IAAI,CAACG,IAAI,EAAE;QACT,MAAM,IAAIxB,MAAM,CAACW,KAAK,CAAC,GAAG,EAAE,gBAAgB,CAAC;MAC/C;MAEA,MAAMsF,MAAM,GAAG;QACbV,MAAM,EAAE;UACN,yBAAyB,EAAE;QAC7B,CAAC;QACDrD,IAAI,EAAE;UAAC,0BAA0B,EAAE,MAAMrB,YAAY,CAAC6E,oBAAoB;QAAC;MAC7E,CAAC;MAED,IAAI3F,OAAO,CAACgG,MAAM,EAAE;QAClBE,MAAM,CAACV,MAAM,CAAC,6BAA6B,CAAC,GAAG,CAAC;MAClD;MAEA,MAAMvF,MAAM,CAACC,KAAK,CAACgC,WAAW,CAAC;QAACZ,GAAG,EAAEG,IAAI,CAACH;MAAG,CAAC,EAAE4E,MAAM,CAAC;IACzD,CAAC;;IAED;IACA;IACA;;IAEA;IACA,MAAMC,cAAc,GAAG,SAAAA,CAAA;MAAA,IAACC,MAAM,GAAAC,SAAA,CAAAlF,MAAA,QAAAkF,SAAA,QAAAvC,SAAA,GAAAuC,SAAA,MAAG,EAAE;MAAA,OAAKD,MAAM,CAACE,GAAG,CAAC7D,KAAK,IAAIA,KAAK,CAAC8D,OAAO,CAAC;IAAA;;IAE1E;IACA;IACAtG,MAAM,CAAC4E,OAAO,CAAC;MAAC2B,cAAc,EAAE,MAAMxG,OAAO,IAAI;QAC/C8C,KAAK,CAAC9C,OAAO,EAAE;UAACyC,KAAK,EAAEM;QAAM,CAAC,CAAC;QAE/B,MAAMtB,IAAI,GAAG,MAAM7B,QAAQ,CAAC4C,eAAe,CAACxC,OAAO,CAACyC,KAAK,EAAE;UAAEyB,MAAM,EAAE;YAAEkC,MAAM,EAAE;UAAE;QAAE,CAAC,CAAC;QAErF,IAAI,CAAC3E,IAAI,EAAE;UACT7B,QAAQ,CAACoC,YAAY,CAAC,gBAAgB,CAAC;QACzC;QAEA,MAAMoE,MAAM,GAAGD,cAAc,CAAC1E,IAAI,CAAC2E,MAAM,CAAC;QAC1C,MAAMK,kBAAkB,GAAGL,MAAM,CAACM,IAAI,CACpCjE,KAAK,IAAIA,KAAK,CAACkE,WAAW,CAAC,CAAC,KAAK3G,OAAO,CAACyC,KAAK,CAACkE,WAAW,CAAC,CAC7D,CAAC;QAED,MAAM/G,QAAQ,CAACgH,sBAAsB,CAACnF,IAAI,CAACH,GAAG,EAAEmF,kBAAkB,CAAC;MACrE;IAAC,CAAC,CAAC;;IAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACA7G,QAAQ,CAACiH,kBAAkB,GACzB,OAAOlF,MAAM,EAAEc,KAAK,EAAEqE,MAAM,EAAEC,cAAc,KAAK;MACjD;MACA;MACA;MACA,MAAMtF,IAAI,GAAG,MAAM3B,WAAW,CAAC6B,MAAM,CAAC;MACtC,IAAI,CAACF,IAAI,EAAE;QACT7B,QAAQ,CAACoC,YAAY,CAAC,iBAAiB,CAAC;MAC1C;;MAEA;MACA,IAAI,CAACS,KAAK,IAAIhB,IAAI,CAAC2E,MAAM,IAAI3E,IAAI,CAAC2E,MAAM,CAAC,CAAC,CAAC,EAAE;QAC3C3D,KAAK,GAAGhB,IAAI,CAAC2E,MAAM,CAAC,CAAC,CAAC,CAACG,OAAO;MAChC;;MAEA;MACA,IAAI,CAAC9D,KAAK,IACR,CAAE0D,cAAc,CAAC1E,IAAI,CAAC2E,MAAM,CAAC,CAACY,QAAQ,CAACvE,KAAK,CAAE,EAAE;QAChD7C,QAAQ,CAACoC,YAAY,CAAC,yBAAyB,CAAC;MAClD;MAEA,MAAMiF,KAAK,GAAGC,MAAM,CAAC3C,MAAM,CAAC,CAAC;MAC7B,MAAM4C,WAAW,GAAG;QAClBF,KAAK;QACLxE,KAAK;QACL2E,IAAI,EAAE,IAAIC,IAAI,CAAC;MACjB,CAAC;MAED,IAAIP,MAAM,KAAK,eAAe,EAAE;QAC9BK,WAAW,CAACL,MAAM,GAAG,OAAO;MAC9B,CAAC,MAAM,IAAIA,MAAM,KAAK,eAAe,EAAE;QACrCK,WAAW,CAACL,MAAM,GAAG,QAAQ;MAC/B,CAAC,MAAM,IAAIA,MAAM,EAAE;QACjB;QACAK,WAAW,CAACL,MAAM,GAAGA,MAAM;MAC7B;MAEA,IAAIC,cAAc,EAAE;QAClBO,MAAM,CAACC,MAAM,CAACJ,WAAW,EAAEJ,cAAc,CAAC;MAC5C;MACA;MACA;MACA;MACA,IAAGD,MAAM,KAAK,eAAe,EAAE;QAC7B,MAAM7G,MAAM,CAACC,KAAK,CAACgC,WAAW,CAAC;UAACZ,GAAG,EAAEG,IAAI,CAACH;QAAG,CAAC,EAAE;UAC9Ca,IAAI,EAAG;YACL,0BAA0B,EAAEgF;UAC9B;QACF,CAAC,CAAC;QACF;QACClH,MAAM,CAACuH,OAAO,CAAC/F,IAAI,EAAE,UAAU,EAAE,UAAU,CAAC,CAACgG,MAAM,GAAGN,WAAW;MACpE,CAAC,MAAM;QACL,MAAMlH,MAAM,CAACC,KAAK,CAACgC,WAAW,CAAC;UAACZ,GAAG,EAAEG,IAAI,CAACH;QAAG,CAAC,EAAE;UAC9Ca,IAAI,EAAG;YACL,yBAAyB,EAAEgF;UAC7B;QACF,CAAC,CAAC;QACF;QACClH,MAAM,CAACuH,OAAO,CAAC/F,IAAI,EAAE,UAAU,EAAE,UAAU,CAAC,CAACiG,KAAK,GAAGP,WAAW;MACnE;MAEA,OAAO;QAAC1E,KAAK;QAAEhB,IAAI;QAAEwF;MAAK,CAAC;IAC7B,CAAC;;IAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACArH,QAAQ,CAAC+H,yBAAyB,GAChC,OAAOhG,MAAM,EAAEc,KAAK,EAAEsE,cAAc,KAAK;MACzC;MACA;MACA;MACA,MAAMtF,IAAI,GAAG,MAAM3B,WAAW,CAAC6B,MAAM,CAAC;MACtC,IAAI,CAACF,IAAI,EAAE;QACT7B,QAAQ,CAACoC,YAAY,CAAC,iBAAiB,CAAC;MAC1C;;MAEA;MACA,IAAI,CAACS,KAAK,EAAE;QACV,MAAMmF,WAAW,GAAG,CAACnG,IAAI,CAAC2E,MAAM,IAAI,EAAE,EAAEM,IAAI,CAACmB,CAAC,IAAI,CAACA,CAAC,CAACC,QAAQ,CAAC;QAC9DrF,KAAK,GAAG,CAACmF,WAAW,IAAI,CAAC,CAAC,EAAErB,OAAO;QAEnC,IAAI,CAAC9D,KAAK,EAAE;UACV7C,QAAQ,CAACoC,YAAY,CAAC,8CAA8C,CAAC;QACvE;MACF;;MAEA;MACA,IAAI,CAACS,KAAK,IACR,CAAE0D,cAAc,CAAC1E,IAAI,CAAC2E,MAAM,CAAC,CAACY,QAAQ,CAACvE,KAAK,CAAE,EAAE;QAChD7C,QAAQ,CAACoC,YAAY,CAAC,yBAAyB,CAAC;MAClD;MAEA,MAAMiF,KAAK,GAAGC,MAAM,CAAC3C,MAAM,CAAC,CAAC;MAC7B,MAAM4C,WAAW,GAAG;QAClBF,KAAK;QACL;QACAV,OAAO,EAAE9D,KAAK;QACd2E,IAAI,EAAE,IAAIC,IAAI,CAAC;MACjB,CAAC;MAED,IAAIN,cAAc,EAAE;QAClBO,MAAM,CAACC,MAAM,CAACJ,WAAW,EAAEJ,cAAc,CAAC;MAC5C;MAEA,MAAM9G,MAAM,CAACC,KAAK,CAACgC,WAAW,CAAC;QAACZ,GAAG,EAAEG,IAAI,CAACH;MAAG,CAAC,EAAE;QAACyG,KAAK,EAAE;UACtD,mCAAmC,EAAEZ;QACvC;MAAC,CAAC,CAAC;;MAEH;MACAlH,MAAM,CAACuH,OAAO,CAAC/F,IAAI,EAAE,UAAU,EAAE,OAAO,CAAC;MACzC,IAAI,CAACA,IAAI,CAACF,QAAQ,CAACkB,KAAK,CAACuF,kBAAkB,EAAE;QAC3CvG,IAAI,CAACF,QAAQ,CAACkB,KAAK,CAACuF,kBAAkB,GAAG,EAAE;MAC7C;MACAvG,IAAI,CAACF,QAAQ,CAACkB,KAAK,CAACuF,kBAAkB,CAACC,IAAI,CAACd,WAAW,CAAC;MAExD,OAAO;QAAC1E,KAAK;QAAEhB,IAAI;QAAEwF;MAAK,CAAC;IAC7B,CAAC;;IAGD;IACA;;IAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACArH,QAAQ,CAACgH,sBAAsB,GAC7B,OAAOjF,MAAM,EAAEc,KAAK,EAAEsE,cAAc,EAAEmB,WAAW,KAAK;MACpD,MAAM;QAAEzF,KAAK,EAAE0F,SAAS;QAAE1G,IAAI;QAAEwF;MAAM,CAAC,GACrC,MAAMrH,QAAQ,CAACiH,kBAAkB,CAAClF,MAAM,EAAEc,KAAK,EAAE,eAAe,EAAEsE,cAAc,CAAC;MACnF,MAAMqB,GAAG,GAAGxI,QAAQ,CAACyI,IAAI,CAACC,aAAa,CAACrB,KAAK,EAAEiB,WAAW,CAAC;MAC3D,MAAMlI,OAAO,GAAG,MAAMJ,QAAQ,CAAC2I,uBAAuB,CAACJ,SAAS,EAAE1G,IAAI,EAAE2G,GAAG,EAAE,eAAe,CAAC;MAC7F,MAAMI,KAAK,CAACC,SAAS,CAACzI,OAAO,CAAC;MAE9B,IAAIC,MAAM,CAACyI,aAAa,EAAE;QACxBC,OAAO,CAACC,GAAG,0BAAAC,MAAA,CAA2BT,GAAG,CAAG,CAAC;MAC/C;MACA,OAAO;QAAE3F,KAAK,EAAE0F,SAAS;QAAE1G,IAAI;QAAEwF,KAAK;QAAEmB,GAAG;QAAEpI;MAAQ,CAAC;IACxD,CAAC;;IAEH;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACAJ,QAAQ,CAACkJ,mBAAmB,GAC1B,OAAOnH,MAAM,EAAEc,KAAK,EAAEsE,cAAc,EAAEmB,WAAW,KAAK;MAEpD,MAAM;QAAEzF,KAAK,EAAE0F,SAAS;QAAE1G,IAAI;QAAEwF;MAAM,CAAC,GACrC,MAAMrH,QAAQ,CAACiH,kBAAkB,CAAClF,MAAM,EAAEc,KAAK,EAAE,eAAe,EAAEsE,cAAc,CAAC;MAEnF,MAAMqB,GAAG,GAAGxI,QAAQ,CAACyI,IAAI,CAACU,aAAa,CAAC9B,KAAK,EAAEiB,WAAW,CAAC;MAE3D,MAAMlI,OAAO,GACX,MAAMJ,QAAQ,CAAC2I,uBAAuB,CAACJ,SAAS,EAAE1G,IAAI,EAAE2G,GAAG,EAAE,eAAe,CAAC;MAE/E,MAAMI,KAAK,CAACC,SAAS,CAACzI,OAAO,CAAC;MAC9B,IAAIC,MAAM,CAACyI,aAAa,EAAE;QACxBC,OAAO,CAACC,GAAG,4BAAAC,MAAA,CAA6BT,GAAG,CAAG,CAAC;MACjD;MACA,OAAO;QAAE3F,KAAK,EAAE0F,SAAS;QAAE1G,IAAI;QAAEwF,KAAK;QAAEmB,GAAG;QAAEpI;MAAQ,CAAC;IACxD,CAAC;;IAGH;IACA;IACAC,MAAM,CAAC4E,OAAO,CACZ;MACEyD,aAAa,EACX,eAAAA,CAAA,EAAyB;QAAA,SAAAU,IAAA,GAAA3C,SAAA,CAAAlF,MAAA,EAAN8H,IAAI,OAAAC,KAAA,CAAAF,IAAA,GAAAG,IAAA,MAAAA,IAAA,GAAAH,IAAA,EAAAG,IAAA;UAAJF,IAAI,CAAAE,IAAA,IAAA9C,SAAA,CAAA8C,IAAA;QAAA;QACrB,MAAMlC,KAAK,GAAGgC,IAAI,CAAC,CAAC,CAAC;QACrB,MAAMjE,WAAW,GAAGiE,IAAI,CAAC,CAAC,CAAC;QAC3B,OAAO,MAAMrJ,QAAQ,CAACwJ,YAAY,CAChC,IAAI,EACJ,eAAe,EACfH,IAAI,EACJ,UAAU,EACV,YAAY;UAAA,IAAAI,sBAAA,EAAAC,UAAA;UACVxG,KAAK,CAACmE,KAAK,EAAElE,MAAM,CAAC;UACpBD,KAAK,CAACkC,WAAW,EAAEhC,iBAAiB,CAAC;UACrC,IAAIvB,IAAI,GAAG,MAAMxB,MAAM,CAACC,KAAK,CAACC,YAAY,CACxC;YAAE,+BAA+B,EAAE8G;UAAM,CAAC,EAC1C;YACE/C,MAAM,EAAE;cACN3C,QAAQ,EAAE,CAAC;cACX6E,MAAM,EAAE;YACV;UACF,CACF,CAAC;UAED,IAAImD,QAAQ,GAAG,KAAK;UACpB;UACA;UACA;UACA,IAAI,CAAC9H,IAAI,EAAE;YACTA,IAAI,GAAG,MAAMxB,MAAM,CAACC,KAAK,CAACC,YAAY,CACpC;cAAE,gCAAgC,EAAE8G;YAAM,CAAC,EAC3C;cACE/C,MAAM,EAAE;gBACN3C,QAAQ,EAAE,CAAC;gBACX6E,MAAM,EAAE;cACV;YACF,CACF,CAAC;YACDmD,QAAQ,GAAG,IAAI;UACjB;UACA,IAAI,CAAC9H,IAAI,EAAE;YACT,MAAM,IAAIxB,MAAM,CAACW,KAAK,CAAC,GAAG,EAAE,eAAe,CAAC;UAC9C;UACA,IAAIuG,WAAW,GAAG,CAAC,CAAC;UACpB,IAAIoC,QAAQ,EAAE;YACZpC,WAAW,GAAG1F,IAAI,CAACF,QAAQ,CAACd,QAAQ,CAACgH,MAAM;UAC7C,CAAC,MAAM;YACLN,WAAW,GAAG1F,IAAI,CAACF,QAAQ,CAACd,QAAQ,CAACiH,KAAK;UAC5C;UACA,MAAM;YAAEN,IAAI;YAAE3E;UAAM,CAAC,GAAG0E,WAAW;UACnC,IAAIqC,eAAe,GAAG5J,QAAQ,CAAC6J,gCAAgC,CAAC,CAAC;UACjE,IAAIF,QAAQ,EAAE;YACZC,eAAe,GAAG5J,QAAQ,CAAC8J,iCAAiC,CAAC,CAAC;UAChE;UACA,MAAMC,aAAa,GAAGtC,IAAI,CAACuC,GAAG,CAAC,CAAC;UAChC,IAAKD,aAAa,GAAGvC,IAAI,GAAIoC,eAAe,EAC1C,MAAM,IAAIvJ,MAAM,CAACW,KAAK,CAAC,GAAG,EAAE,eAAe,CAAC;UAC9C,IAAI,CAAEuF,cAAc,CAAC1E,IAAI,CAAC2E,MAAM,CAAC,CAACY,QAAQ,CAACvE,KAAK,CAAE,EAChD,OAAO;YACLd,MAAM,EAAEF,IAAI,CAACH,GAAG;YAChBS,KAAK,EAAE,IAAI9B,MAAM,CAACW,KAAK,CAAC,GAAG,EAAE,iCAAiC;UAChE,CAAC;UAEH,MAAMqE,MAAM,GAAG,MAAMnE,YAAY,CAACkE,WAAW,CAAC;;UAE9C;UACA;UACA;UACA;UACA,MAAM6E,QAAQ,GAAGjK,QAAQ,CAACuF,cAAc,CAAC,IAAI,CAACC,UAAU,CAACrF,EAAE,CAAC;UAC5DH,QAAQ,CAACkK,cAAc,CAACrI,IAAI,CAACH,GAAG,EAAE,IAAI,CAAC8D,UAAU,EAAE,IAAI,CAAC;UACxD,MAAM2E,eAAe,GAAGA,CAAA,KACtBnK,QAAQ,CAACkK,cAAc,CAACrI,IAAI,CAACH,GAAG,EAAE,IAAI,CAAC8D,UAAU,EAAEyE,QAAQ,CAAC;UAE9D,IAAI;YACF;YACA;YACA;YACA;YACA,IAAIG,eAAe,GAAG,CAAC,CAAC;YACxB;YACA,IAAIT,QAAQ,EAAE;cACZS,eAAe,GAAG,MAAM/J,MAAM,CAACC,KAAK,CAACgC,WAAW,CAC9C;gBACEZ,GAAG,EAAEG,IAAI,CAACH,GAAG;gBACb,gBAAgB,EAAEmB,KAAK;gBACvB,gCAAgC,EAAEwE;cACpC,CAAC,EACD;gBACE9E,IAAI,EAAE;kBACJ,0BAA0B,EAAE8C,MAAM;kBAClC,mBAAmB,EAAE;gBACvB,CAAC;gBACDO,MAAM,EAAE;kBAAE,0BAA0B,EAAE;gBAAE;cAC1C,CAAC,CAAC;YACN,CAAC,MAAM;cACLwE,eAAe,GAAG,MAAM/J,MAAM,CAACC,KAAK,CAACgC,WAAW,CAC9C;gBACEZ,GAAG,EAAEG,IAAI,CAACH,GAAG;gBACb,gBAAgB,EAAEmB,KAAK;gBACvB,+BAA+B,EAAEwE;cACnC,CAAC,EACD;gBACE9E,IAAI,EAAE;kBACJ,0BAA0B,EAAE8C,MAAM;kBAClC,mBAAmB,EAAE;gBACvB,CAAC;gBACDO,MAAM,EAAE;kBAAE,yBAAyB,EAAE;gBAAE;cACzC,CAAC,CAAC;YACN;YACA,IAAIwE,eAAe,KAAK,CAAC,EACvB,OAAO;cACLrI,MAAM,EAAEF,IAAI,CAACH,GAAG;cAChBS,KAAK,EAAE,IAAI9B,MAAM,CAACW,KAAK,CAAC,GAAG,EAAE,eAAe;YAC9C,CAAC;UACL,CAAC,CAAC,OAAOqJ,GAAG,EAAE;YACZF,eAAe,CAAC,CAAC;YACjB,MAAME,GAAG;UACX;;UAEA;UACA;UACA,MAAMrK,QAAQ,CAACsK,oBAAoB,CAACzI,IAAI,CAACH,GAAG,CAAC;UAE7C,KAAA+H,sBAAA,GAAI,CAAAC,UAAA,GAAA1J,QAAQ,EAACuE,gBAAgB,cAAAkF,sBAAA,eAAzBA,sBAAA,CAAAjF,IAAA,CAAAkF,UAAA,EAA4B7H,IAAI,CAAC,EAAE;YAC3C,OAAO;cACLE,MAAM,EAAEF,IAAI,CAACH,GAAG;cAChBS,KAAK,EAAEnC,QAAQ,CAACoC,YAAY,CAC1B,iEAAiE,EACjE,KAAK,EACL,aACF;YACF,CAAC;UACH;UAAC,OAAO;YAAEL,MAAM,EAAEF,IAAI,CAACH;UAAI,CAAC;QACxB,CACF,CAAC;MACH;IACJ,CACF,CAAC;;IAED;IACA;IACA;;IAGA;IACA;;IAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACA1B,QAAQ,CAACuK,qBAAqB,GAC5B,OAAOxI,MAAM,EAAEc,KAAK,EAAEsE,cAAc,EAAEmB,WAAW,KAAK;MACpD;MACA;MACA;;MAEA,MAAM;QAAEzF,KAAK,EAAE0F,SAAS;QAAE1G,IAAI;QAAEwF;MAAM,CAAC,GACrC,MAAMrH,QAAQ,CAAC+H,yBAAyB,CAAChG,MAAM,EAAEc,KAAK,EAAEsE,cAAc,CAAC;MACzE,MAAMqB,GAAG,GAAGxI,QAAQ,CAACyI,IAAI,CAAC+B,WAAW,CAACnD,KAAK,EAAEiB,WAAW,CAAC;MACzD,MAAMlI,OAAO,GAAG,MAAMJ,QAAQ,CAAC2I,uBAAuB,CAACJ,SAAS,EAAE1G,IAAI,EAAE2G,GAAG,EAAE,aAAa,CAAC;MAC3F,MAAMI,KAAK,CAACC,SAAS,CAACzI,OAAO,CAAC;MAC9B,IAAIC,MAAM,CAACyI,aAAa,EAAE;QACxBC,OAAO,CAACC,GAAG,8BAAAC,MAAA,CAA+BT,GAAG,CAAG,CAAC;MACnD;MACA,OAAO;QAAE3F,KAAK,EAAE0F,SAAS;QAAE1G,IAAI;QAAEwF,KAAK;QAAEmB,GAAG;QAAEpI;MAAQ,CAAC;IACxD,CAAC;;IAEH;IACA;IACAC,MAAM,CAAC4E,OAAO,CACZ;MACEuF,WAAW,EAAE,eAAAA,CAAA,EAAyB;QAAA,SAAAC,KAAA,GAAAhE,SAAA,CAAAlF,MAAA,EAAN8H,IAAI,OAAAC,KAAA,CAAAmB,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;UAAJrB,IAAI,CAAAqB,KAAA,IAAAjE,SAAA,CAAAiE,KAAA;QAAA;QAClC,MAAMrD,KAAK,GAAGgC,IAAI,CAAC,CAAC,CAAC;QACrB,OAAO,MAAMrJ,QAAQ,CAACwJ,YAAY,CAChC,IAAI,EACJ,aAAa,EACbH,IAAI,EACJ,UAAU,EACV,YAAY;UAAA,IAAAsB,sBAAA,EAAAC,UAAA;UACV1H,KAAK,CAACmE,KAAK,EAAElE,MAAM,CAAC;UAEpB,MAAMtB,IAAI,GAAG,MAAMxB,MAAM,CAACC,KAAK,CAACC,YAAY,CAC1C;YAAE,yCAAyC,EAAE8G;UAAM,CAAC,EACpD;YACE/C,MAAM,EAAE;cACN3C,QAAQ,EAAE,CAAC;cACX6E,MAAM,EAAE;YACV;UACF,CACF,CAAC;UACD,IAAI,CAAC3E,IAAI,EACP,MAAM,IAAIxB,MAAM,CAACW,KAAK,CAAC,GAAG,EAAE,2BAA2B,CAAC;UAE1D,MAAMuG,WAAW,GACf,MAAM1F,IAAI,CACPF,QAAQ,CAACkB,KAAK,CAACuF,kBAAkB,CAACtB,IAAI,CAAC+D,CAAC,IAAIA,CAAC,CAACxD,KAAK,IAAIA,KAAK,CAAC;UAElE,IAAI,CAACE,WAAW,EACd,OAAO;YACLxF,MAAM,EAAEF,IAAI,CAACH,GAAG;YAChBS,KAAK,EAAE,IAAI9B,MAAM,CAACW,KAAK,CAAC,GAAG,EAAE,2BAA2B;UAC1D,CAAC;UAEH,MAAM8J,YAAY,GAChBjJ,IAAI,CAAC2E,MAAM,CAACM,IAAI,CAACmB,CAAC,IAAIA,CAAC,CAACtB,OAAO,IAAIY,WAAW,CAACZ,OAAO,CAAC;UAEzD,IAAI,CAACmE,YAAY,EACf,OAAO;YACL/I,MAAM,EAAEF,IAAI,CAACH,GAAG;YAChBS,KAAK,EAAE,IAAI9B,MAAM,CAACW,KAAK,CAAC,GAAG,EAAE,0CAA0C;UACzE,CAAC;;UAEH;UACA;UACA;UACA;UACA;UACA,MAAMX,MAAM,CAACC,KAAK,CAACgC,WAAW,CAC5B;YACEZ,GAAG,EAAEG,IAAI,CAACH,GAAG;YACb,gBAAgB,EAAE6F,WAAW,CAACZ;UAChC,CAAC,EACD;YACEpE,IAAI,EAAE;cAAE,mBAAmB,EAAE;YAAK,CAAC;YACnCkD,KAAK,EAAE;cAAE,mCAAmC,EAAE;gBAAEkB,OAAO,EAAEY,WAAW,CAACZ;cAAQ;YAAE;UACjF,CAAC,CAAC;UAEJ,KAAAgE,sBAAA,GAAI,CAAAC,UAAA,GAAA5K,QAAQ,EAACuE,gBAAgB,cAAAoG,sBAAA,eAAzBA,sBAAA,CAAAnG,IAAA,CAAAoG,UAAA,EAA4B/I,IAAI,CAAC,EAAE;YACzC,OAAO;cACLE,MAAM,EAAEF,IAAI,CAACH,GAAG;cAChBS,KAAK,EAAEnC,QAAQ,CAACoC,YAAY,CAC1B,+DAA+D,EAC/D,KAAK,EACL,aACF;YACF,CAAC;UACH;UAAC,OAAO;YAAEL,MAAM,EAAEF,IAAI,CAACH;UAAI,CAAC;QAC1B,CACF,CAAC;MACH;IACF,CAAC,CAAC;;IAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACA1B,QAAQ,CAAC+K,aAAa,GAAG,OAAOhJ,MAAM,EAAEiJ,QAAQ,EAAE9C,QAAQ,KAAK;MAC7DhF,KAAK,CAACnB,MAAM,EAAEe,cAAc,CAAC;MAC7BI,KAAK,CAAC8H,QAAQ,EAAElI,cAAc,CAAC;MAC/BI,KAAK,CAACgF,QAAQ,EAAEnF,KAAK,CAACsB,QAAQ,CAACgC,OAAO,CAAC,CAAC;MAExC,IAAI6B,QAAQ,KAAK,KAAK,CAAC,EAAE;QACvBA,QAAQ,GAAG,KAAK;MAClB;MAEA,MAAMrG,IAAI,GAAG,MAAM3B,WAAW,CAAC6B,MAAM,EAAE;QAAEuC,MAAM,EAAE;UAAEkC,MAAM,EAAE;QAAE;MAAE,CAAC,CAAC;MACjE,IAAI,CAAC3E,IAAI,EAAE,MAAM,IAAIxB,MAAM,CAACW,KAAK,CAAC,GAAG,EAAE,gBAAgB,CAAC;;MAExD;;MAEA;MACA;MACA;MACA;MACA;MACA;MACA,MAAMiK,qBAAqB,GAAG,IAAIC,MAAM,KAAAjC,MAAA,CAClC5I,MAAM,CAAC8K,aAAa,CAACH,QAAQ,CAAC,QAClC,GACF,CAAC;;MAED;MACA;MACA,MAAMI,YAAY,GAAG,eAAAA,CAAA,EAA4B;QAAA,IAArB5E,MAAM,GAAAC,SAAA,CAAAlF,MAAA,QAAAkF,SAAA,QAAAvC,SAAA,GAAAuC,SAAA,MAAG,EAAE;QAAA,IAAE/E,GAAG,GAAA+E,SAAA,CAAAlF,MAAA,OAAAkF,SAAA,MAAAvC,SAAA;QAC1C,IAAImH,OAAO,GAAG,KAAK;QACnB,KAAK,MAAMxI,KAAK,IAAI2D,MAAM,EAAE;UAC1B,IAAIyE,qBAAqB,CAACvH,IAAI,CAACb,KAAK,CAAC8D,OAAO,CAAC,EAAE;YAC7C,MAAMtG,MAAM,CAACC,KAAK,CAACgC,WAAW,CAC5B;cACEZ,GAAG,EAAEA,GAAG;cACR,gBAAgB,EAAEmB,KAAK,CAAC8D;YAC1B,CAAC,EACD;cACEpE,IAAI,EAAE;gBACJ,kBAAkB,EAAEyI,QAAQ;gBAC5B,mBAAmB,EAAE9C;cACvB;YACF,CACF,CAAC;YACDmD,OAAO,GAAG,IAAI;UAChB;QACF;QACA,OAAOA,OAAO;MAChB,CAAC;MACD,MAAMC,iBAAiB,GAAG,MAAMF,YAAY,CAACvJ,IAAI,CAAC2E,MAAM,EAAE3E,IAAI,CAACH,GAAG,CAAC;;MAEnE;MACA;MACA;MACA;MACA;MACA;;MAEA,IAAI4J,iBAAiB,EAAE;QACrB;MACF;;MAEA;MACA,MAAMtL,QAAQ,CAAC+E,kCAAkC,CAC/C,gBAAgB,EAChB,OAAO,EACPiG,QAAQ,EACRnJ,IAAI,CAACH,GACP,CAAC;MAED,MAAMrB,MAAM,CAACC,KAAK,CAACgC,WAAW,CAC5B;QACEZ,GAAG,EAAEG,IAAI,CAACH;MACZ,CAAC,EACD;QACE6J,SAAS,EAAE;UACT/E,MAAM,EAAE;YACNG,OAAO,EAAEqE,QAAQ;YACjB9C,QAAQ,EAAEA;UACZ;QACF;MACF,CACF,CAAC;;MAED;MACA;MACA,IAAI;QACF,MAAMlI,QAAQ,CAAC+E,kCAAkC,CAC/C,gBAAgB,EAChB,OAAO,EACPiG,QAAQ,EACRnJ,IAAI,CAACH,GACP,CAAC;MACH,CAAC,CAAC,OAAOsD,EAAE,EAAE;QACX;QACA,MAAM3E,MAAM,CAACC,KAAK,CAACgC,WAAW,CAC5B;UAAEZ,GAAG,EAAEG,IAAI,CAACH;QAAI,CAAC,EACjB;UAAE+D,KAAK,EAAE;YAAEe,MAAM,EAAE;cAAEG,OAAO,EAAEqE;YAAS;UAAE;QAAE,CAC7C,CAAC;QACD,MAAMhG,EAAE;MACV;IACF,CAAC;;IAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACAhF,QAAQ,CAACwL,WAAW,GAClB,OAAOzJ,MAAM,EAAEc,KAAK,KAAK;MACvBK,KAAK,CAACnB,MAAM,EAAEe,cAAc,CAAC;MAC7BI,KAAK,CAACL,KAAK,EAAEC,cAAc,CAAC;MAE5B,MAAMjB,IAAI,GAAG,MAAM3B,WAAW,CAAC6B,MAAM,EAAE;QAAEuC,MAAM,EAAE;UAAE5C,GAAG,EAAE;QAAE;MAAE,CAAC,CAAC;MAC9D,IAAI,CAACG,IAAI,EACP,MAAM,IAAIxB,MAAM,CAACW,KAAK,CAAC,GAAG,EAAE,gBAAgB,CAAC;MAE/C,MAAMX,MAAM,CAACC,KAAK,CAACgC,WAAW,CAAC;QAAEZ,GAAG,EAAEG,IAAI,CAACH;MAAI,CAAC,EAC9C;QAAE+D,KAAK,EAAE;UAAEe,MAAM,EAAE;YAAEG,OAAO,EAAE9D;UAAM;QAAE;MAAE,CAAC,CAAC;IAC9C,CAAC;;IAEH;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;IACA,MAAM4I,UAAU,GACd,MAAMrL,OAAO,IAAI;MACf;MACA;MACA8C,KAAK,CAAC9C,OAAO,EAAE2C,KAAK,CAAC2I,eAAe,CAAC;QACnChJ,QAAQ,EAAEK,KAAK,CAACsB,QAAQ,CAAClB,MAAM,CAAC;QAChCN,KAAK,EAAEE,KAAK,CAACsB,QAAQ,CAAClB,MAAM,CAAC;QAC7BtC,QAAQ,EAAEkC,KAAK,CAACsB,QAAQ,CAACjB,iBAAiB;MAC5C,CAAC,CAAC,CAAC;MAEH,MAAM;QAAEV,QAAQ;QAAEG,KAAK;QAAEhC;MAAS,CAAC,GAAGT,OAAO;MAC7C,IAAI,CAACsC,QAAQ,IAAI,CAACG,KAAK,EACrB,MAAM,IAAIxC,MAAM,CAACW,KAAK,CAAC,GAAG,EAAE,iCAAiC,CAAC;MAEhE,MAAMa,IAAI,GAAG;QAAEF,QAAQ,EAAE,CAAC;MAAE,CAAC;MAC7B,IAAId,QAAQ,EAAE;QACZ,MAAMwE,MAAM,GAAG,MAAMnE,YAAY,CAACL,QAAQ,CAAC;QAC3CgB,IAAI,CAACF,QAAQ,CAACd,QAAQ,GAAG;UAAEoB,MAAM,EAAEoD;QAAO,CAAC;MAC7C;MAEA,OAAO,MAAMrF,QAAQ,CAAC2L,6BAA6B,CAAC;QAAE9J,IAAI;QAAEgB,KAAK;QAAEH,QAAQ;QAAEtC;MAAQ,CAAC,CAAC;IACzF,CAAC;;IAEH;IACAC,MAAM,CAAC4E,OAAO,CACZ;MACEwG,UAAU,EAAE,eAAAA,CAAA,EAAyB;QAAA,SAAAG,KAAA,GAAAnF,SAAA,CAAAlF,MAAA,EAAN8H,IAAI,OAAAC,KAAA,CAAAsC,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;UAAJxC,IAAI,CAAAwC,KAAA,IAAApF,SAAA,CAAAoF,KAAA;QAAA;QACjC,MAAMzL,OAAO,GAAGiJ,IAAI,CAAC,CAAC,CAAC;QACvB,OAAO,MAAMrJ,QAAQ,CAACwJ,YAAY,CAChC,IAAI,EACJ,YAAY,EACZH,IAAI,EACJ,UAAU,EACV,YAAY;UACV;UACAnG,KAAK,CAAC9C,OAAO,EAAEsH,MAAM,CAAC;UACtB,IAAI1H,QAAQ,CAACU,QAAQ,CAACoL,2BAA2B,EAC/C,OAAO;YACL3J,KAAK,EAAE,IAAI9B,MAAM,CAACW,KAAK,CAAC,GAAG,EAAE,mBAAmB;UAClD,CAAC;UAEH,MAAMe,MAAM,GAAG,MAAM/B,QAAQ,CAAC+L,wBAAwB,CAAC3L,OAAO,CAAC;;UAE/D;UACA,OAAO;YAAE2B,MAAM,EAAEA;UAAO,CAAC;QAC3B,CACF,CAAC;MACH;IACF,CAAC,CAAC;;IAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACA/B,QAAQ,CAAC+L,wBAAwB,GAC/B,MAAO3L,OAAO,IAAK;MACjBA,OAAO,GAAAb,aAAA,KAAQa,OAAO,CAAE;MACxB;MACA,MAAM2B,MAAM,GAAG,MAAM0J,UAAU,CAACrL,OAAO,CAAC;MACxC;MACA;MACA,IAAI,CAAC2B,MAAM,EACT,MAAM,IAAIf,KAAK,CAAC,sCAAsC,CAAC;;MAEzD;MACA;MACA;MACA,IAAIZ,OAAO,CAACyC,KAAK,IAAI7C,QAAQ,CAACU,QAAQ,CAAC6J,qBAAqB,EAAE;QAC5D,IAAInK,OAAO,CAACS,QAAQ,EAAE;UACpB,MAAMb,QAAQ,CAACuK,qBAAqB,CAACxI,MAAM,EAAE3B,OAAO,CAACyC,KAAK,CAAC;QAC7D,CAAC,MAAM;UACL,MAAM7C,QAAQ,CAACkJ,mBAAmB,CAACnH,MAAM,EAAE3B,OAAO,CAACyC,KAAK,CAAC;QAC3D;MACF;MAEA,OAAOd,MAAM;IACf,CAAC;;IAEH;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA/B,QAAQ,CAACgM,eAAe,GACtB,OAAO5L,OAAO,EAAE6L,QAAQ,KAAK;MAC3B7L,OAAO,GAAAb,aAAA,KAAQa,OAAO,CAAE;;MAExB;MACA,IAAI6L,QAAQ,EAAE;QACZ,MAAM,IAAIjL,KAAK,CAAC,oEAAoE,CAAC;MACvF;MAEA,OAAOyK,UAAU,CAACrL,OAAO,CAAC;IAC5B,CAAC;;IAEH;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEAJ,QAAQ,CAACyL,UAAU,GAAGzL,QAAQ,CAACgM,eAAe;;IAE9C;IACA;IACA;IACA,MAAM3L,MAAM,CAACC,KAAK,CAAC4L,gBAAgB,CAAC,yCAAyC,EAC3E;MAAEC,MAAM,EAAE,IAAI;MAAEC,MAAM,EAAE;IAAK,CAAC,CAAC;IACjC,MAAM/L,MAAM,CAACC,KAAK,CAAC4L,gBAAgB,CAAC,+BAA+B,EACjE;MAAEC,MAAM,EAAE,IAAI;MAAEC,MAAM,EAAE;IAAK,CAAC,CAAC;IACjC,MAAM/L,MAAM,CAACC,KAAK,CAAC4L,gBAAgB,CAAC,gCAAgC,EAClE;MAAEC,MAAM,EAAE,IAAI;MAAEC,MAAM,EAAE;IAAK,CAAC,CAAC;IAACC,sBAAA;EAAA,SAAAC,WAAA;IAAA,OAAAD,sBAAA,CAAAC,WAAA;EAAA;EAAAD,sBAAA;AAAA;EAAAE,IAAA;EAAAC,KAAA;AAAA","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"0fc312918a528f038bf926cf63fa65a7b91b31ad"}
