var $kgI3C$swchelperslib_class_private_field_initjs = require("@swc/helpers/lib/_class_private_field_init.js");
var $kgI3C$swchelperslib_define_propertyjs = require("@swc/helpers/lib/_define_property.js");

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "CalendarDate", () => $625ad1e1f4c43bc1$export$99faa760c7908e4f);
$parcel$export(module.exports, "CalendarDateTime", () => $625ad1e1f4c43bc1$export$ca871e8dbb80966f);
$parcel$export(module.exports, "Time", () => $625ad1e1f4c43bc1$export$680ea196effce5f);
$parcel$export(module.exports, "ZonedDateTime", () => $625ad1e1f4c43bc1$export$d3b7288e7994edea);
$parcel$export(module.exports, "GregorianCalendar", () => $af14c9812fdceb33$export$80ee6245ec4f29ec);
$parcel$export(module.exports, "JapaneseCalendar", () => $b0ac0602ef646b2c$export$b746ab2b60cdffbf);
$parcel$export(module.exports, "BuddhistCalendar", () => $561c4ef058278b74$export$42d20a78301dee44);
$parcel$export(module.exports, "TaiwanCalendar", () => $9cc5d3577ec40243$export$65e01080afcb0799);
$parcel$export(module.exports, "PersianCalendar", () => $3c060181fc7249ae$export$37fccdbfd14c5939);
$parcel$export(module.exports, "IndianCalendar", () => $5f1dfa5c67609fe6$export$39f31c639fa15726);
$parcel$export(module.exports, "IslamicCivilCalendar", () => $ecb2c4cc8c9aae25$export$2066795aadd37bfc);
$parcel$export(module.exports, "IslamicTabularCalendar", () => $ecb2c4cc8c9aae25$export$37f0887f2f9d22f7);
$parcel$export(module.exports, "IslamicUmalquraCalendar", () => $ecb2c4cc8c9aae25$export$5baab4758c231076);
$parcel$export(module.exports, "HebrewCalendar", () => $0f5324ee3bdd9396$export$ca405048b8fb5af);
$parcel$export(module.exports, "EthiopicCalendar", () => $4db04d1051af0f2f$export$26ba6eab5e20cd7d);
$parcel$export(module.exports, "EthiopicAmeteAlemCalendar", () => $4db04d1051af0f2f$export$d72e0c37005a4914);
$parcel$export(module.exports, "CopticCalendar", () => $4db04d1051af0f2f$export$fe6243cbe1a4b7c1);
$parcel$export(module.exports, "createCalendar", () => $4922c0a5a69da0ba$export$dd0bbc9b26defe37);
$parcel$export(module.exports, "toCalendarDate", () => $4ae0260a69729f1d$export$93522d1a439f3617);
$parcel$export(module.exports, "toCalendarDateTime", () => $4ae0260a69729f1d$export$b21e0b124e224484);
$parcel$export(module.exports, "toTime", () => $4ae0260a69729f1d$export$d33f79e3ffc3dc83);
$parcel$export(module.exports, "toCalendar", () => $4ae0260a69729f1d$export$b4a036af3fc0b032);
$parcel$export(module.exports, "toZoned", () => $4ae0260a69729f1d$export$84c95a83c799e074);
$parcel$export(module.exports, "toTimeZone", () => $4ae0260a69729f1d$export$538b00033cc11c75);
$parcel$export(module.exports, "toLocalTimeZone", () => $4ae0260a69729f1d$export$d9b67bc93c097491);
$parcel$export(module.exports, "isSameDay", () => $1f0f7ebf1ae6c530$export$ea39ec197993aef0);
$parcel$export(module.exports, "isSameMonth", () => $1f0f7ebf1ae6c530$export$a18c89cbd24170ff);
$parcel$export(module.exports, "isSameYear", () => $1f0f7ebf1ae6c530$export$5841f9eb9773f25f);
$parcel$export(module.exports, "isEqualDay", () => $1f0f7ebf1ae6c530$export$91b62ebf2ba703ee);
$parcel$export(module.exports, "isEqualMonth", () => $1f0f7ebf1ae6c530$export$5a8da0c44a3afdf2);
$parcel$export(module.exports, "isEqualYear", () => $1f0f7ebf1ae6c530$export$ea840f5a6dda8147);
$parcel$export(module.exports, "isToday", () => $1f0f7ebf1ae6c530$export$629b0a497aa65267);
$parcel$export(module.exports, "getDayOfWeek", () => $1f0f7ebf1ae6c530$export$2061056d06d7cdf7);
$parcel$export(module.exports, "now", () => $1f0f7ebf1ae6c530$export$461939dd4422153);
$parcel$export(module.exports, "today", () => $1f0f7ebf1ae6c530$export$d0bdf45af03a6ea3);
$parcel$export(module.exports, "getHoursInDay", () => $1f0f7ebf1ae6c530$export$126c91c941de7e);
$parcel$export(module.exports, "getLocalTimeZone", () => $1f0f7ebf1ae6c530$export$aa8b41735afcabd2);
$parcel$export(module.exports, "startOfMonth", () => $1f0f7ebf1ae6c530$export$a5a3b454ada2268e);
$parcel$export(module.exports, "startOfWeek", () => $1f0f7ebf1ae6c530$export$42c81a444fbfb5d4);
$parcel$export(module.exports, "startOfYear", () => $1f0f7ebf1ae6c530$export$f91e89d3d0406102);
$parcel$export(module.exports, "endOfMonth", () => $1f0f7ebf1ae6c530$export$a2258d9c4118825c);
$parcel$export(module.exports, "endOfWeek", () => $1f0f7ebf1ae6c530$export$ef8b6d9133084f4e);
$parcel$export(module.exports, "endOfYear", () => $1f0f7ebf1ae6c530$export$8b7aa55c66d5569e);
$parcel$export(module.exports, "getMinimumMonthInYear", () => $1f0f7ebf1ae6c530$export$5412ac11713b72ad);
$parcel$export(module.exports, "getMinimumDayInMonth", () => $1f0f7ebf1ae6c530$export$b2f4953d301981d5);
$parcel$export(module.exports, "getWeeksInMonth", () => $1f0f7ebf1ae6c530$export$ccc1b2479e7dd654);
$parcel$export(module.exports, "minDate", () => $1f0f7ebf1ae6c530$export$5c333a116e949cdd);
$parcel$export(module.exports, "maxDate", () => $1f0f7ebf1ae6c530$export$a75f2bff57811055);
$parcel$export(module.exports, "isWeekend", () => $1f0f7ebf1ae6c530$export$618d60ea299da42);
$parcel$export(module.exports, "isWeekday", () => $1f0f7ebf1ae6c530$export$ee9d87258e1d19ed);
$parcel$export(module.exports, "parseDate", () => $4c32e2d98e5a5134$export$6b862160d295c8e);
$parcel$export(module.exports, "parseDateTime", () => $4c32e2d98e5a5134$export$588937bcd60ade55);
$parcel$export(module.exports, "parseTime", () => $4c32e2d98e5a5134$export$c9698ec7f05a07e1);
$parcel$export(module.exports, "parseAbsolute", () => $4c32e2d98e5a5134$export$5adfdab05168c219);
$parcel$export(module.exports, "parseAbsoluteToLocal", () => $4c32e2d98e5a5134$export$8e384432362ed0f0);
$parcel$export(module.exports, "parseZonedDateTime", () => $4c32e2d98e5a5134$export$fd7893f06e92a6a4);
$parcel$export(module.exports, "parseDuration", () => $4c32e2d98e5a5134$export$ecae829bb3747ea6);
$parcel$export(module.exports, "DateFormatter", () => $8f23a04ae90a588b$export$ad991b66133851cf);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from the TC39 Temporal proposal.
// Original licensing can be found in the NOTICE file in the root directory of this source tree.


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from ICU.
// Original licensing can be found in the NOTICE file in the root directory of this source tree.


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $a5090d6430502238$export$842a2cf37af977e1(amount, numerator) {
    return amount - numerator * Math.floor(amount / numerator);
}
function $a5090d6430502238$export$784d13d8ee351f07(date) {
    if (date.era) return new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)(date.calendar, date.era, date.year, date.month, date.day);
    else return new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)(date.calendar, date.year, date.month, date.day);
}
function $a5090d6430502238$export$27fa0172ae2644b3(date) {
    if (date.era) return new (0, $625ad1e1f4c43bc1$export$ca871e8dbb80966f)(date.calendar, date.era, date.year, date.month, date.day, date.hour, date.minute, date.second, date.millisecond);
    else return new (0, $625ad1e1f4c43bc1$export$ca871e8dbb80966f)(date.calendar, date.year, date.month, date.day, date.hour, date.minute, date.second);
}


const $af14c9812fdceb33$var$EPOCH = 1721426; // 001/01/03 Julian C.E.
function $af14c9812fdceb33$export$f297eb839006d339(era, year, month, day) {
    year = $af14c9812fdceb33$export$c36e0ecb2d4fa69d(era, year);
    let y1 = year - 1;
    let monthOffset = -2;
    if (month <= 2) monthOffset = 0;
    else if ($af14c9812fdceb33$export$553d7fa8e3805fc0(year)) monthOffset = -1;
    return $af14c9812fdceb33$var$EPOCH - 1 + 365 * y1 + Math.floor(y1 / 4) - Math.floor(y1 / 100) + Math.floor(y1 / 400) + Math.floor((367 * month - 362) / 12 + monthOffset + day);
}
function $af14c9812fdceb33$export$553d7fa8e3805fc0(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function $af14c9812fdceb33$export$c36e0ecb2d4fa69d(era, year) {
    return era === "BC" ? 1 - year : year;
}
function $af14c9812fdceb33$export$4475b7e617eb123c(year) {
    let era = "AD";
    if (year <= 0) {
        era = "BC";
        year = 1 - year;
    }
    return [
        era,
        year
    ];
}
const $af14c9812fdceb33$var$daysInMonth = {
    standard: [
        31,
        28,
        31,
        30,
        31,
        30,
        31,
        31,
        30,
        31,
        30,
        31
    ],
    leapyear: [
        31,
        29,
        31,
        30,
        31,
        30,
        31,
        31,
        30,
        31,
        30,
        31
    ]
};
class $af14c9812fdceb33$export$80ee6245ec4f29ec {
    fromJulianDay(jd) {
        let jd0 = jd;
        let depoch = jd0 - $af14c9812fdceb33$var$EPOCH;
        let quadricent = Math.floor(depoch / 146097);
        let dqc = (0, $a5090d6430502238$export$842a2cf37af977e1)(depoch, 146097);
        let cent = Math.floor(dqc / 36524);
        let dcent = (0, $a5090d6430502238$export$842a2cf37af977e1)(dqc, 36524);
        let quad = Math.floor(dcent / 1461);
        let dquad = (0, $a5090d6430502238$export$842a2cf37af977e1)(dcent, 1461);
        let yindex = Math.floor(dquad / 365);
        let extendedYear = quadricent * 400 + cent * 100 + quad * 4 + yindex + (cent !== 4 && yindex !== 4 ? 1 : 0);
        let [era, year] = $af14c9812fdceb33$export$4475b7e617eb123c(extendedYear);
        let yearDay = jd0 - $af14c9812fdceb33$export$f297eb839006d339(era, year, 1, 1);
        let leapAdj = 2;
        if (jd0 < $af14c9812fdceb33$export$f297eb839006d339(era, year, 3, 1)) leapAdj = 0;
        else if ($af14c9812fdceb33$export$553d7fa8e3805fc0(year)) leapAdj = 1;
        let month = Math.floor(((yearDay + leapAdj) * 12 + 373) / 367);
        let day = jd0 - $af14c9812fdceb33$export$f297eb839006d339(era, year, month, 1) + 1;
        return new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)(era, year, month, day);
    }
    toJulianDay(date) {
        return $af14c9812fdceb33$export$f297eb839006d339(date.era, date.year, date.month, date.day);
    }
    getDaysInMonth(date) {
        return $af14c9812fdceb33$var$daysInMonth[$af14c9812fdceb33$export$553d7fa8e3805fc0(date.year) ? "leapyear" : "standard"][date.month - 1];
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getMonthsInYear(date) {
        return 12;
    }
    getDaysInYear(date) {
        return $af14c9812fdceb33$export$553d7fa8e3805fc0(date.year) ? 366 : 365;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getYearsInEra(date) {
        return 9999;
    }
    getEras() {
        return [
            "BC",
            "AD"
        ];
    }
    isInverseEra(date) {
        return date.era === "BC";
    }
    balanceDate(date) {
        if (date.year <= 0) {
            date.era = date.era === "BC" ? "AD" : "BC";
            date.year = 1 - date.year;
        }
    }
    constructor(){
        (0, ($parcel$interopDefault($kgI3C$swchelperslib_define_propertyjs)))(this, "identifier", "gregory");
    }
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Data from https://github.com/unicode-cldr/cldr-core/blob/master/supplemental/weekData.json
// Locales starting on Sunday have been removed for compression.
const $4d88eff242b38a9e$export$7a5acbd77d414bd9 = {
    "001": 1,
    AD: 1,
    AE: 6,
    AF: 6,
    AI: 1,
    AL: 1,
    AM: 1,
    AN: 1,
    AT: 1,
    AX: 1,
    AZ: 1,
    BA: 1,
    BE: 1,
    BG: 1,
    BH: 6,
    BM: 1,
    BN: 1,
    BY: 1,
    CH: 1,
    CL: 1,
    CM: 1,
    CR: 1,
    CY: 1,
    CZ: 1,
    DE: 1,
    DJ: 6,
    DK: 1,
    DZ: 6,
    EC: 1,
    EE: 1,
    EG: 6,
    ES: 1,
    FI: 1,
    FJ: 1,
    FO: 1,
    FR: 1,
    GB: 1,
    GE: 1,
    GF: 1,
    GP: 1,
    GR: 1,
    HR: 1,
    HU: 1,
    IE: 1,
    IQ: 6,
    IR: 6,
    IS: 1,
    IT: 1,
    JO: 6,
    KG: 1,
    KW: 6,
    KZ: 1,
    LB: 1,
    LI: 1,
    LK: 1,
    LT: 1,
    LU: 1,
    LV: 1,
    LY: 6,
    MC: 1,
    MD: 1,
    ME: 1,
    MK: 1,
    MN: 1,
    MQ: 1,
    MV: 5,
    MY: 1,
    NL: 1,
    NO: 1,
    NZ: 1,
    OM: 6,
    PL: 1,
    QA: 6,
    RE: 1,
    RO: 1,
    RS: 1,
    RU: 1,
    SD: 6,
    SE: 1,
    SI: 1,
    SK: 1,
    SM: 1,
    SY: 6,
    TJ: 1,
    TM: 1,
    TR: 1,
    UA: 1,
    UY: 1,
    UZ: 1,
    VA: 1,
    VN: 1,
    XK: 1
};


function $1f0f7ebf1ae6c530$export$ea39ec197993aef0(a, b) {
    b = (0, $4ae0260a69729f1d$export$b4a036af3fc0b032)(b, a.calendar);
    return a.era === b.era && a.year === b.year && a.month === b.month && a.day === b.day;
}
function $1f0f7ebf1ae6c530$export$a18c89cbd24170ff(a, b) {
    b = (0, $4ae0260a69729f1d$export$b4a036af3fc0b032)(b, a.calendar);
    // In the Japanese calendar, months can span multiple eras/years, so only compare the first of the month.
    a = $1f0f7ebf1ae6c530$export$a5a3b454ada2268e(a);
    b = $1f0f7ebf1ae6c530$export$a5a3b454ada2268e(b);
    return a.era === b.era && a.year === b.year && a.month === b.month;
}
function $1f0f7ebf1ae6c530$export$5841f9eb9773f25f(a, b) {
    b = (0, $4ae0260a69729f1d$export$b4a036af3fc0b032)(b, a.calendar);
    a = $1f0f7ebf1ae6c530$export$f91e89d3d0406102(a);
    b = $1f0f7ebf1ae6c530$export$f91e89d3d0406102(b);
    return a.era === b.era && a.year === b.year;
}
function $1f0f7ebf1ae6c530$export$91b62ebf2ba703ee(a, b) {
    return a.calendar.identifier === b.calendar.identifier && a.era === b.era && a.year === b.year && a.month === b.month && a.day === b.day;
}
function $1f0f7ebf1ae6c530$export$5a8da0c44a3afdf2(a, b) {
    a = $1f0f7ebf1ae6c530$export$a5a3b454ada2268e(a);
    b = $1f0f7ebf1ae6c530$export$a5a3b454ada2268e(b);
    return a.calendar.identifier === b.calendar.identifier && a.era === b.era && a.year === b.year && a.month === b.month;
}
function $1f0f7ebf1ae6c530$export$ea840f5a6dda8147(a, b) {
    a = $1f0f7ebf1ae6c530$export$f91e89d3d0406102(a);
    b = $1f0f7ebf1ae6c530$export$f91e89d3d0406102(b);
    return a.calendar.identifier === b.calendar.identifier && a.era === b.era && a.year === b.year;
}
function $1f0f7ebf1ae6c530$export$629b0a497aa65267(date, timeZone) {
    return $1f0f7ebf1ae6c530$export$ea39ec197993aef0(date, $1f0f7ebf1ae6c530$export$d0bdf45af03a6ea3(timeZone));
}
function $1f0f7ebf1ae6c530$export$2061056d06d7cdf7(date, locale) {
    let julian = date.calendar.toJulianDay(date);
    // If julian is negative, then julian % 7 will be negative, so we adjust
    // accordingly.  Julian day 0 is Monday.
    let dayOfWeek = Math.ceil(julian + 1 - $1f0f7ebf1ae6c530$var$getWeekStart(locale)) % 7;
    if (dayOfWeek < 0) dayOfWeek += 7;
    return dayOfWeek;
}
function $1f0f7ebf1ae6c530$export$461939dd4422153(timeZone) {
    return (0, $4ae0260a69729f1d$export$1b96692a1ba042ac)(Date.now(), timeZone);
}
function $1f0f7ebf1ae6c530$export$d0bdf45af03a6ea3(timeZone) {
    return (0, $4ae0260a69729f1d$export$93522d1a439f3617)($1f0f7ebf1ae6c530$export$461939dd4422153(timeZone));
}
function $1f0f7ebf1ae6c530$export$68781ddf31c0090f(a, b) {
    return a.calendar.toJulianDay(a) - b.calendar.toJulianDay(b);
}
function $1f0f7ebf1ae6c530$export$c19a80a9721b80f6(a, b) {
    return $1f0f7ebf1ae6c530$var$timeToMs(a) - $1f0f7ebf1ae6c530$var$timeToMs(b);
}
function $1f0f7ebf1ae6c530$var$timeToMs(a) {
    return a.hour * 3600000 + a.minute * 60000 + a.second * 1000 + a.millisecond;
}
function $1f0f7ebf1ae6c530$export$126c91c941de7e(a, timeZone) {
    let ms = (0, $4ae0260a69729f1d$export$5107c82f94518f5c)(a, timeZone);
    let tomorrow = a.add({
        days: 1
    });
    let tomorrowMs = (0, $4ae0260a69729f1d$export$5107c82f94518f5c)(tomorrow, timeZone);
    return (tomorrowMs - ms) / 3600000;
}
let $1f0f7ebf1ae6c530$var$localTimeZone = null;
function $1f0f7ebf1ae6c530$export$aa8b41735afcabd2() {
    // TODO: invalidate this somehow?
    if ($1f0f7ebf1ae6c530$var$localTimeZone == null) $1f0f7ebf1ae6c530$var$localTimeZone = new Intl.DateTimeFormat().resolvedOptions().timeZone;
    return $1f0f7ebf1ae6c530$var$localTimeZone;
}
function $1f0f7ebf1ae6c530$export$a5a3b454ada2268e(date) {
    // Use `subtract` instead of `set` so we don't get constrained in an era.
    return date.subtract({
        days: date.day - 1
    });
}
function $1f0f7ebf1ae6c530$export$a2258d9c4118825c(date) {
    return date.add({
        days: date.calendar.getDaysInMonth(date) - date.day
    });
}
function $1f0f7ebf1ae6c530$export$f91e89d3d0406102(date) {
    return $1f0f7ebf1ae6c530$export$a5a3b454ada2268e(date.subtract({
        months: date.month - 1
    }));
}
function $1f0f7ebf1ae6c530$export$8b7aa55c66d5569e(date) {
    return $1f0f7ebf1ae6c530$export$a2258d9c4118825c(date.add({
        months: date.calendar.getMonthsInYear(date) - date.month
    }));
}
function $1f0f7ebf1ae6c530$export$5412ac11713b72ad(date) {
    if (date.calendar.getMinimumMonthInYear) return date.calendar.getMinimumMonthInYear(date);
    return 1;
}
function $1f0f7ebf1ae6c530$export$b2f4953d301981d5(date) {
    if (date.calendar.getMinimumDayInMonth) return date.calendar.getMinimumDayInMonth(date);
    return 1;
}
function $1f0f7ebf1ae6c530$export$42c81a444fbfb5d4(date, locale) {
    let dayOfWeek = $1f0f7ebf1ae6c530$export$2061056d06d7cdf7(date, locale);
    return date.subtract({
        days: dayOfWeek
    });
}
function $1f0f7ebf1ae6c530$export$ef8b6d9133084f4e(date, locale) {
    return $1f0f7ebf1ae6c530$export$42c81a444fbfb5d4(date, locale).add({
        days: 6
    });
}
const $1f0f7ebf1ae6c530$var$cachedRegions = new Map();
function $1f0f7ebf1ae6c530$var$getRegion(locale) {
    // If the Intl.Locale API is available, use it to get the region for the locale.
    // @ts-ignore
    if (Intl.Locale) {
        // Constructing an Intl.Locale is expensive, so cache the result.
        let region = $1f0f7ebf1ae6c530$var$cachedRegions.get(locale);
        if (!region) {
            // @ts-ignore
            region = new Intl.Locale(locale).maximize().region;
            $1f0f7ebf1ae6c530$var$cachedRegions.set(locale, region);
        }
        return region;
    }
    // If not, just try splitting the string.
    // If the second part of the locale string is 'u',
    // then this is a unicode extension, so ignore it.
    // Otherwise, it should be the region.
    let part = locale.split("-")[1];
    return part === "u" ? null : part;
}
function $1f0f7ebf1ae6c530$var$getWeekStart(locale) {
    // TODO: use Intl.Locale for this once browsers support the weekInfo property
    // https://github.com/tc39/proposal-intl-locale-info
    let region = $1f0f7ebf1ae6c530$var$getRegion(locale);
    return (0, $4d88eff242b38a9e$export$7a5acbd77d414bd9)[region] || 0;
}
function $1f0f7ebf1ae6c530$export$ccc1b2479e7dd654(date, locale) {
    let days = date.calendar.getDaysInMonth(date);
    return Math.ceil(($1f0f7ebf1ae6c530$export$2061056d06d7cdf7($1f0f7ebf1ae6c530$export$a5a3b454ada2268e(date), locale) + days) / 7);
}
function $1f0f7ebf1ae6c530$export$5c333a116e949cdd(a, b) {
    if (a && b) return a.compare(b) <= 0 ? a : b;
    return a || b;
}
function $1f0f7ebf1ae6c530$export$a75f2bff57811055(a, b) {
    if (a && b) return a.compare(b) >= 0 ? a : b;
    return a || b;
}
const $1f0f7ebf1ae6c530$var$WEEKEND_DATA = {
    AF: [
        4,
        5
    ],
    AE: [
        5,
        6
    ],
    BH: [
        5,
        6
    ],
    DZ: [
        5,
        6
    ],
    EG: [
        5,
        6
    ],
    IL: [
        5,
        6
    ],
    IQ: [
        5,
        6
    ],
    IR: [
        5,
        5
    ],
    JO: [
        5,
        6
    ],
    KW: [
        5,
        6
    ],
    LY: [
        5,
        6
    ],
    OM: [
        5,
        6
    ],
    QA: [
        5,
        6
    ],
    SA: [
        5,
        6
    ],
    SD: [
        5,
        6
    ],
    SY: [
        5,
        6
    ],
    YE: [
        5,
        6
    ]
};
function $1f0f7ebf1ae6c530$export$618d60ea299da42(date, locale) {
    let julian = date.calendar.toJulianDay(date);
    // If julian is negative, then julian % 7 will be negative, so we adjust
    // accordingly.  Julian day 0 is Monday.
    let dayOfWeek = Math.ceil(julian + 1) % 7;
    if (dayOfWeek < 0) dayOfWeek += 7;
    let region = $1f0f7ebf1ae6c530$var$getRegion(locale);
    // Use Intl.Locale for this once weekInfo is supported.
    // https://github.com/tc39/proposal-intl-locale-info
    let [start, end] = $1f0f7ebf1ae6c530$var$WEEKEND_DATA[region] || [
        6,
        0
    ];
    return dayOfWeek === start || dayOfWeek === end;
}
function $1f0f7ebf1ae6c530$export$ee9d87258e1d19ed(date, locale) {
    return !$1f0f7ebf1ae6c530$export$618d60ea299da42(date, locale);
}


function $4ae0260a69729f1d$export$bd4fb2bc8bb06fb(date) {
    date = $4ae0260a69729f1d$export$b4a036af3fc0b032(date, new (0, $af14c9812fdceb33$export$80ee6245ec4f29ec)());
    let year = (0, $af14c9812fdceb33$export$c36e0ecb2d4fa69d)(date.era, date.year);
    return $4ae0260a69729f1d$var$epochFromParts(year, date.month, date.day, date.hour, date.minute, date.second, date.millisecond);
}
function $4ae0260a69729f1d$var$epochFromParts(year, month, day, hour, minute, second, millisecond) {
    // Note: Date.UTC() interprets one and two-digit years as being in the
    // 20th century, so don't use it
    let date = new Date();
    date.setUTCHours(hour, minute, second, millisecond);
    date.setUTCFullYear(year, month - 1, day);
    return date.getTime();
}
function $4ae0260a69729f1d$export$59c99f3515d3493f(ms, timeZone) {
    // Fast path for UTC.
    if (timeZone === "UTC") return 0;
    // Fast path: for local timezone after 1970, use native Date.
    if (ms > 0 && timeZone === (0, $1f0f7ebf1ae6c530$export$aa8b41735afcabd2)()) return new Date(ms).getTimezoneOffset() * -60000;
    let { year: year , month: month , day: day , hour: hour , minute: minute , second: second  } = $4ae0260a69729f1d$var$getTimeZoneParts(ms, timeZone);
    let utc = $4ae0260a69729f1d$var$epochFromParts(year, month, day, hour, minute, second, 0);
    return utc - Math.floor(ms / 1000) * 1000;
}
const $4ae0260a69729f1d$var$formattersByTimeZone = new Map();
function $4ae0260a69729f1d$var$getTimeZoneParts(ms, timeZone) {
    let formatter = $4ae0260a69729f1d$var$formattersByTimeZone.get(timeZone);
    if (!formatter) {
        formatter = new Intl.DateTimeFormat("en-US", {
            timeZone: timeZone,
            hour12: false,
            era: "short",
            year: "numeric",
            month: "numeric",
            day: "numeric",
            hour: "numeric",
            minute: "numeric",
            second: "numeric"
        });
        $4ae0260a69729f1d$var$formattersByTimeZone.set(timeZone, formatter);
    }
    let parts = formatter.formatToParts(new Date(ms));
    let namedParts = {};
    for (let part of parts)if (part.type !== "literal") namedParts[part.type] = part.value;
    return {
        // Firefox returns B instead of BC... https://bugzilla.mozilla.org/show_bug.cgi?id=1752253
        year: namedParts.era === "BC" || namedParts.era === "B" ? -namedParts.year + 1 : +namedParts.year,
        month: +namedParts.month,
        day: +namedParts.day,
        hour: namedParts.hour === "24" ? 0 : +namedParts.hour,
        minute: +namedParts.minute,
        second: +namedParts.second
    };
}
const $4ae0260a69729f1d$var$DAYMILLIS = 86400000;
function $4ae0260a69729f1d$export$136f38efe7caf549(date, timeZone) {
    let ms = $4ae0260a69729f1d$export$bd4fb2bc8bb06fb(date);
    let earlier = ms - $4ae0260a69729f1d$export$59c99f3515d3493f(ms - $4ae0260a69729f1d$var$DAYMILLIS, timeZone);
    let later = ms - $4ae0260a69729f1d$export$59c99f3515d3493f(ms + $4ae0260a69729f1d$var$DAYMILLIS, timeZone);
    return $4ae0260a69729f1d$var$getValidWallTimes(date, timeZone, earlier, later);
}
function $4ae0260a69729f1d$var$getValidWallTimes(date, timeZone, earlier, later) {
    let found = earlier === later ? [
        earlier
    ] : [
        earlier,
        later
    ];
    return found.filter((absolute)=>$4ae0260a69729f1d$var$isValidWallTime(date, timeZone, absolute));
}
function $4ae0260a69729f1d$var$isValidWallTime(date, timeZone, absolute) {
    let parts = $4ae0260a69729f1d$var$getTimeZoneParts(absolute, timeZone);
    return date.year === parts.year && date.month === parts.month && date.day === parts.day && date.hour === parts.hour && date.minute === parts.minute && date.second === parts.second;
}
function $4ae0260a69729f1d$export$5107c82f94518f5c(date, timeZone, disambiguation = "compatible") {
    let dateTime = $4ae0260a69729f1d$export$b21e0b124e224484(date);
    // Fast path: if the time zone is UTC, use native Date.
    if (timeZone === "UTC") return $4ae0260a69729f1d$export$bd4fb2bc8bb06fb(dateTime);
    // Fast path: if the time zone is the local timezone and disambiguation is compatible, use native Date.
    if (timeZone === (0, $1f0f7ebf1ae6c530$export$aa8b41735afcabd2)() && disambiguation === "compatible") {
        dateTime = $4ae0260a69729f1d$export$b4a036af3fc0b032(dateTime, new (0, $af14c9812fdceb33$export$80ee6245ec4f29ec)());
        // Don't use Date constructor here because two-digit years are interpreted in the 20th century.
        let date1 = new Date();
        let year = (0, $af14c9812fdceb33$export$c36e0ecb2d4fa69d)(dateTime.era, dateTime.year);
        date1.setFullYear(year, dateTime.month - 1, dateTime.day);
        date1.setHours(dateTime.hour, dateTime.minute, dateTime.second, dateTime.millisecond);
        return date1.getTime();
    }
    let ms = $4ae0260a69729f1d$export$bd4fb2bc8bb06fb(dateTime);
    let offsetBefore = $4ae0260a69729f1d$export$59c99f3515d3493f(ms - $4ae0260a69729f1d$var$DAYMILLIS, timeZone);
    let offsetAfter = $4ae0260a69729f1d$export$59c99f3515d3493f(ms + $4ae0260a69729f1d$var$DAYMILLIS, timeZone);
    let valid = $4ae0260a69729f1d$var$getValidWallTimes(dateTime, timeZone, ms - offsetBefore, ms - offsetAfter);
    if (valid.length === 1) return valid[0];
    if (valid.length > 1) switch(disambiguation){
        // 'compatible' means 'earlier' for "fall back" transitions
        case "compatible":
        case "earlier":
            return valid[0];
        case "later":
            return valid[valid.length - 1];
        case "reject":
            throw new RangeError("Multiple possible absolute times found");
    }
    switch(disambiguation){
        case "earlier":
            return Math.min(ms - offsetBefore, ms - offsetAfter);
        // 'compatible' means 'later' for "spring forward" transitions
        case "compatible":
        case "later":
            return Math.max(ms - offsetBefore, ms - offsetAfter);
        case "reject":
            throw new RangeError("No such absolute time found");
    }
}
function $4ae0260a69729f1d$export$e67a095c620b86fe(dateTime, timeZone, disambiguation = "compatible") {
    return new Date($4ae0260a69729f1d$export$5107c82f94518f5c(dateTime, timeZone, disambiguation));
}
function $4ae0260a69729f1d$export$1b96692a1ba042ac(ms, timeZone) {
    let offset = $4ae0260a69729f1d$export$59c99f3515d3493f(ms, timeZone);
    let date = new Date(ms + offset);
    let year = date.getUTCFullYear();
    let month = date.getUTCMonth() + 1;
    let day = date.getUTCDate();
    let hour = date.getUTCHours();
    let minute = date.getUTCMinutes();
    let second = date.getUTCSeconds();
    let millisecond = date.getUTCMilliseconds();
    return new (0, $625ad1e1f4c43bc1$export$d3b7288e7994edea)(year, month, day, timeZone, offset, hour, minute, second, millisecond);
}
function $4ae0260a69729f1d$export$e57ff100d91bd4b9(date, timeZone) {
    return $4ae0260a69729f1d$export$1b96692a1ba042ac(date.getTime(), timeZone);
}
function $4ae0260a69729f1d$export$d7f92bcd3596b086(date) {
    return $4ae0260a69729f1d$export$e57ff100d91bd4b9(date, (0, $1f0f7ebf1ae6c530$export$aa8b41735afcabd2)());
}
function $4ae0260a69729f1d$export$93522d1a439f3617(dateTime) {
    return new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)(dateTime.calendar, dateTime.era, dateTime.year, dateTime.month, dateTime.day);
}
function $4ae0260a69729f1d$export$6f4d78149f3f53ac(date) {
    return {
        era: date.era,
        year: date.year,
        month: date.month,
        day: date.day
    };
}
function $4ae0260a69729f1d$export$4d0393e732857be5(date) {
    return {
        hour: date.hour,
        minute: date.minute,
        second: date.second,
        millisecond: date.millisecond
    };
}
function $4ae0260a69729f1d$export$b21e0b124e224484(date, time) {
    let hour = 0, minute = 0, second = 0, millisecond = 0;
    if ("timeZone" in date) ({ hour: hour , minute: minute , second: second , millisecond: millisecond  } = date);
    else if ("hour" in date && !time) return date;
    if (time) ({ hour: hour , minute: minute , second: second , millisecond: millisecond  } = time);
    return new (0, $625ad1e1f4c43bc1$export$ca871e8dbb80966f)(date.calendar, date.era, date.year, date.month, date.day, hour, minute, second, millisecond);
}
function $4ae0260a69729f1d$export$d33f79e3ffc3dc83(dateTime) {
    return new (0, $625ad1e1f4c43bc1$export$680ea196effce5f)(dateTime.hour, dateTime.minute, dateTime.second, dateTime.millisecond);
}
function $4ae0260a69729f1d$export$b4a036af3fc0b032(date, calendar) {
    if (date.calendar.identifier === calendar.identifier) return date;
    let calendarDate = calendar.fromJulianDay(date.calendar.toJulianDay(date));
    let copy = date.copy();
    copy.calendar = calendar;
    copy.era = calendarDate.era;
    copy.year = calendarDate.year;
    copy.month = calendarDate.month;
    copy.day = calendarDate.day;
    (0, $5c0571aa5b6fb5da$export$c4e2ecac49351ef2)(copy);
    return copy;
}
function $4ae0260a69729f1d$export$84c95a83c799e074(date, timeZone, disambiguation) {
    if (date instanceof (0, $625ad1e1f4c43bc1$export$d3b7288e7994edea)) {
        if (date.timeZone === timeZone) return date;
        return $4ae0260a69729f1d$export$538b00033cc11c75(date, timeZone);
    }
    let ms = $4ae0260a69729f1d$export$5107c82f94518f5c(date, timeZone, disambiguation);
    return $4ae0260a69729f1d$export$1b96692a1ba042ac(ms, timeZone);
}
function $4ae0260a69729f1d$export$83aac07b4c37b25(date) {
    let ms = $4ae0260a69729f1d$export$bd4fb2bc8bb06fb(date) - date.offset;
    return new Date(ms);
}
function $4ae0260a69729f1d$export$538b00033cc11c75(date, timeZone) {
    let ms = $4ae0260a69729f1d$export$bd4fb2bc8bb06fb(date) - date.offset;
    return $4ae0260a69729f1d$export$b4a036af3fc0b032($4ae0260a69729f1d$export$1b96692a1ba042ac(ms, timeZone), date.calendar);
}
function $4ae0260a69729f1d$export$d9b67bc93c097491(date) {
    return $4ae0260a69729f1d$export$538b00033cc11c75(date, (0, $1f0f7ebf1ae6c530$export$aa8b41735afcabd2)());
}



const $5c0571aa5b6fb5da$var$ONE_HOUR = 3600000;
function $5c0571aa5b6fb5da$export$e16d8520af44a096(date, duration) {
    let mutableDate = date.copy();
    let days = "hour" in mutableDate ? $5c0571aa5b6fb5da$var$addTimeFields(mutableDate, duration) : 0;
    $5c0571aa5b6fb5da$var$addYears(mutableDate, duration.years || 0);
    if (mutableDate.calendar.balanceYearMonth) mutableDate.calendar.balanceYearMonth(mutableDate, date);
    mutableDate.month += duration.months || 0;
    $5c0571aa5b6fb5da$var$balanceYearMonth(mutableDate);
    $5c0571aa5b6fb5da$var$constrainMonthDay(mutableDate);
    mutableDate.day += (duration.weeks || 0) * 7;
    mutableDate.day += duration.days || 0;
    mutableDate.day += days;
    $5c0571aa5b6fb5da$var$balanceDay(mutableDate);
    if (mutableDate.calendar.balanceDate) mutableDate.calendar.balanceDate(mutableDate);
    // Constrain in case adding ended up with a date outside the valid range for the calendar system.
    // The behavior here is slightly different than when constraining in the `set` function in that
    // we adjust smaller fields to their minimum/maximum values rather than constraining each field
    // individually. This matches the general behavior of `add` vs `set` regarding how fields are balanced.
    if (mutableDate.year < 1) {
        mutableDate.year = 1;
        mutableDate.month = 1;
        mutableDate.day = 1;
    }
    let maxYear = mutableDate.calendar.getYearsInEra(mutableDate);
    if (mutableDate.year > maxYear) {
        var _mutableDate_calendar, _mutableDate_calendar_isInverseEra;
        let isInverseEra = (_mutableDate_calendar_isInverseEra = (_mutableDate_calendar = mutableDate.calendar).isInverseEra) === null || _mutableDate_calendar_isInverseEra === void 0 ? void 0 : _mutableDate_calendar_isInverseEra.call(_mutableDate_calendar, mutableDate);
        mutableDate.year = maxYear;
        mutableDate.month = isInverseEra ? 1 : mutableDate.calendar.getMonthsInYear(mutableDate);
        mutableDate.day = isInverseEra ? 1 : mutableDate.calendar.getDaysInMonth(mutableDate);
    }
    if (mutableDate.month < 1) {
        mutableDate.month = 1;
        mutableDate.day = 1;
    }
    let maxMonth = mutableDate.calendar.getMonthsInYear(mutableDate);
    if (mutableDate.month > maxMonth) {
        mutableDate.month = maxMonth;
        mutableDate.day = mutableDate.calendar.getDaysInMonth(mutableDate);
    }
    mutableDate.day = Math.max(1, Math.min(mutableDate.calendar.getDaysInMonth(mutableDate), mutableDate.day));
    return mutableDate;
}
function $5c0571aa5b6fb5da$var$addYears(date, years) {
    var _date_calendar, _date_calendar_isInverseEra;
    if ((_date_calendar_isInverseEra = (_date_calendar = date.calendar).isInverseEra) === null || _date_calendar_isInverseEra === void 0 ? void 0 : _date_calendar_isInverseEra.call(_date_calendar, date)) years = -years;
    date.year += years;
}
function $5c0571aa5b6fb5da$var$balanceYearMonth(date) {
    while(date.month < 1){
        $5c0571aa5b6fb5da$var$addYears(date, -1);
        date.month += date.calendar.getMonthsInYear(date);
    }
    let monthsInYear = 0;
    while(date.month > (monthsInYear = date.calendar.getMonthsInYear(date))){
        date.month -= monthsInYear;
        $5c0571aa5b6fb5da$var$addYears(date, 1);
    }
}
function $5c0571aa5b6fb5da$var$balanceDay(date) {
    while(date.day < 1){
        date.month--;
        $5c0571aa5b6fb5da$var$balanceYearMonth(date);
        date.day += date.calendar.getDaysInMonth(date);
    }
    while(date.day > date.calendar.getDaysInMonth(date)){
        date.day -= date.calendar.getDaysInMonth(date);
        date.month++;
        $5c0571aa5b6fb5da$var$balanceYearMonth(date);
    }
}
function $5c0571aa5b6fb5da$var$constrainMonthDay(date) {
    date.month = Math.max(1, Math.min(date.calendar.getMonthsInYear(date), date.month));
    date.day = Math.max(1, Math.min(date.calendar.getDaysInMonth(date), date.day));
}
function $5c0571aa5b6fb5da$export$c4e2ecac49351ef2(date) {
    if (date.calendar.constrainDate) date.calendar.constrainDate(date);
    date.year = Math.max(1, Math.min(date.calendar.getYearsInEra(date), date.year));
    $5c0571aa5b6fb5da$var$constrainMonthDay(date);
}
function $5c0571aa5b6fb5da$export$3e2544e88a25bff8(duration) {
    let inverseDuration = {};
    for(let key in duration)if (typeof duration[key] === "number") inverseDuration[key] = -duration[key];
    return inverseDuration;
}
function $5c0571aa5b6fb5da$export$4e2d2ead65e5f7e3(date, duration) {
    return $5c0571aa5b6fb5da$export$e16d8520af44a096(date, $5c0571aa5b6fb5da$export$3e2544e88a25bff8(duration));
}
function $5c0571aa5b6fb5da$export$adaa4cf7ef1b65be(date, fields) {
    let mutableDate = date.copy();
    if (fields.era != null) mutableDate.era = fields.era;
    if (fields.year != null) mutableDate.year = fields.year;
    if (fields.month != null) mutableDate.month = fields.month;
    if (fields.day != null) mutableDate.day = fields.day;
    $5c0571aa5b6fb5da$export$c4e2ecac49351ef2(mutableDate);
    return mutableDate;
}
function $5c0571aa5b6fb5da$export$e5d5e1c1822b6e56(value, fields) {
    let mutableValue = value.copy();
    if (fields.hour != null) mutableValue.hour = fields.hour;
    if (fields.minute != null) mutableValue.minute = fields.minute;
    if (fields.second != null) mutableValue.second = fields.second;
    if (fields.millisecond != null) mutableValue.millisecond = fields.millisecond;
    $5c0571aa5b6fb5da$export$7555de1e070510cb(mutableValue);
    return mutableValue;
}
function $5c0571aa5b6fb5da$var$balanceTime(time) {
    time.second += Math.floor(time.millisecond / 1000);
    time.millisecond = $5c0571aa5b6fb5da$var$nonNegativeMod(time.millisecond, 1000);
    time.minute += Math.floor(time.second / 60);
    time.second = $5c0571aa5b6fb5da$var$nonNegativeMod(time.second, 60);
    time.hour += Math.floor(time.minute / 60);
    time.minute = $5c0571aa5b6fb5da$var$nonNegativeMod(time.minute, 60);
    let days = Math.floor(time.hour / 24);
    time.hour = $5c0571aa5b6fb5da$var$nonNegativeMod(time.hour, 24);
    return days;
}
function $5c0571aa5b6fb5da$export$7555de1e070510cb(time) {
    time.millisecond = Math.max(0, Math.min(time.millisecond, 1000));
    time.second = Math.max(0, Math.min(time.second, 59));
    time.minute = Math.max(0, Math.min(time.minute, 59));
    time.hour = Math.max(0, Math.min(time.hour, 23));
}
function $5c0571aa5b6fb5da$var$nonNegativeMod(a, b) {
    let result = a % b;
    if (result < 0) result += b;
    return result;
}
function $5c0571aa5b6fb5da$var$addTimeFields(time, duration) {
    time.hour += duration.hours || 0;
    time.minute += duration.minutes || 0;
    time.second += duration.seconds || 0;
    time.millisecond += duration.milliseconds || 0;
    return $5c0571aa5b6fb5da$var$balanceTime(time);
}
function $5c0571aa5b6fb5da$export$7ed87b6bc2506470(time, duration) {
    let res = time.copy();
    $5c0571aa5b6fb5da$var$addTimeFields(res, duration);
    return res;
}
function $5c0571aa5b6fb5da$export$fe34d3a381cd7501(time, duration) {
    return $5c0571aa5b6fb5da$export$7ed87b6bc2506470(time, $5c0571aa5b6fb5da$export$3e2544e88a25bff8(duration));
}
function $5c0571aa5b6fb5da$export$d52ced6badfb9a4c(value, field, amount, options) {
    let mutable = value.copy();
    switch(field){
        case "era":
            {
                let eras = value.calendar.getEras();
                let eraIndex = eras.indexOf(value.era);
                if (eraIndex < 0) throw new Error("Invalid era: " + value.era);
                eraIndex = $5c0571aa5b6fb5da$var$cycleValue(eraIndex, amount, 0, eras.length - 1, options === null || options === void 0 ? void 0 : options.round);
                mutable.era = eras[eraIndex];
                // Constrain the year and other fields within the era, so the era doesn't change when we balance below.
                $5c0571aa5b6fb5da$export$c4e2ecac49351ef2(mutable);
                break;
            }
        case "year":
            var _mutable_calendar, _mutable_calendar_isInverseEra;
            if ((_mutable_calendar_isInverseEra = (_mutable_calendar = mutable.calendar).isInverseEra) === null || _mutable_calendar_isInverseEra === void 0 ? void 0 : _mutable_calendar_isInverseEra.call(_mutable_calendar, mutable)) amount = -amount;
            // The year field should not cycle within the era as that can cause weird behavior affecting other fields.
            // We need to also allow values < 1 so that decrementing goes to the previous era. If we get -Infinity back
            // we know we wrapped around after reaching 9999 (the maximum), so set the year back to 1.
            mutable.year = $5c0571aa5b6fb5da$var$cycleValue(value.year, amount, -Infinity, 9999, options === null || options === void 0 ? void 0 : options.round);
            if (mutable.year === -Infinity) mutable.year = 1;
            if (mutable.calendar.balanceYearMonth) mutable.calendar.balanceYearMonth(mutable, value);
            break;
        case "month":
            mutable.month = $5c0571aa5b6fb5da$var$cycleValue(value.month, amount, 1, value.calendar.getMonthsInYear(value), options === null || options === void 0 ? void 0 : options.round);
            break;
        case "day":
            mutable.day = $5c0571aa5b6fb5da$var$cycleValue(value.day, amount, 1, value.calendar.getDaysInMonth(value), options === null || options === void 0 ? void 0 : options.round);
            break;
        default:
            throw new Error("Unsupported field " + field);
    }
    if (value.calendar.balanceDate) value.calendar.balanceDate(mutable);
    $5c0571aa5b6fb5da$export$c4e2ecac49351ef2(mutable);
    return mutable;
}
function $5c0571aa5b6fb5da$export$dd02b3e0007dfe28(value, field, amount, options) {
    let mutable = value.copy();
    switch(field){
        case "hour":
            {
                let hours = value.hour;
                let min = 0;
                let max = 23;
                if ((options === null || options === void 0 ? void 0 : options.hourCycle) === 12) {
                    let isPM = hours >= 12;
                    min = isPM ? 12 : 0;
                    max = isPM ? 23 : 11;
                }
                mutable.hour = $5c0571aa5b6fb5da$var$cycleValue(hours, amount, min, max, options === null || options === void 0 ? void 0 : options.round);
                break;
            }
        case "minute":
            mutable.minute = $5c0571aa5b6fb5da$var$cycleValue(value.minute, amount, 0, 59, options === null || options === void 0 ? void 0 : options.round);
            break;
        case "second":
            mutable.second = $5c0571aa5b6fb5da$var$cycleValue(value.second, amount, 0, 59, options === null || options === void 0 ? void 0 : options.round);
            break;
        case "millisecond":
            mutable.millisecond = $5c0571aa5b6fb5da$var$cycleValue(value.millisecond, amount, 0, 999, options === null || options === void 0 ? void 0 : options.round);
            break;
        default:
            throw new Error("Unsupported field " + field);
    }
    return mutable;
}
function $5c0571aa5b6fb5da$var$cycleValue(value, amount, min, max, round = false) {
    if (round) {
        value += Math.sign(amount);
        if (value < min) value = max;
        let div = Math.abs(amount);
        if (amount > 0) value = Math.ceil(value / div) * div;
        else value = Math.floor(value / div) * div;
        if (value > max) value = min;
    } else {
        value += amount;
        if (value < min) value = max - (min - value - 1);
        else if (value > max) value = min + (value - max - 1);
    }
    return value;
}
function $5c0571aa5b6fb5da$export$96b1d28349274637(dateTime, duration) {
    let ms;
    if (duration.years != null && duration.years !== 0 || duration.months != null && duration.months !== 0 || duration.days != null && duration.days !== 0) {
        let res = $5c0571aa5b6fb5da$export$e16d8520af44a096((0, $4ae0260a69729f1d$export$b21e0b124e224484)(dateTime), {
            years: duration.years,
            months: duration.months,
            days: duration.days
        });
        // Changing the date may change the timezone offset, so we need to recompute
        // using the 'compatible' disambiguation.
        ms = (0, $4ae0260a69729f1d$export$5107c82f94518f5c)(res, dateTime.timeZone);
    } else // Otherwise, preserve the offset of the original date.
    ms = (0, $4ae0260a69729f1d$export$bd4fb2bc8bb06fb)(dateTime) - dateTime.offset;
    // Perform time manipulation in milliseconds rather than on the original time fields to account for DST.
    // For example, adding one hour during a DST transition may result in the hour field staying the same or
    // skipping an hour. This results in the offset field changing value instead of the specified field.
    ms += duration.milliseconds || 0;
    ms += (duration.seconds || 0) * 1000;
    ms += (duration.minutes || 0) * 60000;
    ms += (duration.hours || 0) * 3600000;
    let res1 = (0, $4ae0260a69729f1d$export$1b96692a1ba042ac)(ms, dateTime.timeZone);
    return (0, $4ae0260a69729f1d$export$b4a036af3fc0b032)(res1, dateTime.calendar);
}
function $5c0571aa5b6fb5da$export$6814caac34ca03c7(dateTime, duration) {
    return $5c0571aa5b6fb5da$export$96b1d28349274637(dateTime, $5c0571aa5b6fb5da$export$3e2544e88a25bff8(duration));
}
function $5c0571aa5b6fb5da$export$9a297d111fc86b79(dateTime, field, amount, options) {
    // For date fields, we want the time to remain consistent and the UTC offset to potentially change to account for DST changes.
    // For time fields, we want the time to change by the amount given. This may result in the hour field staying the same, but the UTC
    // offset changing in the case of a backward DST transition, or skipping an hour in the case of a forward DST transition.
    switch(field){
        case "hour":
            {
                let min = 0;
                let max = 23;
                if ((options === null || options === void 0 ? void 0 : options.hourCycle) === 12) {
                    let isPM = dateTime.hour >= 12;
                    min = isPM ? 12 : 0;
                    max = isPM ? 23 : 11;
                }
                // The minimum and maximum hour may be affected by daylight saving time.
                // For example, it might jump forward at midnight, and skip 1am.
                // Or it might end at midnight and repeat the 11pm hour. To handle this, we get
                // the possible absolute times for the min and max, and find the maximum range
                // that is within the current day.
                let plainDateTime = (0, $4ae0260a69729f1d$export$b21e0b124e224484)(dateTime);
                let minDate = (0, $4ae0260a69729f1d$export$b4a036af3fc0b032)($5c0571aa5b6fb5da$export$e5d5e1c1822b6e56(plainDateTime, {
                    hour: min
                }), new (0, $af14c9812fdceb33$export$80ee6245ec4f29ec)());
                let minAbsolute = [
                    (0, $4ae0260a69729f1d$export$5107c82f94518f5c)(minDate, dateTime.timeZone, "earlier"),
                    (0, $4ae0260a69729f1d$export$5107c82f94518f5c)(minDate, dateTime.timeZone, "later")
                ].filter((ms)=>(0, $4ae0260a69729f1d$export$1b96692a1ba042ac)(ms, dateTime.timeZone).day === minDate.day)[0];
                let maxDate = (0, $4ae0260a69729f1d$export$b4a036af3fc0b032)($5c0571aa5b6fb5da$export$e5d5e1c1822b6e56(plainDateTime, {
                    hour: max
                }), new (0, $af14c9812fdceb33$export$80ee6245ec4f29ec)());
                let maxAbsolute = [
                    (0, $4ae0260a69729f1d$export$5107c82f94518f5c)(maxDate, dateTime.timeZone, "earlier"),
                    (0, $4ae0260a69729f1d$export$5107c82f94518f5c)(maxDate, dateTime.timeZone, "later")
                ].filter((ms)=>(0, $4ae0260a69729f1d$export$1b96692a1ba042ac)(ms, dateTime.timeZone).day === maxDate.day).pop();
                // Since hours may repeat, we need to operate on the absolute time in milliseconds.
                // This is done in hours from the Unix epoch so that cycleValue works correctly,
                // and then converted back to milliseconds.
                let ms = (0, $4ae0260a69729f1d$export$bd4fb2bc8bb06fb)(dateTime) - dateTime.offset;
                let hours = Math.floor(ms / $5c0571aa5b6fb5da$var$ONE_HOUR);
                let remainder = ms % $5c0571aa5b6fb5da$var$ONE_HOUR;
                ms = $5c0571aa5b6fb5da$var$cycleValue(hours, amount, Math.floor(minAbsolute / $5c0571aa5b6fb5da$var$ONE_HOUR), Math.floor(maxAbsolute / $5c0571aa5b6fb5da$var$ONE_HOUR), options === null || options === void 0 ? void 0 : options.round) * $5c0571aa5b6fb5da$var$ONE_HOUR + remainder;
                // Now compute the new timezone offset, and convert the absolute time back to local time.
                return (0, $4ae0260a69729f1d$export$b4a036af3fc0b032)((0, $4ae0260a69729f1d$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);
            }
        case "minute":
        case "second":
        case "millisecond":
            // @ts-ignore
            return $5c0571aa5b6fb5da$export$dd02b3e0007dfe28(dateTime, field, amount, options);
        case "era":
        case "year":
        case "month":
        case "day":
            {
                let res = $5c0571aa5b6fb5da$export$d52ced6badfb9a4c((0, $4ae0260a69729f1d$export$b21e0b124e224484)(dateTime), field, amount, options);
                let ms1 = (0, $4ae0260a69729f1d$export$5107c82f94518f5c)(res, dateTime.timeZone);
                return (0, $4ae0260a69729f1d$export$b4a036af3fc0b032)((0, $4ae0260a69729f1d$export$1b96692a1ba042ac)(ms1, dateTime.timeZone), dateTime.calendar);
            }
        default:
            throw new Error("Unsupported field " + field);
    }
}
function $5c0571aa5b6fb5da$export$31b5430eb18be4f8(dateTime, fields, disambiguation) {
    // Set the date/time fields, and recompute the UTC offset to account for DST changes.
    // We also need to validate by converting back to a local time in case hours are skipped during forward DST transitions.
    let plainDateTime = (0, $4ae0260a69729f1d$export$b21e0b124e224484)(dateTime);
    let res = $5c0571aa5b6fb5da$export$e5d5e1c1822b6e56($5c0571aa5b6fb5da$export$adaa4cf7ef1b65be(plainDateTime, fields), fields);
    // If the resulting plain date time values are equal, return the original time.
    // We don't want to change the offset when setting the time to the same value.
    if (res.compare(plainDateTime) === 0) return dateTime;
    let ms = (0, $4ae0260a69729f1d$export$5107c82f94518f5c)(res, dateTime.timeZone, disambiguation);
    return (0, $4ae0260a69729f1d$export$b4a036af3fc0b032)((0, $4ae0260a69729f1d$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);
}



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 



const $4c32e2d98e5a5134$var$TIME_RE = /^(\d{2})(?::(\d{2}))?(?::(\d{2}))?(\.\d+)?$/;
const $4c32e2d98e5a5134$var$DATE_RE = /^(\d{4})-(\d{2})-(\d{2})$/;
const $4c32e2d98e5a5134$var$DATE_TIME_RE = /^(\d{4})-(\d{2})-(\d{2})(?:T(\d{2}))?(?::(\d{2}))?(?::(\d{2}))?(\.\d+)?$/;
const $4c32e2d98e5a5134$var$ZONED_DATE_TIME_RE = /^(\d{4})-(\d{2})-(\d{2})(?:T(\d{2}))?(?::(\d{2}))?(?::(\d{2}))?(\.\d+)?(?:([+-]\d{2})(?::(\d{2}))?)?\[(.*?)\]$/;
const $4c32e2d98e5a5134$var$ABSOLUTE_RE = /^(\d{4})-(\d{2})-(\d{2})(?:T(\d{2}))?(?::(\d{2}))?(?::(\d{2}))?(\.\d+)?(?:(?:([+-]\d{2})(?::(\d{2}))?)|Z)$/;
const $4c32e2d98e5a5134$var$DATE_TIME_DURATION_RE = /^((?<negative>-)|\+)?P((?<years>\d*)Y)?((?<months>\d*)M)?((?<weeks>\d*)W)?((?<days>\d*)D)?((?<time>T)((?<hours>\d*[.,]?\d{1,9})H)?((?<minutes>\d*[.,]?\d{1,9})M)?((?<seconds>\d*[.,]?\d{1,9})S)?)?$/;
const $4c32e2d98e5a5134$var$requiredDurationTimeGroups = [
    "hours",
    "minutes",
    "seconds"
];
const $4c32e2d98e5a5134$var$requiredDurationGroups = [
    "years",
    "months",
    "weeks",
    "days",
    ...$4c32e2d98e5a5134$var$requiredDurationTimeGroups
];
function $4c32e2d98e5a5134$export$c9698ec7f05a07e1(value) {
    let m = value.match($4c32e2d98e5a5134$var$TIME_RE);
    if (!m) throw new Error("Invalid ISO 8601 time string: " + value);
    return new (0, $625ad1e1f4c43bc1$export$680ea196effce5f)($4c32e2d98e5a5134$var$parseNumber(m[1], 0, 23), m[2] ? $4c32e2d98e5a5134$var$parseNumber(m[2], 0, 59) : 0, m[3] ? $4c32e2d98e5a5134$var$parseNumber(m[3], 0, 59) : 0, m[4] ? $4c32e2d98e5a5134$var$parseNumber(m[4], 0, Infinity) * 1000 : 0);
}
function $4c32e2d98e5a5134$export$6b862160d295c8e(value) {
    let m = value.match($4c32e2d98e5a5134$var$DATE_RE);
    if (!m) throw new Error("Invalid ISO 8601 date string: " + value);
    let date = new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)($4c32e2d98e5a5134$var$parseNumber(m[1], 0, 9999), $4c32e2d98e5a5134$var$parseNumber(m[2], 1, 12), 1);
    date.day = $4c32e2d98e5a5134$var$parseNumber(m[3], 0, date.calendar.getDaysInMonth(date));
    return date;
}
function $4c32e2d98e5a5134$export$588937bcd60ade55(value) {
    let m = value.match($4c32e2d98e5a5134$var$DATE_TIME_RE);
    if (!m) throw new Error("Invalid ISO 8601 date time string: " + value);
    let date = new (0, $625ad1e1f4c43bc1$export$ca871e8dbb80966f)($4c32e2d98e5a5134$var$parseNumber(m[1], 1, 9999), $4c32e2d98e5a5134$var$parseNumber(m[2], 1, 12), 1, m[4] ? $4c32e2d98e5a5134$var$parseNumber(m[4], 0, 23) : 0, m[5] ? $4c32e2d98e5a5134$var$parseNumber(m[5], 0, 59) : 0, m[6] ? $4c32e2d98e5a5134$var$parseNumber(m[6], 0, 59) : 0, m[7] ? $4c32e2d98e5a5134$var$parseNumber(m[7], 0, Infinity) * 1000 : 0);
    date.day = $4c32e2d98e5a5134$var$parseNumber(m[3], 0, date.calendar.getDaysInMonth(date));
    return date;
}
function $4c32e2d98e5a5134$export$fd7893f06e92a6a4(value, disambiguation) {
    let m = value.match($4c32e2d98e5a5134$var$ZONED_DATE_TIME_RE);
    if (!m) throw new Error("Invalid ISO 8601 date time string: " + value);
    let date = new (0, $625ad1e1f4c43bc1$export$d3b7288e7994edea)($4c32e2d98e5a5134$var$parseNumber(m[1], 1, 9999), $4c32e2d98e5a5134$var$parseNumber(m[2], 1, 12), 1, m[10], 0, m[4] ? $4c32e2d98e5a5134$var$parseNumber(m[4], 0, 23) : 0, m[5] ? $4c32e2d98e5a5134$var$parseNumber(m[5], 0, 59) : 0, m[6] ? $4c32e2d98e5a5134$var$parseNumber(m[6], 0, 59) : 0, m[7] ? $4c32e2d98e5a5134$var$parseNumber(m[7], 0, Infinity) * 1000 : 0);
    date.day = $4c32e2d98e5a5134$var$parseNumber(m[3], 0, date.calendar.getDaysInMonth(date));
    let plainDateTime = (0, $4ae0260a69729f1d$export$b21e0b124e224484)(date);
    let ms;
    if (m[8]) {
        var _m_;
        date.offset = $4c32e2d98e5a5134$var$parseNumber(m[8], -23, 23) * 3600000 + $4c32e2d98e5a5134$var$parseNumber((_m_ = m[9]) !== null && _m_ !== void 0 ? _m_ : "0", 0, 59) * 60000;
        ms = (0, $4ae0260a69729f1d$export$bd4fb2bc8bb06fb)(date) - date.offset;
        // Validate offset against parsed date.
        let absolutes = (0, $4ae0260a69729f1d$export$136f38efe7caf549)(plainDateTime, date.timeZone);
        if (!absolutes.includes(ms)) throw new Error(`Offset ${$4c32e2d98e5a5134$var$offsetToString(date.offset)} is invalid for ${$4c32e2d98e5a5134$export$4223de14708adc63(date)} in ${date.timeZone}`);
    } else // Convert to absolute and back to fix invalid times due to DST.
    ms = (0, $4ae0260a69729f1d$export$5107c82f94518f5c)((0, $4ae0260a69729f1d$export$b21e0b124e224484)(plainDateTime), date.timeZone, disambiguation);
    return (0, $4ae0260a69729f1d$export$1b96692a1ba042ac)(ms, date.timeZone);
}
function $4c32e2d98e5a5134$export$5adfdab05168c219(value, timeZone) {
    let m = value.match($4c32e2d98e5a5134$var$ABSOLUTE_RE);
    if (!m) throw new Error("Invalid ISO 8601 date time string: " + value);
    let date = new (0, $625ad1e1f4c43bc1$export$d3b7288e7994edea)($4c32e2d98e5a5134$var$parseNumber(m[1], 1, 9999), $4c32e2d98e5a5134$var$parseNumber(m[2], 1, 12), 1, timeZone, 0, m[4] ? $4c32e2d98e5a5134$var$parseNumber(m[4], 0, 23) : 0, m[5] ? $4c32e2d98e5a5134$var$parseNumber(m[5], 0, 59) : 0, m[6] ? $4c32e2d98e5a5134$var$parseNumber(m[6], 0, 59) : 0, m[7] ? $4c32e2d98e5a5134$var$parseNumber(m[7], 0, Infinity) * 1000 : 0);
    date.day = $4c32e2d98e5a5134$var$parseNumber(m[3], 0, date.calendar.getDaysInMonth(date));
    var _m_;
    if (m[8]) date.offset = $4c32e2d98e5a5134$var$parseNumber(m[8], -23, 23) * 3600000 + $4c32e2d98e5a5134$var$parseNumber((_m_ = m[9]) !== null && _m_ !== void 0 ? _m_ : "0", 0, 59) * 60000;
    return (0, $4ae0260a69729f1d$export$538b00033cc11c75)(date, timeZone);
}
function $4c32e2d98e5a5134$export$8e384432362ed0f0(value) {
    return $4c32e2d98e5a5134$export$5adfdab05168c219(value, (0, $1f0f7ebf1ae6c530$export$aa8b41735afcabd2)());
}
function $4c32e2d98e5a5134$var$parseNumber(value, min, max) {
    let val = Number(value);
    if (val < min || val > max) throw new RangeError(`Value out of range: ${min} <= ${val} <= ${max}`);
    return val;
}
function $4c32e2d98e5a5134$export$f59dee82248f5ad4(time) {
    return `${String(time.hour).padStart(2, "0")}:${String(time.minute).padStart(2, "0")}:${String(time.second).padStart(2, "0")}${time.millisecond ? String(time.millisecond / 1000).slice(1) : ""}`;
}
function $4c32e2d98e5a5134$export$60dfd74aa96791bd(date) {
    let gregorianDate = (0, $4ae0260a69729f1d$export$b4a036af3fc0b032)(date, new (0, $af14c9812fdceb33$export$80ee6245ec4f29ec)());
    return `${String(gregorianDate.year).padStart(4, "0")}-${String(gregorianDate.month).padStart(2, "0")}-${String(gregorianDate.day).padStart(2, "0")}`;
}
function $4c32e2d98e5a5134$export$4223de14708adc63(date) {
    // @ts-ignore
    return `${$4c32e2d98e5a5134$export$60dfd74aa96791bd(date)}T${$4c32e2d98e5a5134$export$f59dee82248f5ad4(date)}`;
}
function $4c32e2d98e5a5134$var$offsetToString(offset) {
    let sign = Math.sign(offset) < 0 ? "-" : "+";
    offset = Math.abs(offset);
    let offsetHours = Math.floor(offset / 3600000);
    let offsetMinutes = offset % 3600000 / 60000;
    return `${sign}${String(offsetHours).padStart(2, "0")}:${String(offsetMinutes).padStart(2, "0")}`;
}
function $4c32e2d98e5a5134$export$bf79f1ebf4b18792(date) {
    return `${$4c32e2d98e5a5134$export$4223de14708adc63(date)}${$4c32e2d98e5a5134$var$offsetToString(date.offset)}[${date.timeZone}]`;
}
function $4c32e2d98e5a5134$export$ecae829bb3747ea6(value) {
    var _match_groups, _match_groups1, _match_groups2, _match_groups3, _match_groups4, _match_groups5, _match_groups6, _match_groups7, _match_groups8;
    const match = value.match($4c32e2d98e5a5134$var$DATE_TIME_DURATION_RE);
    if (!match) throw new Error(`Invalid ISO 8601 Duration string: ${value}`);
    const parseDurationGroup = (group, isNegative, min, max)=>{
        if (!group) return 0;
        try {
            const sign = isNegative ? -1 : 1;
            return sign * $4c32e2d98e5a5134$var$parseNumber(group.replace(",", "."), min, max);
        } catch  {
            throw new Error(`Invalid ISO 8601 Duration string: ${value}`);
        }
    };
    const isNegative = !!((_match_groups = match.groups) === null || _match_groups === void 0 ? void 0 : _match_groups.negative);
    const hasRequiredGroups = $4c32e2d98e5a5134$var$requiredDurationGroups.some((group)=>{
        var _match_groups;
        return (_match_groups = match.groups) === null || _match_groups === void 0 ? void 0 : _match_groups[group];
    });
    if (!hasRequiredGroups) throw new Error(`Invalid ISO 8601 Duration string: ${value}`);
    const durationStringIncludesTime = (_match_groups1 = match.groups) === null || _match_groups1 === void 0 ? void 0 : _match_groups1.time;
    if (durationStringIncludesTime) {
        const hasRequiredDurationTimeGroups = $4c32e2d98e5a5134$var$requiredDurationTimeGroups.some((group)=>{
            var _match_groups;
            return (_match_groups = match.groups) === null || _match_groups === void 0 ? void 0 : _match_groups[group];
        });
        if (!hasRequiredDurationTimeGroups) throw new Error(`Invalid ISO 8601 Duration string: ${value}`);
    }
    const duration = {
        years: parseDurationGroup((_match_groups2 = match.groups) === null || _match_groups2 === void 0 ? void 0 : _match_groups2.years, isNegative, 0, 9999),
        months: parseDurationGroup((_match_groups3 = match.groups) === null || _match_groups3 === void 0 ? void 0 : _match_groups3.months, isNegative, 0, 12),
        weeks: parseDurationGroup((_match_groups4 = match.groups) === null || _match_groups4 === void 0 ? void 0 : _match_groups4.weeks, isNegative, 0, Infinity),
        days: parseDurationGroup((_match_groups5 = match.groups) === null || _match_groups5 === void 0 ? void 0 : _match_groups5.days, isNegative, 0, 31),
        hours: parseDurationGroup((_match_groups6 = match.groups) === null || _match_groups6 === void 0 ? void 0 : _match_groups6.hours, isNegative, 0, 23),
        minutes: parseDurationGroup((_match_groups7 = match.groups) === null || _match_groups7 === void 0 ? void 0 : _match_groups7.minutes, isNegative, 0, 59),
        seconds: parseDurationGroup((_match_groups8 = match.groups) === null || _match_groups8 === void 0 ? void 0 : _match_groups8.seconds, isNegative, 0, 59)
    };
    if (duration.hours % 1 !== 0 && (duration.minutes || duration.seconds)) throw new Error(`Invalid ISO 8601 Duration string: ${value} - only the smallest unit can be fractional`);
    if (duration.minutes % 1 !== 0 && duration.seconds) throw new Error(`Invalid ISO 8601 Duration string: ${value} - only the smallest unit can be fractional`);
    return duration;
}




function $625ad1e1f4c43bc1$var$shiftArgs(args) {
    let calendar = typeof args[0] === "object" ? args.shift() : new (0, $af14c9812fdceb33$export$80ee6245ec4f29ec)();
    let era;
    if (typeof args[0] === "string") era = args.shift();
    else {
        let eras = calendar.getEras();
        era = eras[eras.length - 1];
    }
    let year = args.shift();
    let month = args.shift();
    let day = args.shift();
    return [
        calendar,
        era,
        year,
        month,
        day
    ];
}
var // This prevents TypeScript from allowing other types with the same fields to match.
// i.e. a ZonedDateTime should not be be passable to a parameter that expects CalendarDate.
// If that behavior is desired, use the AnyCalendarDate interface instead.
// @ts-ignore
$625ad1e1f4c43bc1$var$_type = /*#__PURE__*/ new WeakMap();
class $625ad1e1f4c43bc1$export$99faa760c7908e4f {
    /** Returns a copy of this date. */ copy() {
        if (this.era) return new $625ad1e1f4c43bc1$export$99faa760c7908e4f(this.calendar, this.era, this.year, this.month, this.day);
        else return new $625ad1e1f4c43bc1$export$99faa760c7908e4f(this.calendar, this.year, this.month, this.day);
    }
    /** Returns a new `CalendarDate` with the given duration added to it. */ add(duration) {
        return (0, $5c0571aa5b6fb5da$export$e16d8520af44a096)(this, duration);
    }
    /** Returns a new `CalendarDate` with the given duration subtracted from it. */ subtract(duration) {
        return (0, $5c0571aa5b6fb5da$export$4e2d2ead65e5f7e3)(this, duration);
    }
    /** Returns a new `CalendarDate` with the given fields set to the provided values. Other fields will be constrained accordingly. */ set(fields) {
        return (0, $5c0571aa5b6fb5da$export$adaa4cf7ef1b65be)(this, fields);
    }
    /**
   * Returns a new `CalendarDate` with the given field adjusted by a specified amount.
   * When the resulting value reaches the limits of the field, it wraps around.
   */ cycle(field, amount, options) {
        return (0, $5c0571aa5b6fb5da$export$d52ced6badfb9a4c)(this, field, amount, options);
    }
    /** Converts the date to a native JavaScript Date object, with the time set to midnight in the given time zone. */ toDate(timeZone) {
        return (0, $4ae0260a69729f1d$export$e67a095c620b86fe)(this, timeZone);
    }
    /** Converts the date to an ISO 8601 formatted string. */ toString() {
        return (0, $4c32e2d98e5a5134$export$60dfd74aa96791bd)(this);
    }
    /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */ compare(b) {
        return (0, $1f0f7ebf1ae6c530$export$68781ddf31c0090f)(this, b);
    }
    constructor(...args){
        (0, ($parcel$interopDefault($kgI3C$swchelperslib_class_private_field_initjs)))(this, $625ad1e1f4c43bc1$var$_type, {
            writable: true,
            value: void 0
        });
        let [calendar, era, year, month, day] = $625ad1e1f4c43bc1$var$shiftArgs(args);
        this.calendar = calendar;
        this.era = era;
        this.year = year;
        this.month = month;
        this.day = day;
        (0, $5c0571aa5b6fb5da$export$c4e2ecac49351ef2)(this);
    }
}
var // This prevents TypeScript from allowing other types with the same fields to match.
// @ts-ignore
$625ad1e1f4c43bc1$var$_type1 = /*#__PURE__*/ new WeakMap();
class $625ad1e1f4c43bc1$export$680ea196effce5f {
    /** Returns a copy of this time. */ copy() {
        return new $625ad1e1f4c43bc1$export$680ea196effce5f(this.hour, this.minute, this.second, this.millisecond);
    }
    /** Returns a new `Time` with the given duration added to it. */ add(duration) {
        return (0, $5c0571aa5b6fb5da$export$7ed87b6bc2506470)(this, duration);
    }
    /** Returns a new `Time` with the given duration subtracted from it. */ subtract(duration) {
        return (0, $5c0571aa5b6fb5da$export$fe34d3a381cd7501)(this, duration);
    }
    /** Returns a new `Time` with the given fields set to the provided values. Other fields will be constrained accordingly. */ set(fields) {
        return (0, $5c0571aa5b6fb5da$export$e5d5e1c1822b6e56)(this, fields);
    }
    /**
   * Returns a new `Time` with the given field adjusted by a specified amount.
   * When the resulting value reaches the limits of the field, it wraps around.
   */ cycle(field, amount, options) {
        return (0, $5c0571aa5b6fb5da$export$dd02b3e0007dfe28)(this, field, amount, options);
    }
    /** Converts the time to an ISO 8601 formatted string. */ toString() {
        return (0, $4c32e2d98e5a5134$export$f59dee82248f5ad4)(this);
    }
    /** Compares this time with another. A negative result indicates that this time is before the given one, and a positive time indicates that it is after. */ compare(b) {
        return (0, $1f0f7ebf1ae6c530$export$c19a80a9721b80f6)(this, b);
    }
    constructor(hour = 0, minute = 0, second = 0, millisecond = 0){
        (0, ($parcel$interopDefault($kgI3C$swchelperslib_class_private_field_initjs)))(this, $625ad1e1f4c43bc1$var$_type1, {
            writable: true,
            value: void 0
        });
        this.hour = hour;
        this.minute = minute;
        this.second = second;
        this.millisecond = millisecond;
        (0, $5c0571aa5b6fb5da$export$7555de1e070510cb)(this);
    }
}
var // This prevents TypeScript from allowing other types with the same fields to match.
// @ts-ignore
$625ad1e1f4c43bc1$var$_type2 = /*#__PURE__*/ new WeakMap();
class $625ad1e1f4c43bc1$export$ca871e8dbb80966f {
    /** Returns a copy of this date. */ copy() {
        if (this.era) return new $625ad1e1f4c43bc1$export$ca871e8dbb80966f(this.calendar, this.era, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
        else return new $625ad1e1f4c43bc1$export$ca871e8dbb80966f(this.calendar, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
    }
    /** Returns a new `CalendarDateTime` with the given duration added to it. */ add(duration) {
        return (0, $5c0571aa5b6fb5da$export$e16d8520af44a096)(this, duration);
    }
    /** Returns a new `CalendarDateTime` with the given duration subtracted from it. */ subtract(duration) {
        return (0, $5c0571aa5b6fb5da$export$4e2d2ead65e5f7e3)(this, duration);
    }
    /** Returns a new `CalendarDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */ set(fields) {
        return (0, $5c0571aa5b6fb5da$export$adaa4cf7ef1b65be)((0, $5c0571aa5b6fb5da$export$e5d5e1c1822b6e56)(this, fields), fields);
    }
    /**
   * Returns a new `CalendarDateTime` with the given field adjusted by a specified amount.
   * When the resulting value reaches the limits of the field, it wraps around.
   */ cycle(field, amount, options) {
        switch(field){
            case "era":
            case "year":
            case "month":
            case "day":
                return (0, $5c0571aa5b6fb5da$export$d52ced6badfb9a4c)(this, field, amount, options);
            default:
                return (0, $5c0571aa5b6fb5da$export$dd02b3e0007dfe28)(this, field, amount, options);
        }
    }
    /** Converts the date to a native JavaScript Date object in the given time zone. */ toDate(timeZone, disambiguation) {
        return (0, $4ae0260a69729f1d$export$e67a095c620b86fe)(this, timeZone, disambiguation);
    }
    /** Converts the date to an ISO 8601 formatted string. */ toString() {
        return (0, $4c32e2d98e5a5134$export$4223de14708adc63)(this);
    }
    /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */ compare(b) {
        let res = (0, $1f0f7ebf1ae6c530$export$68781ddf31c0090f)(this, b);
        if (res === 0) return (0, $1f0f7ebf1ae6c530$export$c19a80a9721b80f6)(this, (0, $4ae0260a69729f1d$export$b21e0b124e224484)(b));
        return res;
    }
    constructor(...args){
        (0, ($parcel$interopDefault($kgI3C$swchelperslib_class_private_field_initjs)))(this, $625ad1e1f4c43bc1$var$_type2, {
            writable: true,
            value: void 0
        });
        let [calendar, era, year, month, day] = $625ad1e1f4c43bc1$var$shiftArgs(args);
        this.calendar = calendar;
        this.era = era;
        this.year = year;
        this.month = month;
        this.day = day;
        this.hour = args.shift() || 0;
        this.minute = args.shift() || 0;
        this.second = args.shift() || 0;
        this.millisecond = args.shift() || 0;
        (0, $5c0571aa5b6fb5da$export$c4e2ecac49351ef2)(this);
    }
}
var // This prevents TypeScript from allowing other types with the same fields to match.
// @ts-ignore
$625ad1e1f4c43bc1$var$_type3 = /*#__PURE__*/ new WeakMap();
class $625ad1e1f4c43bc1$export$d3b7288e7994edea {
    /** Returns a copy of this date. */ copy() {
        if (this.era) return new $625ad1e1f4c43bc1$export$d3b7288e7994edea(this.calendar, this.era, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
        else return new $625ad1e1f4c43bc1$export$d3b7288e7994edea(this.calendar, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
    }
    /** Returns a new `ZonedDateTime` with the given duration added to it. */ add(duration) {
        return (0, $5c0571aa5b6fb5da$export$96b1d28349274637)(this, duration);
    }
    /** Returns a new `ZonedDateTime` with the given duration subtracted from it. */ subtract(duration) {
        return (0, $5c0571aa5b6fb5da$export$6814caac34ca03c7)(this, duration);
    }
    /** Returns a new `ZonedDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */ set(fields, disambiguation) {
        return (0, $5c0571aa5b6fb5da$export$31b5430eb18be4f8)(this, fields, disambiguation);
    }
    /**
   * Returns a new `ZonedDateTime` with the given field adjusted by a specified amount.
   * When the resulting value reaches the limits of the field, it wraps around.
   */ cycle(field, amount, options) {
        return (0, $5c0571aa5b6fb5da$export$9a297d111fc86b79)(this, field, amount, options);
    }
    /** Converts the date to a native JavaScript Date object. */ toDate() {
        return (0, $4ae0260a69729f1d$export$83aac07b4c37b25)(this);
    }
    /** Converts the date to an ISO 8601 formatted string, including the UTC offset and time zone identifier. */ toString() {
        return (0, $4c32e2d98e5a5134$export$bf79f1ebf4b18792)(this);
    }
    /** Converts the date to an ISO 8601 formatted string in UTC. */ toAbsoluteString() {
        return this.toDate().toISOString();
    }
    /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */ compare(b) {
        // TODO: Is this a bad idea??
        return this.toDate().getTime() - (0, $4ae0260a69729f1d$export$84c95a83c799e074)(b, this.timeZone).toDate().getTime();
    }
    constructor(...args){
        (0, ($parcel$interopDefault($kgI3C$swchelperslib_class_private_field_initjs)))(this, $625ad1e1f4c43bc1$var$_type3, {
            writable: true,
            value: void 0
        });
        let [calendar, era, year, month, day] = $625ad1e1f4c43bc1$var$shiftArgs(args);
        let timeZone = args.shift();
        let offset = args.shift();
        this.calendar = calendar;
        this.era = era;
        this.year = year;
        this.month = month;
        this.day = day;
        this.timeZone = timeZone;
        this.offset = offset;
        this.hour = args.shift() || 0;
        this.minute = args.shift() || 0;
        this.second = args.shift() || 0;
        this.millisecond = args.shift() || 0;
        (0, $5c0571aa5b6fb5da$export$c4e2ecac49351ef2)(this);
    }
}



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from the TC39 Temporal proposal.
// Original licensing can be found in the NOTICE file in the root directory of this source tree.



const $b0ac0602ef646b2c$var$ERA_START_DATES = [
    [
        1868,
        9,
        8
    ],
    [
        1912,
        7,
        30
    ],
    [
        1926,
        12,
        25
    ],
    [
        1989,
        1,
        8
    ],
    [
        2019,
        5,
        1
    ]
];
const $b0ac0602ef646b2c$var$ERA_END_DATES = [
    [
        1912,
        7,
        29
    ],
    [
        1926,
        12,
        24
    ],
    [
        1989,
        1,
        7
    ],
    [
        2019,
        4,
        30
    ]
];
const $b0ac0602ef646b2c$var$ERA_ADDENDS = [
    1867,
    1911,
    1925,
    1988,
    2018
];
const $b0ac0602ef646b2c$var$ERA_NAMES = [
    "meiji",
    "taisho",
    "showa",
    "heisei",
    "reiwa"
];
function $b0ac0602ef646b2c$var$findEraFromGregorianDate(date) {
    const idx = $b0ac0602ef646b2c$var$ERA_START_DATES.findIndex(([year, month, day])=>{
        if (date.year < year) return true;
        if (date.year === year && date.month < month) return true;
        if (date.year === year && date.month === month && date.day < day) return true;
        return false;
    });
    if (idx === -1) return $b0ac0602ef646b2c$var$ERA_START_DATES.length - 1;
    if (idx === 0) return 0;
    return idx - 1;
}
function $b0ac0602ef646b2c$var$toGregorian(date) {
    let eraAddend = $b0ac0602ef646b2c$var$ERA_ADDENDS[$b0ac0602ef646b2c$var$ERA_NAMES.indexOf(date.era)];
    if (!eraAddend) throw new Error("Unknown era: " + date.era);
    return new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)(date.year + eraAddend, date.month, date.day);
}
class $b0ac0602ef646b2c$export$b746ab2b60cdffbf extends (0, $af14c9812fdceb33$export$80ee6245ec4f29ec) {
    fromJulianDay(jd) {
        let date = super.fromJulianDay(jd);
        let era = $b0ac0602ef646b2c$var$findEraFromGregorianDate(date);
        return new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)(this, $b0ac0602ef646b2c$var$ERA_NAMES[era], date.year - $b0ac0602ef646b2c$var$ERA_ADDENDS[era], date.month, date.day);
    }
    toJulianDay(date) {
        return super.toJulianDay($b0ac0602ef646b2c$var$toGregorian(date));
    }
    balanceDate(date) {
        let gregorianDate = $b0ac0602ef646b2c$var$toGregorian(date);
        let era = $b0ac0602ef646b2c$var$findEraFromGregorianDate(gregorianDate);
        if ($b0ac0602ef646b2c$var$ERA_NAMES[era] !== date.era) {
            date.era = $b0ac0602ef646b2c$var$ERA_NAMES[era];
            date.year = gregorianDate.year - $b0ac0602ef646b2c$var$ERA_ADDENDS[era];
        }
        // Constrain in case we went before the first supported era.
        this.constrainDate(date);
    }
    constrainDate(date) {
        let idx = $b0ac0602ef646b2c$var$ERA_NAMES.indexOf(date.era);
        let end = $b0ac0602ef646b2c$var$ERA_END_DATES[idx];
        if (end != null) {
            let [endYear, endMonth, endDay] = end;
            // Constrain the year to the maximum possible value in the era.
            // Then constrain the month and day fields within that.
            let maxYear = endYear - $b0ac0602ef646b2c$var$ERA_ADDENDS[idx];
            date.year = Math.max(1, Math.min(maxYear, date.year));
            if (date.year === maxYear) {
                date.month = Math.min(endMonth, date.month);
                if (date.month === endMonth) date.day = Math.min(endDay, date.day);
            }
        }
        if (date.year === 1 && idx >= 0) {
            let [, startMonth, startDay] = $b0ac0602ef646b2c$var$ERA_START_DATES[idx];
            date.month = Math.max(startMonth, date.month);
            if (date.month === startMonth) date.day = Math.max(startDay, date.day);
        }
    }
    getEras() {
        return $b0ac0602ef646b2c$var$ERA_NAMES;
    }
    getYearsInEra(date) {
        // Get the number of years in the era, taking into account the date's month and day fields.
        let era = $b0ac0602ef646b2c$var$ERA_NAMES.indexOf(date.era);
        let cur = $b0ac0602ef646b2c$var$ERA_START_DATES[era];
        let next = $b0ac0602ef646b2c$var$ERA_START_DATES[era + 1];
        if (next == null) // 9999 gregorian is the maximum year allowed.
        return 9999 - cur[0] + 1;
        let years = next[0] - cur[0];
        if (date.month < next[1] || date.month === next[1] && date.day < next[2]) years++;
        return years;
    }
    getDaysInMonth(date) {
        return super.getDaysInMonth($b0ac0602ef646b2c$var$toGregorian(date));
    }
    getMinimumMonthInYear(date) {
        let start = $b0ac0602ef646b2c$var$getMinimums(date);
        return start ? start[1] : 1;
    }
    getMinimumDayInMonth(date) {
        let start = $b0ac0602ef646b2c$var$getMinimums(date);
        return start && date.month === start[1] ? start[2] : 1;
    }
    constructor(...args){
        super(...args);
        (0, ($parcel$interopDefault($kgI3C$swchelperslib_define_propertyjs)))(this, "identifier", "japanese");
    }
}
function $b0ac0602ef646b2c$var$getMinimums(date) {
    if (date.year === 1) {
        let idx = $b0ac0602ef646b2c$var$ERA_NAMES.indexOf(date.era);
        return $b0ac0602ef646b2c$var$ERA_START_DATES[idx];
    }
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from ICU.
// Original licensing can be found in the NOTICE file in the root directory of this source tree.



const $561c4ef058278b74$var$BUDDHIST_ERA_START = -543;
class $561c4ef058278b74$export$42d20a78301dee44 extends (0, $af14c9812fdceb33$export$80ee6245ec4f29ec) {
    fromJulianDay(jd) {
        let gregorianDate = super.fromJulianDay(jd);
        let year = (0, $af14c9812fdceb33$export$c36e0ecb2d4fa69d)(gregorianDate.era, gregorianDate.year);
        return new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)(this, year - $561c4ef058278b74$var$BUDDHIST_ERA_START, gregorianDate.month, gregorianDate.day);
    }
    toJulianDay(date) {
        return super.toJulianDay($561c4ef058278b74$var$toGregorian(date));
    }
    getEras() {
        return [
            "BE"
        ];
    }
    getDaysInMonth(date) {
        return super.getDaysInMonth($561c4ef058278b74$var$toGregorian(date));
    }
    balanceDate() {}
    constructor(...args){
        super(...args);
        (0, ($parcel$interopDefault($kgI3C$swchelperslib_define_propertyjs)))(this, "identifier", "buddhist");
    }
}
function $561c4ef058278b74$var$toGregorian(date) {
    let [era, year] = (0, $af14c9812fdceb33$export$4475b7e617eb123c)(date.year + $561c4ef058278b74$var$BUDDHIST_ERA_START);
    return new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)(era, year, date.month, date.day);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from ICU.
// Original licensing can be found in the NOTICE file in the root directory of this source tree.



const $9cc5d3577ec40243$var$TAIWAN_ERA_START = 1911;
function $9cc5d3577ec40243$var$gregorianYear(date) {
    return date.era === "minguo" ? date.year + $9cc5d3577ec40243$var$TAIWAN_ERA_START : 1 - date.year + $9cc5d3577ec40243$var$TAIWAN_ERA_START;
}
function $9cc5d3577ec40243$var$gregorianToTaiwan(year) {
    let y = year - $9cc5d3577ec40243$var$TAIWAN_ERA_START;
    if (y > 0) return [
        "minguo",
        y
    ];
    else return [
        "before_minguo",
        1 - y
    ];
}
class $9cc5d3577ec40243$export$65e01080afcb0799 extends (0, $af14c9812fdceb33$export$80ee6245ec4f29ec) {
    fromJulianDay(jd) {
        let date = super.fromJulianDay(jd);
        let extendedYear = (0, $af14c9812fdceb33$export$c36e0ecb2d4fa69d)(date.era, date.year);
        let [era, year] = $9cc5d3577ec40243$var$gregorianToTaiwan(extendedYear);
        return new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)(this, era, year, date.month, date.day);
    }
    toJulianDay(date) {
        return super.toJulianDay($9cc5d3577ec40243$var$toGregorian(date));
    }
    getEras() {
        return [
            "before_minguo",
            "minguo"
        ];
    }
    balanceDate(date) {
        let [era, year] = $9cc5d3577ec40243$var$gregorianToTaiwan($9cc5d3577ec40243$var$gregorianYear(date));
        date.era = era;
        date.year = year;
    }
    isInverseEra(date) {
        return date.era === "before_minguo";
    }
    getDaysInMonth(date) {
        return super.getDaysInMonth($9cc5d3577ec40243$var$toGregorian(date));
    }
    getYearsInEra(date) {
        return date.era === "before_minguo" ? 9999 : 9999 - $9cc5d3577ec40243$var$TAIWAN_ERA_START;
    }
    constructor(...args){
        super(...args);
        (0, ($parcel$interopDefault($kgI3C$swchelperslib_define_propertyjs)))(this, "identifier", "roc") // Republic of China
        ;
    }
}
function $9cc5d3577ec40243$var$toGregorian(date) {
    let [era, year] = (0, $af14c9812fdceb33$export$4475b7e617eb123c)($9cc5d3577ec40243$var$gregorianYear(date));
    return new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)(era, year, date.month, date.day);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from ICU.
// Original licensing can be found in the NOTICE file in the root directory of this source tree.



const $3c060181fc7249ae$var$PERSIAN_EPOCH = 1948321; // 622/03/19 Julian C.E.
function $3c060181fc7249ae$var$isLeapYear(year) {
    let y0 = year > 0 ? year - 474 : year - 473;
    let y1 = (0, $a5090d6430502238$export$842a2cf37af977e1)(y0, 2820) + 474;
    return (0, $a5090d6430502238$export$842a2cf37af977e1)((y1 + 38) * 31, 128) < 31;
}
function $3c060181fc7249ae$var$persianToJulianDay(year, month, day) {
    let y0 = year > 0 ? year - 474 : year - 473;
    let y1 = (0, $a5090d6430502238$export$842a2cf37af977e1)(y0, 2820) + 474;
    let offset = month <= 7 ? 31 * (month - 1) : 30 * (month - 1) + 6;
    return $3c060181fc7249ae$var$PERSIAN_EPOCH - 1 + 1029983 * Math.floor(y0 / 2820) + 365 * (y1 - 1) + Math.floor((31 * y1 - 5) / 128) + offset + day;
}
class $3c060181fc7249ae$export$37fccdbfd14c5939 {
    fromJulianDay(jd) {
        let d0 = jd - $3c060181fc7249ae$var$persianToJulianDay(475, 1, 1);
        let n2820 = Math.floor(d0 / 1029983);
        let d1 = (0, $a5090d6430502238$export$842a2cf37af977e1)(d0, 1029983);
        let y2820 = d1 === 1029982 ? 2820 : Math.floor((128 * d1 + 46878) / 46751);
        let year = 474 + 2820 * n2820 + y2820;
        if (year <= 0) year--;
        let yDay = jd - $3c060181fc7249ae$var$persianToJulianDay(year, 1, 1) + 1;
        let month = yDay <= 186 ? Math.ceil(yDay / 31) : Math.ceil((yDay - 6) / 31);
        let day = jd - $3c060181fc7249ae$var$persianToJulianDay(year, month, 1) + 1;
        return new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)(this, year, month, day);
    }
    toJulianDay(date) {
        return $3c060181fc7249ae$var$persianToJulianDay(date.year, date.month, date.day);
    }
    getMonthsInYear() {
        return 12;
    }
    getDaysInMonth(date) {
        if (date.month <= 6) return 31;
        if (date.month <= 11) return 30;
        return $3c060181fc7249ae$var$isLeapYear(date.year) ? 30 : 29;
    }
    getEras() {
        return [
            "AP"
        ];
    }
    getYearsInEra() {
        // 9378-10-10 persian is 9999-12-31 gregorian.
        // Round down to 9377 to set the maximum full year.
        return 9377;
    }
    constructor(){
        (0, ($parcel$interopDefault($kgI3C$swchelperslib_define_propertyjs)))(this, "identifier", "persian");
    }
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from ICU.
// Original licensing can be found in the NOTICE file in the root directory of this source tree.



// Starts in 78 AD,
const $5f1dfa5c67609fe6$var$INDIAN_ERA_START = 78;
// The Indian year starts 80 days later than the Gregorian year.
const $5f1dfa5c67609fe6$var$INDIAN_YEAR_START = 80;
class $5f1dfa5c67609fe6$export$39f31c639fa15726 extends (0, $af14c9812fdceb33$export$80ee6245ec4f29ec) {
    fromJulianDay(jd) {
        // Gregorian date for Julian day
        let date = super.fromJulianDay(jd);
        // Year in Saka era
        let indianYear = date.year - $5f1dfa5c67609fe6$var$INDIAN_ERA_START;
        // Day number in Gregorian year (starting from 0)
        let yDay = jd - (0, $af14c9812fdceb33$export$f297eb839006d339)(date.era, date.year, 1, 1);
        let leapMonth;
        if (yDay < $5f1dfa5c67609fe6$var$INDIAN_YEAR_START) {
            //  Day is at the end of the preceding Saka year
            indianYear--;
            // Days in leapMonth this year, previous Gregorian year
            leapMonth = (0, $af14c9812fdceb33$export$553d7fa8e3805fc0)(date.year - 1) ? 31 : 30;
            yDay += leapMonth + 155 + 90 + 10;
        } else {
            // Days in leapMonth this year
            leapMonth = (0, $af14c9812fdceb33$export$553d7fa8e3805fc0)(date.year) ? 31 : 30;
            yDay -= $5f1dfa5c67609fe6$var$INDIAN_YEAR_START;
        }
        let indianMonth;
        let indianDay;
        if (yDay < leapMonth) {
            indianMonth = 1;
            indianDay = yDay + 1;
        } else {
            let mDay = yDay - leapMonth;
            if (mDay < 155) {
                indianMonth = Math.floor(mDay / 31) + 2;
                indianDay = mDay % 31 + 1;
            } else {
                mDay -= 155;
                indianMonth = Math.floor(mDay / 30) + 7;
                indianDay = mDay % 30 + 1;
            }
        }
        return new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)(this, indianYear, indianMonth, indianDay);
    }
    toJulianDay(date) {
        let extendedYear = date.year + $5f1dfa5c67609fe6$var$INDIAN_ERA_START;
        let [era, year] = (0, $af14c9812fdceb33$export$4475b7e617eb123c)(extendedYear);
        let leapMonth;
        let jd;
        if ((0, $af14c9812fdceb33$export$553d7fa8e3805fc0)(year)) {
            leapMonth = 31;
            jd = (0, $af14c9812fdceb33$export$f297eb839006d339)(era, year, 3, 21);
        } else {
            leapMonth = 30;
            jd = (0, $af14c9812fdceb33$export$f297eb839006d339)(era, year, 3, 22);
        }
        if (date.month === 1) return jd + date.day - 1;
        jd += leapMonth + Math.min(date.month - 2, 5) * 31;
        if (date.month >= 8) jd += (date.month - 7) * 30;
        jd += date.day - 1;
        return jd;
    }
    getDaysInMonth(date) {
        if (date.month === 1 && (0, $af14c9812fdceb33$export$553d7fa8e3805fc0)(date.year + $5f1dfa5c67609fe6$var$INDIAN_ERA_START)) return 31;
        if (date.month >= 2 && date.month <= 6) return 31;
        return 30;
    }
    getYearsInEra() {
        // 9999-12-31 gregorian is 9920-10-10 indian.
        // Round down to 9919 for the last full year.
        return 9919;
    }
    getEras() {
        return [
            "saka"
        ];
    }
    balanceDate() {}
    constructor(...args){
        super(...args);
        (0, ($parcel$interopDefault($kgI3C$swchelperslib_define_propertyjs)))(this, "identifier", "indian");
    }
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from ICU.
// Original licensing can be found in the NOTICE file in the root directory of this source tree.


const $ecb2c4cc8c9aae25$var$CIVIL_EPOC = 1948440; // CE 622 July 16 Friday (Julian calendar) / CE 622 July 19 (Gregorian calendar)
const $ecb2c4cc8c9aae25$var$ASTRONOMICAL_EPOC = 1948439; // CE 622 July 15 Thursday (Julian calendar)
const $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START = 1300;
const $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_END = 1600;
const $ecb2c4cc8c9aae25$var$UMALQURA_START_DAYS = 460322;
function $ecb2c4cc8c9aae25$var$islamicToJulianDay(epoch, year, month, day) {
    return day + Math.ceil(29.5 * (month - 1)) + (year - 1) * 354 + Math.floor((3 + 11 * year) / 30) + epoch - 1;
}
function $ecb2c4cc8c9aae25$var$julianDayToIslamic(calendar, epoch, jd) {
    let year = Math.floor((30 * (jd - epoch) + 10646) / 10631);
    let month = Math.min(12, Math.ceil((jd - (29 + $ecb2c4cc8c9aae25$var$islamicToJulianDay(epoch, year, 1, 1))) / 29.5) + 1);
    let day = jd - $ecb2c4cc8c9aae25$var$islamicToJulianDay(epoch, year, month, 1) + 1;
    return new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)(calendar, year, month, day);
}
function $ecb2c4cc8c9aae25$var$isLeapYear(year) {
    return (14 + 11 * year) % 30 < 11;
}
class $ecb2c4cc8c9aae25$export$2066795aadd37bfc {
    fromJulianDay(jd) {
        return $ecb2c4cc8c9aae25$var$julianDayToIslamic(this, $ecb2c4cc8c9aae25$var$CIVIL_EPOC, jd);
    }
    toJulianDay(date) {
        return $ecb2c4cc8c9aae25$var$islamicToJulianDay($ecb2c4cc8c9aae25$var$CIVIL_EPOC, date.year, date.month, date.day);
    }
    getDaysInMonth(date) {
        let length = 29 + date.month % 2;
        if (date.month === 12 && $ecb2c4cc8c9aae25$var$isLeapYear(date.year)) length++;
        return length;
    }
    getMonthsInYear() {
        return 12;
    }
    getDaysInYear(date) {
        return $ecb2c4cc8c9aae25$var$isLeapYear(date.year) ? 355 : 354;
    }
    getYearsInEra() {
        // 9999 gregorian
        return 9665;
    }
    getEras() {
        return [
            "AH"
        ];
    }
    constructor(){
        (0, ($parcel$interopDefault($kgI3C$swchelperslib_define_propertyjs)))(this, "identifier", "islamic-civil");
    }
}
class $ecb2c4cc8c9aae25$export$37f0887f2f9d22f7 extends $ecb2c4cc8c9aae25$export$2066795aadd37bfc {
    fromJulianDay(jd) {
        return $ecb2c4cc8c9aae25$var$julianDayToIslamic(this, $ecb2c4cc8c9aae25$var$ASTRONOMICAL_EPOC, jd);
    }
    toJulianDay(date) {
        return $ecb2c4cc8c9aae25$var$islamicToJulianDay($ecb2c4cc8c9aae25$var$ASTRONOMICAL_EPOC, date.year, date.month, date.day);
    }
    constructor(...args){
        super(...args);
        (0, ($parcel$interopDefault($kgI3C$swchelperslib_define_propertyjs)))(this, "identifier", "islamic-tbla");
    }
}
// Generated by scripts/generate-umalqura.js
const $ecb2c4cc8c9aae25$var$UMALQURA_DATA = "qgpUDckO1AbqBmwDrQpVBakGkgepC9QF2gpcBS0NlQZKB1QLagutBa4ETwoXBYsGpQbVCtYCWwmdBE0KJg2VDawFtgm6AlsKKwWVCsoG6Qr0AnYJtgJWCcoKpAvSC9kF3AJtCU0FpQpSC6ULtAW2CVcFlwJLBaMGUgdlC2oFqworBZUMSg2lDcoF1gpXCasESwmlClILagt1BXYCtwhbBFUFqQW0BdoJ3QRuAjYJqgpUDbIN1QXaAlsJqwRVCkkLZAtxC7QFtQpVCiUNkg7JDtQG6QprCasEkwpJDaQNsg25CroEWworBZUKKgtVC1wFvQQ9Ah0JlQpKC1oLbQW2AjsJmwRVBqkGVAdqC2wFrQpVBSkLkgupC9QF2gpaBasKlQVJB2QHqgu1BbYCVgpNDiULUgtqC60FrgIvCZcESwalBqwG1gpdBZ0ETQoWDZUNqgW1BdoCWwmtBJUFygbkBuoK9QS2AlYJqgpUC9IL2QXqAm0JrQSVCkoLpQuyBbUJ1gSXCkcFkwZJB1ULagVrCisFiwpGDaMNygXWCtsEawJLCaUKUgtpC3UFdgG3CFsCKwVlBbQF2gntBG0BtgimClINqQ3UBdoKWwmrBFMGKQdiB6kLsgW1ClUFJQuSDckO0gbpCmsFqwRVCikNVA2qDbUJugQ7CpsETQqqCtUK2gJdCV4ELgqaDFUNsga5BroEXQotBZUKUguoC7QLuQXaAloJSgukDdEO6AZqC20FNQWVBkoNqA3UDdoGWwWdAisGFQtKC5ULqgWuCi4JjwwnBZUGqgbWCl0FnQI=";
let $ecb2c4cc8c9aae25$var$UMALQURA_MONTHLENGTH;
let $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START_TABLE;
function $ecb2c4cc8c9aae25$var$umalquraYearStart(year) {
    return $ecb2c4cc8c9aae25$var$UMALQURA_START_DAYS + $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START_TABLE[year - $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START];
}
function $ecb2c4cc8c9aae25$var$umalquraMonthLength(year, month) {
    let idx = year - $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START;
    let mask = 0x01 << 11 - (month - 1);
    if (($ecb2c4cc8c9aae25$var$UMALQURA_MONTHLENGTH[idx] & mask) === 0) return 29;
    else return 30;
}
function $ecb2c4cc8c9aae25$var$umalquraMonthStart(year, month) {
    let day = $ecb2c4cc8c9aae25$var$umalquraYearStart(year);
    for(let i = 1; i < month; i++)day += $ecb2c4cc8c9aae25$var$umalquraMonthLength(year, i);
    return day;
}
function $ecb2c4cc8c9aae25$var$umalquraYearLength(year) {
    return $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START_TABLE[year + 1 - $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START] - $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START_TABLE[year - $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START];
}
class $ecb2c4cc8c9aae25$export$5baab4758c231076 extends $ecb2c4cc8c9aae25$export$2066795aadd37bfc {
    fromJulianDay(jd) {
        let days = jd - $ecb2c4cc8c9aae25$var$CIVIL_EPOC;
        let startDays = $ecb2c4cc8c9aae25$var$umalquraYearStart($ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START);
        let endDays = $ecb2c4cc8c9aae25$var$umalquraYearStart($ecb2c4cc8c9aae25$var$UMALQURA_YEAR_END);
        if (days < startDays || days > endDays) return super.fromJulianDay(jd);
        else {
            let y = $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START - 1;
            let m = 1;
            let d = 1;
            while(d > 0){
                y++;
                d = days - $ecb2c4cc8c9aae25$var$umalquraYearStart(y) + 1;
                let yearLength = $ecb2c4cc8c9aae25$var$umalquraYearLength(y);
                if (d === yearLength) {
                    m = 12;
                    break;
                } else if (d < yearLength) {
                    let monthLength = $ecb2c4cc8c9aae25$var$umalquraMonthLength(y, m);
                    m = 1;
                    while(d > monthLength){
                        d -= monthLength;
                        m++;
                        monthLength = $ecb2c4cc8c9aae25$var$umalquraMonthLength(y, m);
                    }
                    break;
                }
            }
            return new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)(this, y, m, days - $ecb2c4cc8c9aae25$var$umalquraMonthStart(y, m) + 1);
        }
    }
    toJulianDay(date) {
        if (date.year < $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START || date.year > $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_END) return super.toJulianDay(date);
        return $ecb2c4cc8c9aae25$var$CIVIL_EPOC + $ecb2c4cc8c9aae25$var$umalquraMonthStart(date.year, date.month) + (date.day - 1);
    }
    getDaysInMonth(date) {
        if (date.year < $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START || date.year > $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_END) return super.getDaysInMonth(date);
        return $ecb2c4cc8c9aae25$var$umalquraMonthLength(date.year, date.month);
    }
    getDaysInYear(date) {
        if (date.year < $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START || date.year > $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_END) return super.getDaysInYear(date);
        return $ecb2c4cc8c9aae25$var$umalquraYearLength(date.year);
    }
    constructor(){
        super();
        (0, ($parcel$interopDefault($kgI3C$swchelperslib_define_propertyjs)))(this, "identifier", "islamic-umalqura");
        if (!$ecb2c4cc8c9aae25$var$UMALQURA_MONTHLENGTH) $ecb2c4cc8c9aae25$var$UMALQURA_MONTHLENGTH = new Uint16Array(Uint8Array.from(atob($ecb2c4cc8c9aae25$var$UMALQURA_DATA), (c)=>c.charCodeAt(0)).buffer);
        if (!$ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START_TABLE) {
            $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START_TABLE = new Uint32Array($ecb2c4cc8c9aae25$var$UMALQURA_YEAR_END - $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START + 1);
            let yearStart = 0;
            for(let year = $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START; year <= $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_END; year++){
                $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START_TABLE[year - $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START] = yearStart;
                for(let i = 1; i <= 12; i++)yearStart += $ecb2c4cc8c9aae25$var$umalquraMonthLength(year, i);
            }
        }
    }
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from ICU.
// Original licensing can be found in the NOTICE file in the root directory of this source tree.



const $0f5324ee3bdd9396$var$HEBREW_EPOCH = 347997;
// Hebrew date calculations are performed in terms of days, hours, and
// "parts" (or halakim), which are 1/1080 of an hour, or 3 1/3 seconds.
const $0f5324ee3bdd9396$var$HOUR_PARTS = 1080;
const $0f5324ee3bdd9396$var$DAY_PARTS = 24 * $0f5324ee3bdd9396$var$HOUR_PARTS;
// An approximate value for the length of a lunar month.
// It is used to calculate the approximate year and month of a given
// absolute date.
const $0f5324ee3bdd9396$var$MONTH_DAYS = 29;
const $0f5324ee3bdd9396$var$MONTH_FRACT = 12 * $0f5324ee3bdd9396$var$HOUR_PARTS + 793;
const $0f5324ee3bdd9396$var$MONTH_PARTS = $0f5324ee3bdd9396$var$MONTH_DAYS * $0f5324ee3bdd9396$var$DAY_PARTS + $0f5324ee3bdd9396$var$MONTH_FRACT;
function $0f5324ee3bdd9396$var$isLeapYear(year) {
    return (0, $a5090d6430502238$export$842a2cf37af977e1)(year * 7 + 1, 19) < 7;
}
// Test for delay of start of new year and to avoid
// Sunday, Wednesday, and Friday as start of the new year.
function $0f5324ee3bdd9396$var$hebrewDelay1(year) {
    let months = Math.floor((235 * year - 234) / 19);
    let parts = 12084 + 13753 * months;
    let day = months * 29 + Math.floor(parts / 25920);
    if ((0, $a5090d6430502238$export$842a2cf37af977e1)(3 * (day + 1), 7) < 3) day += 1;
    return day;
}
// Check for delay in start of new year due to length of adjacent years
function $0f5324ee3bdd9396$var$hebrewDelay2(year) {
    let last = $0f5324ee3bdd9396$var$hebrewDelay1(year - 1);
    let present = $0f5324ee3bdd9396$var$hebrewDelay1(year);
    let next = $0f5324ee3bdd9396$var$hebrewDelay1(year + 1);
    if (next - present === 356) return 2;
    if (present - last === 382) return 1;
    return 0;
}
function $0f5324ee3bdd9396$var$startOfYear(year) {
    return $0f5324ee3bdd9396$var$hebrewDelay1(year) + $0f5324ee3bdd9396$var$hebrewDelay2(year);
}
function $0f5324ee3bdd9396$var$getDaysInYear(year) {
    return $0f5324ee3bdd9396$var$startOfYear(year + 1) - $0f5324ee3bdd9396$var$startOfYear(year);
}
function $0f5324ee3bdd9396$var$getYearType(year) {
    let yearLength = $0f5324ee3bdd9396$var$getDaysInYear(year);
    if (yearLength > 380) yearLength -= 30; // Subtract length of leap month.
    switch(yearLength){
        case 353:
            return 0; // deficient
        case 354:
            return 1; // normal
        case 355:
            return 2; // complete
    }
}
function $0f5324ee3bdd9396$var$getDaysInMonth(year, month) {
    // Normalize month numbers from 1 - 13, even on non-leap years
    if (month >= 6 && !$0f5324ee3bdd9396$var$isLeapYear(year)) month++;
    // First of all, dispose of fixed-length 29 day months
    if (month === 4 || month === 7 || month === 9 || month === 11 || month === 13) return 29;
    let yearType = $0f5324ee3bdd9396$var$getYearType(year);
    // If it's Heshvan, days depend on length of year
    if (month === 2) return yearType === 2 ? 30 : 29;
    // Similarly, Kislev varies with the length of year
    if (month === 3) return yearType === 0 ? 29 : 30;
    // Adar I only exists in leap years
    if (month === 6) return $0f5324ee3bdd9396$var$isLeapYear(year) ? 30 : 0;
    return 30;
}
class $0f5324ee3bdd9396$export$ca405048b8fb5af {
    fromJulianDay(jd) {
        let d = jd - $0f5324ee3bdd9396$var$HEBREW_EPOCH;
        let m = d * $0f5324ee3bdd9396$var$DAY_PARTS / $0f5324ee3bdd9396$var$MONTH_PARTS; // Months (approx)
        let year = Math.floor((19 * m + 234) / 235) + 1; // Years (approx)
        let ys = $0f5324ee3bdd9396$var$startOfYear(year); // 1st day of year
        let dayOfYear = Math.floor(d - ys);
        // Because of the postponement rules, it's possible to guess wrong.  Fix it.
        while(dayOfYear < 1){
            year--;
            ys = $0f5324ee3bdd9396$var$startOfYear(year);
            dayOfYear = Math.floor(d - ys);
        }
        // Now figure out which month we're in, and the date within that month
        let month = 1;
        let monthStart = 0;
        while(monthStart < dayOfYear){
            monthStart += $0f5324ee3bdd9396$var$getDaysInMonth(year, month);
            month++;
        }
        month--;
        monthStart -= $0f5324ee3bdd9396$var$getDaysInMonth(year, month);
        let day = dayOfYear - monthStart;
        return new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)(this, year, month, day);
    }
    toJulianDay(date) {
        let jd = $0f5324ee3bdd9396$var$startOfYear(date.year);
        for(let month = 1; month < date.month; month++)jd += $0f5324ee3bdd9396$var$getDaysInMonth(date.year, month);
        return jd + date.day + $0f5324ee3bdd9396$var$HEBREW_EPOCH;
    }
    getDaysInMonth(date) {
        return $0f5324ee3bdd9396$var$getDaysInMonth(date.year, date.month);
    }
    getMonthsInYear(date) {
        return $0f5324ee3bdd9396$var$isLeapYear(date.year) ? 13 : 12;
    }
    getDaysInYear(date) {
        return $0f5324ee3bdd9396$var$getDaysInYear(date.year);
    }
    getYearsInEra() {
        // 6239 gregorian
        return 9999;
    }
    getEras() {
        return [
            "AM"
        ];
    }
    balanceYearMonth(date, previousDate) {
        // Keep date in the same month when switching between leap years and non leap years
        if (previousDate.year !== date.year) {
            if ($0f5324ee3bdd9396$var$isLeapYear(previousDate.year) && !$0f5324ee3bdd9396$var$isLeapYear(date.year) && previousDate.month > 6) date.month--;
            else if (!$0f5324ee3bdd9396$var$isLeapYear(previousDate.year) && $0f5324ee3bdd9396$var$isLeapYear(date.year) && previousDate.month > 6) date.month++;
        }
    }
    constructor(){
        (0, ($parcel$interopDefault($kgI3C$swchelperslib_define_propertyjs)))(this, "identifier", "hebrew");
    }
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from ICU.
// Original licensing can be found in the NOTICE file in the root directory of this source tree.


const $4db04d1051af0f2f$var$ETHIOPIC_EPOCH = 1723856;
const $4db04d1051af0f2f$var$COPTIC_EPOCH = 1824665;
// The delta between Amete Alem 1 and Amete Mihret 1
// AA 5501 = AM 1
const $4db04d1051af0f2f$var$AMETE_MIHRET_DELTA = 5500;
function $4db04d1051af0f2f$var$ceToJulianDay(epoch, year, month, day) {
    return epoch // difference from Julian epoch to 1,1,1
     + 365 * year // number of days from years
     + Math.floor(year / 4) // extra day of leap year
     + 30 * (month - 1 // number of days from months (1 based)
    ) + day - 1 // number of days for present month (1 based)
    ;
}
function $4db04d1051af0f2f$var$julianDayToCE(epoch, jd) {
    let year = Math.floor(4 * (jd - epoch) / 1461);
    let month = 1 + Math.floor((jd - $4db04d1051af0f2f$var$ceToJulianDay(epoch, year, 1, 1)) / 30);
    let day = jd + 1 - $4db04d1051af0f2f$var$ceToJulianDay(epoch, year, month, 1);
    return [
        year,
        month,
        day
    ];
}
function $4db04d1051af0f2f$var$getLeapDay(year) {
    return Math.floor(year % 4 / 3);
}
function $4db04d1051af0f2f$var$getDaysInMonth(year, month) {
    // The Ethiopian and Coptic calendars have 13 months, 12 of 30 days each and
    // an intercalary month at the end of the year of 5 or 6 days, depending whether
    // the year is a leap year or not. The Leap Year follows the same rules as the
    // Julian Calendar so that the extra month always has six days in the year before
    // a Julian Leap Year.
    if (month % 13 !== 0) // not intercalary month
    return 30;
    else // intercalary month 5 days + possible leap day
    return $4db04d1051af0f2f$var$getLeapDay(year) + 5;
}
class $4db04d1051af0f2f$export$26ba6eab5e20cd7d {
    fromJulianDay(jd) {
        let [year, month, day] = $4db04d1051af0f2f$var$julianDayToCE($4db04d1051af0f2f$var$ETHIOPIC_EPOCH, jd);
        let era = "AM";
        if (year <= 0) {
            era = "AA";
            year += $4db04d1051af0f2f$var$AMETE_MIHRET_DELTA;
        }
        return new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)(this, era, year, month, day);
    }
    toJulianDay(date) {
        let year = date.year;
        if (date.era === "AA") year -= $4db04d1051af0f2f$var$AMETE_MIHRET_DELTA;
        return $4db04d1051af0f2f$var$ceToJulianDay($4db04d1051af0f2f$var$ETHIOPIC_EPOCH, year, date.month, date.day);
    }
    getDaysInMonth(date) {
        return $4db04d1051af0f2f$var$getDaysInMonth(date.year, date.month);
    }
    getMonthsInYear() {
        return 13;
    }
    getDaysInYear(date) {
        return 365 + $4db04d1051af0f2f$var$getLeapDay(date.year);
    }
    getYearsInEra(date) {
        // 9999-12-31 gregorian is 9992-20-02 ethiopic.
        // Round down to 9991 for the last full year.
        // AA 9999-01-01 ethiopic is 4506-09-30 gregorian.
        return date.era === "AA" ? 9999 : 9991;
    }
    getEras() {
        return [
            "AA",
            "AM"
        ];
    }
    constructor(){
        (0, ($parcel$interopDefault($kgI3C$swchelperslib_define_propertyjs)))(this, "identifier", "ethiopic");
    }
}
class $4db04d1051af0f2f$export$d72e0c37005a4914 extends $4db04d1051af0f2f$export$26ba6eab5e20cd7d {
    fromJulianDay(jd) {
        let [year, month, day] = $4db04d1051af0f2f$var$julianDayToCE($4db04d1051af0f2f$var$ETHIOPIC_EPOCH, jd);
        year += $4db04d1051af0f2f$var$AMETE_MIHRET_DELTA;
        return new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)(this, "AA", year, month, day);
    }
    getEras() {
        return [
            "AA"
        ];
    }
    getYearsInEra() {
        // 9999-13-04 ethioaa is the maximum date, which is equivalent to 4506-09-29 gregorian.
        return 9999;
    }
    constructor(...args){
        super(...args);
        (0, ($parcel$interopDefault($kgI3C$swchelperslib_define_propertyjs)))(this, "identifier", "ethioaa") // also known as 'ethiopic-amete-alem' in ICU
        ;
    }
}
class $4db04d1051af0f2f$export$fe6243cbe1a4b7c1 extends $4db04d1051af0f2f$export$26ba6eab5e20cd7d {
    fromJulianDay(jd) {
        let [year, month, day] = $4db04d1051af0f2f$var$julianDayToCE($4db04d1051af0f2f$var$COPTIC_EPOCH, jd);
        let era = "CE";
        if (year <= 0) {
            era = "BCE";
            year = 1 - year;
        }
        return new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)(this, era, year, month, day);
    }
    toJulianDay(date) {
        let year = date.year;
        if (date.era === "BCE") year = 1 - year;
        return $4db04d1051af0f2f$var$ceToJulianDay($4db04d1051af0f2f$var$COPTIC_EPOCH, year, date.month, date.day);
    }
    getDaysInMonth(date) {
        let year = date.year;
        if (date.era === "BCE") year = 1 - year;
        return $4db04d1051af0f2f$var$getDaysInMonth(year, date.month);
    }
    isInverseEra(date) {
        return date.era === "BCE";
    }
    balanceDate(date) {
        if (date.year <= 0) {
            date.era = date.era === "BCE" ? "CE" : "BCE";
            date.year = 1 - date.year;
        }
    }
    getEras() {
        return [
            "BCE",
            "CE"
        ];
    }
    getYearsInEra(date) {
        // 9999-12-30 gregorian is 9716-02-20 coptic.
        // Round down to 9715 for the last full year.
        // BCE 9999-01-01 coptic is BC 9716-06-15 gregorian.
        return date.era === "BCE" ? 9999 : 9715;
    }
    constructor(...args){
        super(...args);
        (0, ($parcel$interopDefault($kgI3C$swchelperslib_define_propertyjs)))(this, "identifier", "coptic");
    }
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 








function $4922c0a5a69da0ba$export$dd0bbc9b26defe37(name) {
    switch(name){
        case "buddhist":
            return new (0, $561c4ef058278b74$export$42d20a78301dee44)();
        case "ethiopic":
            return new (0, $4db04d1051af0f2f$export$26ba6eab5e20cd7d)();
        case "ethioaa":
            return new (0, $4db04d1051af0f2f$export$d72e0c37005a4914)();
        case "coptic":
            return new (0, $4db04d1051af0f2f$export$fe6243cbe1a4b7c1)();
        case "hebrew":
            return new (0, $0f5324ee3bdd9396$export$ca405048b8fb5af)();
        case "indian":
            return new (0, $5f1dfa5c67609fe6$export$39f31c639fa15726)();
        case "islamic-civil":
            return new (0, $ecb2c4cc8c9aae25$export$2066795aadd37bfc)();
        case "islamic-tbla":
            return new (0, $ecb2c4cc8c9aae25$export$37f0887f2f9d22f7)();
        case "islamic-umalqura":
            return new (0, $ecb2c4cc8c9aae25$export$5baab4758c231076)();
        case "japanese":
            return new (0, $b0ac0602ef646b2c$export$b746ab2b60cdffbf)();
        case "persian":
            return new (0, $3c060181fc7249ae$export$37fccdbfd14c5939)();
        case "roc":
            return new (0, $9cc5d3577ec40243$export$65e01080afcb0799)();
        case "gregory":
        default:
            return new (0, $af14c9812fdceb33$export$80ee6245ec4f29ec)();
    }
}





/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ let $8f23a04ae90a588b$var$formatterCache = new Map();
class $8f23a04ae90a588b$export$ad991b66133851cf {
    /** Formats a date as a string according to the locale and format options passed to the constructor. */ format(value) {
        return this.formatter.format(value);
    }
    /** Formats a date to an array of parts such as separators, numbers, punctuation, and more. */ formatToParts(value) {
        return this.formatter.formatToParts(value);
    }
    /** Formats a date range as a string. */ formatRange(start, end) {
        // @ts-ignore
        if (typeof this.formatter.formatRange === "function") // @ts-ignore
        return this.formatter.formatRange(start, end);
        if (end < start) throw new RangeError("End date must be >= start date");
        // Very basic fallback for old browsers.
        return `${this.formatter.format(start)}  ${this.formatter.format(end)}`;
    }
    /** Formats a date range as an array of parts. */ formatRangeToParts(start, end) {
        // @ts-ignore
        if (typeof this.formatter.formatRangeToParts === "function") // @ts-ignore
        return this.formatter.formatRangeToParts(start, end);
        if (end < start) throw new RangeError("End date must be >= start date");
        let startParts = this.formatter.formatToParts(start);
        let endParts = this.formatter.formatToParts(end);
        return [
            ...startParts.map((p)=>({
                    ...p,
                    source: "startRange"
                })),
            {
                type: "literal",
                value: "  ",
                source: "shared"
            },
            ...endParts.map((p)=>({
                    ...p,
                    source: "endRange"
                }))
        ];
    }
    /** Returns the resolved formatting options based on the values passed to the constructor. */ resolvedOptions() {
        let resolvedOptions = this.formatter.resolvedOptions();
        if ($8f23a04ae90a588b$var$hasBuggyResolvedHourCycle()) {
            if (!this.resolvedHourCycle) this.resolvedHourCycle = $8f23a04ae90a588b$var$getResolvedHourCycle(resolvedOptions.locale, this.options);
            resolvedOptions.hourCycle = this.resolvedHourCycle;
            resolvedOptions.hour12 = this.resolvedHourCycle === "h11" || this.resolvedHourCycle === "h12";
        }
        // Safari uses a different name for the Ethiopic (Amete Alem) calendar.
        // https://bugs.webkit.org/show_bug.cgi?id=241564
        if (resolvedOptions.calendar === "ethiopic-amete-alem") resolvedOptions.calendar = "ethioaa";
        return resolvedOptions;
    }
    constructor(locale, options = {}){
        this.formatter = $8f23a04ae90a588b$var$getCachedDateFormatter(locale, options);
        this.options = options;
    }
}
// There are multiple bugs involving the hour12 and hourCycle options in various browser engines.
//   - Chrome [1] (and the ECMA 402 spec [2]) resolve hour12: false in English and other locales to h24 (24:00 - 23:59)
//     rather than h23 (00:00 - 23:59). Same can happen with hour12: true in French, which Chrome resolves to h11 (00:00 - 11:59)
//     rather than h12 (12:00 - 11:59).
//   - WebKit returns an incorrect hourCycle resolved option in the French locale due to incorrect parsing of 'h' literal
//     in the resolved pattern. It also formats incorrectly when specifying the hourCycle option for the same reason. [3]
// [1] https://bugs.chromium.org/p/chromium/issues/detail?id=1045791
// [2] https://github.com/tc39/ecma402/issues/402
// [3] https://bugs.webkit.org/show_bug.cgi?id=229313
// https://github.com/unicode-org/cldr/blob/018b55eff7ceb389c7e3fc44e2f657eae3b10b38/common/supplemental/supplementalData.xml#L4774-L4802
const $8f23a04ae90a588b$var$hour12Preferences = {
    true: {
        // Only Japanese uses the h11 style for 12 hour time. All others use h12.
        ja: "h11"
    },
    false: {
    }
};
function $8f23a04ae90a588b$var$getCachedDateFormatter(locale, options = {}) {
    // Work around buggy hour12 behavior in Chrome / ECMA 402 spec by using hourCycle instead.
    // Only apply the workaround if the issue is detected, because the hourCycle option is buggy in Safari.
    if (typeof options.hour12 === "boolean" && $8f23a04ae90a588b$var$hasBuggyHour12Behavior()) {
        options = {
            ...options
        };
        let pref = $8f23a04ae90a588b$var$hour12Preferences[String(options.hour12)][locale.split("-")[0]];
        let defaultHourCycle = options.hour12 ? "h12" : "h23";
        options.hourCycle = pref !== null && pref !== void 0 ? pref : defaultHourCycle;
        delete options.hour12;
    }
    let cacheKey = locale + (options ? Object.entries(options).sort((a, b)=>a[0] < b[0] ? -1 : 1).join() : "");
    if ($8f23a04ae90a588b$var$formatterCache.has(cacheKey)) return $8f23a04ae90a588b$var$formatterCache.get(cacheKey);
    let numberFormatter = new Intl.DateTimeFormat(locale, options);
    $8f23a04ae90a588b$var$formatterCache.set(cacheKey, numberFormatter);
    return numberFormatter;
}
let $8f23a04ae90a588b$var$_hasBuggyHour12Behavior = null;
function $8f23a04ae90a588b$var$hasBuggyHour12Behavior() {
    if ($8f23a04ae90a588b$var$_hasBuggyHour12Behavior == null) $8f23a04ae90a588b$var$_hasBuggyHour12Behavior = new Intl.DateTimeFormat("en-US", {
        hour: "numeric",
        hour12: false
    }).format(new Date(2020, 2, 3, 0)) === "24";
    return $8f23a04ae90a588b$var$_hasBuggyHour12Behavior;
}
let $8f23a04ae90a588b$var$_hasBuggyResolvedHourCycle = null;
function $8f23a04ae90a588b$var$hasBuggyResolvedHourCycle() {
    if ($8f23a04ae90a588b$var$_hasBuggyResolvedHourCycle == null) $8f23a04ae90a588b$var$_hasBuggyResolvedHourCycle = new Intl.DateTimeFormat("fr", {
        hour: "numeric",
        hour12: false
    }).resolvedOptions().hourCycle === "h12";
    return $8f23a04ae90a588b$var$_hasBuggyResolvedHourCycle;
}
function $8f23a04ae90a588b$var$getResolvedHourCycle(locale, options) {
    if (!options.timeStyle && !options.hour) return undefined;
    // Work around buggy results in resolved hourCycle and hour12 options in WebKit.
    // Format the minimum possible hour and maximum possible hour in a day and parse the results.
    locale = locale.replace(/(-u-)?-nu-[a-zA-Z0-9]+/, "");
    locale += (locale.includes("-u-") ? "" : "-u") + "-nu-latn";
    let formatter = $8f23a04ae90a588b$var$getCachedDateFormatter(locale, {
        ...options,
        timeZone: undefined // use local timezone
    });
    let min = parseInt(formatter.formatToParts(new Date(2020, 2, 3, 0)).find((p)=>p.type === "hour").value, 10);
    let max = parseInt(formatter.formatToParts(new Date(2020, 2, 3, 23)).find((p)=>p.type === "hour").value, 10);
    if (min === 0 && max === 23) return "h23";
    if (min === 24 && max === 23) return "h24";
    if (min === 0 && max === 11) return "h11";
    if (min === 12 && max === 11) return "h12";
    throw new Error("Unexpected hour cycle result");
}




//# sourceMappingURL=main.js.map
