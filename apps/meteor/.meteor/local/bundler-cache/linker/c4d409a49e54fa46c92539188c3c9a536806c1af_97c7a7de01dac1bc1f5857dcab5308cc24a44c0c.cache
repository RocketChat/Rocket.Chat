[{"type":"js","data":"Package[\"core-runtime\"].queue(\"modules-runtime\",function () {/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar EmitterPromise = Package.meteor.EmitterPromise;\n\n/* Package-scope variables */\nvar makeInstaller, imports, cannotFindMeteorPackage, meteorInstall, verifyErrors;\n\n//////////////////////////////////////////////////////////////////////////////////////\n//                                                                                  //\n// packages/modules-runtime/.npm/package/node_modules/install/install.js            //\n// This file is in bare mode and is not in its own closure.                         //\n//                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////\n                                                                                    //\nmakeInstaller = function (options) {\n  \"use strict\";\n\n  options = options || {};\n\n  // These file extensions will be appended to required module identifiers\n  // if they do not exactly match an installed module.\n  var defaultExtensions = options.extensions || [\".js\", \".json\"];\n\n  // If defined, the options.fallback function will be called when no\n  // installed module is found for a required module identifier. Often\n  // options.fallback will be implemented in terms of the native Node\n  // require function, which has the ability to load binary modules.\n  var fallback = options.fallback;\n\n  // List of fields to look for in package.json files to determine the\n  // main entry module of the package. The first field listed here whose\n  // value is a string will be used to resolve the entry module.\n  var mainFields = options.mainFields ||\n    // If options.mainFields is absent and options.browser is truthy,\n    // package resolution will prefer the \"browser\" field of package.json\n    // files to the \"main\" field. Note that this only supports\n    // string-valued \"browser\" fields for now, though in the future it\n    // might make sense to support the object version, a la browserify.\n    (options.browser ? [\"browser\", \"main\"] : [\"main\"]);\n\n  var hasOwn = {}.hasOwnProperty;\n  function strictHasOwn(obj, key) {\n    return isObject(obj) && isString(key) && hasOwn.call(obj, key);\n  }\n\n  // Cache for looking up File objects given absolute module identifiers.\n  // Invariants:\n  //   filesByModuleId[module.id] === fileAppendId(root, module.id)\n  //   filesByModuleId[module.id].module === module\n  var filesByModuleId = {};\n\n  // The file object representing the root directory of the installed\n  // module tree.\n  var root = new File(\"/\", new File(\"/..\"));\n  var rootRequire = makeRequire(root);\n\n  // Merges the given tree of directories and module factory functions\n  // into the tree of installed modules and returns a require function\n  // that behaves as if called from a module in the root directory.\n  function install(tree, options) {\n    if (isObject(tree)) {\n      fileMergeContents(root, tree, options);\n    }\n    return rootRequire;\n  }\n\n  // Replace this function to enable Module.prototype.prefetch.\n  install.fetch = function (ids) {\n    throw new Error(\"fetch not implemented\");\n  };\n\n  // This constructor will be used to instantiate the module objects\n  // passed to module factory functions (i.e. the third argument after\n  // require and exports), and is exposed as install.Module in case the\n  // caller of makeInstaller wishes to modify Module.prototype.\n  function Module(id) {\n    this.id = id;\n\n    // The Node implementation of module.children unfortunately includes\n    // only those child modules that were imported for the first time by\n    // this parent module (i.e., child.parent === this).\n    this.children = [];\n\n    // This object is an install.js extension that includes all child\n    // modules imported by this module, even if this module is not the\n    // first to import them.\n    this.childrenById = {};\n  }\n\n  // Used to keep module.prefetch promise resolutions well-ordered.\n  var lastPrefetchPromise;\n\n  // May be shared by multiple sequential calls to module.prefetch.\n  // Initialized to {} only when necessary.\n  var missing;\n\n  Module.prototype.prefetch = function (id) {\n    var module = this;\n    var parentFile = getOwn(filesByModuleId, module.id);\n\n    lastPrefetchPromise = lastPrefetchPromise || Promise.resolve();\n    var previousPromise = lastPrefetchPromise;\n\n    function walk(module) {\n      var file = getOwn(filesByModuleId, module.id);\n      if (fileIsDynamic(file) && ! file.pending) {\n        file.pending = true;\n        missing = missing || {};\n\n        // These are the data that will be exposed to the install.fetch\n        // callback, so it's worth documenting each item with a comment.\n        missing[module.id] = {\n          // The CommonJS module object that will be exposed to this\n          // dynamic module when it is evaluated. Note that install.fetch\n          // could decide to populate module.exports directly, instead of\n          // fetching anything. In that case, install.fetch should omit\n          // this module from the tree that it produces.\n          module: file.module,\n          // List of module identifier strings imported by this module.\n          // Note that the missing object already contains all available\n          // dependencies (including transitive dependencies), so\n          // install.fetch should not need to traverse these dependencies\n          // in most cases; however, they may be useful for other reasons.\n          // Though the strings are unique, note that two different\n          // strings could resolve to the same module.\n          deps: Object.keys(file.deps),\n          // The options (if any) that were passed as the second argument\n          // to the install(tree, options) function when this stub was\n          // first registered. Typically contains options.extensions, but\n          // could contain any information appropriate for the entire tree\n          // as originally installed. These options will be automatically\n          // inherited by the newly fetched modules, so install.fetch\n          // should not need to modify them.\n          options: file.options,\n          // Any stub data included in the array notation from the\n          // original entry for this dynamic module. Typically contains\n          // \"main\" and/or \"browser\" fields for package.json files, and is\n          // otherwise undefined.\n          stub: file.stub\n        };\n\n        each(file.deps, function (parentId, id) {\n          fileResolve(file, id);\n        });\n\n        each(module.childrenById, walk);\n      }\n    }\n\n    return lastPrefetchPromise = new Promise(function (resolve) {\n      var absChildId = module.resolve(id);\n      each(module.childrenById, walk);\n      resolve(absChildId);\n\n    }).then(function (absChildId) {\n      // Grab the current missing object and fetch its contents.\n      var toBeFetched = missing;\n      missing = null;\n\n      function clearPending() {\n        if (toBeFetched) {\n          Object.keys(toBeFetched).forEach(function (id) {\n            getOwn(filesByModuleId, id).pending = false;\n          });\n        }\n      }\n\n      return new Promise(function (resolve) {\n        // The install.fetch function takes an object mapping missing\n        // dynamic module identifiers to options objects, and should\n        // return a Promise that resolves to a module tree that can be\n        // installed. As an optimization, if there were no missing dynamic\n        // modules, then we can skip calling install.fetch entirely.\n        resolve(toBeFetched && install.fetch(toBeFetched));\n\n      }).then(function (tree) {\n        function both() {\n          install(tree);\n          clearPending();\n          return absChildId;\n        }\n\n        // Although we want multiple install.fetch calls to run in\n        // parallel, it is important that the promises returned by\n        // module.prefetch are resolved in the same order as the original\n        // calls to module.prefetch, because previous fetches may include\n        // modules assumed to exist by more recent module.prefetch calls.\n        // Whether previousPromise was resolved or rejected, carry on with\n        // the installation regardless.\n        return previousPromise.then(both, both);\n\n      }, function (error) {\n        // Fixes https://github.com/meteor/meteor/issues/10182.\n        clearPending();\n        throw error;\n      });\n    });\n  };\n\n  install.Module = Module;\n\n  function getOwn(obj, key) {\n    return strictHasOwn(obj, key) && obj[key];\n  }\n\n  function isObject(value) {\n    return value !== null && typeof value === \"object\";\n  }\n\n  function isFunction(value) {\n    return typeof value === \"function\";\n  }\n\n  function isString(value) {\n    return typeof value === \"string\";\n  }\n\n  function makeMissingError(id) {\n    return new Error(\"Cannot find module '\" + id + \"'\");\n  }\n\n  Module.prototype.resolve = function (id) {\n    var file = fileResolve(filesByModuleId[this.id], id);\n    if (file) return file.module.id;\n    var error = makeMissingError(id);\n    if (fallback && isFunction(fallback.resolve)) {\n      return fallback.resolve(id, this.id, error);\n    }\n    throw error;\n  };\n\n  Module.prototype.require = function require(id) {\n    var result = fileResolve(filesByModuleId[this.id], id);\n    if (result) {\n      return fileEvaluate(result, this);\n    }\n\n    var error = makeMissingError(id);\n\n    if (isFunction(fallback)) {\n      return fallback(\n        id, // The missing module identifier.\n        this.id, // ID of the parent module.\n        error // The error we would have thrown.\n      );\n    }\n\n    throw error;\n  };\n\n  function makeRequire(file) {\n    var module = file.module;\n\n    function require(id) {\n      return module.require(id);\n    }\n\n    require.extensions = fileGetExtensions(file).slice(0);\n\n    require.resolve = function resolve(id) {\n      return module.resolve(id);\n    };\n\n    return require;\n  }\n\n  // File objects represent either directories or modules that have been\n  // installed. When a `File` respresents a directory, its `.contents`\n  // property is an object containing the names of the files (or\n  // directories) that it contains. When a `File` represents a module, its\n  // `.contents` property is a function that can be invoked with the\n  // appropriate `(require, exports, module)` arguments to evaluate the\n  // module. If the `.contents` property is a string, that string will be\n  // resolved as a module identifier, and the exports of the resulting\n  // module will provide the exports of the original file. The `.parent`\n  // property of a File is either a directory `File` or `null`. Note that\n  // a child may claim another `File` as its parent even if the parent\n  // does not have an entry for that child in its `.contents` object.\n  // This is important for implementing anonymous files, and preventing\n  // child modules from using `../relative/identifier` syntax to examine\n  // unrelated modules.\n  function File(moduleId, parent) {\n    var file = this;\n\n    // Link to the parent file.\n    file.parent = parent = parent || null;\n\n    // The module object for this File, which will eventually boast an\n    // .exports property when/if the file is evaluated.\n    file.module = new Module(moduleId);\n    filesByModuleId[moduleId] = file;\n\n    // The .contents of the file can be either (1) an object, if the file\n    // represents a directory containing other files; (2) a factory\n    // function, if the file represents a module that can be imported; (3)\n    // a string, if the file is an alias for another file; or (4) null, if\n    // the file's contents are not (yet) available.\n    file.contents = null;\n\n    // Set of module identifiers imported by this module. Note that this\n    // set is not necessarily complete, so don't rely on it unless you\n    // know what you're doing.\n    file.deps = {};\n  }\n\n  function fileEvaluate(file, parentModule) {\n    var module = file.module;\n    if (! strictHasOwn(module, \"exports\")) {\n      var contents = file.contents;\n      if (! contents) {\n        // If this file was installed with array notation, and the array\n        // contained one or more objects but no functions, then the combined\n        // properties of the objects are treated as a temporary stub for\n        // file.module.exports. This is particularly important for partial\n        // package.json modules, so that the resolution logic can know the\n        // value of the \"main\" and/or \"browser\" fields, at least, even if\n        // the rest of the package.json file is not (yet) available.\n        if (file.stub) {\n          return file.stub;\n        }\n\n        throw makeMissingError(module.id);\n      }\n\n      if (parentModule) {\n        module.parent = parentModule;\n        var children = parentModule.children;\n        if (Array.isArray(children)) {\n          children.push(module);\n        }\n      }\n\n      contents(\n        makeRequire(file),\n        // If the file had a .stub, reuse the same object for exports.\n        module.exports = file.stub || {},\n        module,\n        file.module.id,\n        file.parent.module.id\n      );\n\n      module.loaded = true;\n    }\n\n    // The module.runModuleSetters method will be deprecated in favor of\n    // just module.runSetters: https://github.com/benjamn/reify/pull/160\n    var runSetters = module.runSetters || module.runModuleSetters;\n    if (isFunction(runSetters)) {\n      runSetters.call(module);\n    }\n\n    return module.exports;\n  }\n\n  function fileIsDirectory(file) {\n    return file && isObject(file.contents);\n  }\n\n  function fileIsDynamic(file) {\n    return file && file.contents === null;\n  }\n\n  function fileMergeContents(file, contents, options) {\n    if (Array.isArray(contents)) {\n      contents.forEach(function (item) {\n        if (isString(item)) {\n          file.deps[item] = file.module.id;\n        } else if (isFunction(item)) {\n          contents = item;\n        } else if (isObject(item)) {\n          file.stub = file.stub || {};\n          each(item, function (value, key) {\n            file.stub[key] = value;\n          });\n        }\n      });\n\n      if (! isFunction(contents)) {\n        // If the array did not contain a function, merge nothing.\n        contents = null;\n      }\n\n    } else if (! isFunction(contents) &&\n               ! isString(contents) &&\n               ! isObject(contents)) {\n      // If contents is neither an array nor a function nor a string nor\n      // an object, just give up and merge nothing.\n      contents = null;\n    }\n\n    if (contents) {\n      file.contents = file.contents || (isObject(contents) ? {} : contents);\n      if (isObject(contents) && fileIsDirectory(file)) {\n        each(contents, function (value, key) {\n          if (key === \"..\") {\n            child = file.parent;\n\n          } else {\n            var child = getOwn(file.contents, key);\n\n            if (! child) {\n              child = file.contents[key] = new File(\n                file.module.id.replace(/\\/*$/, \"/\") + key,\n                file\n              );\n\n              child.options = options;\n            }\n          }\n\n          fileMergeContents(child, value, options);\n        });\n      }\n    }\n  }\n\n  function each(obj, callback, context) {\n    Object.keys(obj).forEach(function (key) {\n      callback.call(this, obj[key], key);\n    }, context);\n  }\n\n  function fileGetExtensions(file) {\n    return file.options\n      && file.options.extensions\n      || defaultExtensions;\n  }\n\n  function fileAppendIdPart(file, part, extensions) {\n    // Always append relative to a directory.\n    while (file && ! fileIsDirectory(file)) {\n      file = file.parent;\n    }\n\n    if (! file || ! part || part === \".\") {\n      return file;\n    }\n\n    if (part === \"..\") {\n      return file.parent;\n    }\n\n    var exactChild = getOwn(file.contents, part);\n\n    // Only consider multiple file extensions if this part is the last\n    // part of a module identifier and not equal to `.` or `..`, and there\n    // was no exact match or the exact match was a directory.\n    if (extensions && (! exactChild || fileIsDirectory(exactChild))) {\n      for (var e = 0; e < extensions.length; ++e) {\n        var child = getOwn(file.contents, part + extensions[e]);\n        if (child && ! fileIsDirectory(child)) {\n          return child;\n        }\n      }\n    }\n\n    return exactChild;\n  }\n\n  function fileAppendId(file, id, extensions) {\n    var parts = id.split(\"/\");\n\n    // Use `Array.prototype.every` to terminate iteration early if\n    // `fileAppendIdPart` returns a falsy value.\n    parts.every(function (part, i) {\n      return file = i < parts.length - 1\n        ? fileAppendIdPart(file, part)\n        : fileAppendIdPart(file, part, extensions);\n    });\n\n    return file;\n  }\n\n  function recordChild(parentModule, childFile) {\n    var childModule = childFile && childFile.module;\n    if (parentModule && childModule) {\n      parentModule.childrenById[childModule.id] = childModule;\n    }\n  }\n\n  function fileResolve(file, id, parentModule, seenDirFiles) {\n    var parentModule = parentModule || file.module;\n    var extensions = fileGetExtensions(file);\n\n    file =\n      // Absolute module identifiers (i.e. those that begin with a `/`\n      // character) are interpreted relative to the root directory, which\n      // is a slight deviation from Node, which has access to the entire\n      // file system.\n      id.charAt(0) === \"/\" ? fileAppendId(root, id, extensions) :\n      // Relative module identifiers are interpreted relative to the\n      // current file, naturally.\n      id.charAt(0) === \".\" ? fileAppendId(file, id, extensions) :\n      // Top-level module identifiers are interpreted as referring to\n      // packages in `node_modules` directories.\n      nodeModulesLookup(file, id, extensions);\n\n    // If the identifier resolves to a directory, we use the same logic as\n    // Node to find an `index.js` or `package.json` file to evaluate.\n    while (fileIsDirectory(file)) {\n      seenDirFiles = seenDirFiles || [];\n\n      // If the \"main\" field of a `package.json` file resolves to a\n      // directory we've already considered, then we should not attempt to\n      // read the same `package.json` file again. Using an array as a set\n      // is acceptable here because the number of directories to consider\n      // is rarely greater than 1 or 2. Also, using indexOf allows us to\n      // store File objects instead of strings.\n      if (seenDirFiles.indexOf(file) < 0) {\n        seenDirFiles.push(file);\n\n        var pkgJsonFile = fileAppendIdPart(file, \"package.json\");\n        var pkg = pkgJsonFile && fileEvaluate(pkgJsonFile, parentModule);\n        var mainFile, resolved = pkg && mainFields.some(function (name) {\n          var main = pkg[name];\n          if (isString(main)) {\n            // The \"main\" field of package.json does not have to begin\n            // with ./ to be considered relative, so first we try\n            // simply appending it to the directory path before\n            // falling back to a full fileResolve, which might return\n            // a package from a node_modules directory.\n            return mainFile = fileAppendId(file, main, extensions) ||\n              fileResolve(file, main, parentModule, seenDirFiles);\n          }\n        });\n\n        if (resolved && mainFile) {\n          file = mainFile;\n          recordChild(parentModule, pkgJsonFile);\n          // The fileAppendId call above may have returned a directory,\n          // so continue the loop to make sure we resolve it to a\n          // non-directory file.\n          continue;\n        }\n      }\n\n      // If we didn't find a `package.json` file, or it didn't have a\n      // resolvable `.main` property, the only possibility left to\n      // consider is that this directory contains an `index.js` module.\n      // This assignment almost always terminates the while loop, because\n      // there's very little chance `fileIsDirectory(file)` will be true\n      // for `fileAppendIdPart(file, \"index\", extensions)`. However, in\n      // principle it is remotely possible that a file called `index.js`\n      // could be a directory instead of a file.\n      file = fileAppendIdPart(file, \"index\", extensions);\n    }\n\n    if (file && isString(file.contents)) {\n      file = fileResolve(file, file.contents, parentModule, seenDirFiles);\n    }\n\n    recordChild(parentModule, file);\n\n    return file;\n  };\n\n  function nodeModulesLookup(file, id, extensions) {\n    for (var resolved; file && ! resolved; file = file.parent) {\n      resolved = fileIsDirectory(file) &&\n        fileAppendId(file, \"node_modules/\" + id, extensions);\n    }\n    return resolved;\n  }\n\n  return install;\n};\n\nif (typeof exports === \"object\") {\n  exports.makeInstaller = makeInstaller;\n}\n\n//////////////////////////////////////////////////////////////////////////////////////\n\n\n\n\n\n\n\n(function(){\n\n//////////////////////////////////////////////////////////////////////////////////////\n//                                                                                  //\n// packages/modules-runtime/errors/importsErrors.js                                 //\n//                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////\n                                                                                    //\n/**\n *\n * @param id{string}\n * @return {{fromServer: (function(): Error), from: (function(location: string): boolean), fromClient: (function(): Error)}}\n */\nimports = function (id) {\n  /**\n   *\n   * @param location{string}\n   * @return {boolean}\n   */\n  var from =\n    function (location) {\n      if (!id) {\n        return false;\n      }\n\n      // XXX: removed last part of path so that it does not trigger false positives\n      var path = String(id).split('/').slice(0, -1);\n\n      return path.some(function (subPath) {\n        return subPath === location;\n      });\n    };\n\n  var fromClientError =\n    function () {\n      return new Error(\n        'Unable to import on the server a module from a client directory: \"' + id + '\" \\n (cross-boundary import) see: https://guide.meteor.com/structure.html#special-directories'\n      );\n    };\n\n\n  var fromServerError =\n    function () {\n      return new Error(\n        'Unable to import on the client a module from a server directory: \"' + id + '\" \\n (cross-boundary import) see: https://guide.meteor.com/structure.html#special-directories'\n      );\n    };\n\n  return {\n    from: from,\n    fromClientError: fromClientError,\n    fromServerError: fromServerError\n  };\n};\n\n//////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n//////////////////////////////////////////////////////////////////////////////////////\n//                                                                                  //\n// packages/modules-runtime/errors/cannotFindMeteorPackage.js                       //\n//                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////\n                                                                                    //\n/**\n * @description Default error message for when a package is not found\n * @param id{string}\n * @return {Error}\n */\ncannotFindMeteorPackage = function(id) {\n  var packageName = id.split('/', 2)[1];\n  return new Error(\n    'Cannot find package \"' + packageName + '\". ' +\n    'Try \"meteor add ' + packageName + '\".'\n  );\n};\n\n//////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n//////////////////////////////////////////////////////////////////////////////////////\n//                                                                                  //\n// packages/modules-runtime/server.js                                               //\n//                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////\n                                                                                    //\n// Options that will be populated below and then passed to makeInstaller.\nvar makeInstallerOptions = {};\n\n// RegExp matching strings that don't start with a `.` or a `/`.\nvar topLevelIdPattern = /^[^./]/;\n\n// This function will be called whenever a module identifier that hasn't\n// been installed is required. For backwards compatibility, and so that we\n// can require binary dependencies on the server, we implement the\n// fallback in terms of Npm.require.\nmakeInstallerOptions.fallback = function (id, parentId, error) {\n  // For simplicity, we honor only top-level module identifiers here.\n  // We could try to honor relative and absolute module identifiers by\n  // somehow combining `id` with `dir`, but we'd have to be really careful\n  // that the resulting modules were located in a known directory (not\n  // some arbitrary location on the file system), and we only really need\n  // the fallback for dependencies installed in node_modules directories.\n  if (topLevelIdPattern.test(id)) {\n    if (id && id.startsWith('meteor/')) {\n      const [meteorPrefix, packageName] = id.split('/', 2);\n      throw new Error(\n        `Cannot find package \"${packageName}\". ` +\n        `Try \"meteor add ${packageName}\".`\n      );\n    }\n    if (typeof Npm === \"object\" &&\n        typeof Npm.require === \"function\") {\n      return Npm.require(id, error);\n    }\n  }\n  verifyErrors(id, parentId, error);\n  throw error;\n};\n\nmakeInstallerOptions.fallback.resolve = function (id, parentId, error) {\n  if (topLevelIdPattern.test(id)) {\n    // Allow any top-level identifier to resolve to itself on the server,\n    // so that makeInstallerOptions.fallback has a chance to handle it.\n    return id;\n  }\n\n  throw error;\n};\n\nmeteorInstall = makeInstaller(makeInstallerOptions);\nvar Module = meteorInstall.Module;\n\nModule.prototype.useNode = function () {\n  if (typeof npmRequire !== \"function\") {\n    // Can't use Node if npmRequire is not defined.\n    throw new Error('npmRequire must be defined to use useNode');\n  }\n\n  try {\n    npmRequire.resolve(this.id);\n  } catch (e) {\n    throw new Error(\n      `Cannot find module \"${this.id}\". ` +\n      `Try installing the npm package or make sure it is not a devDependency.`\n    );\n  }\n\n  // See tools/static-assets/server/npm-require.js for the implementation\n  // of npmRequire. Note that this strategy fails when importing ESM\n  // modules (typically, a .js file in a package with \"type\": \"module\" in\n  // its package.json), as of Node 12.16.0 (Meteor 1.9.1).\n  this.exports = npmRequire(this.id);\n};\n\n//////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n//////////////////////////////////////////////////////////////////////////////////////\n//                                                                                  //\n// packages/modules-runtime/profile.js                                              //\n//                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////\n                                                                                    //\nif (typeof Profile === \"function\" &&\n    process.env.METEOR_PROFILE) {\n  var Mp = meteorInstall.Module.prototype;\n  Mp.require = Profile(function (id) {\n    return \"require(\" + JSON.stringify(id) + \")\";\n  }, Mp.require);\n}\n\n//////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n//////////////////////////////////////////////////////////////////////////////////////\n//                                                                                  //\n// packages/modules-runtime/verifyErrors.js                                         //\n//                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////\n                                                                                    //\n\n/**\n *\n * @param id{string}\n * @param parentId{string}\n * @param err {Error}\n */\nverifyErrors = function (id, parentId,err)  {\n\n  if (id && id.startsWith('meteor/')) {\n    throw cannotFindMeteorPackage(id);\n  }\n\n  if(!(id.startsWith('.') || id.startsWith('/'))) {\n    throw err;\n  }\n\n  if (imports(id).from('node_modules')) {\n    // Problem with node modules\n    throw err;\n  }\n\n  // custom errors\n  if (Meteor.isServer && imports(id).from('client')) {\n    throw imports(id).fromClientError();\n  }\n  if (Meteor.isClient && imports(id).from('server')) {\n    throw imports(id).fromServerError();\n  }\n\n  if (err) {\n    throw err;\n  }\n};\n\n//////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nreturn {\n  export: function () { return {\n      meteorInstall: meteorInstall,\n      verifyErrors: verifyErrors\n    };}\n}});\n","servePath":"/packages/modules-runtime.js"}]