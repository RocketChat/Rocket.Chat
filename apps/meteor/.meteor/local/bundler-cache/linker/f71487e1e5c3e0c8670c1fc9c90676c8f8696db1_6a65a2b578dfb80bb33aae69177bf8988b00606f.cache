[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\nPackage[\"core-runtime\"].queue(\"mongo\",function () {/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar AllowDeny = Package['allow-deny'].AllowDeny;\nvar Random = Package.random.Random;\nvar EJSON = Package.ejson.EJSON;\nvar LocalCollection = Package.minimongo.LocalCollection;\nvar Minimongo = Package.minimongo.Minimongo;\nvar DDP = Package['ddp-client'].DDP;\nvar Tracker = Package.tracker.Tracker;\nvar Deps = Package.tracker.Deps;\nvar DiffSequence = Package['diff-sequence'].DiffSequence;\nvar MongoID = Package['mongo-id'].MongoID;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar Log = Package.logging.Log;\nvar meteorInstall = Package.modules.meteorInstall;\nvar Promise = Package.promise.Promise;\n\n/* Package-scope variables */\nvar Mongo, selector, callback, options;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"mongo\":{\"local_collection_driver.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/mongo/local_collection_driver.js                                                                           //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.export({\n  LocalCollectionDriver: () => LocalCollectionDriver\n});\nconst LocalCollectionDriver = new class LocalCollectionDriver {\n  constructor() {\n    this.noConnCollections = Object.create(null);\n  }\n  open(name, conn) {\n    if (!name) {\n      return new LocalCollection();\n    }\n    if (!conn) {\n      return ensureCollection(name, this.noConnCollections);\n    }\n    if (!conn._mongo_livedata_collections) {\n      conn._mongo_livedata_collections = Object.create(null);\n    }\n\n    // XXX is there a way to keep track of a connection's collections without\n    // dangling it off the connection object?\n    return ensureCollection(name, conn._mongo_livedata_collections);\n  }\n}();\nfunction ensureCollection(name, collections) {\n  return name in collections ? collections[name] : collections[name] = new LocalCollection(name);\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"collection.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/mongo/collection.js                                                                                        //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n!function (module1) {\n  let _objectSpread;\n  module1.link(\"@babel/runtime/helpers/objectSpread2\", {\n    default(v) {\n      _objectSpread = v;\n    }\n  }, 0);\n  let ASYNC_COLLECTION_METHODS, getAsyncMethodName;\n  module1.link(\"meteor/minimongo/constants\", {\n    ASYNC_COLLECTION_METHODS(v) {\n      ASYNC_COLLECTION_METHODS = v;\n    },\n    getAsyncMethodName(v) {\n      getAsyncMethodName = v;\n    }\n  }, 0);\n  let normalizeProjection;\n  module1.link(\"./mongo_utils\", {\n    normalizeProjection(v) {\n      normalizeProjection = v;\n    }\n  }, 1);\n  /**\n   * @summary Namespace for MongoDB-related items\n   * @namespace\n   */\n  Mongo = {};\n\n  /**\n   * @summary Constructor for a Collection\n   * @locus Anywhere\n   * @instancename collection\n   * @class\n   * @param {String} name The name of the collection.  If null, creates an unmanaged (unsynchronized) local collection.\n   * @param {Object} [options]\n   * @param {Object} options.connection The server connection that will manage this collection. Uses the default connection if not specified.  Pass the return value of calling [`DDP.connect`](#DDP-connect) to specify a different server. Pass `null` to specify no connection. Unmanaged (`name` is null) collections cannot specify a connection.\n   * @param {String} options.idGeneration The method of generating the `_id` fields of new documents in this collection.  Possible values:\n  \n   - **`'STRING'`**: random strings\n   - **`'MONGO'`**:  random [`Mongo.ObjectID`](#mongo_object_id) values\n  \n  The default id generation technique is `'STRING'`.\n   * @param {Function} options.transform An optional transformation function. Documents will be passed through this function before being returned from `fetch` or `findOneAsync`, and before being passed to callbacks of `observe`, `map`, `forEach`, `allow`, and `deny`. Transforms are *not* applied for the callbacks of `observeChanges` or to cursors returned from publish functions.\n   * @param {Boolean} options.defineMutationMethods Set to `false` to skip setting up the mutation methods that enable insert/update/remove from client code. Default `true`.\n   */\n  Mongo.Collection = function Collection(name, options) {\n    if (!name && name !== null) {\n      Meteor._debug('Warning: creating anonymous collection. It will not be ' + 'saved or synchronized over the network. (Pass null for ' + 'the collection name to turn off this warning.)');\n      name = null;\n    }\n    if (name !== null && typeof name !== 'string') {\n      throw new Error('First argument to new Mongo.Collection must be a string or null');\n    }\n    if (options && options.methods) {\n      // Backwards compatibility hack with original signature (which passed\n      // \"connection\" directly instead of in options. (Connections must have a \"methods\"\n      // method.)\n      // XXX remove before 1.0\n      options = {\n        connection: options\n      };\n    }\n    // Backwards compatibility: \"connection\" used to be called \"manager\".\n    if (options && options.manager && !options.connection) {\n      options.connection = options.manager;\n    }\n    options = _objectSpread({\n      connection: undefined,\n      idGeneration: 'STRING',\n      transform: null,\n      _driver: undefined,\n      _preventAutopublish: false\n    }, options);\n    switch (options.idGeneration) {\n      case 'MONGO':\n        this._makeNewID = function () {\n          var src = name ? DDP.randomStream('/collection/' + name) : Random.insecure;\n          return new Mongo.ObjectID(src.hexString(24));\n        };\n        break;\n      case 'STRING':\n      default:\n        this._makeNewID = function () {\n          var src = name ? DDP.randomStream('/collection/' + name) : Random.insecure;\n          return src.id();\n        };\n        break;\n    }\n    this._transform = LocalCollection.wrapTransform(options.transform);\n    this.resolverType = options.resolverType;\n    if (!name || options.connection === null)\n      // note: nameless collections never have a connection\n      this._connection = null;else if (options.connection) this._connection = options.connection;else if (Meteor.isClient) this._connection = Meteor.connection;else this._connection = Meteor.server;\n    if (!options._driver) {\n      // XXX This check assumes that webapp is loaded so that Meteor.server !==\n      // null. We should fully support the case of \"want to use a Mongo-backed\n      // collection from Node code without webapp\", but we don't yet.\n      // #MeteorServerNull\n      if (name && this._connection === Meteor.server && typeof MongoInternals !== 'undefined' && MongoInternals.defaultRemoteCollectionDriver) {\n        options._driver = MongoInternals.defaultRemoteCollectionDriver();\n      } else {\n        const {\n          LocalCollectionDriver\n        } = require('./local_collection_driver.js');\n        options._driver = LocalCollectionDriver;\n      }\n    }\n    this._collection = options._driver.open(name, this._connection);\n    this._name = name;\n    this._driver = options._driver;\n\n    // TODO[fibers]: _maybeSetUpReplication is now async. Let's watch how not waiting for this function to finish\n    // will affect everything\n    this._settingUpReplicationPromise = this._maybeSetUpReplication(name, options);\n\n    // XXX don't define these until allow or deny is actually used for this\n    // collection. Could be hard if the security rules are only defined on the\n    // server.\n    if (options.defineMutationMethods !== false) {\n      try {\n        this._defineMutationMethods({\n          useExisting: options._suppressSameNameError === true\n        });\n      } catch (error) {\n        // Throw a more understandable error on the server for same collection name\n        if (error.message === \"A method named '/\".concat(name, \"/insertAsync' is already defined\")) throw new Error(\"There is already a collection named \\\"\".concat(name, \"\\\"\"));\n        throw error;\n      }\n    }\n\n    // autopublish\n    if (Package.autopublish && !options._preventAutopublish && this._connection && this._connection.publish) {\n      this._connection.publish(null, () => this.find(), {\n        is_auto: true\n      });\n    }\n    Mongo._collections.set(this._name, this);\n  };\n  Object.assign(Mongo.Collection.prototype, {\n    async _maybeSetUpReplication(name) {\n      var _registerStoreResult, _registerStoreResult$;\n      const self = this;\n      if (!(self._connection && self._connection.registerStoreClient && self._connection.registerStoreServer)) {\n        return;\n      }\n      const wrappedStoreCommon = {\n        // Called around method stub invocations to capture the original versions\n        // of modified documents.\n        saveOriginals() {\n          self._collection.saveOriginals();\n        },\n        retrieveOriginals() {\n          return self._collection.retrieveOriginals();\n        },\n        // To be able to get back to the collection from the store.\n        _getCollection() {\n          return self;\n        }\n      };\n      const wrappedStoreClient = _objectSpread({\n        // Called at the beginning of a batch of updates. batchSize is the number\n        // of update calls to expect.\n        //\n        // XXX This interface is pretty janky. reset probably ought to go back to\n        // being its own function, and callers shouldn't have to calculate\n        // batchSize. The optimization of not calling pause/remove should be\n        // delayed until later: the first call to update() should buffer its\n        // message, and then we can either directly apply it at endUpdate time if\n        // it was the only update, or do pauseObservers/apply/apply at the next\n        // update() if there's another one.\n        async beginUpdate(batchSize, reset) {\n          // pause observers so users don't see flicker when updating several\n          // objects at once (including the post-reconnect reset-and-reapply\n          // stage), and so that a re-sorting of a query can take advantage of the\n          // full _diffQuery moved calculation instead of applying change one at a\n          // time.\n          if (batchSize > 1 || reset) self._collection.pauseObservers();\n          if (reset) await self._collection.remove({});\n        },\n        // Apply an update.\n        // XXX better specify this interface (not in terms of a wire message)?\n        update(msg) {\n          var mongoId = MongoID.idParse(msg.id);\n          var doc = self._collection._docs.get(mongoId);\n\n          //When the server's mergebox is disabled for a collection, the client must gracefully handle it when:\n          // *We receive an added message for a document that is already there. Instead, it will be changed\n          // *We reeive a change message for a document that is not there. Instead, it will be added\n          // *We receive a removed messsage for a document that is not there. Instead, noting wil happen.\n\n          //Code is derived from client-side code originally in peerlibrary:control-mergebox\n          //https://github.com/peerlibrary/meteor-control-mergebox/blob/master/client.coffee\n\n          //For more information, refer to discussion \"Initial support for publication strategies in livedata server\":\n          //https://github.com/meteor/meteor/pull/11151\n          if (Meteor.isClient) {\n            if (msg.msg === 'added' && doc) {\n              msg.msg = 'changed';\n            } else if (msg.msg === 'removed' && !doc) {\n              return;\n            } else if (msg.msg === 'changed' && !doc) {\n              msg.msg = 'added';\n              const _ref = msg.fields;\n              for (let field in _ref) {\n                const value = _ref[field];\n                if (value === void 0) {\n                  delete msg.fields[field];\n                }\n              }\n            }\n          }\n          // Is this a \"replace the whole doc\" message coming from the quiescence\n          // of method writes to an object? (Note that 'undefined' is a valid\n          // value meaning \"remove it\".)\n          if (msg.msg === 'replace') {\n            var replace = msg.replace;\n            if (!replace) {\n              if (doc) self._collection.remove(mongoId);\n            } else if (!doc) {\n              self._collection.insert(replace);\n            } else {\n              // XXX check that replace has no $ ops\n              self._collection.update(mongoId, replace);\n            }\n            return;\n          } else if (msg.msg === 'added') {\n            if (doc) {\n              throw new Error('Expected not to find a document already present for an add');\n            }\n            self._collection.insert(_objectSpread({\n              _id: mongoId\n            }, msg.fields));\n          } else if (msg.msg === 'removed') {\n            if (!doc) throw new Error('Expected to find a document already present for removed');\n            self._collection.remove(mongoId);\n          } else if (msg.msg === 'changed') {\n            if (!doc) throw new Error('Expected to find a document to change');\n            const keys = Object.keys(msg.fields);\n            if (keys.length > 0) {\n              var modifier = {};\n              keys.forEach(key => {\n                const value = msg.fields[key];\n                if (EJSON.equals(doc[key], value)) {\n                  return;\n                }\n                if (typeof value === 'undefined') {\n                  if (!modifier.$unset) {\n                    modifier.$unset = {};\n                  }\n                  modifier.$unset[key] = 1;\n                } else {\n                  if (!modifier.$set) {\n                    modifier.$set = {};\n                  }\n                  modifier.$set[key] = value;\n                }\n              });\n              if (Object.keys(modifier).length > 0) {\n                self._collection.update(mongoId, modifier);\n              }\n            }\n          } else {\n            throw new Error(\"I don't know how to deal with this message\");\n          }\n        },\n        // Called at the end of a batch of updates.livedata_connection.js:1287\n        endUpdate() {\n          self._collection.resumeObserversClient();\n        },\n        // Used to preserve current versions of documents across a store reset.\n        getDoc(id) {\n          return self.findOne(id);\n        }\n      }, wrappedStoreCommon);\n      const wrappedStoreServer = _objectSpread({\n        async beginUpdate(batchSize, reset) {\n          if (batchSize > 1 || reset) self._collection.pauseObservers();\n          if (reset) await self._collection.removeAsync({});\n        },\n        async update(msg) {\n          var mongoId = MongoID.idParse(msg.id);\n          var doc = self._collection._docs.get(mongoId);\n\n          // Is this a \"replace the whole doc\" message coming from the quiescence\n          // of method writes to an object? (Note that 'undefined' is a valid\n          // value meaning \"remove it\".)\n          if (msg.msg === 'replace') {\n            var replace = msg.replace;\n            if (!replace) {\n              if (doc) await self._collection.removeAsync(mongoId);\n            } else if (!doc) {\n              await self._collection.insertAsync(replace);\n            } else {\n              // XXX check that replace has no $ ops\n              await self._collection.updateAsync(mongoId, replace);\n            }\n            return;\n          } else if (msg.msg === 'added') {\n            if (doc) {\n              throw new Error('Expected not to find a document already present for an add');\n            }\n            await self._collection.insertAsync(_objectSpread({\n              _id: mongoId\n            }, msg.fields));\n          } else if (msg.msg === 'removed') {\n            if (!doc) throw new Error('Expected to find a document already present for removed');\n            await self._collection.removeAsync(mongoId);\n          } else if (msg.msg === 'changed') {\n            if (!doc) throw new Error('Expected to find a document to change');\n            const keys = Object.keys(msg.fields);\n            if (keys.length > 0) {\n              var modifier = {};\n              keys.forEach(key => {\n                const value = msg.fields[key];\n                if (EJSON.equals(doc[key], value)) {\n                  return;\n                }\n                if (typeof value === 'undefined') {\n                  if (!modifier.$unset) {\n                    modifier.$unset = {};\n                  }\n                  modifier.$unset[key] = 1;\n                } else {\n                  if (!modifier.$set) {\n                    modifier.$set = {};\n                  }\n                  modifier.$set[key] = value;\n                }\n              });\n              if (Object.keys(modifier).length > 0) {\n                await self._collection.updateAsync(mongoId, modifier);\n              }\n            }\n          } else {\n            throw new Error(\"I don't know how to deal with this message\");\n          }\n        },\n        // Called at the end of a batch of updates.\n        async endUpdate() {\n          await self._collection.resumeObserversServer();\n        },\n        // Used to preserve current versions of documents across a store reset.\n        async getDoc(id) {\n          return self.findOneAsync(id);\n        }\n      }, wrappedStoreCommon);\n\n      // OK, we're going to be a slave, replicating some remote\n      // database, except possibly with some temporary divergence while\n      // we have unacknowledged RPC's.\n      let registerStoreResult;\n      if (Meteor.isClient) {\n        registerStoreResult = self._connection.registerStoreClient(name, wrappedStoreClient);\n      } else {\n        registerStoreResult = self._connection.registerStoreServer(name, wrappedStoreServer);\n      }\n      const message = \"There is already a collection named \\\"\".concat(name, \"\\\"\");\n      const logWarn = () => {\n        console.warn ? console.warn(message) : console.log(message);\n      };\n      if (!registerStoreResult) {\n        return logWarn();\n      }\n      return (_registerStoreResult = registerStoreResult) === null || _registerStoreResult === void 0 ? void 0 : (_registerStoreResult$ = _registerStoreResult.then) === null || _registerStoreResult$ === void 0 ? void 0 : _registerStoreResult$.call(_registerStoreResult, ok => {\n        if (!ok) {\n          logWarn();\n        }\n      });\n    },\n    ///\n    /// Main collection API\n    ///\n    /**\n     * @summary Gets the number of documents matching the filter. For a fast count of the total documents in a collection see `estimatedDocumentCount`.\n     * @locus Anywhere\n     * @method countDocuments\n     * @memberof Mongo.Collection\n     * @instance\n     * @param {MongoSelector} [selector] A query describing the documents to count\n     * @param {Object} [options] All options are listed in [MongoDB documentation](https://mongodb.github.io/node-mongodb-native/4.11/interfaces/CountDocumentsOptions.html). Please note that not all of them are available on the client.\n     * @returns {Promise<number>}\n     */\n    countDocuments() {\n      return this._collection.countDocuments(...arguments);\n    },\n    /**\n     * @summary Gets an estimate of the count of documents in a collection using collection metadata. For an exact count of the documents in a collection see `countDocuments`.\n     * @locus Anywhere\n     * @method estimatedDocumentCount\n     * @memberof Mongo.Collection\n     * @instance\n     * @param {Object} [options] All options are listed in [MongoDB documentation](https://mongodb.github.io/node-mongodb-native/4.11/interfaces/EstimatedDocumentCountOptions.html). Please note that not all of them are available on the client.\n     * @returns {Promise<number>}\n     */\n    estimatedDocumentCount() {\n      return this._collection.estimatedDocumentCount(...arguments);\n    },\n    _getFindSelector(args) {\n      if (args.length == 0) return {};else return args[0];\n    },\n    _getFindOptions(args) {\n      const [, options] = args || [];\n      const newOptions = normalizeProjection(options);\n      var self = this;\n      if (args.length < 2) {\n        return {\n          transform: self._transform\n        };\n      } else {\n        check(newOptions, Match.Optional(Match.ObjectIncluding({\n          projection: Match.Optional(Match.OneOf(Object, undefined)),\n          sort: Match.Optional(Match.OneOf(Object, Array, Function, undefined)),\n          limit: Match.Optional(Match.OneOf(Number, undefined)),\n          skip: Match.Optional(Match.OneOf(Number, undefined))\n        })));\n        return _objectSpread({\n          transform: self._transform\n        }, newOptions);\n      }\n    },\n    /**\n     * @summary Find the documents in a collection that match the selector.\n     * @locus Anywhere\n     * @method find\n     * @memberof Mongo.Collection\n     * @instance\n     * @param {MongoSelector} [selector] A query describing the documents to find\n     * @param {Object} [options]\n     * @param {MongoSortSpecifier} options.sort Sort order (default: natural order)\n     * @param {Number} options.skip Number of results to skip at the beginning\n     * @param {Number} options.limit Maximum number of results to return\n     * @param {MongoFieldSpecifier} options.fields Dictionary of fields to return or exclude.\n     * @param {Boolean} options.reactive (Client only) Default `true`; pass `false` to disable reactivity\n     * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections) for this cursor.  Pass `null` to disable transformation.\n     * @param {Boolean} options.disableOplog (Server only) Pass true to disable oplog-tailing on this query. This affects the way server processes calls to `observe` on this query. Disabling the oplog can be useful when working with data that updates in large batches.\n     * @param {Number} options.pollingIntervalMs (Server only) When oplog is disabled (through the use of `disableOplog` or when otherwise not available), the frequency (in milliseconds) of how often to poll this query when observing on the server. Defaults to 10000ms (10 seconds).\n     * @param {Number} options.pollingThrottleMs (Server only) When oplog is disabled (through the use of `disableOplog` or when otherwise not available), the minimum time (in milliseconds) to allow between re-polling when observing on the server. Increasing this will save CPU and mongo load at the expense of slower updates to users. Decreasing this is not recommended. Defaults to 50ms.\n     * @param {Number} options.maxTimeMs (Server only) If set, instructs MongoDB to set a time limit for this cursor's operations. If the operation reaches the specified time limit (in milliseconds) without the having been completed, an exception will be thrown. Useful to prevent an (accidental or malicious) unoptimized query from causing a full collection scan that would disrupt other database users, at the expense of needing to handle the resulting error.\n     * @param {String|Object} options.hint (Server only) Overrides MongoDB's default index selection and query optimization process. Specify an index to force its use, either by its name or index specification. You can also specify `{ $natural : 1 }` to force a forwards collection scan, or `{ $natural : -1 }` for a reverse collection scan. Setting this is only recommended for advanced users.\n     * @param {String} options.readPreference (Server only) Specifies a custom MongoDB [`readPreference`](https://docs.mongodb.com/manual/core/read-preference) for this particular cursor. Possible values are `primary`, `primaryPreferred`, `secondary`, `secondaryPreferred` and `nearest`.\n     * @returns {Mongo.Cursor}\n     */\n    find() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      // Collection.find() (return all docs) behaves differently\n      // from Collection.find(undefined) (return 0 docs).  so be\n      // careful about the length of arguments.\n      return this._collection.find(this._getFindSelector(args), this._getFindOptions(args));\n    },\n    /**\n     * @summary Finds the first document that matches the selector, as ordered by sort and skip options. Returns `undefined` if no matching document is found.\n     * @locus Anywhere\n     * @method findOneAsync\n     * @memberof Mongo.Collection\n     * @instance\n     * @param {MongoSelector} [selector] A query describing the documents to find\n     * @param {Object} [options]\n     * @param {MongoSortSpecifier} options.sort Sort order (default: natural order)\n     * @param {Number} options.skip Number of results to skip at the beginning\n     * @param {MongoFieldSpecifier} options.fields Dictionary of fields to return or exclude.\n     * @param {Boolean} options.reactive (Client only) Default true; pass false to disable reactivity\n     * @param {Function} options.transform Overrides `transform` on the [`Collection`](#collections) for this cursor.  Pass `null` to disable transformation.\n     * @param {String} options.readPreference (Server only) Specifies a custom MongoDB [`readPreference`](https://docs.mongodb.com/manual/core/read-preference) for fetching the document. Possible values are `primary`, `primaryPreferred`, `secondary`, `secondaryPreferred` and `nearest`.\n     * @returns {Object}\n     */\n    findOneAsync() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return this._collection.findOneAsync(this._getFindSelector(args), this._getFindOptions(args));\n    },\n    /**\n     * @summary Finds the first document that matches the selector, as ordered by sort and skip options. Returns `undefined` if no matching document is found.\n     * @locus Anywhere\n     * @method findOne\n     * @memberof Mongo.Collection\n     * @instance\n     * @param {MongoSelector} [selector] A query describing the documents to find\n     * @param {Object} [options]\n     * @param {MongoSortSpecifier} options.sort Sort order (default: natural order)\n     * @param {Number} options.skip Number of results to skip at the beginning\n     * @param {MongoFieldSpecifier} options.fields Dictionary of fields to return or exclude.\n     * @param {Boolean} options.reactive (Client only) Default true; pass false to disable reactivity\n     * @param {Function} options.transform Overrides `transform` on the [`Collection`](#collections) for this cursor.  Pass `null` to disable transformation.\n     * @param {String} options.readPreference (Server only) Specifies a custom MongoDB [`readPreference`](https://docs.mongodb.com/manual/core/read-preference) for fetching the document. Possible values are `primary`, `primaryPreferred`, `secondary`, `secondaryPreferred` and `nearest`.\n     * @returns {Object}\n     */\n    findOne() {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return this._collection.findOne(this._getFindSelector(args), this._getFindOptions(args));\n    }\n  });\n  Object.assign(Mongo.Collection, {\n    async _publishCursor(cursor, sub, collection) {\n      var observeHandle = await cursor.observeChanges({\n        added: function (id, fields) {\n          sub.added(collection, id, fields);\n        },\n        changed: function (id, fields) {\n          sub.changed(collection, id, fields);\n        },\n        removed: function (id) {\n          sub.removed(collection, id);\n        }\n      },\n      // Publications don't mutate the documents\n      // This is tested by the `livedata - publish callbacks clone` test\n      {\n        nonMutatingCallbacks: true\n      });\n\n      // We don't call sub.ready() here: it gets called in livedata_server, after\n      // possibly calling _publishCursor on multiple returned cursors.\n\n      // register stop callback (expects lambda w/ no args).\n      sub.onStop(async function () {\n        return await observeHandle.stop();\n      });\n\n      // return the observeHandle in case it needs to be stopped early\n      return observeHandle;\n    },\n    // protect against dangerous selectors.  falsey and {_id: falsey} are both\n    // likely programmer error, and not what you want, particularly for destructive\n    // operations. If a falsey _id is sent in, a new string _id will be\n    // generated and returned; if a fallbackId is provided, it will be returned\n    // instead.\n    _rewriteSelector(selector) {\n      let {\n        fallbackId\n      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      // shorthand -- scalars match _id\n      if (LocalCollection._selectorIsId(selector)) selector = {\n        _id: selector\n      };\n      if (Array.isArray(selector)) {\n        // This is consistent with the Mongo console itself; if we don't do this\n        // check passing an empty array ends up selecting all items\n        throw new Error(\"Mongo selector can't be an array.\");\n      }\n      if (!selector || '_id' in selector && !selector._id) {\n        // can't match anything\n        return {\n          _id: fallbackId || Random.id()\n        };\n      }\n      return selector;\n    }\n  });\n  Object.assign(Mongo.Collection.prototype, {\n    // 'insert' immediately returns the inserted document's new _id.\n    // The others return values immediately if you are in a stub, an in-memory\n    // unmanaged collection, or a mongo-backed collection and you don't pass a\n    // callback. 'update' and 'remove' return the number of affected\n    // documents. 'upsert' returns an object with keys 'numberAffected' and, if an\n    // insert happened, 'insertedId'.\n    //\n    // Otherwise, the semantics are exactly like other methods: they take\n    // a callback as an optional last argument; if no callback is\n    // provided, they block until the operation is complete, and throw an\n    // exception if it fails; if a callback is provided, then they don't\n    // necessarily block, and they call the callback when they finish with error and\n    // result arguments.  (The insert method provides the document ID as its result;\n    // update and remove provide the number of affected docs as the result; upsert\n    // provides an object with numberAffected and maybe insertedId.)\n    //\n    // On the client, blocking is impossible, so if a callback\n    // isn't provided, they just return immediately and any error\n    // information is lost.\n    //\n    // There's one more tweak. On the client, if you don't provide a\n    // callback, then if there is an error, a message will be logged with\n    // Meteor._debug.\n    //\n    // The intent (though this is actually determined by the underlying\n    // drivers) is that the operations should be done synchronously, not\n    // generating their result until the database has acknowledged\n    // them. In the future maybe we should provide a flag to turn this\n    // off.\n\n    _insert(doc, callback) {\n      // Make sure we were passed a document to insert\n      if (!doc) {\n        throw new Error('insert requires an argument');\n      }\n\n      // Make a shallow clone of the document, preserving its prototype.\n      doc = Object.create(Object.getPrototypeOf(doc), Object.getOwnPropertyDescriptors(doc));\n      if ('_id' in doc) {\n        if (!doc._id || !(typeof doc._id === 'string' || doc._id instanceof Mongo.ObjectID)) {\n          throw new Error('Meteor requires document _id fields to be non-empty strings or ObjectIDs');\n        }\n      } else {\n        let generateId = true;\n\n        // Don't generate the id if we're the client and the 'outermost' call\n        // This optimization saves us passing both the randomSeed and the id\n        // Passing both is redundant.\n        if (this._isRemoteCollection()) {\n          const enclosing = DDP._CurrentMethodInvocation.get();\n          if (!enclosing) {\n            generateId = false;\n          }\n        }\n        if (generateId) {\n          doc._id = this._makeNewID();\n        }\n      }\n\n      // On inserts, always return the id that we generated; on all other\n      // operations, just return the result from the collection.\n      var chooseReturnValueFromCollectionResult = function (result) {\n        if (Meteor._isPromise(result)) return result;\n        if (doc._id) {\n          return doc._id;\n        }\n\n        // XXX what is this for??\n        // It's some iteraction between the callback to _callMutatorMethod and\n        // the return value conversion\n        doc._id = result;\n        return result;\n      };\n      const wrappedCallback = wrapCallback(callback, chooseReturnValueFromCollectionResult);\n      if (this._isRemoteCollection()) {\n        const result = this._callMutatorMethod('insert', [doc], wrappedCallback);\n        return chooseReturnValueFromCollectionResult(result);\n      }\n\n      // it's my collection.  descend into the collection object\n      // and propagate any exception.\n      try {\n        // If the user provided a callback and the collection implements this\n        // operation asynchronously, then queryRet will be undefined, and the\n        // result will be returned through the callback instead.\n        let result;\n        if (!!wrappedCallback) {\n          this._collection.insert(doc, wrappedCallback);\n        } else {\n          // If we don't have the callback, we assume the user is using the promise.\n          // We can't just pass this._collection.insert to the promisify because it would lose the context.\n          result = this._collection.insert(doc);\n        }\n        return chooseReturnValueFromCollectionResult(result);\n      } catch (e) {\n        if (callback) {\n          callback(e);\n          return null;\n        }\n        throw e;\n      }\n    },\n    /**\n     * @summary Insert a document in the collection.  Returns its unique _id.\n     * @locus Anywhere\n     * @method  insert\n     * @memberof Mongo.Collection\n     * @instance\n     * @param {Object} doc The document to insert. May not yet have an _id attribute, in which case Meteor will generate one for you.\n     * @param {Function} [callback] Optional.  If present, called with an error object as the first argument and, if no error, the _id as the second.\n     */\n    insert(doc, callback) {\n      return this._insert(doc, callback);\n    },\n    _insertAsync(doc) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      // Make sure we were passed a document to insert\n      if (!doc) {\n        throw new Error('insert requires an argument');\n      }\n\n      // Make a shallow clone of the document, preserving its prototype.\n      doc = Object.create(Object.getPrototypeOf(doc), Object.getOwnPropertyDescriptors(doc));\n      if ('_id' in doc) {\n        if (!doc._id || !(typeof doc._id === 'string' || doc._id instanceof Mongo.ObjectID)) {\n          throw new Error('Meteor requires document _id fields to be non-empty strings or ObjectIDs');\n        }\n      } else {\n        let generateId = true;\n\n        // Don't generate the id if we're the client and the 'outermost' call\n        // This optimization saves us passing both the randomSeed and the id\n        // Passing both is redundant.\n        if (this._isRemoteCollection()) {\n          const enclosing = DDP._CurrentMethodInvocation.get();\n          if (!enclosing) {\n            generateId = false;\n          }\n        }\n        if (generateId) {\n          doc._id = this._makeNewID();\n        }\n      }\n\n      // On inserts, always return the id that we generated; on all other\n      // operations, just return the result from the collection.\n      var chooseReturnValueFromCollectionResult = function (result) {\n        if (Meteor._isPromise(result)) return result;\n        if (doc._id) {\n          return doc._id;\n        }\n\n        // XXX what is this for??\n        // It's some iteraction between the callback to _callMutatorMethod and\n        // the return value conversion\n        doc._id = result;\n        return result;\n      };\n      if (this._isRemoteCollection()) {\n        const promise = this._callMutatorMethodAsync('insertAsync', [doc], options);\n        promise.then(chooseReturnValueFromCollectionResult);\n        promise.stubPromise = promise.stubPromise.then(chooseReturnValueFromCollectionResult);\n        promise.serverPromise = promise.serverPromise.then(chooseReturnValueFromCollectionResult);\n        return promise;\n      }\n\n      // it's my collection.  descend into the collection object\n      // and propagate any exception.\n      return this._collection.insertAsync(doc).then(chooseReturnValueFromCollectionResult);\n    },\n    /**\n     * @summary Insert a document in the collection.  Returns a promise that will return the document's unique _id when solved.\n     * @locus Anywhere\n     * @method  insert\n     * @memberof Mongo.Collection\n     * @instance\n     * @param {Object} doc The document to insert. May not yet have an _id attribute, in which case Meteor will generate one for you.\n     */\n    insertAsync(doc, options) {\n      return this._insertAsync(doc, options);\n    },\n    /**\n     * @summary Modify one or more documents in the collection. Returns the number of matched documents.\n     * @locus Anywhere\n     * @method update\n     * @memberof Mongo.Collection\n     * @instance\n     * @param {MongoSelector} selector Specifies which documents to modify\n     * @param {MongoModifier} modifier Specifies how to modify the documents\n     * @param {Object} [options]\n     * @param {Boolean} options.multi True to modify all matching documents; false to only modify one of the matching documents (the default).\n     * @param {Boolean} options.upsert True to insert a document if no matching documents are found.\n     * @param {Array} options.arrayFilters Optional. Used in combination with MongoDB [filtered positional operator](https://docs.mongodb.com/manual/reference/operator/update/positional-filtered/) to specify which elements to modify in an array field.\n     */\n    updateAsync(selector, modifier) {\n      // We've already popped off the callback, so we are left with an array\n      // of one or zero items\n      const options = _objectSpread({}, (arguments.length <= 2 ? undefined : arguments[2]) || null);\n      let insertedId;\n      if (options && options.upsert) {\n        // set `insertedId` if absent.  `insertedId` is a Meteor extension.\n        if (options.insertedId) {\n          if (!(typeof options.insertedId === 'string' || options.insertedId instanceof Mongo.ObjectID)) throw new Error('insertedId must be string or ObjectID');\n          insertedId = options.insertedId;\n        } else if (!selector || !selector._id) {\n          insertedId = this._makeNewID();\n          options.generatedId = true;\n          options.insertedId = insertedId;\n        }\n      }\n      selector = Mongo.Collection._rewriteSelector(selector, {\n        fallbackId: insertedId\n      });\n      if (this._isRemoteCollection()) {\n        const args = [selector, modifier, options];\n        return this._callMutatorMethodAsync('updateAsync', args, options);\n      }\n\n      // it's my collection.  descend into the collection object\n      // and propagate any exception.\n      // If the user provided a callback and the collection implements this\n      // operation asynchronously, then queryRet will be undefined, and the\n      // result will be returned through the callback instead.\n\n      return this._collection.updateAsync(selector, modifier, options);\n    },\n    /**\n     * @summary Asynchronously modifies one or more documents in the collection. Returns the number of matched documents.\n     * @locus Anywhere\n     * @method update\n     * @memberof Mongo.Collection\n     * @instance\n     * @param {MongoSelector} selector Specifies which documents to modify\n     * @param {MongoModifier} modifier Specifies how to modify the documents\n     * @param {Object} [options]\n     * @param {Boolean} options.multi True to modify all matching documents; false to only modify one of the matching documents (the default).\n     * @param {Boolean} options.upsert True to insert a document if no matching documents are found.\n     * @param {Array} options.arrayFilters Optional. Used in combination with MongoDB [filtered positional operator](https://docs.mongodb.com/manual/reference/operator/update/positional-filtered/) to specify which elements to modify in an array field.\n     * @param {Function} [callback] Optional.  If present, called with an error object as the first argument and, if no error, the number of affected documents as the second.\n     */\n    update(selector, modifier) {\n      for (var _len4 = arguments.length, optionsAndCallback = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {\n        optionsAndCallback[_key4 - 2] = arguments[_key4];\n      }\n      const callback = popCallbackFromArgs(optionsAndCallback);\n\n      // We've already popped off the callback, so we are left with an array\n      // of one or zero items\n      const options = _objectSpread({}, optionsAndCallback[0] || null);\n      let insertedId;\n      if (options && options.upsert) {\n        // set `insertedId` if absent.  `insertedId` is a Meteor extension.\n        if (options.insertedId) {\n          if (!(typeof options.insertedId === 'string' || options.insertedId instanceof Mongo.ObjectID)) throw new Error('insertedId must be string or ObjectID');\n          insertedId = options.insertedId;\n        } else if (!selector || !selector._id) {\n          insertedId = this._makeNewID();\n          options.generatedId = true;\n          options.insertedId = insertedId;\n        }\n      }\n      selector = Mongo.Collection._rewriteSelector(selector, {\n        fallbackId: insertedId\n      });\n      const wrappedCallback = wrapCallback(callback);\n      if (this._isRemoteCollection()) {\n        const args = [selector, modifier, options];\n        return this._callMutatorMethod('update', args, callback);\n      }\n\n      // it's my collection.  descend into the collection object\n      // and propagate any exception.\n      // If the user provided a callback and the collection implements this\n      // operation asynchronously, then queryRet will be undefined, and the\n      // result will be returned through the callback instead.\n      //console.log({callback, options, selector, modifier, coll: this._collection});\n      try {\n        // If the user provided a callback and the collection implements this\n        // operation asynchronously, then queryRet will be undefined, and the\n        // result will be returned through the callback instead.\n        return this._collection.update(selector, modifier, options, wrappedCallback);\n      } catch (e) {\n        if (callback) {\n          callback(e);\n          return null;\n        }\n        throw e;\n      }\n    },\n    /**\n     * @summary Asynchronously removes documents from the collection.\n     * @locus Anywhere\n     * @method remove\n     * @memberof Mongo.Collection\n     * @instance\n     * @param {MongoSelector} selector Specifies which documents to remove\n     */\n    removeAsync(selector) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      selector = Mongo.Collection._rewriteSelector(selector);\n      if (this._isRemoteCollection()) {\n        return this._callMutatorMethodAsync('removeAsync', [selector], options);\n      }\n\n      // it's my collection.  descend into the collection1 object\n      // and propagate any exception.\n      return this._collection.removeAsync(selector);\n    },\n    /**\n     * @summary Remove documents from the collection\n     * @locus Anywhere\n     * @method remove\n     * @memberof Mongo.Collection\n     * @instance\n     * @param {MongoSelector} selector Specifies which documents to remove\n     * @param {Function} [callback] Optional.  If present, called with an error object as the first argument and, if no error, the number of affected documents as the second.\n     */\n    remove(selector, callback) {\n      selector = Mongo.Collection._rewriteSelector(selector);\n      if (this._isRemoteCollection()) {\n        return this._callMutatorMethod('remove', [selector], callback);\n      }\n\n      // it's my collection.  descend into the collection1 object\n      // and propagate any exception.\n      return this._collection.remove(selector);\n    },\n    // Determine if this collection is simply a minimongo representation of a real\n    // database on another server\n    _isRemoteCollection() {\n      // XXX see #MeteorServerNull\n      return this._connection && this._connection !== Meteor.server;\n    },\n    /**\n     * @summary Asynchronously modifies one or more documents in the collection, or insert one if no matching documents were found. Returns an object with keys `numberAffected` (the number of documents modified)  and `insertedId` (the unique _id of the document that was inserted, if any).\n     * @locus Anywhere\n     * @method upsert\n     * @memberof Mongo.Collection\n     * @instance\n     * @param {MongoSelector} selector Specifies which documents to modify\n     * @param {MongoModifier} modifier Specifies how to modify the documents\n     * @param {Object} [options]\n     * @param {Boolean} options.multi True to modify all matching documents; false to only modify one of the matching documents (the default).\n     */\n    async upsertAsync(selector, modifier, options) {\n      return this.updateAsync(selector, modifier, _objectSpread(_objectSpread({}, options), {}, {\n        _returnObject: true,\n        upsert: true\n      }));\n    },\n    /**\n     * @summary Asynchronously modifies one or more documents in the collection, or insert one if no matching documents were found. Returns an object with keys `numberAffected` (the number of documents modified)  and `insertedId` (the unique _id of the document that was inserted, if any).\n     * @locus Anywhere\n     * @method upsert\n     * @memberof Mongo.Collection\n     * @instance\n     * @param {MongoSelector} selector Specifies which documents to modify\n     * @param {MongoModifier} modifier Specifies how to modify the documents\n     * @param {Object} [options]\n     * @param {Boolean} options.multi True to modify all matching documents; false to only modify one of the matching documents (the default).\n     * @param {Function} [callback] Optional.  If present, called with an error object as the first argument and, if no error, the number of affected documents as the second.\n     */\n    upsert(selector, modifier, options, callback) {\n      if (!callback && typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n      return this.update(selector, modifier, _objectSpread(_objectSpread({}, options), {}, {\n        _returnObject: true,\n        upsert: true\n      }));\n    },\n    // We'll actually design an index API later. For now, we just pass through to\n    // Mongo's, but make it synchronous.\n    /**\n     * @summary Asynchronously creates the specified index on the collection.\n     * @locus server\n     * @method ensureIndexAsync\n     * @deprecated in 3.0\n     * @memberof Mongo.Collection\n     * @instance\n     * @param {Object} index A document that contains the field and value pairs where the field is the index key and the value describes the type of index for that field. For an ascending index on a field, specify a value of `1`; for descending index, specify a value of `-1`. Use `text` for text indexes.\n     * @param {Object} [options] All options are listed in [MongoDB documentation](https://docs.mongodb.com/manual/reference/method/db.collection.createIndex/#options)\n     * @param {String} options.name Name of the index\n     * @param {Boolean} options.unique Define that the index values must be unique, more at [MongoDB documentation](https://docs.mongodb.com/manual/core/index-unique/)\n     * @param {Boolean} options.sparse Define that the index is sparse, more at [MongoDB documentation](https://docs.mongodb.com/manual/core/index-sparse/)\n     */\n    async ensureIndexAsync(index, options) {\n      var self = this;\n      if (!self._collection.ensureIndexAsync || !self._collection.createIndexAsync) throw new Error('Can only call createIndexAsync on server collections');\n      if (self._collection.createIndexAsync) {\n        await self._collection.createIndexAsync(index, options);\n      } else {\n        let Log;\n        module1.link(\"meteor/logging\", {\n          Log(v) {\n            Log = v;\n          }\n        }, 2);\n        Log.debug(\"ensureIndexAsync has been deprecated, please use the new 'createIndexAsync' instead\".concat(options !== null && options !== void 0 && options.name ? \", index name: \".concat(options.name) : \", index: \".concat(JSON.stringify(index))));\n        await self._collection.ensureIndexAsync(index, options);\n      }\n    },\n    /**\n     * @summary Asynchronously creates the specified index on the collection.\n     * @locus server\n     * @method createIndexAsync\n     * @memberof Mongo.Collection\n     * @instance\n     * @param {Object} index A document that contains the field and value pairs where the field is the index key and the value describes the type of index for that field. For an ascending index on a field, specify a value of `1`; for descending index, specify a value of `-1`. Use `text` for text indexes.\n     * @param {Object} [options] All options are listed in [MongoDB documentation](https://docs.mongodb.com/manual/reference/method/db.collection.createIndex/#options)\n     * @param {String} options.name Name of the index\n     * @param {Boolean} options.unique Define that the index values must be unique, more at [MongoDB documentation](https://docs.mongodb.com/manual/core/index-unique/)\n     * @param {Boolean} options.sparse Define that the index is sparse, more at [MongoDB documentation](https://docs.mongodb.com/manual/core/index-sparse/)\n     */\n    async createIndexAsync(index, options) {\n      var self = this;\n      if (!self._collection.createIndexAsync) throw new Error('Can only call createIndexAsync on server collections');\n      try {\n        await self._collection.createIndexAsync(index, options);\n      } catch (e) {\n        var _Meteor$settings, _Meteor$settings$pack, _Meteor$settings$pack2;\n        if (e.message.includes('An equivalent index already exists with the same name but different options.') && (_Meteor$settings = Meteor.settings) !== null && _Meteor$settings !== void 0 && (_Meteor$settings$pack = _Meteor$settings.packages) !== null && _Meteor$settings$pack !== void 0 && (_Meteor$settings$pack2 = _Meteor$settings$pack.mongo) !== null && _Meteor$settings$pack2 !== void 0 && _Meteor$settings$pack2.reCreateIndexOnOptionMismatch) {\n          let Log;\n          module1.link(\"meteor/logging\", {\n            Log(v) {\n              Log = v;\n            }\n          }, 3);\n          Log.info(\"Re-creating index \".concat(index, \" for \").concat(self._name, \" due to options mismatch.\"));\n          await self._collection.dropIndexAsync(index);\n          await self._collection.createIndexAsync(index, options);\n        } else {\n          console.error(e);\n          throw new Meteor.Error(\"An error occurred when creating an index for collection \\\"\".concat(self._name, \": \").concat(e.message));\n        }\n      }\n    },\n    /**\n     * @summary Asynchronously creates the specified index on the collection.\n     * @locus server\n     * @method createIndex\n     * @memberof Mongo.Collection\n     * @instance\n     * @param {Object} index A document that contains the field and value pairs where the field is the index key and the value describes the type of index for that field. For an ascending index on a field, specify a value of `1`; for descending index, specify a value of `-1`. Use `text` for text indexes.\n     * @param {Object} [options] All options are listed in [MongoDB documentation](https://docs.mongodb.com/manual/reference/method/db.collection.createIndex/#options)\n     * @param {String} options.name Name of the index\n     * @param {Boolean} options.unique Define that the index values must be unique, more at [MongoDB documentation](https://docs.mongodb.com/manual/core/index-unique/)\n     * @param {Boolean} options.sparse Define that the index is sparse, more at [MongoDB documentation](https://docs.mongodb.com/manual/core/index-sparse/)\n     */\n    createIndex(index, options) {\n      return this.createIndexAsync(index, options);\n    },\n    async dropIndexAsync(index) {\n      var self = this;\n      if (!self._collection.dropIndexAsync) throw new Error('Can only call dropIndexAsync on server collections');\n      await self._collection.dropIndexAsync(index);\n    },\n    async dropCollectionAsync() {\n      var self = this;\n      if (!self._collection.dropCollectionAsync) throw new Error('Can only call dropCollectionAsync on server collections');\n      await self._collection.dropCollectionAsync();\n    },\n    async createCappedCollectionAsync(byteSize, maxDocuments) {\n      var self = this;\n      if (!(await self._collection.createCappedCollectionAsync)) throw new Error('Can only call createCappedCollectionAsync on server collections');\n      await self._collection.createCappedCollectionAsync(byteSize, maxDocuments);\n    },\n    /**\n     * @summary Returns the [`Collection`](http://mongodb.github.io/node-mongodb-native/3.0/api/Collection.html) object corresponding to this collection from the [npm `mongodb` driver module](https://www.npmjs.com/package/mongodb) which is wrapped by `Mongo.Collection`.\n     * @locus Server\n     * @memberof Mongo.Collection\n     * @instance\n     */\n    rawCollection() {\n      var self = this;\n      if (!self._collection.rawCollection) {\n        throw new Error('Can only call rawCollection on server collections');\n      }\n      return self._collection.rawCollection();\n    },\n    /**\n     * @summary Returns the [`Db`](http://mongodb.github.io/node-mongodb-native/3.0/api/Db.html) object corresponding to this collection's database connection from the [npm `mongodb` driver module](https://www.npmjs.com/package/mongodb) which is wrapped by `Mongo.Collection`.\n     * @locus Server\n     * @memberof Mongo.Collection\n     * @instance\n     */\n    rawDatabase() {\n      var self = this;\n      if (!(self._driver.mongo && self._driver.mongo.db)) {\n        throw new Error('Can only call rawDatabase on server collections');\n      }\n      return self._driver.mongo.db;\n    }\n  });\n  Object.assign(Mongo, {\n    /**\n     * @summary Retrieve a Meteor collection instance by name. Only collections defined with [`new Mongo.Collection(...)`](#collections) are available with this method. For plain MongoDB collections, you'll want to look at [`rawDatabase()`](#Mongo-Collection-rawDatabase).\n     * @locus Anywhere\n     * @memberof Mongo\n     * @static\n     * @param {string} name Name of your collection as it was defined with `new Mongo.Collection()`.\n     * @returns {Mongo.Collection | undefined}\n     */\n    getCollection(name) {\n      return this._collections.get(name);\n    },\n    /**\n     * @summary A record of all defined Mongo.Collection instances, indexed by collection name.\n     * @type {Map<string, Mongo.Collection>}\n     * @memberof Mongo\n     * @protected\n     */\n    _collections: new Map()\n  });\n\n  // Convert the callback to not return a result if there is an error\n  function wrapCallback(callback, convertResult) {\n    return callback && function (error, result) {\n      if (error) {\n        callback(error);\n      } else if (typeof convertResult === 'function') {\n        callback(error, convertResult(result));\n      } else {\n        callback(error, result);\n      }\n    };\n  }\n\n  /**\n   * @summary Create a Mongo-style `ObjectID`.  If you don't specify a `hexString`, the `ObjectID` will be generated randomly (not using MongoDB's ID construction rules).\n   * @locus Anywhere\n   * @class\n   * @param {String} [hexString] Optional.  The 24-character hexadecimal contents of the ObjectID to create\n   */\n  Mongo.ObjectID = MongoID.ObjectID;\n\n  /**\n   * @summary To create a cursor, use find. To access the documents in a cursor, use forEach, map, or fetch.\n   * @class\n   * @instanceName cursor\n   */\n  Mongo.Cursor = LocalCollection.Cursor;\n\n  /**\n   * @deprecated in 0.9.1\n   */\n  Mongo.Collection.Cursor = Mongo.Cursor;\n\n  /**\n   * @deprecated in 0.9.1\n   */\n  Mongo.Collection.ObjectID = Mongo.ObjectID;\n\n  /**\n   * @deprecated in 0.9.1\n   */\n  Meteor.Collection = Mongo.Collection;\n\n  // Allow deny stuff is now in the allow-deny package\n  Object.assign(Mongo.Collection.prototype, AllowDeny.CollectionPrototype);\n  function popCallbackFromArgs(args) {\n    // Pull off any callback (or perhaps a 'callback' variable that was passed\n    // in undefined, like how 'upsert' does it).\n    if (args.length && (args[args.length - 1] === undefined || args[args.length - 1] instanceof Function)) {\n      return args.pop();\n    }\n  }\n}.call(this, module);\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"mongo_utils.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/mongo/mongo_utils.js                                                                                       //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nconst _excluded = [\"fields\", \"projection\"];\nlet _objectSpread;\nmodule.link(\"@babel/runtime/helpers/objectSpread2\", {\n  default(v) {\n    _objectSpread = v;\n  }\n}, 0);\nlet _objectWithoutProperties;\nmodule.link(\"@babel/runtime/helpers/objectWithoutProperties\", {\n  default(v) {\n    _objectWithoutProperties = v;\n  }\n}, 1);\nmodule.export({\n  normalizeProjection: () => normalizeProjection\n});\nconst normalizeProjection = options => {\n  // transform fields key in projection\n  const _ref = options || {},\n    {\n      fields,\n      projection\n    } = _ref,\n    otherOptions = _objectWithoutProperties(_ref, _excluded);\n  // TODO: enable this comment when deprecating the fields option\n  // Log.debug(`fields option has been deprecated, please use the new 'projection' instead`)\n\n  return _objectSpread(_objectSpread({}, otherOptions), projection || fields ? {\n    projection: fields || projection\n  } : {});\n};\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\n\n\n/* Exports */\nreturn {\n  export: function () { return {\n      Mongo: Mongo\n    };},\n  require: require,\n  eagerModulePaths: [\n    \"/node_modules/meteor/mongo/local_collection_driver.js\",\n    \"/node_modules/meteor/mongo/collection.js\"\n  ]\n}});\n","servePath":"/packages/mongo.js","sourceMap":{"version":3,"sources":["packages/mongo/local_collection_driver.js","packages/mongo/collection.js","packages/mongo/mongo_utils.js"],"names":["module","export","LocalCollectionDriver","constructor","noConnCollections","Object","create","open","name","conn","LocalCollection","ensureCollection","_mongo_livedata_collections","collections","_objectSpread","module1","link","default","v","ASYNC_COLLECTION_METHODS","getAsyncMethodName","normalizeProjection","Mongo","Collection","options","Meteor","_debug","Error","methods","connection","manager","undefined","idGeneration","transform","_driver","_preventAutopublish","_makeNewID","src","DDP","randomStream","Random","insecure","ObjectID","hexString","id","_transform","wrapTransform","resolverType","_connection","isClient","server","MongoInternals","defaultRemoteCollectionDriver","require","_collection","_name","_settingUpReplicationPromise","_maybeSetUpReplication","defineMutationMethods","_defineMutationMethods","useExisting","_suppressSameNameError","error","message","concat","Package","autopublish","publish","find","is_auto","_collections","set","assign","prototype","_registerStoreResult","_registerStoreResult$","self","registerStoreClient","registerStoreServer","wrappedStoreCommon","saveOriginals","retrieveOriginals","_getCollection","wrappedStoreClient","beginUpdate","batchSize","reset","pauseObservers","remove","update","msg","mongoId","MongoID","idParse","doc","_docs","get","_ref","fields","field","value","replace","insert","_id","keys","length","modifier","forEach","key","EJSON","equals","$unset","$set","endUpdate","resumeObserversClient","getDoc","findOne","wrappedStoreServer","removeAsync","insertAsync","updateAsync","resumeObserversServer","findOneAsync","registerStoreResult","logWarn","console","warn","log","then","call","ok","countDocuments","arguments","estimatedDocumentCount","_getFindSelector","args","_getFindOptions","newOptions","check","Match","Optional","ObjectIncluding","projection","OneOf","sort","Array","Function","limit","Number","skip","_len","_key","_len2","_key2","_len3","_key3","_publishCursor","cursor","sub","collection","observeHandle","observeChanges","added","changed","removed","nonMutatingCallbacks","onStop","stop","_rewriteSelector","selector","fallbackId","_selectorIsId","isArray","_insert","callback","getPrototypeOf","getOwnPropertyDescriptors","generateId","_isRemoteCollection","enclosing","_CurrentMethodInvocation","chooseReturnValueFromCollectionResult","result","_isPromise","wrappedCallback","wrapCallback","_callMutatorMethod","e","_insertAsync","promise","_callMutatorMethodAsync","stubPromise","serverPromise","insertedId","upsert","generatedId","_len4","optionsAndCallback","_key4","popCallbackFromArgs","upsertAsync","_returnObject","ensureIndexAsync","index","createIndexAsync","Log","debug","JSON","stringify","_Meteor$settings","_Meteor$settings$pack","_Meteor$settings$pack2","includes","settings","packages","mongo","reCreateIndexOnOptionMismatch","info","dropIndexAsync","createIndex","dropCollectionAsync","createCappedCollectionAsync","byteSize","maxDocuments","rawCollection","rawDatabase","db","getCollection","Map","convertResult","Cursor","AllowDeny","CollectionPrototype","pop","_objectWithoutProperties","otherOptions","_excluded"],"mappings":"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","file":"/packages/mongo.js","sourcesContent":["// singleton\nexport const LocalCollectionDriver = new (class LocalCollectionDriver {\n  constructor() {\n    this.noConnCollections = Object.create(null);\n  }\n\n  open(name, conn) {\n    if (! name) {\n      return new LocalCollection;\n    }\n\n    if (! conn) {\n      return ensureCollection(name, this.noConnCollections);\n    }\n\n    if (! conn._mongo_livedata_collections) {\n      conn._mongo_livedata_collections = Object.create(null);\n    }\n\n    // XXX is there a way to keep track of a connection's collections without\n    // dangling it off the connection object?\n    return ensureCollection(name, conn._mongo_livedata_collections);\n  }\n});\n\nfunction ensureCollection(name, collections) {\n  return (name in collections)\n    ? collections[name]\n    : collections[name] = new LocalCollection(name);\n}\n","// options.connection, if given, is a LivedataClient or LivedataServer\n// XXX presently there is no way to destroy/clean up a Collection\nimport {\n  ASYNC_COLLECTION_METHODS,\n  getAsyncMethodName,\n} from 'meteor/minimongo/constants';\n\nimport { normalizeProjection } from \"./mongo_utils\";\n\n/**\n * @summary Namespace for MongoDB-related items\n * @namespace\n */\nMongo = {};\n\n/**\n * @summary Constructor for a Collection\n * @locus Anywhere\n * @instancename collection\n * @class\n * @param {String} name The name of the collection.  If null, creates an unmanaged (unsynchronized) local collection.\n * @param {Object} [options]\n * @param {Object} options.connection The server connection that will manage this collection. Uses the default connection if not specified.  Pass the return value of calling [`DDP.connect`](#DDP-connect) to specify a different server. Pass `null` to specify no connection. Unmanaged (`name` is null) collections cannot specify a connection.\n * @param {String} options.idGeneration The method of generating the `_id` fields of new documents in this collection.  Possible values:\n\n - **`'STRING'`**: random strings\n - **`'MONGO'`**:  random [`Mongo.ObjectID`](#mongo_object_id) values\n\nThe default id generation technique is `'STRING'`.\n * @param {Function} options.transform An optional transformation function. Documents will be passed through this function before being returned from `fetch` or `findOneAsync`, and before being passed to callbacks of `observe`, `map`, `forEach`, `allow`, and `deny`. Transforms are *not* applied for the callbacks of `observeChanges` or to cursors returned from publish functions.\n * @param {Boolean} options.defineMutationMethods Set to `false` to skip setting up the mutation methods that enable insert/update/remove from client code. Default `true`.\n */\nMongo.Collection = function Collection(name, options) {\n  if (!name && name !== null) {\n    Meteor._debug(\n      'Warning: creating anonymous collection. It will not be ' +\n        'saved or synchronized over the network. (Pass null for ' +\n        'the collection name to turn off this warning.)'\n    );\n    name = null;\n  }\n\n  if (name !== null && typeof name !== 'string') {\n    throw new Error(\n      'First argument to new Mongo.Collection must be a string or null'\n    );\n  }\n\n  if (options && options.methods) {\n    // Backwards compatibility hack with original signature (which passed\n    // \"connection\" directly instead of in options. (Connections must have a \"methods\"\n    // method.)\n    // XXX remove before 1.0\n    options = { connection: options };\n  }\n  // Backwards compatibility: \"connection\" used to be called \"manager\".\n  if (options && options.manager && !options.connection) {\n    options.connection = options.manager;\n  }\n\n  options = {\n    connection: undefined,\n    idGeneration: 'STRING',\n    transform: null,\n    _driver: undefined,\n    _preventAutopublish: false,\n    ...options,\n  };\n\n  switch (options.idGeneration) {\n    case 'MONGO':\n      this._makeNewID = function() {\n        var src = name\n          ? DDP.randomStream('/collection/' + name)\n          : Random.insecure;\n        return new Mongo.ObjectID(src.hexString(24));\n      };\n      break;\n    case 'STRING':\n    default:\n      this._makeNewID = function() {\n        var src = name\n          ? DDP.randomStream('/collection/' + name)\n          : Random.insecure;\n        return src.id();\n      };\n      break;\n  }\n\n  this._transform = LocalCollection.wrapTransform(options.transform);\n\n  this.resolverType = options.resolverType;\n\n  if (!name || options.connection === null)\n    // note: nameless collections never have a connection\n    this._connection = null;\n  else if (options.connection) this._connection = options.connection;\n  else if (Meteor.isClient) this._connection = Meteor.connection;\n  else this._connection = Meteor.server;\n\n  if (!options._driver) {\n    // XXX This check assumes that webapp is loaded so that Meteor.server !==\n    // null. We should fully support the case of \"want to use a Mongo-backed\n    // collection from Node code without webapp\", but we don't yet.\n    // #MeteorServerNull\n    if (\n      name &&\n      this._connection === Meteor.server &&\n      typeof MongoInternals !== 'undefined' &&\n      MongoInternals.defaultRemoteCollectionDriver\n    ) {\n      options._driver = MongoInternals.defaultRemoteCollectionDriver();\n    } else {\n      const { LocalCollectionDriver } = require('./local_collection_driver.js');\n      options._driver = LocalCollectionDriver;\n    }\n  }\n\n  this._collection = options._driver.open(name, this._connection);\n  this._name = name;\n  this._driver = options._driver;\n\n  // TODO[fibers]: _maybeSetUpReplication is now async. Let's watch how not waiting for this function to finish\n    // will affect everything\n  this._settingUpReplicationPromise = this._maybeSetUpReplication(name, options);\n\n  // XXX don't define these until allow or deny is actually used for this\n  // collection. Could be hard if the security rules are only defined on the\n  // server.\n  if (options.defineMutationMethods !== false) {\n    try {\n      this._defineMutationMethods({\n        useExisting: options._suppressSameNameError === true,\n      });\n    } catch (error) {\n      // Throw a more understandable error on the server for same collection name\n      if (\n        error.message === `A method named '/${name}/insertAsync' is already defined`\n      )\n        throw new Error(`There is already a collection named \"${name}\"`);\n      throw error;\n    }\n  }\n\n  // autopublish\n  if (\n    Package.autopublish &&\n    !options._preventAutopublish &&\n    this._connection &&\n    this._connection.publish\n  ) {\n    this._connection.publish(null, () => this.find(), {\n      is_auto: true,\n    });\n  }\n\n  Mongo._collections.set(this._name, this);\n};\n\nObject.assign(Mongo.Collection.prototype, {\n  async _maybeSetUpReplication(name) {\n    const self = this;\n    if (\n      !(\n        self._connection &&\n        self._connection.registerStoreClient &&\n        self._connection.registerStoreServer\n      )\n    ) {\n      return;\n    }\n\n\n    const wrappedStoreCommon = {\n      // Called around method stub invocations to capture the original versions\n      // of modified documents.\n      saveOriginals() {\n        self._collection.saveOriginals();\n      },\n      retrieveOriginals() {\n        return self._collection.retrieveOriginals();\n      },\n      // To be able to get back to the collection from the store.\n      _getCollection() {\n        return self;\n      },\n    };\n    const wrappedStoreClient = {\n      // Called at the beginning of a batch of updates. batchSize is the number\n      // of update calls to expect.\n      //\n      // XXX This interface is pretty janky. reset probably ought to go back to\n      // being its own function, and callers shouldn't have to calculate\n      // batchSize. The optimization of not calling pause/remove should be\n      // delayed until later: the first call to update() should buffer its\n      // message, and then we can either directly apply it at endUpdate time if\n      // it was the only update, or do pauseObservers/apply/apply at the next\n      // update() if there's another one.\n      async beginUpdate(batchSize, reset) {\n        // pause observers so users don't see flicker when updating several\n        // objects at once (including the post-reconnect reset-and-reapply\n        // stage), and so that a re-sorting of a query can take advantage of the\n        // full _diffQuery moved calculation instead of applying change one at a\n        // time.\n        if (batchSize > 1 || reset) self._collection.pauseObservers();\n\n        if (reset) await self._collection.remove({});\n      },\n\n      // Apply an update.\n      // XXX better specify this interface (not in terms of a wire message)?\n      update(msg) {\n        var mongoId = MongoID.idParse(msg.id);\n        var doc = self._collection._docs.get(mongoId);\n\n        //When the server's mergebox is disabled for a collection, the client must gracefully handle it when:\n        // *We receive an added message for a document that is already there. Instead, it will be changed\n        // *We reeive a change message for a document that is not there. Instead, it will be added\n        // *We receive a removed messsage for a document that is not there. Instead, noting wil happen.\n\n        //Code is derived from client-side code originally in peerlibrary:control-mergebox\n        //https://github.com/peerlibrary/meteor-control-mergebox/blob/master/client.coffee\n\n        //For more information, refer to discussion \"Initial support for publication strategies in livedata server\":\n        //https://github.com/meteor/meteor/pull/11151\n        if (Meteor.isClient) {\n          if (msg.msg === 'added' && doc) {\n            msg.msg = 'changed';\n          } else if (msg.msg === 'removed' && !doc) {\n            return;\n          } else if (msg.msg === 'changed' && !doc) {\n            msg.msg = 'added';\n            const _ref = msg.fields;\n            for (let field in _ref) {\n              const value = _ref[field];\n              if (value === void 0) {\n                delete msg.fields[field];\n              }\n            }\n          }\n        }\n        // Is this a \"replace the whole doc\" message coming from the quiescence\n        // of method writes to an object? (Note that 'undefined' is a valid\n        // value meaning \"remove it\".)\n        if (msg.msg === 'replace') {\n          var replace = msg.replace;\n          if (!replace) {\n            if (doc) self._collection.remove(mongoId);\n          } else if (!doc) {\n            self._collection.insert(replace);\n          } else {\n            // XXX check that replace has no $ ops\n            self._collection.update(mongoId, replace);\n          }\n          return;\n        } else if (msg.msg === 'added') {\n          if (doc) {\n            throw new Error(\n              'Expected not to find a document already present for an add'\n            );\n          }\n          self._collection.insert({ _id: mongoId, ...msg.fields });\n        } else if (msg.msg === 'removed') {\n          if (!doc)\n            throw new Error(\n              'Expected to find a document already present for removed'\n            );\n          self._collection.remove(mongoId);\n        } else if (msg.msg === 'changed') {\n          if (!doc) throw new Error('Expected to find a document to change');\n          const keys = Object.keys(msg.fields);\n          if (keys.length > 0) {\n            var modifier = {};\n            keys.forEach(key => {\n              const value = msg.fields[key];\n              if (EJSON.equals(doc[key], value)) {\n                return;\n              }\n              if (typeof value === 'undefined') {\n                if (!modifier.$unset) {\n                  modifier.$unset = {};\n                }\n                modifier.$unset[key] = 1;\n              } else {\n                if (!modifier.$set) {\n                  modifier.$set = {};\n                }\n                modifier.$set[key] = value;\n              }\n            });\n            if (Object.keys(modifier).length > 0) {\n              self._collection.update(mongoId, modifier);\n            }\n          }\n        } else {\n          throw new Error(\"I don't know how to deal with this message\");\n        }\n      },\n\n      // Called at the end of a batch of updates.livedata_connection.js:1287\n      endUpdate() {\n        self._collection.resumeObserversClient();\n      },\n\n      // Used to preserve current versions of documents across a store reset.\n      getDoc(id) {\n        return self.findOne(id);\n      },\n\n      ...wrappedStoreCommon,\n    };\n    const wrappedStoreServer = {\n      async beginUpdate(batchSize, reset) {\n        if (batchSize > 1 || reset) self._collection.pauseObservers();\n\n        if (reset) await self._collection.removeAsync({});\n      },\n\n      async update(msg) {\n        var mongoId = MongoID.idParse(msg.id);\n        var doc = self._collection._docs.get(mongoId);\n\n        // Is this a \"replace the whole doc\" message coming from the quiescence\n        // of method writes to an object? (Note that 'undefined' is a valid\n        // value meaning \"remove it\".)\n        if (msg.msg === 'replace') {\n          var replace = msg.replace;\n          if (!replace) {\n            if (doc) await self._collection.removeAsync(mongoId);\n          } else if (!doc) {\n            await self._collection.insertAsync(replace);\n          } else {\n            // XXX check that replace has no $ ops\n            await self._collection.updateAsync(mongoId, replace);\n          }\n          return;\n        } else if (msg.msg === 'added') {\n          if (doc) {\n            throw new Error(\n              'Expected not to find a document already present for an add'\n            );\n          }\n          await self._collection.insertAsync({ _id: mongoId, ...msg.fields });\n        } else if (msg.msg === 'removed') {\n          if (!doc)\n            throw new Error(\n              'Expected to find a document already present for removed'\n            );\n          await self._collection.removeAsync(mongoId);\n        } else if (msg.msg === 'changed') {\n          if (!doc) throw new Error('Expected to find a document to change');\n          const keys = Object.keys(msg.fields);\n          if (keys.length > 0) {\n            var modifier = {};\n            keys.forEach(key => {\n              const value = msg.fields[key];\n              if (EJSON.equals(doc[key], value)) {\n                return;\n              }\n              if (typeof value === 'undefined') {\n                if (!modifier.$unset) {\n                  modifier.$unset = {};\n                }\n                modifier.$unset[key] = 1;\n              } else {\n                if (!modifier.$set) {\n                  modifier.$set = {};\n                }\n                modifier.$set[key] = value;\n              }\n            });\n            if (Object.keys(modifier).length > 0) {\n              await self._collection.updateAsync(mongoId, modifier);\n            }\n          }\n        } else {\n          throw new Error(\"I don't know how to deal with this message\");\n        }\n      },\n\n      // Called at the end of a batch of updates.\n      async endUpdate() {\n        await self._collection.resumeObserversServer();\n      },\n\n      // Used to preserve current versions of documents across a store reset.\n      async getDoc(id) {\n        return self.findOneAsync(id);\n      },\n      ...wrappedStoreCommon,\n    };\n\n\n    // OK, we're going to be a slave, replicating some remote\n    // database, except possibly with some temporary divergence while\n    // we have unacknowledged RPC's.\n    let registerStoreResult;\n    if (Meteor.isClient) {\n      registerStoreResult = self._connection.registerStoreClient(\n        name,\n        wrappedStoreClient\n      );\n    } else {\n      registerStoreResult = self._connection.registerStoreServer(\n        name,\n        wrappedStoreServer\n      );\n    }\n\n    const message = `There is already a collection named \"${name}\"`;\n    const logWarn = () => {\n      console.warn ? console.warn(message) : console.log(message);\n    };\n\n    if (!registerStoreResult) {\n      return logWarn();\n    }\n\n    return registerStoreResult?.then?.(ok => {\n      if (!ok) {\n        logWarn();\n      }\n    });\n  },\n\n  ///\n  /// Main collection API\n  ///\n  /**\n   * @summary Gets the number of documents matching the filter. For a fast count of the total documents in a collection see `estimatedDocumentCount`.\n   * @locus Anywhere\n   * @method countDocuments\n   * @memberof Mongo.Collection\n   * @instance\n   * @param {MongoSelector} [selector] A query describing the documents to count\n   * @param {Object} [options] All options are listed in [MongoDB documentation](https://mongodb.github.io/node-mongodb-native/4.11/interfaces/CountDocumentsOptions.html). Please note that not all of them are available on the client.\n   * @returns {Promise<number>}\n   */\n  countDocuments(...args) {\n    return this._collection.countDocuments(...args);\n  },\n\n  /**\n   * @summary Gets an estimate of the count of documents in a collection using collection metadata. For an exact count of the documents in a collection see `countDocuments`.\n   * @locus Anywhere\n   * @method estimatedDocumentCount\n   * @memberof Mongo.Collection\n   * @instance\n   * @param {Object} [options] All options are listed in [MongoDB documentation](https://mongodb.github.io/node-mongodb-native/4.11/interfaces/EstimatedDocumentCountOptions.html). Please note that not all of them are available on the client.\n   * @returns {Promise<number>}\n   */\n  estimatedDocumentCount(...args) {\n    return this._collection.estimatedDocumentCount(...args);\n  },\n\n  _getFindSelector(args) {\n    if (args.length == 0) return {};\n    else return args[0];\n  },\n\n  _getFindOptions(args) {\n    const [, options] = args || [];\n    const newOptions = normalizeProjection(options);\n\n    var self = this;\n    if (args.length < 2) {\n      return { transform: self._transform };\n    } else {\n      check(\n        newOptions,\n        Match.Optional(\n          Match.ObjectIncluding({\n            projection: Match.Optional(Match.OneOf(Object, undefined)),\n            sort: Match.Optional(\n              Match.OneOf(Object, Array, Function, undefined)\n            ),\n            limit: Match.Optional(Match.OneOf(Number, undefined)),\n            skip: Match.Optional(Match.OneOf(Number, undefined)),\n          })\n        )\n      );\n\n      return {\n        transform: self._transform,\n        ...newOptions,\n      };\n    }\n  },\n\n  /**\n   * @summary Find the documents in a collection that match the selector.\n   * @locus Anywhere\n   * @method find\n   * @memberof Mongo.Collection\n   * @instance\n   * @param {MongoSelector} [selector] A query describing the documents to find\n   * @param {Object} [options]\n   * @param {MongoSortSpecifier} options.sort Sort order (default: natural order)\n   * @param {Number} options.skip Number of results to skip at the beginning\n   * @param {Number} options.limit Maximum number of results to return\n   * @param {MongoFieldSpecifier} options.fields Dictionary of fields to return or exclude.\n   * @param {Boolean} options.reactive (Client only) Default `true`; pass `false` to disable reactivity\n   * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections) for this cursor.  Pass `null` to disable transformation.\n   * @param {Boolean} options.disableOplog (Server only) Pass true to disable oplog-tailing on this query. This affects the way server processes calls to `observe` on this query. Disabling the oplog can be useful when working with data that updates in large batches.\n   * @param {Number} options.pollingIntervalMs (Server only) When oplog is disabled (through the use of `disableOplog` or when otherwise not available), the frequency (in milliseconds) of how often to poll this query when observing on the server. Defaults to 10000ms (10 seconds).\n   * @param {Number} options.pollingThrottleMs (Server only) When oplog is disabled (through the use of `disableOplog` or when otherwise not available), the minimum time (in milliseconds) to allow between re-polling when observing on the server. Increasing this will save CPU and mongo load at the expense of slower updates to users. Decreasing this is not recommended. Defaults to 50ms.\n   * @param {Number} options.maxTimeMs (Server only) If set, instructs MongoDB to set a time limit for this cursor's operations. If the operation reaches the specified time limit (in milliseconds) without the having been completed, an exception will be thrown. Useful to prevent an (accidental or malicious) unoptimized query from causing a full collection scan that would disrupt other database users, at the expense of needing to handle the resulting error.\n   * @param {String|Object} options.hint (Server only) Overrides MongoDB's default index selection and query optimization process. Specify an index to force its use, either by its name or index specification. You can also specify `{ $natural : 1 }` to force a forwards collection scan, or `{ $natural : -1 }` for a reverse collection scan. Setting this is only recommended for advanced users.\n   * @param {String} options.readPreference (Server only) Specifies a custom MongoDB [`readPreference`](https://docs.mongodb.com/manual/core/read-preference) for this particular cursor. Possible values are `primary`, `primaryPreferred`, `secondary`, `secondaryPreferred` and `nearest`.\n   * @returns {Mongo.Cursor}\n   */\n  find(...args) {\n    // Collection.find() (return all docs) behaves differently\n    // from Collection.find(undefined) (return 0 docs).  so be\n    // careful about the length of arguments.\n    return this._collection.find(\n      this._getFindSelector(args),\n      this._getFindOptions(args)\n    );\n  },\n\n  /**\n   * @summary Finds the first document that matches the selector, as ordered by sort and skip options. Returns `undefined` if no matching document is found.\n   * @locus Anywhere\n   * @method findOneAsync\n   * @memberof Mongo.Collection\n   * @instance\n   * @param {MongoSelector} [selector] A query describing the documents to find\n   * @param {Object} [options]\n   * @param {MongoSortSpecifier} options.sort Sort order (default: natural order)\n   * @param {Number} options.skip Number of results to skip at the beginning\n   * @param {MongoFieldSpecifier} options.fields Dictionary of fields to return or exclude.\n   * @param {Boolean} options.reactive (Client only) Default true; pass false to disable reactivity\n   * @param {Function} options.transform Overrides `transform` on the [`Collection`](#collections) for this cursor.  Pass `null` to disable transformation.\n   * @param {String} options.readPreference (Server only) Specifies a custom MongoDB [`readPreference`](https://docs.mongodb.com/manual/core/read-preference) for fetching the document. Possible values are `primary`, `primaryPreferred`, `secondary`, `secondaryPreferred` and `nearest`.\n   * @returns {Object}\n   */\n  findOneAsync(...args) {\n    return this._collection.findOneAsync(\n      this._getFindSelector(args),\n      this._getFindOptions(args)\n    );\n  },\n  /**\n   * @summary Finds the first document that matches the selector, as ordered by sort and skip options. Returns `undefined` if no matching document is found.\n   * @locus Anywhere\n   * @method findOne\n   * @memberof Mongo.Collection\n   * @instance\n   * @param {MongoSelector} [selector] A query describing the documents to find\n   * @param {Object} [options]\n   * @param {MongoSortSpecifier} options.sort Sort order (default: natural order)\n   * @param {Number} options.skip Number of results to skip at the beginning\n   * @param {MongoFieldSpecifier} options.fields Dictionary of fields to return or exclude.\n   * @param {Boolean} options.reactive (Client only) Default true; pass false to disable reactivity\n   * @param {Function} options.transform Overrides `transform` on the [`Collection`](#collections) for this cursor.  Pass `null` to disable transformation.\n   * @param {String} options.readPreference (Server only) Specifies a custom MongoDB [`readPreference`](https://docs.mongodb.com/manual/core/read-preference) for fetching the document. Possible values are `primary`, `primaryPreferred`, `secondary`, `secondaryPreferred` and `nearest`.\n   * @returns {Object}\n   */\n  findOne(...args) {\n    return this._collection.findOne(\n      this._getFindSelector(args),\n      this._getFindOptions(args)\n    );\n  },\n});\n\nObject.assign(Mongo.Collection, {\n  async _publishCursor(cursor, sub, collection) {\n    var observeHandle = await cursor.observeChanges(\n        {\n          added: function(id, fields) {\n            sub.added(collection, id, fields);\n          },\n          changed: function(id, fields) {\n            sub.changed(collection, id, fields);\n          },\n          removed: function(id) {\n            sub.removed(collection, id);\n          },\n        },\n        // Publications don't mutate the documents\n        // This is tested by the `livedata - publish callbacks clone` test\n        { nonMutatingCallbacks: true }\n    );\n\n    // We don't call sub.ready() here: it gets called in livedata_server, after\n    // possibly calling _publishCursor on multiple returned cursors.\n\n    // register stop callback (expects lambda w/ no args).\n    sub.onStop(async function() {\n      return await observeHandle.stop();\n    });\n\n    // return the observeHandle in case it needs to be stopped early\n    return observeHandle;\n  },\n\n  // protect against dangerous selectors.  falsey and {_id: falsey} are both\n  // likely programmer error, and not what you want, particularly for destructive\n  // operations. If a falsey _id is sent in, a new string _id will be\n  // generated and returned; if a fallbackId is provided, it will be returned\n  // instead.\n  _rewriteSelector(selector, { fallbackId } = {}) {\n    // shorthand -- scalars match _id\n    if (LocalCollection._selectorIsId(selector)) selector = { _id: selector };\n\n    if (Array.isArray(selector)) {\n      // This is consistent with the Mongo console itself; if we don't do this\n      // check passing an empty array ends up selecting all items\n      throw new Error(\"Mongo selector can't be an array.\");\n    }\n\n    if (!selector || ('_id' in selector && !selector._id)) {\n      // can't match anything\n      return { _id: fallbackId || Random.id() };\n    }\n\n    return selector;\n  },\n});\n\nObject.assign(Mongo.Collection.prototype, {\n  // 'insert' immediately returns the inserted document's new _id.\n  // The others return values immediately if you are in a stub, an in-memory\n  // unmanaged collection, or a mongo-backed collection and you don't pass a\n  // callback. 'update' and 'remove' return the number of affected\n  // documents. 'upsert' returns an object with keys 'numberAffected' and, if an\n  // insert happened, 'insertedId'.\n  //\n  // Otherwise, the semantics are exactly like other methods: they take\n  // a callback as an optional last argument; if no callback is\n  // provided, they block until the operation is complete, and throw an\n  // exception if it fails; if a callback is provided, then they don't\n  // necessarily block, and they call the callback when they finish with error and\n  // result arguments.  (The insert method provides the document ID as its result;\n  // update and remove provide the number of affected docs as the result; upsert\n  // provides an object with numberAffected and maybe insertedId.)\n  //\n  // On the client, blocking is impossible, so if a callback\n  // isn't provided, they just return immediately and any error\n  // information is lost.\n  //\n  // There's one more tweak. On the client, if you don't provide a\n  // callback, then if there is an error, a message will be logged with\n  // Meteor._debug.\n  //\n  // The intent (though this is actually determined by the underlying\n  // drivers) is that the operations should be done synchronously, not\n  // generating their result until the database has acknowledged\n  // them. In the future maybe we should provide a flag to turn this\n  // off.\n\n  _insert(doc, callback) {\n    // Make sure we were passed a document to insert\n    if (!doc) {\n      throw new Error('insert requires an argument');\n    }\n\n\n    // Make a shallow clone of the document, preserving its prototype.\n    doc = Object.create(\n      Object.getPrototypeOf(doc),\n      Object.getOwnPropertyDescriptors(doc)\n    );\n\n    if ('_id' in doc) {\n      if (\n        !doc._id ||\n        !(typeof doc._id === 'string' || doc._id instanceof Mongo.ObjectID)\n      ) {\n        throw new Error(\n          'Meteor requires document _id fields to be non-empty strings or ObjectIDs'\n        );\n      }\n    } else {\n      let generateId = true;\n\n      // Don't generate the id if we're the client and the 'outermost' call\n      // This optimization saves us passing both the randomSeed and the id\n      // Passing both is redundant.\n      if (this._isRemoteCollection()) {\n        const enclosing = DDP._CurrentMethodInvocation.get();\n        if (!enclosing) {\n          generateId = false;\n        }\n      }\n\n      if (generateId) {\n        doc._id = this._makeNewID();\n      }\n    }\n\n\n    // On inserts, always return the id that we generated; on all other\n    // operations, just return the result from the collection.\n    var chooseReturnValueFromCollectionResult = function(result) {\n      if (Meteor._isPromise(result)) return result;\n\n      if (doc._id) {\n        return doc._id;\n      }\n\n      // XXX what is this for??\n      // It's some iteraction between the callback to _callMutatorMethod and\n      // the return value conversion\n      doc._id = result;\n\n      return result;\n    };\n\n    const wrappedCallback = wrapCallback(\n      callback,\n      chooseReturnValueFromCollectionResult\n    );\n\n    if (this._isRemoteCollection()) {\n      const result = this._callMutatorMethod('insert', [doc], wrappedCallback);\n      return chooseReturnValueFromCollectionResult(result);\n    }\n\n    // it's my collection.  descend into the collection object\n    // and propagate any exception.\n    try {\n      // If the user provided a callback and the collection implements this\n      // operation asynchronously, then queryRet will be undefined, and the\n      // result will be returned through the callback instead.\n      let result;\n      if (!!wrappedCallback) {\n        this._collection.insert(doc, wrappedCallback);\n      } else {\n        // If we don't have the callback, we assume the user is using the promise.\n        // We can't just pass this._collection.insert to the promisify because it would lose the context.\n        result = this._collection.insert(doc);\n      }\n\n      return chooseReturnValueFromCollectionResult(result);\n    } catch (e) {\n      if (callback) {\n        callback(e);\n        return null;\n      }\n      throw e;\n    }\n  },\n\n  /**\n   * @summary Insert a document in the collection.  Returns its unique _id.\n   * @locus Anywhere\n   * @method  insert\n   * @memberof Mongo.Collection\n   * @instance\n   * @param {Object} doc The document to insert. May not yet have an _id attribute, in which case Meteor will generate one for you.\n   * @param {Function} [callback] Optional.  If present, called with an error object as the first argument and, if no error, the _id as the second.\n   */\n  insert(doc, callback) {\n    return this._insert(doc, callback);\n  },\n\n  _insertAsync(doc, options = {}) {\n    // Make sure we were passed a document to insert\n    if (!doc) {\n      throw new Error('insert requires an argument');\n    }\n\n    // Make a shallow clone of the document, preserving its prototype.\n    doc = Object.create(\n        Object.getPrototypeOf(doc),\n        Object.getOwnPropertyDescriptors(doc)\n    );\n\n    if ('_id' in doc) {\n      if (\n          !doc._id ||\n          !(typeof doc._id === 'string' || doc._id instanceof Mongo.ObjectID)\n      ) {\n        throw new Error(\n            'Meteor requires document _id fields to be non-empty strings or ObjectIDs'\n        );\n      }\n    } else {\n      let generateId = true;\n\n      // Don't generate the id if we're the client and the 'outermost' call\n      // This optimization saves us passing both the randomSeed and the id\n      // Passing both is redundant.\n      if (this._isRemoteCollection()) {\n        const enclosing = DDP._CurrentMethodInvocation.get();\n        if (!enclosing) {\n          generateId = false;\n        }\n      }\n\n      if (generateId) {\n        doc._id = this._makeNewID();\n      }\n    }\n\n    // On inserts, always return the id that we generated; on all other\n    // operations, just return the result from the collection.\n    var chooseReturnValueFromCollectionResult = function(result) {\n      if (Meteor._isPromise(result)) return result;\n\n      if (doc._id) {\n        return doc._id;\n      }\n\n      // XXX what is this for??\n      // It's some iteraction between the callback to _callMutatorMethod and\n      // the return value conversion\n      doc._id = result;\n\n      return result;\n    };\n\n    if (this._isRemoteCollection()) {\n      const promise = this._callMutatorMethodAsync('insertAsync', [doc], options);\n      promise.then(chooseReturnValueFromCollectionResult);\n      promise.stubPromise = promise.stubPromise.then(chooseReturnValueFromCollectionResult);\n      promise.serverPromise = promise.serverPromise.then(chooseReturnValueFromCollectionResult);\n      return promise;\n    }\n\n    // it's my collection.  descend into the collection object\n    // and propagate any exception.\n    return this._collection.insertAsync(doc)\n      .then(chooseReturnValueFromCollectionResult);\n  },\n\n  /**\n   * @summary Insert a document in the collection.  Returns a promise that will return the document's unique _id when solved.\n   * @locus Anywhere\n   * @method  insert\n   * @memberof Mongo.Collection\n   * @instance\n   * @param {Object} doc The document to insert. May not yet have an _id attribute, in which case Meteor will generate one for you.\n   */\n  insertAsync(doc, options) {\n    return this._insertAsync(doc, options);\n  },\n\n  /**\n   * @summary Modify one or more documents in the collection. Returns the number of matched documents.\n   * @locus Anywhere\n   * @method update\n   * @memberof Mongo.Collection\n   * @instance\n   * @param {MongoSelector} selector Specifies which documents to modify\n   * @param {MongoModifier} modifier Specifies how to modify the documents\n   * @param {Object} [options]\n   * @param {Boolean} options.multi True to modify all matching documents; false to only modify one of the matching documents (the default).\n   * @param {Boolean} options.upsert True to insert a document if no matching documents are found.\n   * @param {Array} options.arrayFilters Optional. Used in combination with MongoDB [filtered positional operator](https://docs.mongodb.com/manual/reference/operator/update/positional-filtered/) to specify which elements to modify in an array field.\n   */\n  updateAsync(selector, modifier, ...optionsAndCallback) {\n\n    // We've already popped off the callback, so we are left with an array\n    // of one or zero items\n    const options = { ...(optionsAndCallback[0] || null) };\n    let insertedId;\n    if (options && options.upsert) {\n      // set `insertedId` if absent.  `insertedId` is a Meteor extension.\n      if (options.insertedId) {\n        if (\n          !(\n            typeof options.insertedId === 'string' ||\n            options.insertedId instanceof Mongo.ObjectID\n          )\n        )\n          throw new Error('insertedId must be string or ObjectID');\n        insertedId = options.insertedId;\n      } else if (!selector || !selector._id) {\n        insertedId = this._makeNewID();\n        options.generatedId = true;\n        options.insertedId = insertedId;\n      }\n    }\n\n    selector = Mongo.Collection._rewriteSelector(selector, {\n      fallbackId: insertedId,\n    });\n\n    if (this._isRemoteCollection()) {\n      const args = [selector, modifier, options];\n\n      return this._callMutatorMethodAsync('updateAsync', args, options);\n    }\n\n    // it's my collection.  descend into the collection object\n    // and propagate any exception.\n      // If the user provided a callback and the collection implements this\n      // operation asynchronously, then queryRet will be undefined, and the\n      // result will be returned through the callback instead.\n\n    return this._collection.updateAsync(\n      selector,\n      modifier,\n      options\n    );\n  },\n\n  /**\n   * @summary Asynchronously modifies one or more documents in the collection. Returns the number of matched documents.\n   * @locus Anywhere\n   * @method update\n   * @memberof Mongo.Collection\n   * @instance\n   * @param {MongoSelector} selector Specifies which documents to modify\n   * @param {MongoModifier} modifier Specifies how to modify the documents\n   * @param {Object} [options]\n   * @param {Boolean} options.multi True to modify all matching documents; false to only modify one of the matching documents (the default).\n   * @param {Boolean} options.upsert True to insert a document if no matching documents are found.\n   * @param {Array} options.arrayFilters Optional. Used in combination with MongoDB [filtered positional operator](https://docs.mongodb.com/manual/reference/operator/update/positional-filtered/) to specify which elements to modify in an array field.\n   * @param {Function} [callback] Optional.  If present, called with an error object as the first argument and, if no error, the number of affected documents as the second.\n   */\n  update(selector, modifier, ...optionsAndCallback) {\n    const callback = popCallbackFromArgs(optionsAndCallback);\n\n    // We've already popped off the callback, so we are left with an array\n    // of one or zero items\n    const options = { ...(optionsAndCallback[0] || null) };\n    let insertedId;\n    if (options && options.upsert) {\n      // set `insertedId` if absent.  `insertedId` is a Meteor extension.\n      if (options.insertedId) {\n        if (\n          !(\n            typeof options.insertedId === 'string' ||\n            options.insertedId instanceof Mongo.ObjectID\n          )\n        )\n          throw new Error('insertedId must be string or ObjectID');\n        insertedId = options.insertedId;\n      } else if (!selector || !selector._id) {\n        insertedId = this._makeNewID();\n        options.generatedId = true;\n        options.insertedId = insertedId;\n      }\n    }\n\n    selector = Mongo.Collection._rewriteSelector(selector, {\n      fallbackId: insertedId,\n    });\n\n    const wrappedCallback = wrapCallback(callback);\n\n    if (this._isRemoteCollection()) {\n      const args = [selector, modifier, options];\n      return this._callMutatorMethod('update', args, callback);\n    }\n\n    // it's my collection.  descend into the collection object\n    // and propagate any exception.\n    // If the user provided a callback and the collection implements this\n    // operation asynchronously, then queryRet will be undefined, and the\n    // result will be returned through the callback instead.\n    //console.log({callback, options, selector, modifier, coll: this._collection});\n    try {\n      // If the user provided a callback and the collection implements this\n      // operation asynchronously, then queryRet will be undefined, and the\n      // result will be returned through the callback instead.\n      return this._collection.update(\n        selector,\n        modifier,\n        options,\n        wrappedCallback\n      );\n    } catch (e) {\n      if (callback) {\n        callback(e);\n        return null;\n      }\n      throw e;\n    }\n  },\n\n  /**\n   * @summary Asynchronously removes documents from the collection.\n   * @locus Anywhere\n   * @method remove\n   * @memberof Mongo.Collection\n   * @instance\n   * @param {MongoSelector} selector Specifies which documents to remove\n   */\n  removeAsync(selector, options = {}) {\n    selector = Mongo.Collection._rewriteSelector(selector);\n\n    if (this._isRemoteCollection()) {\n      return this._callMutatorMethodAsync('removeAsync', [selector], options);\n    }\n\n    // it's my collection.  descend into the collection1 object\n    // and propagate any exception.\n    return this._collection.removeAsync(selector);\n  },\n\n  /**\n   * @summary Remove documents from the collection\n   * @locus Anywhere\n   * @method remove\n   * @memberof Mongo.Collection\n   * @instance\n   * @param {MongoSelector} selector Specifies which documents to remove\n   * @param {Function} [callback] Optional.  If present, called with an error object as the first argument and, if no error, the number of affected documents as the second.\n   */\n  remove(selector, callback) {\n    selector = Mongo.Collection._rewriteSelector(selector);\n\n    if (this._isRemoteCollection()) {\n      return this._callMutatorMethod('remove', [selector], callback);\n    }\n\n\n    // it's my collection.  descend into the collection1 object\n    // and propagate any exception.\n    return this._collection.remove(selector);\n  },\n\n\n  // Determine if this collection is simply a minimongo representation of a real\n  // database on another server\n  _isRemoteCollection() {\n    // XXX see #MeteorServerNull\n    return this._connection && this._connection !== Meteor.server;\n  },\n\n  /**\n   * @summary Asynchronously modifies one or more documents in the collection, or insert one if no matching documents were found. Returns an object with keys `numberAffected` (the number of documents modified)  and `insertedId` (the unique _id of the document that was inserted, if any).\n   * @locus Anywhere\n   * @method upsert\n   * @memberof Mongo.Collection\n   * @instance\n   * @param {MongoSelector} selector Specifies which documents to modify\n   * @param {MongoModifier} modifier Specifies how to modify the documents\n   * @param {Object} [options]\n   * @param {Boolean} options.multi True to modify all matching documents; false to only modify one of the matching documents (the default).\n   */\n    async upsertAsync(selector, modifier, options) {\n      return this.updateAsync(\n        selector,\n        modifier,\n        {\n          ...options,\n          _returnObject: true,\n          upsert: true,\n        });\n    },\n\n\n  /**\n   * @summary Asynchronously modifies one or more documents in the collection, or insert one if no matching documents were found. Returns an object with keys `numberAffected` (the number of documents modified)  and `insertedId` (the unique _id of the document that was inserted, if any).\n   * @locus Anywhere\n   * @method upsert\n   * @memberof Mongo.Collection\n   * @instance\n   * @param {MongoSelector} selector Specifies which documents to modify\n   * @param {MongoModifier} modifier Specifies how to modify the documents\n   * @param {Object} [options]\n   * @param {Boolean} options.multi True to modify all matching documents; false to only modify one of the matching documents (the default).\n   * @param {Function} [callback] Optional.  If present, called with an error object as the first argument and, if no error, the number of affected documents as the second.\n   */\n  upsert(selector, modifier, options, callback) {\n    if (!callback && typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    return this.update(\n      selector,\n      modifier,\n      {\n        ...options,\n        _returnObject: true,\n        upsert: true,\n      });\n  },\n\n  // We'll actually design an index API later. For now, we just pass through to\n  // Mongo's, but make it synchronous.\n  /**\n   * @summary Asynchronously creates the specified index on the collection.\n   * @locus server\n   * @method ensureIndexAsync\n   * @deprecated in 3.0\n   * @memberof Mongo.Collection\n   * @instance\n   * @param {Object} index A document that contains the field and value pairs where the field is the index key and the value describes the type of index for that field. For an ascending index on a field, specify a value of `1`; for descending index, specify a value of `-1`. Use `text` for text indexes.\n   * @param {Object} [options] All options are listed in [MongoDB documentation](https://docs.mongodb.com/manual/reference/method/db.collection.createIndex/#options)\n   * @param {String} options.name Name of the index\n   * @param {Boolean} options.unique Define that the index values must be unique, more at [MongoDB documentation](https://docs.mongodb.com/manual/core/index-unique/)\n   * @param {Boolean} options.sparse Define that the index is sparse, more at [MongoDB documentation](https://docs.mongodb.com/manual/core/index-sparse/)\n   */\n  async ensureIndexAsync(index, options) {\n    var self = this;\n    if (!self._collection.ensureIndexAsync || !self._collection.createIndexAsync)\n      throw new Error('Can only call createIndexAsync on server collections');\n    if (self._collection.createIndexAsync) {\n      await self._collection.createIndexAsync(index, options);\n    } else {\n      import { Log } from 'meteor/logging';\n\n      Log.debug(`ensureIndexAsync has been deprecated, please use the new 'createIndexAsync' instead${ options?.name ? `, index name: ${ options.name }` : `, index: ${ JSON.stringify(index) }` }`)\n      await self._collection.ensureIndexAsync(index, options);\n    }\n  },\n\n  /**\n   * @summary Asynchronously creates the specified index on the collection.\n   * @locus server\n   * @method createIndexAsync\n   * @memberof Mongo.Collection\n   * @instance\n   * @param {Object} index A document that contains the field and value pairs where the field is the index key and the value describes the type of index for that field. For an ascending index on a field, specify a value of `1`; for descending index, specify a value of `-1`. Use `text` for text indexes.\n   * @param {Object} [options] All options are listed in [MongoDB documentation](https://docs.mongodb.com/manual/reference/method/db.collection.createIndex/#options)\n   * @param {String} options.name Name of the index\n   * @param {Boolean} options.unique Define that the index values must be unique, more at [MongoDB documentation](https://docs.mongodb.com/manual/core/index-unique/)\n   * @param {Boolean} options.sparse Define that the index is sparse, more at [MongoDB documentation](https://docs.mongodb.com/manual/core/index-sparse/)\n   */\n  async createIndexAsync(index, options) {\n    var self = this;\n    if (!self._collection.createIndexAsync)\n      throw new Error('Can only call createIndexAsync on server collections');\n\n    try {\n      await self._collection.createIndexAsync(index, options);\n    } catch (e) {\n      if (\n        e.message.includes(\n          'An equivalent index already exists with the same name but different options.'\n        ) &&\n        Meteor.settings?.packages?.mongo?.reCreateIndexOnOptionMismatch\n      ) {\n        import { Log } from 'meteor/logging';\n\n        Log.info(`Re-creating index ${ index } for ${ self._name } due to options mismatch.`);\n        await self._collection.dropIndexAsync(index);\n        await self._collection.createIndexAsync(index, options);\n      } else {\n        console.error(e);\n        throw new Meteor.Error(`An error occurred when creating an index for collection \"${ self._name }: ${ e.message }`);\n      }\n    }\n  },\n\n  /**\n   * @summary Asynchronously creates the specified index on the collection.\n   * @locus server\n   * @method createIndex\n   * @memberof Mongo.Collection\n   * @instance\n   * @param {Object} index A document that contains the field and value pairs where the field is the index key and the value describes the type of index for that field. For an ascending index on a field, specify a value of `1`; for descending index, specify a value of `-1`. Use `text` for text indexes.\n   * @param {Object} [options] All options are listed in [MongoDB documentation](https://docs.mongodb.com/manual/reference/method/db.collection.createIndex/#options)\n   * @param {String} options.name Name of the index\n   * @param {Boolean} options.unique Define that the index values must be unique, more at [MongoDB documentation](https://docs.mongodb.com/manual/core/index-unique/)\n   * @param {Boolean} options.sparse Define that the index is sparse, more at [MongoDB documentation](https://docs.mongodb.com/manual/core/index-sparse/)\n   */\n  createIndex(index, options){\n    return this.createIndexAsync(index, options);\n  },\n\n  async dropIndexAsync(index) {\n    var self = this;\n    if (!self._collection.dropIndexAsync)\n      throw new Error('Can only call dropIndexAsync on server collections');\n    await self._collection.dropIndexAsync(index);\n  },\n\n  async dropCollectionAsync() {\n    var self = this;\n    if (!self._collection.dropCollectionAsync)\n      throw new Error('Can only call dropCollectionAsync on server collections');\n   await self._collection.dropCollectionAsync();\n  },\n\n  async createCappedCollectionAsync(byteSize, maxDocuments) {\n    var self = this;\n    if (! await self._collection.createCappedCollectionAsync)\n      throw new Error(\n        'Can only call createCappedCollectionAsync on server collections'\n      );\n    await self._collection.createCappedCollectionAsync(byteSize, maxDocuments);\n  },\n\n  /**\n   * @summary Returns the [`Collection`](http://mongodb.github.io/node-mongodb-native/3.0/api/Collection.html) object corresponding to this collection from the [npm `mongodb` driver module](https://www.npmjs.com/package/mongodb) which is wrapped by `Mongo.Collection`.\n   * @locus Server\n   * @memberof Mongo.Collection\n   * @instance\n   */\n  rawCollection() {\n    var self = this;\n    if (!self._collection.rawCollection) {\n      throw new Error('Can only call rawCollection on server collections');\n    }\n    return self._collection.rawCollection();\n  },\n\n  /**\n   * @summary Returns the [`Db`](http://mongodb.github.io/node-mongodb-native/3.0/api/Db.html) object corresponding to this collection's database connection from the [npm `mongodb` driver module](https://www.npmjs.com/package/mongodb) which is wrapped by `Mongo.Collection`.\n   * @locus Server\n   * @memberof Mongo.Collection\n   * @instance\n   */\n  rawDatabase() {\n    var self = this;\n    if (!(self._driver.mongo && self._driver.mongo.db)) {\n      throw new Error('Can only call rawDatabase on server collections');\n    }\n    return self._driver.mongo.db;\n  },\n});\n\nObject.assign(Mongo, {\n  /**\n   * @summary Retrieve a Meteor collection instance by name. Only collections defined with [`new Mongo.Collection(...)`](#collections) are available with this method. For plain MongoDB collections, you'll want to look at [`rawDatabase()`](#Mongo-Collection-rawDatabase).\n   * @locus Anywhere\n   * @memberof Mongo\n   * @static\n   * @param {string} name Name of your collection as it was defined with `new Mongo.Collection()`.\n   * @returns {Mongo.Collection | undefined}\n   */\n  getCollection(name) {\n    return this._collections.get(name);\n  },\n\n  /**\n   * @summary A record of all defined Mongo.Collection instances, indexed by collection name.\n   * @type {Map<string, Mongo.Collection>}\n   * @memberof Mongo\n   * @protected\n   */\n  _collections: new Map(),\n})\n\n// Convert the callback to not return a result if there is an error\nfunction wrapCallback(callback, convertResult) {\n  return (\n    callback &&\n    function(error, result) {\n      if (error) {\n        callback(error);\n      } else if (typeof convertResult === 'function') {\n        callback(error, convertResult(result));\n      } else {\n        callback(error, result);\n      }\n    }\n  );\n}\n\n/**\n * @summary Create a Mongo-style `ObjectID`.  If you don't specify a `hexString`, the `ObjectID` will be generated randomly (not using MongoDB's ID construction rules).\n * @locus Anywhere\n * @class\n * @param {String} [hexString] Optional.  The 24-character hexadecimal contents of the ObjectID to create\n */\nMongo.ObjectID = MongoID.ObjectID;\n\n/**\n * @summary To create a cursor, use find. To access the documents in a cursor, use forEach, map, or fetch.\n * @class\n * @instanceName cursor\n */\nMongo.Cursor = LocalCollection.Cursor;\n\n/**\n * @deprecated in 0.9.1\n */\nMongo.Collection.Cursor = Mongo.Cursor;\n\n/**\n * @deprecated in 0.9.1\n */\nMongo.Collection.ObjectID = Mongo.ObjectID;\n\n/**\n * @deprecated in 0.9.1\n */\nMeteor.Collection = Mongo.Collection;\n\n// Allow deny stuff is now in the allow-deny package\nObject.assign(Mongo.Collection.prototype, AllowDeny.CollectionPrototype);\n\nfunction popCallbackFromArgs(args) {\n  // Pull off any callback (or perhaps a 'callback' variable that was passed\n  // in undefined, like how 'upsert' does it).\n  if (\n    args.length &&\n    (args[args.length - 1] === undefined ||\n      args[args.length - 1] instanceof Function)\n  ) {\n    return args.pop();\n  }\n}\n","export const normalizeProjection = options => {\n  // transform fields key in projection\n  const { fields, projection, ...otherOptions } = options || {};\n  // TODO: enable this comment when deprecating the fields option\n  // Log.debug(`fields option has been deprecated, please use the new 'projection' instead`)\n\n  return {\n    ...otherOptions,\n    ...(projection || fields ? { projection: fields || projection } : {}),\n  };\n};\n"]}}]