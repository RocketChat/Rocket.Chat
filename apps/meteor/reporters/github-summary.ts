import { writeFileSync, mkdirSync } from 'fs';
import { dirname } from 'path';

import type { Reporter, TestCase, TestResult, Suite } from '@playwright/test/reporter';

interface ITestSummary {
	name: string;
	passed: number;
	failed: number;
	skipped: number;
	total: number;
	status: 'passed' | 'failed' | 'mixed';
}

class GitHubSummaryReporter implements Reporter {
	private testResults: Map<string, ITestSummary> = new Map();

	private outputPath: string;

	constructor(options: { outputPath?: string } = {}) {
		this.outputPath = options.outputPath || 'test-summary.md';
	}

	onTestEnd(test: TestCase, result: TestResult) {
		// Get the describe block name (suite title)
		const suiteName = this.getSuiteName(test);

		// Initialize or get existing summary
		let summary = this.testResults.get(suiteName);
		if (!summary) {
			summary = {
				name: suiteName,
				passed: 0,
				failed: 0,
				skipped: 0,
				total: 0,
				status: 'passed',
			};
			this.testResults.set(suiteName, summary);
		}

		// Update counters based on test result
		summary.total++;
		switch (result.status) {
			case 'passed':
				summary.passed++;
				break;
			case 'failed':
				summary.failed++;
				break;
			case 'skipped':
				summary.skipped++;
				break;
			case 'timedOut':
			case 'interrupted':
				summary.failed++;
				break;
		}

		// Update suite status
		if (summary.failed > 0) {
			summary.status = 'failed';
		} else if (summary.passed > 0 && summary.skipped > 0) {
			summary.status = 'mixed';
		}
	}

	onEnd() {
		this.generateSummary();
	}

	private getSuiteName(test: TestCase): string {
		// Walk up the suite hierarchy to collect all suite titles
		const suiteTitles: string[] = [];
		let suite: Suite | undefined = test.parent;

		while (suite) {
			if (suite.title && suite.title !== '') {
				// Skip filenames (they typically end with .spec.ts or .spec.js)
				if (!suite.title.endsWith('.spec.ts') && !suite.title.endsWith('.spec.js')) {
					suiteTitles.push(suite.title);
				}
			}
			suite = suite.parent;
		}

		// Return the top-most (outermost) describe block name
		// The array is built from innermost to outermost, so we want the last element
		if (suiteTitles.length > 0) {
			return suiteTitles[suiteTitles.length - 1];
		}

		return 'Unknown';
	}

	private generateSummary() {
		const summaries = Array.from(this.testResults.values());

		if (summaries.length === 0) {
			return;
		}

		// Sort by name for consistent output
		summaries.sort((a, b) => a.name.localeCompare(b.name));

		// Calculate totals
		const totals = summaries.reduce(
			(acc, summary) => ({
				passed: acc.passed + summary.passed,
				failed: acc.failed + summary.failed,
				skipped: acc.skipped + summary.skipped,
				total: acc.total + summary.total,
			}),
			{ passed: 0, failed: 0, skipped: 0, total: 0 },
		);

		// Generate markdown content
		const markdown = this.generateMarkdown(summaries, totals);

		// Write to file
		try {
			// Ensure directory exists
			const dir = dirname(this.outputPath);
			if (dir !== '.') {
				mkdirSync(dir, { recursive: true });
			}

			writeFileSync(this.outputPath, markdown, 'utf8');
			console.log(`âœ… Test summary written to ${this.outputPath}`);
		} catch (error) {
			console.error('âŒ Failed to write test summary:', error);
		}
	}

	private generateMarkdown(summaries: ITestSummary[], totals: { passed: number; failed: number; skipped: number; total: number }): string {
		const getStatusIcon = (status: string) => {
			switch (status) {
				case 'passed':
					return 'ðŸŸ¢';
				case 'failed':
					return 'ðŸ”´';
				case 'mixed':
					return 'ðŸŸ¡';
				default:
					return 'âšª';
			}
		};

		let markdown = '# ðŸ§ª E2E Test Summary\n\n';

		// Overall status
		const overallStatus = totals.failed > 0 ? 'failed' : 'passed';
		markdown += `## Overall Status: ${getStatusIcon(overallStatus)} ${overallStatus.toUpperCase()}\n\n`;

		// Summary stats
		markdown += '### ðŸ“Š Summary Statistics\n\n';
		markdown += `- **Total Tests**: ${totals.total}\n`;
		markdown += `- **âœ… Passed**: ${totals.passed}\n`;
		markdown += `- **âŒ Failed**: ${totals.failed}\n`;
		markdown += `- **â­ï¸ Skipped**: ${totals.skipped}\n`;

		if (totals.total > 0) {
			const passRate = ((totals.passed / totals.total) * 100).toFixed(1);
			markdown += `- **ðŸ“ˆ Pass Rate**: ${passRate}%\n`;
		}

		markdown += '\n';

		// Test suites breakdown
		markdown += '### ðŸ“‹ Test Suites\n\n';
		markdown += '| Suite | Status | Passed | Failed | Skipped | Total |\n';
		markdown += '|-------|--------|--------|--------|---------|-------|\n';

		for (const summary of summaries) {
			const icon = getStatusIcon(summary.status);
			markdown += `| ${summary.name} | ${icon} ${summary.status} | ${summary.passed} | ${summary.failed} | ${summary.skipped} | ${summary.total} |\n`;
		}

		markdown += '\n---\n';
		markdown += '*Generated by Playwright E2E Test Runner*\n';

		return markdown;
	}
}

export default GitHubSummaryReporter;
