import { generate } from "astring";
// @deno-types="../../acorn.d.ts"
import { parse } from "acorn";
// @deno-types="../../acorn-walk.d.ts"
import { fullAncestor } from "acorn-walk";
import * as operations from "./operations.ts";
function fixAst(ast) {
  const pendingOperations = [
    operations.fixLivechatIsOnlineCalls,
    operations.checkReassignmentOfModifiedIdentifiers,
    operations.fixRoomUsernamesCalls
  ];
  // Have we touched the tree?
  let isModified = false;
  while(pendingOperations.length){
    const ops = pendingOperations.splice(0);
    const state = {
      isModified: false,
      functionIdentifiers: new Set()
    };
    fullAncestor(ast, (node, state, ancestors, type)=>{
      ops.forEach((operation)=>operation(node, state, ancestors, type));
    }, undefined, state);
    if (state.isModified) {
      isModified = true;
    }
    if (state.functionIdentifiers.size) {
      pendingOperations.push(operations.buildFixModifiedFunctionsOperation(state.functionIdentifiers), operations.checkReassignmentOfModifiedIdentifiers);
    }
  }
  return isModified;
}
export function fixBrokenSynchronousAPICalls(appSource) {
  const astRootNode = parse(appSource, {
    ecmaVersion: 2017,
    // Allow everything, we don't want to complain if code is badly written
    // Also, since the code itself has been transpiled, the chance of getting
    // shenanigans is lower
    allowReserved: true,
    allowReturnOutsideFunction: true,
    allowImportExportEverywhere: true,
    allowAwaitOutsideFunction: true,
    allowSuperOutsideMethod: true
  });
  if (fixAst(astRootNode)) {
    return generate(astRootNode);
  }
  return appSource;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vVXNlcnMvYWJoaW5hdi9yb2NrZXQuY2hhdC9Sb2NrZXQuQ2hhdC9wYWNrYWdlcy9hcHBzLWVuZ2luZS9kZW5vLXJ1bnRpbWUvbGliL2FzdC9tb2QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2VuZXJhdGUgfSBmcm9tIFwiYXN0cmluZ1wiO1xuLy8gQGRlbm8tdHlwZXM9XCIuLi8uLi9hY29ybi5kLnRzXCJcbmltcG9ydCB7IFByb2dyYW0sIHBhcnNlIH0gZnJvbSBcImFjb3JuXCI7XG4vLyBAZGVuby10eXBlcz1cIi4uLy4uL2Fjb3JuLXdhbGsuZC50c1wiXG5pbXBvcnQgeyBmdWxsQW5jZXN0b3IgfSBmcm9tIFwiYWNvcm4td2Fsa1wiO1xuXG5pbXBvcnQgKiBhcyBvcGVyYXRpb25zIGZyb20gXCIuL29wZXJhdGlvbnMudHNcIjtcbmltcG9ydCB0eXBlIHsgV2Fsa2VyU3RhdGUgfSBmcm9tIFwiLi9vcGVyYXRpb25zLnRzXCI7XG5cbmZ1bmN0aW9uIGZpeEFzdChhc3Q6IFByb2dyYW0pOiBib29sZWFuIHtcbiAgICBjb25zdCBwZW5kaW5nT3BlcmF0aW9ucyA9IFtcbiAgICAgICAgb3BlcmF0aW9ucy5maXhMaXZlY2hhdElzT25saW5lQ2FsbHMsXG4gICAgICAgIG9wZXJhdGlvbnMuY2hlY2tSZWFzc2lnbm1lbnRPZk1vZGlmaWVkSWRlbnRpZmllcnMsXG4gICAgICAgIG9wZXJhdGlvbnMuZml4Um9vbVVzZXJuYW1lc0NhbGxzLFxuICAgIF07XG5cbiAgICAvLyBIYXZlIHdlIHRvdWNoZWQgdGhlIHRyZWU/XG4gICAgbGV0IGlzTW9kaWZpZWQgPSBmYWxzZTtcblxuICAgIHdoaWxlIChwZW5kaW5nT3BlcmF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3Qgb3BzID0gcGVuZGluZ09wZXJhdGlvbnMuc3BsaWNlKDApO1xuICAgICAgICBjb25zdCBzdGF0ZTogV2Fsa2VyU3RhdGUgPSB7XG4gICAgICAgICAgICBpc01vZGlmaWVkOiBmYWxzZSxcbiAgICAgICAgICAgIGZ1bmN0aW9uSWRlbnRpZmllcnM6IG5ldyBTZXQ8c3RyaW5nPigpLFxuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bGxBbmNlc3Rvcihhc3QsIChub2RlLCBzdGF0ZSwgYW5jZXN0b3JzLCB0eXBlKSA9PiB7XG4gICAgICAgICAgICBvcHMuZm9yRWFjaChvcGVyYXRpb24gPT4gb3BlcmF0aW9uKG5vZGUsIHN0YXRlLCBhbmNlc3RvcnMsIHR5cGUpKTtcbiAgICAgICAgfSwgdW5kZWZpbmVkLCBzdGF0ZSk7XG5cbiAgICAgICAgaWYgKHN0YXRlLmlzTW9kaWZpZWQpIHtcbiAgICAgICAgICAgIGlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRlLmZ1bmN0aW9uSWRlbnRpZmllcnMuc2l6ZSkge1xuICAgICAgICAgICAgcGVuZGluZ09wZXJhdGlvbnMucHVzaChcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25zLmJ1aWxkRml4TW9kaWZpZWRGdW5jdGlvbnNPcGVyYXRpb24oc3RhdGUuZnVuY3Rpb25JZGVudGlmaWVycyksXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9ucy5jaGVja1JlYXNzaWdubWVudE9mTW9kaWZpZWRJZGVudGlmaWVyc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpc01vZGlmaWVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZml4QnJva2VuU3luY2hyb25vdXNBUElDYWxscyhhcHBTb3VyY2U6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgYXN0Um9vdE5vZGUgPSBwYXJzZShhcHBTb3VyY2UsIHtcbiAgICAgICAgZWNtYVZlcnNpb246IDIwMTcsXG4gICAgICAgIC8vIEFsbG93IGV2ZXJ5dGhpbmcsIHdlIGRvbid0IHdhbnQgdG8gY29tcGxhaW4gaWYgY29kZSBpcyBiYWRseSB3cml0dGVuXG4gICAgICAgIC8vIEFsc28sIHNpbmNlIHRoZSBjb2RlIGl0c2VsZiBoYXMgYmVlbiB0cmFuc3BpbGVkLCB0aGUgY2hhbmNlIG9mIGdldHRpbmdcbiAgICAgICAgLy8gc2hlbmFuaWdhbnMgaXMgbG93ZXJcbiAgICAgICAgYWxsb3dSZXNlcnZlZDogdHJ1ZSxcbiAgICAgICAgYWxsb3dSZXR1cm5PdXRzaWRlRnVuY3Rpb246IHRydWUsXG4gICAgICAgIGFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZTogdHJ1ZSxcbiAgICAgICAgYWxsb3dBd2FpdE91dHNpZGVGdW5jdGlvbjogdHJ1ZSxcbiAgICAgICAgYWxsb3dTdXBlck91dHNpZGVNZXRob2Q6IHRydWUsXG4gICAgfSk7XG5cbiAgICBpZiAoZml4QXN0KGFzdFJvb3ROb2RlKSkge1xuICAgICAgICByZXR1cm4gZ2VuZXJhdGUoYXN0Um9vdE5vZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBhcHBTb3VyY2U7XG59XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsU0FBUyxRQUFRLFFBQVEsVUFBVTtBQUNuQyxpQ0FBaUM7QUFDakMsU0FBa0IsS0FBSyxRQUFRLFFBQVE7QUFDdkMsc0NBQXNDO0FBQ3RDLFNBQVMsWUFBWSxRQUFRLGFBQWE7QUFFMUMsWUFBWSxnQkFBZ0Isa0JBQWtCO0FBRzlDLFNBQVMsT0FBTyxHQUFZO0VBQ3hCLE1BQU0sb0JBQW9CO0lBQ3RCLFdBQVcsd0JBQXdCO0lBQ25DLFdBQVcsc0NBQXNDO0lBQ2pELFdBQVcscUJBQXFCO0dBQ25DO0VBRUQsNEJBQTRCO0VBQzVCLElBQUksYUFBYTtFQUVqQixNQUFPLGtCQUFrQixNQUFNLENBQUU7SUFDN0IsTUFBTSxNQUFNLGtCQUFrQixNQUFNLENBQUM7SUFDckMsTUFBTSxRQUFxQjtNQUN2QixZQUFZO01BQ1oscUJBQXFCLElBQUk7SUFDN0I7SUFFQSxhQUFhLEtBQUssQ0FBQyxNQUFNLE9BQU8sV0FBVztNQUN2QyxJQUFJLE9BQU8sQ0FBQyxDQUFBLFlBQWEsVUFBVSxNQUFNLE9BQU8sV0FBVztJQUMvRCxHQUFHLFdBQVc7SUFFZCxJQUFJLE1BQU0sVUFBVSxFQUFFO01BQ2xCLGFBQWE7SUFDakI7SUFFQSxJQUFJLE1BQU0sbUJBQW1CLENBQUMsSUFBSSxFQUFFO01BQ2hDLGtCQUFrQixJQUFJLENBQ2xCLFdBQVcsa0NBQWtDLENBQUMsTUFBTSxtQkFBbUIsR0FDdkUsV0FBVyxzQ0FBc0M7SUFFekQ7RUFDSjtFQUVBLE9BQU87QUFDWDtBQUVBLE9BQU8sU0FBUyw2QkFBNkIsU0FBaUI7RUFDMUQsTUFBTSxjQUFjLE1BQU0sV0FBVztJQUNqQyxhQUFhO0lBQ2IsdUVBQXVFO0lBQ3ZFLHlFQUF5RTtJQUN6RSx1QkFBdUI7SUFDdkIsZUFBZTtJQUNmLDRCQUE0QjtJQUM1Qiw2QkFBNkI7SUFDN0IsMkJBQTJCO0lBQzNCLHlCQUF5QjtFQUM3QjtFQUVBLElBQUksT0FBTyxjQUFjO0lBQ3JCLE9BQU8sU0FBUztFQUNwQjtFQUVBLE9BQU87QUFDWCJ9