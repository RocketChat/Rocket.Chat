// @deno-types="../../acorn.d.ts"
export function getFunctionIdentifier(ancestors, functionNodeIndex) {
  const parent = ancestors[functionNodeIndex - 1];
  // If there is a parent node and it's not a computed property, we can try to
  // extract an identifier for our function from it. This needs to be done first
  // because when functions are assigned to named symbols, this will be the only
  // way to call it, even if the function itself has an identifier
  // Consider the following block:
  //
  // const foo = function bar() {}
  //
  // Even though the function itself has a name, the only way to call it in the
  // program is wiht `foo()`
  if (parent && !parent.computed) {
    // Several node types can have an id prop of type Identifier
    const { id } = parent;
    if (id?.type === 'Identifier') {
      return id.name;
    }
    // Usually assignments to object properties (MethodDefinition, Property)
    const { key } = parent;
    if (key?.type === 'Identifier') {
      return key.name;
    }
    // Variable assignments have left hand side that can be used as Identifier
    const { left } = parent;
    // Simple assignment: `const fn = () => {}`
    if (left?.type === 'Identifier') {
      return left.name;
    }
    // Object property assignment: `obj.fn = () => {}`
    if (left?.type === 'MemberExpression' && !left.computed) {
      return left.property.name;
    }
  }
  // nodeIndex needs to be the index of a Function node (either FunctionDeclaration or FunctionExpression)
  const currentNode = ancestors[functionNodeIndex];
  // Function declarations or expressions can be directly named
  if (currentNode.id?.type === 'Identifier') {
    return currentNode.id.name;
  }
}
export function wrapWithAwait(node) {
  if (!node.type.endsWith('Expression')) {
    throw new Error(`Can't wrap "${node.type}" with await`);
  }
  const innerNode = {
    ...node
  };
  node.type = 'AwaitExpression';
  // starting here node has become an AwaitExpression
  node.argument = innerNode;
  Object.keys(node).forEach((key)=>![
      'type',
      'argument'
    ].includes(key) && delete node[key]);
}
export function asyncifyScope(ancestors, state) {
  const functionNodeIndex = ancestors.findLastIndex((n)=>'async' in n);
  if (functionNodeIndex === -1) return;
  // At this point this is a node with an "async" property, so it has to be
  // of type Function - let TS know about that
  const functionScopeNode = ancestors[functionNodeIndex];
  if (functionScopeNode.async) {
    return;
  }
  functionScopeNode.async = true;
  // If the parent of a function node is a call expression, we're talking about an IIFE
  // Should we care about this case as well?
  // const parentNode = ancestors[functionScopeIndex-1];
  // if (parentNode?.type === 'CallExpression' && ancestors[functionScopeIndex-2] && ancestors[functionScopeIndex-2].type !== 'AwaitExpression') {
  //   pendingOperations.push(buildFunctionPredicate(getFunctionIdentifier(ancestors, functionScopeIndex-2)));
  // }
  const identifier = getFunctionIdentifier(ancestors, functionNodeIndex);
  // We can't fix calls of functions which name we can't determine at compile time
  if (!identifier) return;
  state.functionIdentifiers.add(identifier);
}
export function buildFixModifiedFunctionsOperation(functionIdentifiers) {
  return function _fixModifiedFunctionsOperation(node, state, ancestors) {
    if (node.type !== 'CallExpression') return;
    let isWrappable = false;
    // This node is a simple call to a function, like `fn()`
    isWrappable = node.callee.type === 'Identifier' && functionIdentifiers.has(node.callee.name);
    // This node is a call to an object property or instance method, like `obj.fn()`, but not computed like `obj[fn]()`
    isWrappable ||= node.callee.type === 'MemberExpression' && !node.callee.computed && node.callee.property?.type === 'Identifier' && functionIdentifiers.has(node.callee.property.name);
    // This is a weird dereferencing technique used by bundlers, and since we'll be dealing with bundled sources we have to check for it
    // e.g. `r=(0,fn)(e)`
    if (!isWrappable && node.callee.type === 'SequenceExpression') {
      const [, secondExpression] = node.callee.expressions;
      isWrappable = secondExpression?.type === 'Identifier' && functionIdentifiers.has(secondExpression.name);
      isWrappable ||= secondExpression?.type === 'MemberExpression' && !secondExpression.computed && secondExpression.property.type === 'Identifier' && functionIdentifiers.has(secondExpression.property.name);
    }
    if (!isWrappable) return;
    // ancestors[ancestors.length-1] === node, so here we're checking for parent node
    const parentNode = ancestors[ancestors.length - 2];
    if (!parentNode || parentNode.type === 'AwaitExpression') return;
    wrapWithAwait(node);
    asyncifyScope(ancestors, state);
    state.isModified = true;
  };
}
export const checkReassignmentOfModifiedIdentifiers = (node, { functionIdentifiers }, _ancestors)=>{
  if (node.type === 'AssignmentExpression') {
    if (node.operator !== '=') return;
    let identifier = '';
    if (node.left.type === 'Identifier') identifier = node.left.name;
    if (node.left.type === 'MemberExpression' && !node.left.computed) {
      identifier = node.left.property.name;
    }
    if (!identifier || node.right.type !== 'Identifier' || !functionIdentifiers.has(node.right.name)) return;
    functionIdentifiers.add(identifier);
    return;
  }
  if (node.type === 'VariableDeclarator') {
    if (node.id.type !== 'Identifier' || functionIdentifiers.has(node.id.name)) return;
    if (node.init?.type !== 'Identifier' || !functionIdentifiers.has(node.init?.name)) return;
    functionIdentifiers.add(node.id.name);
    return;
  }
  // "Property" is for plain objects, "PropertyDefinition" is for classes
  // but both share the same structure
  if (node.type === 'Property' || node.type === 'PropertyDefinition') {
    if (node.key.type !== 'Identifier' || functionIdentifiers.has(node.key.name)) return;
    if (node.value?.type !== 'Identifier' || !functionIdentifiers.has(node.value.name)) return;
    functionIdentifiers.add(node.key.name);
    return;
  }
};
export const fixLivechatIsOnlineCalls = (node, state, ancestors)=>{
  if (node.type !== 'MemberExpression' || node.computed) return;
  if (node.property.name !== 'isOnline') return;
  if (node.object.type !== 'CallExpression') return;
  if (node.object.callee.type !== 'MemberExpression') return;
  if (node.object.callee.property.name !== 'getLivechatReader') return;
  let parentIndex = ancestors.length - 2;
  let targetNode = ancestors[parentIndex];
  if (targetNode.type !== 'CallExpression') {
    targetNode = node;
  } else {
    parentIndex--;
  }
  // If we're already wrapped with an await, nothing to do
  if (ancestors[parentIndex].type === 'AwaitExpression') return;
  // If we're in the middle of a chained member access, we can't wrap with await
  if (ancestors[parentIndex].type === 'MemberExpression') return;
  wrapWithAwait(targetNode);
  asyncifyScope(ancestors, state);
  state.isModified = true;
};
export const fixRoomUsernamesCalls = (node, state, ancestors)=>{
  if (node.type !== 'MemberExpression' || node.computed) return;
  if (node.property.name !== 'usernames') return;
  let parentIndex = ancestors.length - 2;
  let targetNode = ancestors[parentIndex];
  if (targetNode.type !== 'CallExpression') {
    targetNode = node;
  } else {
    parentIndex--;
  }
  // If we're already wrapped with an await, nothing to do
  if (ancestors[parentIndex].type === 'AwaitExpression') return;
  wrapWithAwait(targetNode);
  asyncifyScope(ancestors, state);
  state.isModified = true;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vVXNlcnMvYWJoaW5hdi9yb2NrZXQuY2hhdC9Sb2NrZXQuQ2hhdC9wYWNrYWdlcy9hcHBzLWVuZ2luZS9kZW5vLXJ1bnRpbWUvbGliL2FzdC9vcGVyYXRpb25zLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEBkZW5vLXR5cGVzPVwiLi4vLi4vYWNvcm4uZC50c1wiXG5pbXBvcnQgeyBBbnlOb2RlLCBBc3NpZ25tZW50RXhwcmVzc2lvbiwgQXdhaXRFeHByZXNzaW9uLCBFeHByZXNzaW9uLCBGdW5jdGlvbiwgSWRlbnRpZmllciwgTWV0aG9kRGVmaW5pdGlvbiwgUHJvcGVydHkgfSBmcm9tICdhY29ybic7XG4vLyBAZGVuby10eXBlcz1cIi4uLy4uL2Fjb3JuLXdhbGsuZC50c1wiXG5pbXBvcnQgeyBGdWxsQW5jZXN0b3JXYWxrZXJDYWxsYmFjayB9IGZyb20gJ2Fjb3JuLXdhbGsnO1xuXG5leHBvcnQgdHlwZSBXYWxrZXJTdGF0ZSA9IHtcbiAgICBpc01vZGlmaWVkOiBib29sZWFuO1xuICAgIGZ1bmN0aW9uSWRlbnRpZmllcnM6IFNldDxzdHJpbmc+O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZ1bmN0aW9uSWRlbnRpZmllcihhbmNlc3RvcnM6IEFueU5vZGVbXSwgZnVuY3Rpb25Ob2RlSW5kZXg6IG51bWJlcikge1xuICAgIGNvbnN0IHBhcmVudCA9IGFuY2VzdG9yc1tmdW5jdGlvbk5vZGVJbmRleCAtIDFdO1xuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSBwYXJlbnQgbm9kZSBhbmQgaXQncyBub3QgYSBjb21wdXRlZCBwcm9wZXJ0eSwgd2UgY2FuIHRyeSB0b1xuICAgIC8vIGV4dHJhY3QgYW4gaWRlbnRpZmllciBmb3Igb3VyIGZ1bmN0aW9uIGZyb20gaXQuIFRoaXMgbmVlZHMgdG8gYmUgZG9uZSBmaXJzdFxuICAgIC8vIGJlY2F1c2Ugd2hlbiBmdW5jdGlvbnMgYXJlIGFzc2lnbmVkIHRvIG5hbWVkIHN5bWJvbHMsIHRoaXMgd2lsbCBiZSB0aGUgb25seVxuICAgIC8vIHdheSB0byBjYWxsIGl0LCBldmVuIGlmIHRoZSBmdW5jdGlvbiBpdHNlbGYgaGFzIGFuIGlkZW50aWZpZXJcbiAgICAvLyBDb25zaWRlciB0aGUgZm9sbG93aW5nIGJsb2NrOlxuICAgIC8vXG4gICAgLy8gY29uc3QgZm9vID0gZnVuY3Rpb24gYmFyKCkge31cbiAgICAvL1xuICAgIC8vIEV2ZW4gdGhvdWdoIHRoZSBmdW5jdGlvbiBpdHNlbGYgaGFzIGEgbmFtZSwgdGhlIG9ubHkgd2F5IHRvIGNhbGwgaXQgaW4gdGhlXG4gICAgLy8gcHJvZ3JhbSBpcyB3aWh0IGBmb28oKWBcbiAgICBpZiAocGFyZW50ICYmICEocGFyZW50IGFzIFByb3BlcnR5IHwgTWV0aG9kRGVmaW5pdGlvbikuY29tcHV0ZWQpIHtcbiAgICAgICAgLy8gU2V2ZXJhbCBub2RlIHR5cGVzIGNhbiBoYXZlIGFuIGlkIHByb3Agb2YgdHlwZSBJZGVudGlmaWVyXG4gICAgICAgIGNvbnN0IHsgaWQgfSA9IHBhcmVudCBhcyB1bmtub3duIGFzIHsgaWQ/OiBJZGVudGlmaWVyIH07XG4gICAgICAgIGlmIChpZD8udHlwZSA9PT0gJ0lkZW50aWZpZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQubmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVzdWFsbHkgYXNzaWdubWVudHMgdG8gb2JqZWN0IHByb3BlcnRpZXMgKE1ldGhvZERlZmluaXRpb24sIFByb3BlcnR5KVxuICAgICAgICBjb25zdCB7IGtleSB9ID0gcGFyZW50IGFzIE1ldGhvZERlZmluaXRpb24gfCBQcm9wZXJ0eTtcbiAgICAgICAgaWYgKGtleT8udHlwZSA9PT0gJ0lkZW50aWZpZXInKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5Lm5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWYXJpYWJsZSBhc3NpZ25tZW50cyBoYXZlIGxlZnQgaGFuZCBzaWRlIHRoYXQgY2FuIGJlIHVzZWQgYXMgSWRlbnRpZmllclxuICAgICAgICBjb25zdCB7IGxlZnQgfSA9IHBhcmVudCBhcyBBc3NpZ25tZW50RXhwcmVzc2lvbjtcblxuICAgICAgICAvLyBTaW1wbGUgYXNzaWdubWVudDogYGNvbnN0IGZuID0gKCkgPT4ge31gXG4gICAgICAgIGlmIChsZWZ0Py50eXBlID09PSAnSWRlbnRpZmllcicpIHtcbiAgICAgICAgICAgIHJldHVybiBsZWZ0Lm5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPYmplY3QgcHJvcGVydHkgYXNzaWdubWVudDogYG9iai5mbiA9ICgpID0+IHt9YFxuICAgICAgICBpZiAobGVmdD8udHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nICYmICFsZWZ0LmNvbXB1dGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gKGxlZnQucHJvcGVydHkgYXMgSWRlbnRpZmllcikubmFtZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIG5vZGVJbmRleCBuZWVkcyB0byBiZSB0aGUgaW5kZXggb2YgYSBGdW5jdGlvbiBub2RlIChlaXRoZXIgRnVuY3Rpb25EZWNsYXJhdGlvbiBvciBGdW5jdGlvbkV4cHJlc3Npb24pXG4gICAgY29uc3QgY3VycmVudE5vZGUgPSBhbmNlc3RvcnNbZnVuY3Rpb25Ob2RlSW5kZXhdIGFzIEZ1bmN0aW9uO1xuXG4gICAgLy8gRnVuY3Rpb24gZGVjbGFyYXRpb25zIG9yIGV4cHJlc3Npb25zIGNhbiBiZSBkaXJlY3RseSBuYW1lZFxuICAgIGlmIChjdXJyZW50Tm9kZS5pZD8udHlwZSA9PT0gJ0lkZW50aWZpZXInKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50Tm9kZS5pZC5uYW1lO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBXaXRoQXdhaXQobm9kZTogRXhwcmVzc2lvbikge1xuICAgIGlmICghbm9kZS50eXBlLmVuZHNXaXRoKCdFeHByZXNzaW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCB3cmFwIFwiJHtub2RlLnR5cGV9XCIgd2l0aCBhd2FpdGApO1xuICAgIH1cblxuICAgIGNvbnN0IGlubmVyTm9kZTogRXhwcmVzc2lvbiA9IHsgLi4ubm9kZSB9O1xuXG4gICAgbm9kZS50eXBlID0gJ0F3YWl0RXhwcmVzc2lvbic7XG4gICAgLy8gc3RhcnRpbmcgaGVyZSBub2RlIGhhcyBiZWNvbWUgYW4gQXdhaXRFeHByZXNzaW9uXG4gICAgKG5vZGUgYXMgQXdhaXRFeHByZXNzaW9uKS5hcmd1bWVudCA9IGlubmVyTm9kZTtcblxuICAgIE9iamVjdC5rZXlzKG5vZGUpLmZvckVhY2goKGtleSkgPT4gIVsndHlwZScsICdhcmd1bWVudCddLmluY2x1ZGVzKGtleSkgJiYgZGVsZXRlIG5vZGVba2V5IGFzIGtleW9mIEFueU5vZGVdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzeW5jaWZ5U2NvcGUoYW5jZXN0b3JzOiBBbnlOb2RlW10sIHN0YXRlOiBXYWxrZXJTdGF0ZSkge1xuICAgIGNvbnN0IGZ1bmN0aW9uTm9kZUluZGV4ID0gYW5jZXN0b3JzLmZpbmRMYXN0SW5kZXgoKG4pID0+ICdhc3luYycgaW4gbik7XG4gICAgaWYgKGZ1bmN0aW9uTm9kZUluZGV4ID09PSAtMSkgcmV0dXJuO1xuXG4gICAgLy8gQXQgdGhpcyBwb2ludCB0aGlzIGlzIGEgbm9kZSB3aXRoIGFuIFwiYXN5bmNcIiBwcm9wZXJ0eSwgc28gaXQgaGFzIHRvIGJlXG4gICAgLy8gb2YgdHlwZSBGdW5jdGlvbiAtIGxldCBUUyBrbm93IGFib3V0IHRoYXRcbiAgICBjb25zdCBmdW5jdGlvblNjb3BlTm9kZSA9IGFuY2VzdG9yc1tmdW5jdGlvbk5vZGVJbmRleF0gYXMgRnVuY3Rpb247XG5cbiAgICBpZiAoZnVuY3Rpb25TY29wZU5vZGUuYXN5bmMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uU2NvcGVOb2RlLmFzeW5jID0gdHJ1ZTtcblxuICAgIC8vIElmIHRoZSBwYXJlbnQgb2YgYSBmdW5jdGlvbiBub2RlIGlzIGEgY2FsbCBleHByZXNzaW9uLCB3ZSdyZSB0YWxraW5nIGFib3V0IGFuIElJRkVcbiAgICAvLyBTaG91bGQgd2UgY2FyZSBhYm91dCB0aGlzIGNhc2UgYXMgd2VsbD9cbiAgICAvLyBjb25zdCBwYXJlbnROb2RlID0gYW5jZXN0b3JzW2Z1bmN0aW9uU2NvcGVJbmRleC0xXTtcbiAgICAvLyBpZiAocGFyZW50Tm9kZT8udHlwZSA9PT0gJ0NhbGxFeHByZXNzaW9uJyAmJiBhbmNlc3RvcnNbZnVuY3Rpb25TY29wZUluZGV4LTJdICYmIGFuY2VzdG9yc1tmdW5jdGlvblNjb3BlSW5kZXgtMl0udHlwZSAhPT0gJ0F3YWl0RXhwcmVzc2lvbicpIHtcbiAgICAvLyAgIHBlbmRpbmdPcGVyYXRpb25zLnB1c2goYnVpbGRGdW5jdGlvblByZWRpY2F0ZShnZXRGdW5jdGlvbklkZW50aWZpZXIoYW5jZXN0b3JzLCBmdW5jdGlvblNjb3BlSW5kZXgtMikpKTtcbiAgICAvLyB9XG5cbiAgICBjb25zdCBpZGVudGlmaWVyID0gZ2V0RnVuY3Rpb25JZGVudGlmaWVyKGFuY2VzdG9ycywgZnVuY3Rpb25Ob2RlSW5kZXgpO1xuXG4gICAgLy8gV2UgY2FuJ3QgZml4IGNhbGxzIG9mIGZ1bmN0aW9ucyB3aGljaCBuYW1lIHdlIGNhbid0IGRldGVybWluZSBhdCBjb21waWxlIHRpbWVcbiAgICBpZiAoIWlkZW50aWZpZXIpIHJldHVybjtcblxuICAgIHN0YXRlLmZ1bmN0aW9uSWRlbnRpZmllcnMuYWRkKGlkZW50aWZpZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRGaXhNb2RpZmllZEZ1bmN0aW9uc09wZXJhdGlvbihmdW5jdGlvbklkZW50aWZpZXJzOiBTZXQ8c3RyaW5nPik6IEZ1bGxBbmNlc3RvcldhbGtlckNhbGxiYWNrPFdhbGtlclN0YXRlPiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9maXhNb2RpZmllZEZ1bmN0aW9uc09wZXJhdGlvbihub2RlLCBzdGF0ZSwgYW5jZXN0b3JzKSB7XG4gICAgICAgIGlmIChub2RlLnR5cGUgIT09ICdDYWxsRXhwcmVzc2lvbicpIHJldHVybjtcblxuICAgICAgICBsZXQgaXNXcmFwcGFibGUgPSBmYWxzZTtcblxuICAgICAgICAvLyBUaGlzIG5vZGUgaXMgYSBzaW1wbGUgY2FsbCB0byBhIGZ1bmN0aW9uLCBsaWtlIGBmbigpYFxuICAgICAgICBpc1dyYXBwYWJsZSA9IG5vZGUuY2FsbGVlLnR5cGUgPT09ICdJZGVudGlmaWVyJyAmJiBmdW5jdGlvbklkZW50aWZpZXJzLmhhcyhub2RlLmNhbGxlZS5uYW1lKTtcblxuICAgICAgICAvLyBUaGlzIG5vZGUgaXMgYSBjYWxsIHRvIGFuIG9iamVjdCBwcm9wZXJ0eSBvciBpbnN0YW5jZSBtZXRob2QsIGxpa2UgYG9iai5mbigpYCwgYnV0IG5vdCBjb21wdXRlZCBsaWtlIGBvYmpbZm5dKClgXG4gICAgICAgIGlzV3JhcHBhYmxlIHx8PVxuICAgICAgICAgICAgbm9kZS5jYWxsZWUudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nICYmXG4gICAgICAgICAgICAhbm9kZS5jYWxsZWUuY29tcHV0ZWQgJiZcbiAgICAgICAgICAgIG5vZGUuY2FsbGVlLnByb3BlcnR5Py50eXBlID09PSAnSWRlbnRpZmllcicgJiZcbiAgICAgICAgICAgIGZ1bmN0aW9uSWRlbnRpZmllcnMuaGFzKG5vZGUuY2FsbGVlLnByb3BlcnR5Lm5hbWUpO1xuXG4gICAgICAgIC8vIFRoaXMgaXMgYSB3ZWlyZCBkZXJlZmVyZW5jaW5nIHRlY2huaXF1ZSB1c2VkIGJ5IGJ1bmRsZXJzLCBhbmQgc2luY2Ugd2UnbGwgYmUgZGVhbGluZyB3aXRoIGJ1bmRsZWQgc291cmNlcyB3ZSBoYXZlIHRvIGNoZWNrIGZvciBpdFxuICAgICAgICAvLyBlLmcuIGByPSgwLGZuKShlKWBcbiAgICAgICAgaWYgKCFpc1dyYXBwYWJsZSAmJiBub2RlLmNhbGxlZS50eXBlID09PSAnU2VxdWVuY2VFeHByZXNzaW9uJykge1xuICAgICAgICAgICAgY29uc3QgWywgc2Vjb25kRXhwcmVzc2lvbl0gPSBub2RlLmNhbGxlZS5leHByZXNzaW9ucztcbiAgICAgICAgICAgIGlzV3JhcHBhYmxlID0gc2Vjb25kRXhwcmVzc2lvbj8udHlwZSA9PT0gJ0lkZW50aWZpZXInICYmIGZ1bmN0aW9uSWRlbnRpZmllcnMuaGFzKHNlY29uZEV4cHJlc3Npb24ubmFtZSk7XG4gICAgICAgICAgICBpc1dyYXBwYWJsZSB8fD1cbiAgICAgICAgICAgICAgICBzZWNvbmRFeHByZXNzaW9uPy50eXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbicgJiZcbiAgICAgICAgICAgICAgICAhc2Vjb25kRXhwcmVzc2lvbi5jb21wdXRlZCAmJlxuICAgICAgICAgICAgICAgIHNlY29uZEV4cHJlc3Npb24ucHJvcGVydHkudHlwZSA9PT0gJ0lkZW50aWZpZXInICYmXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25JZGVudGlmaWVycy5oYXMoc2Vjb25kRXhwcmVzc2lvbi5wcm9wZXJ0eS5uYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNXcmFwcGFibGUpIHJldHVybjtcblxuICAgICAgICAvLyBhbmNlc3RvcnNbYW5jZXN0b3JzLmxlbmd0aC0xXSA9PT0gbm9kZSwgc28gaGVyZSB3ZSdyZSBjaGVja2luZyBmb3IgcGFyZW50IG5vZGVcbiAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IGFuY2VzdG9yc1thbmNlc3RvcnMubGVuZ3RoIC0gMl07XG4gICAgICAgIGlmICghcGFyZW50Tm9kZSB8fCBwYXJlbnROb2RlLnR5cGUgPT09ICdBd2FpdEV4cHJlc3Npb24nKSByZXR1cm47XG5cbiAgICAgICAgd3JhcFdpdGhBd2FpdChub2RlKTtcbiAgICAgICAgYXN5bmNpZnlTY29wZShhbmNlc3RvcnMsIHN0YXRlKTtcblxuICAgICAgICBzdGF0ZS5pc01vZGlmaWVkID0gdHJ1ZTtcbiAgICB9O1xufVxuXG5leHBvcnQgY29uc3QgY2hlY2tSZWFzc2lnbm1lbnRPZk1vZGlmaWVkSWRlbnRpZmllcnM6IEZ1bGxBbmNlc3RvcldhbGtlckNhbGxiYWNrPFdhbGtlclN0YXRlPiA9IChub2RlLCB7IGZ1bmN0aW9uSWRlbnRpZmllcnMgfSwgX2FuY2VzdG9ycykgPT4ge1xuICAgIGlmIChub2RlLnR5cGUgPT09ICdBc3NpZ25tZW50RXhwcmVzc2lvbicpIHtcbiAgICAgICAgaWYgKG5vZGUub3BlcmF0b3IgIT09ICc9JykgcmV0dXJuO1xuXG4gICAgICAgIGxldCBpZGVudGlmaWVyID0gJyc7XG5cbiAgICAgICAgaWYgKG5vZGUubGVmdC50eXBlID09PSAnSWRlbnRpZmllcicpIGlkZW50aWZpZXIgPSBub2RlLmxlZnQubmFtZTtcblxuICAgICAgICBpZiAobm9kZS5sZWZ0LnR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJyAmJiAhbm9kZS5sZWZ0LmNvbXB1dGVkKSB7XG4gICAgICAgICAgICBpZGVudGlmaWVyID0gKG5vZGUubGVmdC5wcm9wZXJ0eSBhcyBJZGVudGlmaWVyKS5uYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpZGVudGlmaWVyIHx8IG5vZGUucmlnaHQudHlwZSAhPT0gJ0lkZW50aWZpZXInIHx8ICFmdW5jdGlvbklkZW50aWZpZXJzLmhhcyhub2RlLnJpZ2h0Lm5hbWUpKSByZXR1cm47XG5cbiAgICAgICAgZnVuY3Rpb25JZGVudGlmaWVycy5hZGQoaWRlbnRpZmllcik7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLnR5cGUgPT09ICdWYXJpYWJsZURlY2xhcmF0b3InKSB7XG4gICAgICAgIGlmIChub2RlLmlkLnR5cGUgIT09ICdJZGVudGlmaWVyJyB8fCBmdW5jdGlvbklkZW50aWZpZXJzLmhhcyhub2RlLmlkLm5hbWUpKSByZXR1cm47XG5cbiAgICAgICAgaWYgKG5vZGUuaW5pdD8udHlwZSAhPT0gJ0lkZW50aWZpZXInIHx8ICFmdW5jdGlvbklkZW50aWZpZXJzLmhhcyhub2RlLmluaXQ/Lm5hbWUpKSByZXR1cm47XG5cbiAgICAgICAgZnVuY3Rpb25JZGVudGlmaWVycy5hZGQobm9kZS5pZC5uYW1lKTtcblxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gXCJQcm9wZXJ0eVwiIGlzIGZvciBwbGFpbiBvYmplY3RzLCBcIlByb3BlcnR5RGVmaW5pdGlvblwiIGlzIGZvciBjbGFzc2VzXG4gICAgLy8gYnV0IGJvdGggc2hhcmUgdGhlIHNhbWUgc3RydWN0dXJlXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ1Byb3BlcnR5JyB8fCBub2RlLnR5cGUgPT09ICdQcm9wZXJ0eURlZmluaXRpb24nKSB7XG4gICAgICAgIGlmIChub2RlLmtleS50eXBlICE9PSAnSWRlbnRpZmllcicgfHwgZnVuY3Rpb25JZGVudGlmaWVycy5oYXMobm9kZS5rZXkubmFtZSkpIHJldHVybjtcblxuICAgICAgICBpZiAobm9kZS52YWx1ZT8udHlwZSAhPT0gJ0lkZW50aWZpZXInIHx8ICFmdW5jdGlvbklkZW50aWZpZXJzLmhhcyhub2RlLnZhbHVlLm5hbWUpKSByZXR1cm47XG5cbiAgICAgICAgZnVuY3Rpb25JZGVudGlmaWVycy5hZGQobm9kZS5rZXkubmFtZSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbn07XG5cbmV4cG9ydCBjb25zdCBmaXhMaXZlY2hhdElzT25saW5lQ2FsbHM6IEZ1bGxBbmNlc3RvcldhbGtlckNhbGxiYWNrPFdhbGtlclN0YXRlPiA9IChub2RlLCBzdGF0ZSwgYW5jZXN0b3JzKSA9PiB7XG4gICAgaWYgKG5vZGUudHlwZSAhPT0gJ01lbWJlckV4cHJlc3Npb24nIHx8IG5vZGUuY29tcHV0ZWQpIHJldHVybjtcblxuICAgIGlmICgobm9kZS5wcm9wZXJ0eSBhcyBJZGVudGlmaWVyKS5uYW1lICE9PSAnaXNPbmxpbmUnKSByZXR1cm47XG5cbiAgICBpZiAobm9kZS5vYmplY3QudHlwZSAhPT0gJ0NhbGxFeHByZXNzaW9uJykgcmV0dXJuO1xuXG4gICAgaWYgKG5vZGUub2JqZWN0LmNhbGxlZS50eXBlICE9PSAnTWVtYmVyRXhwcmVzc2lvbicpIHJldHVybjtcblxuICAgIGlmICgobm9kZS5vYmplY3QuY2FsbGVlLnByb3BlcnR5IGFzIElkZW50aWZpZXIpLm5hbWUgIT09ICdnZXRMaXZlY2hhdFJlYWRlcicpIHJldHVybjtcblxuICAgIGxldCBwYXJlbnRJbmRleCA9IGFuY2VzdG9ycy5sZW5ndGggLSAyO1xuICAgIGxldCB0YXJnZXROb2RlID0gYW5jZXN0b3JzW3BhcmVudEluZGV4XTtcblxuICAgIGlmICh0YXJnZXROb2RlLnR5cGUgIT09ICdDYWxsRXhwcmVzc2lvbicpIHtcbiAgICAgICAgdGFyZ2V0Tm9kZSA9IG5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50SW5kZXgtLTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSdyZSBhbHJlYWR5IHdyYXBwZWQgd2l0aCBhbiBhd2FpdCwgbm90aGluZyB0byBkb1xuICAgIGlmIChhbmNlc3RvcnNbcGFyZW50SW5kZXhdLnR5cGUgPT09ICdBd2FpdEV4cHJlc3Npb24nKSByZXR1cm47XG5cbiAgICAvLyBJZiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgY2hhaW5lZCBtZW1iZXIgYWNjZXNzLCB3ZSBjYW4ndCB3cmFwIHdpdGggYXdhaXRcbiAgICBpZiAoYW5jZXN0b3JzW3BhcmVudEluZGV4XS50eXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbicpIHJldHVybjtcblxuICAgIHdyYXBXaXRoQXdhaXQodGFyZ2V0Tm9kZSk7XG4gICAgYXN5bmNpZnlTY29wZShhbmNlc3RvcnMsIHN0YXRlKTtcblxuICAgIHN0YXRlLmlzTW9kaWZpZWQgPSB0cnVlO1xufTtcblxuZXhwb3J0IGNvbnN0IGZpeFJvb21Vc2VybmFtZXNDYWxsczogRnVsbEFuY2VzdG9yV2Fsa2VyQ2FsbGJhY2s8V2Fsa2VyU3RhdGU+ID0gKG5vZGUsIHN0YXRlLCBhbmNlc3RvcnMpID0+IHtcbiAgICBpZiAobm9kZS50eXBlICE9PSAnTWVtYmVyRXhwcmVzc2lvbicgfHwgbm9kZS5jb21wdXRlZCkgcmV0dXJuO1xuXG4gICAgaWYgKChub2RlLnByb3BlcnR5IGFzIElkZW50aWZpZXIpLm5hbWUgIT09ICd1c2VybmFtZXMnKSByZXR1cm47XG5cbiAgICBsZXQgcGFyZW50SW5kZXggPSBhbmNlc3RvcnMubGVuZ3RoIC0gMjtcbiAgICBsZXQgdGFyZ2V0Tm9kZSA9IGFuY2VzdG9yc1twYXJlbnRJbmRleF07XG5cbiAgICBpZiAodGFyZ2V0Tm9kZS50eXBlICE9PSAnQ2FsbEV4cHJlc3Npb24nKSB7XG4gICAgICAgIHRhcmdldE5vZGUgPSBub2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmVudEluZGV4LS07XG4gICAgfVxuXG4gICAgLy8gSWYgd2UncmUgYWxyZWFkeSB3cmFwcGVkIHdpdGggYW4gYXdhaXQsIG5vdGhpbmcgdG8gZG9cbiAgICBpZiAoYW5jZXN0b3JzW3BhcmVudEluZGV4XS50eXBlID09PSAnQXdhaXRFeHByZXNzaW9uJykgcmV0dXJuO1xuXG4gICAgd3JhcFdpdGhBd2FpdCh0YXJnZXROb2RlKTtcbiAgICBhc3luY2lmeVNjb3BlKGFuY2VzdG9ycywgc3RhdGUpO1xuXG4gICAgc3RhdGUuaXNNb2RpZmllZCA9IHRydWU7XG59XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUNBQWlDO0FBVWpDLE9BQU8sU0FBUyxzQkFBc0IsU0FBb0IsRUFBRSxpQkFBeUI7RUFDakYsTUFBTSxTQUFTLFNBQVMsQ0FBQyxvQkFBb0IsRUFBRTtFQUUvQyw0RUFBNEU7RUFDNUUsOEVBQThFO0VBQzlFLDhFQUE4RTtFQUM5RSxnRUFBZ0U7RUFDaEUsZ0NBQWdDO0VBQ2hDLEVBQUU7RUFDRixnQ0FBZ0M7RUFDaEMsRUFBRTtFQUNGLDZFQUE2RTtFQUM3RSwwQkFBMEI7RUFDMUIsSUFBSSxVQUFVLENBQUMsQUFBQyxPQUF1QyxRQUFRLEVBQUU7SUFDN0QsNERBQTREO0lBQzVELE1BQU0sRUFBRSxFQUFFLEVBQUUsR0FBRztJQUNmLElBQUksSUFBSSxTQUFTLGNBQWM7TUFDM0IsT0FBTyxHQUFHLElBQUk7SUFDbEI7SUFFQSx3RUFBd0U7SUFDeEUsTUFBTSxFQUFFLEdBQUcsRUFBRSxHQUFHO0lBQ2hCLElBQUksS0FBSyxTQUFTLGNBQWM7TUFDNUIsT0FBTyxJQUFJLElBQUk7SUFDbkI7SUFFQSwwRUFBMEU7SUFDMUUsTUFBTSxFQUFFLElBQUksRUFBRSxHQUFHO0lBRWpCLDJDQUEyQztJQUMzQyxJQUFJLE1BQU0sU0FBUyxjQUFjO01BQzdCLE9BQU8sS0FBSyxJQUFJO0lBQ3BCO0lBRUEsa0RBQWtEO0lBQ2xELElBQUksTUFBTSxTQUFTLHNCQUFzQixDQUFDLEtBQUssUUFBUSxFQUFFO01BQ3JELE9BQU8sQUFBQyxLQUFLLFFBQVEsQ0FBZ0IsSUFBSTtJQUM3QztFQUNKO0VBRUEsd0dBQXdHO0VBQ3hHLE1BQU0sY0FBYyxTQUFTLENBQUMsa0JBQWtCO0VBRWhELDZEQUE2RDtFQUM3RCxJQUFJLFlBQVksRUFBRSxFQUFFLFNBQVMsY0FBYztJQUN2QyxPQUFPLFlBQVksRUFBRSxDQUFDLElBQUk7RUFDOUI7QUFDSjtBQUVBLE9BQU8sU0FBUyxjQUFjLElBQWdCO0VBQzFDLElBQUksQ0FBQyxLQUFLLElBQUksQ0FBQyxRQUFRLENBQUMsZUFBZTtJQUNuQyxNQUFNLElBQUksTUFBTSxDQUFDLFlBQVksRUFBRSxLQUFLLElBQUksQ0FBQyxZQUFZLENBQUM7RUFDMUQ7RUFFQSxNQUFNLFlBQXdCO0lBQUUsR0FBRyxJQUFJO0VBQUM7RUFFeEMsS0FBSyxJQUFJLEdBQUc7RUFDWixtREFBbUQ7RUFDbEQsS0FBeUIsUUFBUSxHQUFHO0VBRXJDLE9BQU8sSUFBSSxDQUFDLE1BQU0sT0FBTyxDQUFDLENBQUMsTUFBUSxDQUFDO01BQUM7TUFBUTtLQUFXLENBQUMsUUFBUSxDQUFDLFFBQVEsT0FBTyxJQUFJLENBQUMsSUFBcUI7QUFDL0c7QUFFQSxPQUFPLFNBQVMsY0FBYyxTQUFvQixFQUFFLEtBQWtCO0VBQ2xFLE1BQU0sb0JBQW9CLFVBQVUsYUFBYSxDQUFDLENBQUMsSUFBTSxXQUFXO0VBQ3BFLElBQUksc0JBQXNCLENBQUMsR0FBRztFQUU5Qix5RUFBeUU7RUFDekUsNENBQTRDO0VBQzVDLE1BQU0sb0JBQW9CLFNBQVMsQ0FBQyxrQkFBa0I7RUFFdEQsSUFBSSxrQkFBa0IsS0FBSyxFQUFFO0lBQ3pCO0VBQ0o7RUFFQSxrQkFBa0IsS0FBSyxHQUFHO0VBRTFCLHFGQUFxRjtFQUNyRiwwQ0FBMEM7RUFDMUMsc0RBQXNEO0VBQ3RELGdKQUFnSjtFQUNoSiw0R0FBNEc7RUFDNUcsSUFBSTtFQUVKLE1BQU0sYUFBYSxzQkFBc0IsV0FBVztFQUVwRCxnRkFBZ0Y7RUFDaEYsSUFBSSxDQUFDLFlBQVk7RUFFakIsTUFBTSxtQkFBbUIsQ0FBQyxHQUFHLENBQUM7QUFDbEM7QUFFQSxPQUFPLFNBQVMsbUNBQW1DLG1CQUFnQztFQUMvRSxPQUFPLFNBQVMsK0JBQStCLElBQUksRUFBRSxLQUFLLEVBQUUsU0FBUztJQUNqRSxJQUFJLEtBQUssSUFBSSxLQUFLLGtCQUFrQjtJQUVwQyxJQUFJLGNBQWM7SUFFbEIsd0RBQXdEO0lBQ3hELGNBQWMsS0FBSyxNQUFNLENBQUMsSUFBSSxLQUFLLGdCQUFnQixvQkFBb0IsR0FBRyxDQUFDLEtBQUssTUFBTSxDQUFDLElBQUk7SUFFM0YsbUhBQW1IO0lBQ25ILGdCQUNJLEtBQUssTUFBTSxDQUFDLElBQUksS0FBSyxzQkFDckIsQ0FBQyxLQUFLLE1BQU0sQ0FBQyxRQUFRLElBQ3JCLEtBQUssTUFBTSxDQUFDLFFBQVEsRUFBRSxTQUFTLGdCQUMvQixvQkFBb0IsR0FBRyxDQUFDLEtBQUssTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJO0lBRXJELG9JQUFvSTtJQUNwSSxxQkFBcUI7SUFDckIsSUFBSSxDQUFDLGVBQWUsS0FBSyxNQUFNLENBQUMsSUFBSSxLQUFLLHNCQUFzQjtNQUMzRCxNQUFNLEdBQUcsaUJBQWlCLEdBQUcsS0FBSyxNQUFNLENBQUMsV0FBVztNQUNwRCxjQUFjLGtCQUFrQixTQUFTLGdCQUFnQixvQkFBb0IsR0FBRyxDQUFDLGlCQUFpQixJQUFJO01BQ3RHLGdCQUNJLGtCQUFrQixTQUFTLHNCQUMzQixDQUFDLGlCQUFpQixRQUFRLElBQzFCLGlCQUFpQixRQUFRLENBQUMsSUFBSSxLQUFLLGdCQUNuQyxvQkFBb0IsR0FBRyxDQUFDLGlCQUFpQixRQUFRLENBQUMsSUFBSTtJQUM5RDtJQUVBLElBQUksQ0FBQyxhQUFhO0lBRWxCLGlGQUFpRjtJQUNqRixNQUFNLGFBQWEsU0FBUyxDQUFDLFVBQVUsTUFBTSxHQUFHLEVBQUU7SUFDbEQsSUFBSSxDQUFDLGNBQWMsV0FBVyxJQUFJLEtBQUssbUJBQW1CO0lBRTFELGNBQWM7SUFDZCxjQUFjLFdBQVc7SUFFekIsTUFBTSxVQUFVLEdBQUc7RUFDdkI7QUFDSjtBQUVBLE9BQU8sTUFBTSx5Q0FBa0YsQ0FBQyxNQUFNLEVBQUUsbUJBQW1CLEVBQUUsRUFBRTtFQUMzSCxJQUFJLEtBQUssSUFBSSxLQUFLLHdCQUF3QjtJQUN0QyxJQUFJLEtBQUssUUFBUSxLQUFLLEtBQUs7SUFFM0IsSUFBSSxhQUFhO0lBRWpCLElBQUksS0FBSyxJQUFJLENBQUMsSUFBSSxLQUFLLGNBQWMsYUFBYSxLQUFLLElBQUksQ0FBQyxJQUFJO0lBRWhFLElBQUksS0FBSyxJQUFJLENBQUMsSUFBSSxLQUFLLHNCQUFzQixDQUFDLEtBQUssSUFBSSxDQUFDLFFBQVEsRUFBRTtNQUM5RCxhQUFhLEFBQUMsS0FBSyxJQUFJLENBQUMsUUFBUSxDQUFnQixJQUFJO0lBQ3hEO0lBRUEsSUFBSSxDQUFDLGNBQWMsS0FBSyxLQUFLLENBQUMsSUFBSSxLQUFLLGdCQUFnQixDQUFDLG9CQUFvQixHQUFHLENBQUMsS0FBSyxLQUFLLENBQUMsSUFBSSxHQUFHO0lBRWxHLG9CQUFvQixHQUFHLENBQUM7SUFFeEI7RUFDSjtFQUVBLElBQUksS0FBSyxJQUFJLEtBQUssc0JBQXNCO0lBQ3BDLElBQUksS0FBSyxFQUFFLENBQUMsSUFBSSxLQUFLLGdCQUFnQixvQkFBb0IsR0FBRyxDQUFDLEtBQUssRUFBRSxDQUFDLElBQUksR0FBRztJQUU1RSxJQUFJLEtBQUssSUFBSSxFQUFFLFNBQVMsZ0JBQWdCLENBQUMsb0JBQW9CLEdBQUcsQ0FBQyxLQUFLLElBQUksRUFBRSxPQUFPO0lBRW5GLG9CQUFvQixHQUFHLENBQUMsS0FBSyxFQUFFLENBQUMsSUFBSTtJQUVwQztFQUNKO0VBRUEsdUVBQXVFO0VBQ3ZFLG9DQUFvQztFQUNwQyxJQUFJLEtBQUssSUFBSSxLQUFLLGNBQWMsS0FBSyxJQUFJLEtBQUssc0JBQXNCO0lBQ2hFLElBQUksS0FBSyxHQUFHLENBQUMsSUFBSSxLQUFLLGdCQUFnQixvQkFBb0IsR0FBRyxDQUFDLEtBQUssR0FBRyxDQUFDLElBQUksR0FBRztJQUU5RSxJQUFJLEtBQUssS0FBSyxFQUFFLFNBQVMsZ0JBQWdCLENBQUMsb0JBQW9CLEdBQUcsQ0FBQyxLQUFLLEtBQUssQ0FBQyxJQUFJLEdBQUc7SUFFcEYsb0JBQW9CLEdBQUcsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxJQUFJO0lBRXJDO0VBQ0o7QUFDSixFQUFFO0FBRUYsT0FBTyxNQUFNLDJCQUFvRSxDQUFDLE1BQU0sT0FBTztFQUMzRixJQUFJLEtBQUssSUFBSSxLQUFLLHNCQUFzQixLQUFLLFFBQVEsRUFBRTtFQUV2RCxJQUFJLEFBQUMsS0FBSyxRQUFRLENBQWdCLElBQUksS0FBSyxZQUFZO0VBRXZELElBQUksS0FBSyxNQUFNLENBQUMsSUFBSSxLQUFLLGtCQUFrQjtFQUUzQyxJQUFJLEtBQUssTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEtBQUssb0JBQW9CO0VBRXBELElBQUksQUFBQyxLQUFLLE1BQU0sQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFnQixJQUFJLEtBQUsscUJBQXFCO0VBRTlFLElBQUksY0FBYyxVQUFVLE1BQU0sR0FBRztFQUNyQyxJQUFJLGFBQWEsU0FBUyxDQUFDLFlBQVk7RUFFdkMsSUFBSSxXQUFXLElBQUksS0FBSyxrQkFBa0I7SUFDdEMsYUFBYTtFQUNqQixPQUFPO0lBQ0g7RUFDSjtFQUVBLHdEQUF3RDtFQUN4RCxJQUFJLFNBQVMsQ0FBQyxZQUFZLENBQUMsSUFBSSxLQUFLLG1CQUFtQjtFQUV2RCw4RUFBOEU7RUFDOUUsSUFBSSxTQUFTLENBQUMsWUFBWSxDQUFDLElBQUksS0FBSyxvQkFBb0I7RUFFeEQsY0FBYztFQUNkLGNBQWMsV0FBVztFQUV6QixNQUFNLFVBQVUsR0FBRztBQUN2QixFQUFFO0FBRUYsT0FBTyxNQUFNLHdCQUFpRSxDQUFDLE1BQU0sT0FBTztFQUN4RixJQUFJLEtBQUssSUFBSSxLQUFLLHNCQUFzQixLQUFLLFFBQVEsRUFBRTtFQUV2RCxJQUFJLEFBQUMsS0FBSyxRQUFRLENBQWdCLElBQUksS0FBSyxhQUFhO0VBRXhELElBQUksY0FBYyxVQUFVLE1BQU0sR0FBRztFQUNyQyxJQUFJLGFBQWEsU0FBUyxDQUFDLFlBQVk7RUFFdkMsSUFBSSxXQUFXLElBQUksS0FBSyxrQkFBa0I7SUFDdEMsYUFBYTtFQUNqQixPQUFPO0lBQ0g7RUFDSjtFQUVBLHdEQUF3RDtFQUN4RCxJQUFJLFNBQVMsQ0FBQyxZQUFZLENBQUMsSUFBSSxLQUFLLG1CQUFtQjtFQUV2RCxjQUFjO0VBQ2QsY0FBYyxXQUFXO0VBRXpCLE1BQU0sVUFBVSxHQUFHO0FBQ3ZCLEVBQUMifQ==