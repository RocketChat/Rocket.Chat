import * as z from 'zod';

import { IAbacAttributeDefinitionSchema } from './IAbacAttribute';
import { IRocketChatRecordSchema } from './IRocketChatRecord';
import { IRoleSchema } from './IRole';
import type { Serialized } from './Serialized';
import { UserStatus } from './UserStatus';
import { serializableDate } from './utils';

export const ILoginTokenSchema = z.object({
	hashedToken: z.string(),
	twoFactorAuthorizedUntil: serializableDate.optional(),
	twoFactorAuthorizedHash: z.string().optional(),
});

export const IMeteorLoginTokenSchema = ILoginTokenSchema.extend({
	when: serializableDate,
});

export const IPersonalAccessTokenSchema = ILoginTokenSchema.extend({
	type: z.literal('personalAccessToken'),
	createdAt: serializableDate,
	lastTokenPart: z.string(),
	name: z.string(),
	bypassTwoFactor: z.boolean().optional(),
});

export const IUserEmailVerificationTokenSchema = z.object({
	token: z.string(),
	address: z.string(),
	when: serializableDate,
});

export const IOAuthUserServicesSchema = z.object({
	google: z.any().optional(),
	facebook: z.any().optional(),
	github: z.any().optional(),
	linkedin: z.any().optional(),
	twitter: z.any().optional(),
	gitlab: z.any().optional(),
	saml: z
		.object({
			inResponseTo: z.string().optional(),
			provider: z.string().optional(),
			idp: z.string().optional(),
			idpSession: z.string().optional(),
			nameID: z.string().optional(),
		})
		.optional(),
	ldap: z
		.object({
			id: z.string(),
			idAttribute: z.string().optional(),
		})
		.optional(),
	nextcloud: z
		.object({
			accessToken: z.string(),
			refreshToken: z.string(),
			serverURL: z.string(),
		})
		.optional(),
	dolphin: z
		.object({
			NickName: z.string().optional(),
		})
		.optional(),
});

const LoginTokenSchema = z.union([IMeteorLoginTokenSchema, IPersonalAccessTokenSchema]);

export const IUserEmailCodeSchema = z.object({
	code: z.string(),
	expire: serializableDate,
	attempts: z.number(),
});

export const IUserServicesSchema = IOAuthUserServicesSchema.extend({
	password: z
		.object({
			exists: z.boolean().optional(),
			bcrypt: z.string().optional(),
		})
		.optional(),
	passwordHistory: z.array(z.string()).optional(),
	email: z
		.object({
			verificationTokens: z.array(IUserEmailVerificationTokenSchema).optional(),
		})
		.optional(),
	resume: z
		.object({
			loginTokens: z.array(LoginTokenSchema).optional(),
		})
		.optional(),
	cloud: z
		.object({
			accessToken: z.string(),
			refreshToken: z.string(),
			expiresAt: serializableDate,
		})
		.optional(),
	totp: z
		.object({
			enabled: z.boolean(),
			hashedBackup: z.array(z.string()),
			secret: z.string(),
			tempSecret: z.string().optional(),
		})
		.optional(),
	email2fa: z
		.object({
			enabled: z.boolean(),
			changedAt: serializableDate,
		})
		.optional(),
	emailCode: IUserEmailCodeSchema.optional(),
	/**
	 * iframe is used for iframe login
	 * the token is generated by an external service
	 * https://developer.rocket.chat/v1/docs/configuring-iframe-auth
	 */
	iframe: z
		.object({
			token: z.string(),
		})
		.optional(),
	/**
	 * loginToken is used for route login 'https://your-rocket.chat/login-token/:token' "one time login" feature
	 * the token is generated by an external service
	 */
	loginToken: z
		.object({
			token: z.string(),
		})
		.optional(),
});

export const ILoginUsernameSchema = z.union([
	z.object({
		username: z.string(),
	}),
	z.object({
		email: z.string(),
	}),
]);

export const IUserEmailSchema = z.object({
	address: z.string(),
	verified: z.boolean().optional(),
});

export const IUserCalendarSchema = z.object({
	outlook: z
		.object({
			Enabled: z.boolean(),
			Exchange_Url: z.string(),
			Outlook_Url: z.string(),
		})
		.optional(),
});

export const IUserSettingsSchema = z.object({
	profile: z.record(z.string(), z.unknown()).optional(),
	preferences: z.record(z.string(), z.any()).optional(),
	calendar: IUserCalendarSchema.optional(),
});

export const IUserSchema = IRocketChatRecordSchema.extend({
	createdAt: serializableDate,
	roles: z.array(IRoleSchema.shape._id),
	type: z.string(),
	active: z.boolean(),
	username: z.string().optional(),
	nickname: z.string().optional(),
	name: z.string().optional(),
	services: IUserServicesSchema.optional(),
	emails: z.array(IUserEmailSchema).optional(),
	status: z.enum(UserStatus).optional(),
	statusConnection: z.string().optional(),
	lastLogin: serializableDate.optional(),
	bio: z.string().optional(),
	avatarOrigin: z.string().optional(),
	avatarETag: z.string().optional(),
	avatarUrl: z.string().optional(),
	utcOffset: z.number().optional(),
	language: z.string().optional(),
	statusDefault: z.enum(UserStatus).optional(),
	statusText: z.string().optional(),
	oauth: z
		.object({
			authorizedClients: z.array(z.string()),
		})
		.optional(),
	e2e: z
		.object({
			private_key: z.string(),
			public_key: z.string(),
		})
		.optional(),
	customFields: z.record(z.string(), z.any()).optional(),
	settings: IUserSettingsSchema.optional(),
	defaultRoom: z.string().optional(),
	ldap: z.boolean().optional(),
	freeSwitchExtension: z.string().optional(),
	inviteToken: z.string().optional(),
	canViewAllInfo: z.boolean().optional(),
	phone: z.string().optional(),
	reason: z.string().optional(),
	// TODO: move this to a specific federation user type
	federated: z.boolean().optional(),
	federation: z
		.object({
			version: z.number().optional(),
			mui: z.string().optional(),
			origin: z.string().optional(),
			avatarUrl: z.string().optional(),
			searchedServerNames: z.array(z.string()).optional(),
		})
		.optional()
		.meta({ deprecated: true }),
	banners: z
		.record(
			z.string(),
			z.object({
				id: z.string(),
				priority: z.number(),
				title: z.string(),
				text: z.string(),
				textArguments: z.array(z.string()).optional(),
				modifiers: z.array(z.enum(['large', 'danger'])),
				link: z.string(),
				read: z.boolean().optional(),
			}),
		)
		.optional(),
	importIds: z.array(z.string()).optional(),
	_pendingAvatarUrl: z.string().optional(),
	requirePasswordChange: z.boolean().optional(),
	requirePasswordChangeReason: z.string().optional(),
	roomRolePriorities: z.record(z.string(), z.number()).optional(),
	isOAuthUser: z.boolean().optional(), // client only field
	__rooms: z.array(z.string()).optional(),
	inactiveReason: z.enum(['deactivated', 'pending_approval', 'idle_too_long']).optional(),
	abacAttributes: z.array(IAbacAttributeDefinitionSchema).optional(),
});

export interface ILoginToken extends z.infer<typeof ILoginTokenSchema> {}
export interface IMeteorLoginToken extends z.infer<typeof IMeteorLoginTokenSchema> {}
export interface IPersonalAccessToken extends z.infer<typeof IPersonalAccessTokenSchema> {}
type LoginToken = z.infer<typeof LoginTokenSchema>;
export interface IUserEmailVerificationToken extends z.infer<typeof IUserEmailVerificationTokenSchema> {}
export interface IUserEmailCode extends z.infer<typeof IUserEmailCodeSchema> {}
export type Username = NonNullable<IUser['username']>;
export type ILoginUsername = z.infer<typeof ILoginUsernameSchema>;
export type LoginUsername = string | ILoginUsername;
export interface IOAuthUserServices extends z.infer<typeof IOAuthUserServicesSchema> {}
export interface IUserServices extends z.infer<typeof IUserServicesSchema> {}
export interface IUserEmail extends z.infer<typeof IUserEmailSchema> {}
export interface IUserCalendar extends z.infer<typeof IUserCalendarSchema> {}
export interface IUserSettings extends z.infer<typeof IUserSettingsSchema> {}
export interface IUser extends z.infer<typeof IUserSchema> {}

export const isPersonalAccessToken = (token: LoginToken): token is IPersonalAccessToken =>
	'type' in token && token.type === 'personalAccessToken';

type IUserService = keyof IUserServices;
type IOAuthService = keyof IOAuthUserServices;

const defaultOAuthKeys = [
	'google',
	'dolphin',
	'facebook',
	'github',
	'gitlab',
	'google',
	'ldap',
	'linkedin',
	'nextcloud',
	'saml',
	'twitter',
] as IOAuthService[];
const userServiceKeys = ['emailCode', 'email2fa', 'totp', 'resume', 'password', 'passwordHistory', 'cloud', 'email'] as IUserService[];

export const isUserServiceKey = (key: string): key is IUserService =>
	userServiceKeys.includes(key as IUserService) || defaultOAuthKeys.includes(key as IOAuthService);

export const isDefaultOAuthUser = (user: IUser): boolean =>
	!!user.services && Object.keys(user.services).some((key) => defaultOAuthKeys.includes(key as IOAuthService));

export const isCustomOAuthUser = (user: IUser): boolean =>
	!!user.services && Object.keys(user.services).some((key) => !isUserServiceKey(key));

export const isOAuthUser = (user: IUser): boolean => isDefaultOAuthUser(user) || isCustomOAuthUser(user);

export interface IGetRoomRoles {
	_id: string;
	rid: string;
	u: {
		_id: string;
		username: string;
	};
	roles: string[];
}

export interface IRegisterUser extends IUser {
	username: string;
	name: string;
}

export const isRegisterUser = (user: IUser): user is IRegisterUser => user.username !== undefined && user.name !== undefined;

export const isUserFederated = (user: Partial<IUser> | Partial<Serialized<IUser>>) => 'federated' in user && user.federated === true;

export interface IUserNativeFederated extends IUser {
	federated: true;
	username: `@${string}:${string}`;
	federation: {
		version: number;
		mui: `@${string}:${string}`;
		origin: string;
	};
}

export const isUserNativeFederated = (user: Partial<IUser>): user is IUserNativeFederated =>
	isUserFederated(user) && 'federation' in user && typeof user.federation?.version === 'number';

export type IUserDataEvent = {
	id: unknown;
} & (
	| {
			type: 'inserted';
			data: IUser;
	  }
	| {
			type: 'removed';
	  }
	| {
			type: 'updated';
			diff: Partial<IUser>;
			unset: Partial<Record<keyof IUser, number>>;
	  }
);

export type IUserInRole = Pick<
	IUser,
	'_id' | 'name' | 'username' | 'emails' | 'avatarETag' | 'createdAt' | 'roles' | 'type' | 'active' | '_updatedAt'
>;

export type UserPresence = Readonly<
	Partial<Pick<IUser, 'name' | 'status' | 'utcOffset' | 'statusText' | 'avatarETag' | 'roles' | 'username'>> & Required<Pick<IUser, '_id'>>
>;

export type AvatarUrlObj = {
	avatarUrl: string;
};

export type AvatarReset = 'reset';

export type AvatarServiceObject = {
	blob: Blob;
	contentType: string;
	service: string;
	url: string;
};

export type AvatarObject = AvatarReset | AvatarUrlObj | FormData | AvatarServiceObject;

export const getUserDisplayName = (name: IUser['name'], username: IUser['username'], useRealName: boolean): string | undefined =>
	useRealName ? name || username : username;
